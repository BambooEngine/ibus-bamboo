// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"context"
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <gdk/gdk.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void _gotk4_gdk4_VulkanContext_ConnectImagesUpdated(gpointer, guintptr);
// extern void _gotk4_gdk4_Surface_ConnectLeaveMonitor(gpointer, GdkMonitor*, guintptr);
// extern void _gotk4_gdk4_Surface_ConnectLayout(gpointer, gint, gint, guintptr);
// extern void _gotk4_gdk4_Surface_ConnectEnterMonitor(gpointer, GdkMonitor*, guintptr);
// extern void _gotk4_gdk4_Seat_ConnectToolRemoved(gpointer, GdkDeviceTool*, guintptr);
// extern void _gotk4_gdk4_Seat_ConnectToolAdded(gpointer, GdkDeviceTool*, guintptr);
// extern void _gotk4_gdk4_Seat_ConnectDeviceRemoved(gpointer, GdkDevice*, guintptr);
// extern void _gotk4_gdk4_Seat_ConnectDeviceAdded(gpointer, GdkDevice*, guintptr);
// extern void _gotk4_gdk4_Paintable_ConnectInvalidateSize(gpointer, guintptr);
// extern void _gotk4_gdk4_Paintable_ConnectInvalidateContents(gpointer, guintptr);
// extern void _gotk4_gdk4_Monitor_ConnectInvalidate(gpointer, guintptr);
// extern void _gotk4_gdk4_FrameClock_ConnectUpdate(gpointer, guintptr);
// extern void _gotk4_gdk4_FrameClock_ConnectResumeEvents(gpointer, guintptr);
// extern void _gotk4_gdk4_FrameClock_ConnectPaint(gpointer, guintptr);
// extern void _gotk4_gdk4_FrameClock_ConnectLayout(gpointer, guintptr);
// extern void _gotk4_gdk4_FrameClock_ConnectFlushEvents(gpointer, guintptr);
// extern void _gotk4_gdk4_FrameClock_ConnectBeforePaint(gpointer, guintptr);
// extern void _gotk4_gdk4_FrameClock_ConnectAfterPaint(gpointer, guintptr);
// extern void _gotk4_gdk4_Drag_ConnectDropPerformed(gpointer, guintptr);
// extern void _gotk4_gdk4_Drag_ConnectDNDFinished(gpointer, guintptr);
// extern void _gotk4_gdk4_Drag_ConnectCancel(gpointer, GdkDragCancelReason, guintptr);
// extern void _gotk4_gdk4_Display_ConnectSettingChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gdk4_Display_ConnectSeatRemoved(gpointer, GdkSeat*, guintptr);
// extern void _gotk4_gdk4_Display_ConnectSeatAdded(gpointer, GdkSeat*, guintptr);
// extern void _gotk4_gdk4_Display_ConnectOpened(gpointer, guintptr);
// extern void _gotk4_gdk4_Display_ConnectClosed(gpointer, gboolean, guintptr);
// extern void _gotk4_gdk4_DisplayManager_ConnectDisplayOpened(gpointer, GdkDisplay*, guintptr);
// extern void _gotk4_gdk4_Device_ConnectToolChanged(gpointer, GdkDeviceTool*, guintptr);
// extern void _gotk4_gdk4_Device_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gdk4_ContentProvider_ConnectContentChanged(gpointer, guintptr);
// extern void _gotk4_gdk4_ContentProviderClass_detach_clipboard(GdkContentProvider*, GdkClipboard*);
// extern void _gotk4_gdk4_ContentProviderClass_content_changed(GdkContentProvider*);
// extern void _gotk4_gdk4_ContentProviderClass_attach_clipboard(GdkContentProvider*, GdkClipboard*);
// extern void _gotk4_gdk4_Clipboard_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gdk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern gboolean _gotk4_gdk4_Surface_ConnectRender(gpointer, cairo_region_t*, guintptr);
// extern gboolean _gotk4_gdk4_Surface_ConnectEvent(gpointer, gpointer*, guintptr);
// extern gboolean _gotk4_gdk4_ContentProviderClass_write_mime_type_finish(GdkContentProvider*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gdk4_ContentProviderClass_get_value(GdkContentProvider*, GValue*, GError**);
// extern GdkContentFormats* _gotk4_gdk4_ContentProviderClass_ref_storable_formats(GdkContentProvider*);
// extern GdkContentFormats* _gotk4_gdk4_ContentProviderClass_ref_formats(GdkContentProvider*);
// GdkContentFormats* _gotk4_gdk4_ContentProvider_virtual_ref_formats(void* fnptr, GdkContentProvider* arg0) {
//   return ((GdkContentFormats* (*)(GdkContentProvider*))(fnptr))(arg0);
// };
// GdkContentFormats* _gotk4_gdk4_ContentProvider_virtual_ref_storable_formats(void* fnptr, GdkContentProvider* arg0) {
//   return ((GdkContentFormats* (*)(GdkContentProvider*))(fnptr))(arg0);
// };
// GdkPaintable* _gotk4_gdk4_Paintable_virtual_get_current_image(void* fnptr, GdkPaintable* arg0) {
//   return ((GdkPaintable* (*)(GdkPaintable*))(fnptr))(arg0);
// };
// GdkPaintableFlags _gotk4_gdk4_Paintable_virtual_get_flags(void* fnptr, GdkPaintable* arg0) {
//   return ((GdkPaintableFlags (*)(GdkPaintable*))(fnptr))(arg0);
// };
// double _gotk4_gdk4_Paintable_virtual_get_intrinsic_aspect_ratio(void* fnptr, GdkPaintable* arg0) {
//   return ((double (*)(GdkPaintable*))(fnptr))(arg0);
// };
// gboolean _gotk4_gdk4_ContentProvider_virtual_get_value(void* fnptr, GdkContentProvider* arg0, GValue* arg1, GError** arg2) {
//   return ((gboolean (*)(GdkContentProvider*, GValue*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gdk4_ContentProvider_virtual_write_mime_type_finish(void* fnptr, GdkContentProvider* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GdkContentProvider*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// int _gotk4_gdk4_Paintable_virtual_get_intrinsic_height(void* fnptr, GdkPaintable* arg0) {
//   return ((int (*)(GdkPaintable*))(fnptr))(arg0);
// };
// int _gotk4_gdk4_Paintable_virtual_get_intrinsic_width(void* fnptr, GdkPaintable* arg0) {
//   return ((int (*)(GdkPaintable*))(fnptr))(arg0);
// };
// void _gotk4_gdk4_ContentProvider_virtual_attach_clipboard(void* fnptr, GdkContentProvider* arg0, GdkClipboard* arg1) {
//   ((void (*)(GdkContentProvider*, GdkClipboard*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gdk4_ContentProvider_virtual_content_changed(void* fnptr, GdkContentProvider* arg0) {
//   ((void (*)(GdkContentProvider*))(fnptr))(arg0);
// };
// void _gotk4_gdk4_ContentProvider_virtual_detach_clipboard(void* fnptr, GdkContentProvider* arg0, GdkClipboard* arg1) {
//   ((void (*)(GdkContentProvider*, GdkClipboard*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gdk4_ContentProvider_virtual_write_mime_type_async(void* fnptr, GdkContentProvider* arg0, char* arg1, GOutputStream* arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GdkContentProvider*, char*, GOutputStream*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gdk4_Paintable_virtual_snapshot(void* fnptr, GdkPaintable* arg0, GdkSnapshot* arg1, double arg2, double arg3) {
//   ((void (*)(GdkPaintable*, GdkSnapshot*, double, double))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeAxisUse               = coreglib.Type(C.gdk_axis_use_get_type())
	GTypeCrossingMode          = coreglib.Type(C.gdk_crossing_mode_get_type())
	GTypeDevicePadFeature      = coreglib.Type(C.gdk_device_pad_feature_get_type())
	GTypeDeviceToolType        = coreglib.Type(C.gdk_device_tool_type_get_type())
	GTypeDmabufError           = coreglib.Type(C.gdk_dmabuf_error_get_type())
	GTypeDragCancelReason      = coreglib.Type(C.gdk_drag_cancel_reason_get_type())
	GTypeEventType             = coreglib.Type(C.gdk_event_type_get_type())
	GTypeFullscreenMode        = coreglib.Type(C.gdk_fullscreen_mode_get_type())
	GTypeGLError               = coreglib.Type(C.gdk_gl_error_get_type())
	GTypeGravity               = coreglib.Type(C.gdk_gravity_get_type())
	GTypeInputSource           = coreglib.Type(C.gdk_input_source_get_type())
	GTypeKeyMatch              = coreglib.Type(C.gdk_key_match_get_type())
	GTypeMemoryFormat          = coreglib.Type(C.gdk_memory_format_get_type())
	GTypeNotifyType            = coreglib.Type(C.gdk_notify_type_get_type())
	GTypeScrollDirection       = coreglib.Type(C.gdk_scroll_direction_get_type())
	GTypeScrollUnit            = coreglib.Type(C.gdk_scroll_unit_get_type())
	GTypeSubpixelLayout        = coreglib.Type(C.gdk_subpixel_layout_get_type())
	GTypeSurfaceEdge           = coreglib.Type(C.gdk_surface_edge_get_type())
	GTypeTextureError          = coreglib.Type(C.gdk_texture_error_get_type())
	GTypeTitlebarGesture       = coreglib.Type(C.gdk_titlebar_gesture_get_type())
	GTypeTouchpadGesturePhase  = coreglib.Type(C.gdk_touchpad_gesture_phase_get_type())
	GTypeVulkanError           = coreglib.Type(C.gdk_vulkan_error_get_type())
	GTypeAnchorHints           = coreglib.Type(C.gdk_anchor_hints_get_type())
	GTypeAxisFlags             = coreglib.Type(C.gdk_axis_flags_get_type())
	GTypeDragAction            = coreglib.Type(C.gdk_drag_action_get_type())
	GTypeFrameClockPhase       = coreglib.Type(C.gdk_frame_clock_phase_get_type())
	GTypeGLAPI                 = coreglib.Type(C.gdk_gl_api_get_type())
	GTypeModifierType          = coreglib.Type(C.gdk_modifier_type_get_type())
	GTypePaintableFlags        = coreglib.Type(C.gdk_paintable_flags_get_type())
	GTypeSeatCapabilities      = coreglib.Type(C.gdk_seat_capabilities_get_type())
	GTypeToplevelState         = coreglib.Type(C.gdk_toplevel_state_get_type())
	GTypeDevicePad             = coreglib.Type(C.gdk_device_pad_get_type())
	GTypeDragSurface           = coreglib.Type(C.gdk_drag_surface_get_type())
	GTypePaintable             = coreglib.Type(C.gdk_paintable_get_type())
	GTypePopup                 = coreglib.Type(C.gdk_popup_get_type())
	GTypeToplevel              = coreglib.Type(C.gdk_toplevel_get_type())
	GTypeAppLaunchContext      = coreglib.Type(C.gdk_app_launch_context_get_type())
	GTypeButtonEvent           = coreglib.Type(C.gdk_button_event_get_type())
	GTypeCairoContext          = coreglib.Type(C.gdk_cairo_context_get_type())
	GTypeClipboard             = coreglib.Type(C.gdk_clipboard_get_type())
	GTypeContentDeserializer   = coreglib.Type(C.gdk_content_deserializer_get_type())
	GTypeContentProvider       = coreglib.Type(C.gdk_content_provider_get_type())
	GTypeContentSerializer     = coreglib.Type(C.gdk_content_serializer_get_type())
	GTypeCrossingEvent         = coreglib.Type(C.gdk_crossing_event_get_type())
	GTypeCursor                = coreglib.Type(C.gdk_cursor_get_type())
	GTypeDNDEvent              = coreglib.Type(C.gdk_dnd_event_get_type())
	GTypeDeleteEvent           = coreglib.Type(C.gdk_delete_event_get_type())
	GTypeDevice                = coreglib.Type(C.gdk_device_get_type())
	GTypeDeviceTool            = coreglib.Type(C.gdk_device_tool_get_type())
	GTypeDisplay               = coreglib.Type(C.gdk_display_get_type())
	GTypeDisplayManager        = coreglib.Type(C.gdk_display_manager_get_type())
	GTypeDmabufTexture         = coreglib.Type(C.gdk_dmabuf_texture_get_type())
	GTypeDmabufTextureBuilder  = coreglib.Type(C.gdk_dmabuf_texture_builder_get_type())
	GTypeDrag                  = coreglib.Type(C.gdk_drag_get_type())
	GTypeDrawContext           = coreglib.Type(C.gdk_draw_context_get_type())
	GTypeDrop                  = coreglib.Type(C.gdk_drop_get_type())
	GTypeEvent                 = coreglib.Type(C.gdk_event_get_type())
	GTypeFocusEvent            = coreglib.Type(C.gdk_focus_event_get_type())
	GTypeFrameClock            = coreglib.Type(C.gdk_frame_clock_get_type())
	GTypeGLContext             = coreglib.Type(C.gdk_gl_context_get_type())
	GTypeGLTexture             = coreglib.Type(C.gdk_gl_texture_get_type())
	GTypeGLTextureBuilder      = coreglib.Type(C.gdk_gl_texture_builder_get_type())
	GTypeGrabBrokenEvent       = coreglib.Type(C.gdk_grab_broken_event_get_type())
	GTypeKeyEvent              = coreglib.Type(C.gdk_key_event_get_type())
	GTypeMemoryTexture         = coreglib.Type(C.gdk_memory_texture_get_type())
	GTypeMonitor               = coreglib.Type(C.gdk_monitor_get_type())
	GTypeMotionEvent           = coreglib.Type(C.gdk_motion_event_get_type())
	GTypePadEvent              = coreglib.Type(C.gdk_pad_event_get_type())
	GTypeProximityEvent        = coreglib.Type(C.gdk_proximity_event_get_type())
	GTypeScrollEvent           = coreglib.Type(C.gdk_scroll_event_get_type())
	GTypeSeat                  = coreglib.Type(C.gdk_seat_get_type())
	GTypeSnapshot              = coreglib.Type(C.gdk_snapshot_get_type())
	GTypeSurface               = coreglib.Type(C.gdk_surface_get_type())
	GTypeTexture               = coreglib.Type(C.gdk_texture_get_type())
	GTypeTouchEvent            = coreglib.Type(C.gdk_touch_event_get_type())
	GTypeTouchpadEvent         = coreglib.Type(C.gdk_touchpad_event_get_type())
	GTypeVulkanContext         = coreglib.Type(C.gdk_vulkan_context_get_type())
	GTypeContentFormats        = coreglib.Type(C.gdk_content_formats_get_type())
	GTypeContentFormatsBuilder = coreglib.Type(C.gdk_content_formats_builder_get_type())
	GTypeDmabufFormats         = coreglib.Type(C.gdk_dmabuf_formats_get_type())
	GTypeEventSequence         = coreglib.Type(C.gdk_event_sequence_get_type())
	GTypeFileList              = coreglib.Type(C.gdk_file_list_get_type())
	GTypeFrameTimings          = coreglib.Type(C.gdk_frame_timings_get_type())
	GTypePopupLayout           = coreglib.Type(C.gdk_popup_layout_get_type())
	GTypeRGBA                  = coreglib.Type(C.gdk_rgba_get_type())
	GTypeRectangle             = coreglib.Type(C.gdk_rectangle_get_type())
	GTypeTextureDownloader     = coreglib.Type(C.gdk_texture_downloader_get_type())
	GTypeToplevelLayout        = coreglib.Type(C.gdk_toplevel_layout_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAxisUse, F: marshalAxisUse},
		coreglib.TypeMarshaler{T: GTypeCrossingMode, F: marshalCrossingMode},
		coreglib.TypeMarshaler{T: GTypeDevicePadFeature, F: marshalDevicePadFeature},
		coreglib.TypeMarshaler{T: GTypeDeviceToolType, F: marshalDeviceToolType},
		coreglib.TypeMarshaler{T: GTypeDmabufError, F: marshalDmabufError},
		coreglib.TypeMarshaler{T: GTypeDragCancelReason, F: marshalDragCancelReason},
		coreglib.TypeMarshaler{T: GTypeEventType, F: marshalEventType},
		coreglib.TypeMarshaler{T: GTypeFullscreenMode, F: marshalFullscreenMode},
		coreglib.TypeMarshaler{T: GTypeGLError, F: marshalGLError},
		coreglib.TypeMarshaler{T: GTypeGravity, F: marshalGravity},
		coreglib.TypeMarshaler{T: GTypeInputSource, F: marshalInputSource},
		coreglib.TypeMarshaler{T: GTypeKeyMatch, F: marshalKeyMatch},
		coreglib.TypeMarshaler{T: GTypeMemoryFormat, F: marshalMemoryFormat},
		coreglib.TypeMarshaler{T: GTypeNotifyType, F: marshalNotifyType},
		coreglib.TypeMarshaler{T: GTypeScrollDirection, F: marshalScrollDirection},
		coreglib.TypeMarshaler{T: GTypeScrollUnit, F: marshalScrollUnit},
		coreglib.TypeMarshaler{T: GTypeSubpixelLayout, F: marshalSubpixelLayout},
		coreglib.TypeMarshaler{T: GTypeSurfaceEdge, F: marshalSurfaceEdge},
		coreglib.TypeMarshaler{T: GTypeTextureError, F: marshalTextureError},
		coreglib.TypeMarshaler{T: GTypeTitlebarGesture, F: marshalTitlebarGesture},
		coreglib.TypeMarshaler{T: GTypeTouchpadGesturePhase, F: marshalTouchpadGesturePhase},
		coreglib.TypeMarshaler{T: GTypeVulkanError, F: marshalVulkanError},
		coreglib.TypeMarshaler{T: GTypeAnchorHints, F: marshalAnchorHints},
		coreglib.TypeMarshaler{T: GTypeAxisFlags, F: marshalAxisFlags},
		coreglib.TypeMarshaler{T: GTypeDragAction, F: marshalDragAction},
		coreglib.TypeMarshaler{T: GTypeFrameClockPhase, F: marshalFrameClockPhase},
		coreglib.TypeMarshaler{T: GTypeGLAPI, F: marshalGLAPI},
		coreglib.TypeMarshaler{T: GTypeModifierType, F: marshalModifierType},
		coreglib.TypeMarshaler{T: GTypePaintableFlags, F: marshalPaintableFlags},
		coreglib.TypeMarshaler{T: GTypeSeatCapabilities, F: marshalSeatCapabilities},
		coreglib.TypeMarshaler{T: GTypeToplevelState, F: marshalToplevelState},
		coreglib.TypeMarshaler{T: GTypeDevicePad, F: marshalDevicePad},
		coreglib.TypeMarshaler{T: GTypeDragSurface, F: marshalDragSurface},
		coreglib.TypeMarshaler{T: GTypePaintable, F: marshalPaintable},
		coreglib.TypeMarshaler{T: GTypePopup, F: marshalPopup},
		coreglib.TypeMarshaler{T: GTypeToplevel, F: marshalToplevel},
		coreglib.TypeMarshaler{T: GTypeAppLaunchContext, F: marshalAppLaunchContext},
		coreglib.TypeMarshaler{T: GTypeButtonEvent, F: marshalButtonEvent},
		coreglib.TypeMarshaler{T: GTypeCairoContext, F: marshalCairoContext},
		coreglib.TypeMarshaler{T: GTypeClipboard, F: marshalClipboard},
		coreglib.TypeMarshaler{T: GTypeContentDeserializer, F: marshalContentDeserializer},
		coreglib.TypeMarshaler{T: GTypeContentProvider, F: marshalContentProvider},
		coreglib.TypeMarshaler{T: GTypeContentSerializer, F: marshalContentSerializer},
		coreglib.TypeMarshaler{T: GTypeCrossingEvent, F: marshalCrossingEvent},
		coreglib.TypeMarshaler{T: GTypeCursor, F: marshalCursor},
		coreglib.TypeMarshaler{T: GTypeDNDEvent, F: marshalDNDEvent},
		coreglib.TypeMarshaler{T: GTypeDeleteEvent, F: marshalDeleteEvent},
		coreglib.TypeMarshaler{T: GTypeDevice, F: marshalDevice},
		coreglib.TypeMarshaler{T: GTypeDeviceTool, F: marshalDeviceTool},
		coreglib.TypeMarshaler{T: GTypeDisplay, F: marshalDisplay},
		coreglib.TypeMarshaler{T: GTypeDisplayManager, F: marshalDisplayManager},
		coreglib.TypeMarshaler{T: GTypeDmabufTexture, F: marshalDmabufTexture},
		coreglib.TypeMarshaler{T: GTypeDmabufTextureBuilder, F: marshalDmabufTextureBuilder},
		coreglib.TypeMarshaler{T: GTypeDrag, F: marshalDrag},
		coreglib.TypeMarshaler{T: GTypeDrawContext, F: marshalDrawContext},
		coreglib.TypeMarshaler{T: GTypeDrop, F: marshalDrop},
		coreglib.TypeMarshaler{T: GTypeEvent, F: marshalEvent},
		coreglib.TypeMarshaler{T: GTypeFocusEvent, F: marshalFocusEvent},
		coreglib.TypeMarshaler{T: GTypeFrameClock, F: marshalFrameClock},
		coreglib.TypeMarshaler{T: GTypeGLContext, F: marshalGLContext},
		coreglib.TypeMarshaler{T: GTypeGLTexture, F: marshalGLTexture},
		coreglib.TypeMarshaler{T: GTypeGLTextureBuilder, F: marshalGLTextureBuilder},
		coreglib.TypeMarshaler{T: GTypeGrabBrokenEvent, F: marshalGrabBrokenEvent},
		coreglib.TypeMarshaler{T: GTypeKeyEvent, F: marshalKeyEvent},
		coreglib.TypeMarshaler{T: GTypeMemoryTexture, F: marshalMemoryTexture},
		coreglib.TypeMarshaler{T: GTypeMonitor, F: marshalMonitor},
		coreglib.TypeMarshaler{T: GTypeMotionEvent, F: marshalMotionEvent},
		coreglib.TypeMarshaler{T: GTypePadEvent, F: marshalPadEvent},
		coreglib.TypeMarshaler{T: GTypeProximityEvent, F: marshalProximityEvent},
		coreglib.TypeMarshaler{T: GTypeScrollEvent, F: marshalScrollEvent},
		coreglib.TypeMarshaler{T: GTypeSeat, F: marshalSeat},
		coreglib.TypeMarshaler{T: GTypeSnapshot, F: marshalSnapshot},
		coreglib.TypeMarshaler{T: GTypeSurface, F: marshalSurface},
		coreglib.TypeMarshaler{T: GTypeTexture, F: marshalTexture},
		coreglib.TypeMarshaler{T: GTypeTouchEvent, F: marshalTouchEvent},
		coreglib.TypeMarshaler{T: GTypeTouchpadEvent, F: marshalTouchpadEvent},
		coreglib.TypeMarshaler{T: GTypeVulkanContext, F: marshalVulkanContext},
		coreglib.TypeMarshaler{T: GTypeContentFormats, F: marshalContentFormats},
		coreglib.TypeMarshaler{T: GTypeContentFormatsBuilder, F: marshalContentFormatsBuilder},
		coreglib.TypeMarshaler{T: GTypeDmabufFormats, F: marshalDmabufFormats},
		coreglib.TypeMarshaler{T: GTypeEventSequence, F: marshalEventSequence},
		coreglib.TypeMarshaler{T: GTypeFileList, F: marshalFileList},
		coreglib.TypeMarshaler{T: GTypeFrameTimings, F: marshalFrameTimings},
		coreglib.TypeMarshaler{T: GTypePopupLayout, F: marshalPopupLayout},
		coreglib.TypeMarshaler{T: GTypeRGBA, F: marshalRGBA},
		coreglib.TypeMarshaler{T: GTypeRectangle, F: marshalRectangle},
		coreglib.TypeMarshaler{T: GTypeTextureDownloader, F: marshalTextureDownloader},
		coreglib.TypeMarshaler{T: GTypeToplevelLayout, F: marshalToplevelLayout},
	})
}

// ACTION_ALL defines all possible DND actions.
//
// This can be used in gdk.Drop.Status() messages when any drop can be accepted
// or a more specific drop method is not yet known.
const ACTION_ALL = 7

// BUTTON_MIDDLE: middle button.
const BUTTON_MIDDLE = 2

// BUTTON_PRIMARY: primary button. This is typically the left mouse button,
// or the right button in a left-handed setup.
const BUTTON_PRIMARY = 1

// BUTTON_SECONDARY: secondary button. This is typically the right mouse button,
// or the left button in a left-handed setup.
const BUTTON_SECONDARY = 3

// CURRENT_TIME represents the current time, and can be used anywhere a time is
// expected.
const CURRENT_TIME = 0

// EVENT_PROPAGATE: use this macro as the return value for continuing the
// propagation of an event handler.
const EVENT_PROPAGATE = false

// EVENT_STOP: use this macro as the return value for stopping the propagation
// of an event handler.
const EVENT_STOP = true
const KEY_0 = 48
const KEY_1 = 49
const KEY_2 = 50
const KEY_3 = 51
const KEY_3270_AltCursor = 64784
const KEY_3270_Attn = 64782
const KEY_3270_BackTab = 64773
const KEY_3270_ChangeScreen = 64793
const KEY_3270_Copy = 64789
const KEY_3270_CursorBlink = 64783
const KEY_3270_CursorSelect = 64796
const KEY_3270_DeleteWord = 64794
const KEY_3270_Duplicate = 64769
const KEY_3270_Enter = 64798
const KEY_3270_EraseEOF = 64774
const KEY_3270_EraseInput = 64775
const KEY_3270_ExSelect = 64795
const KEY_3270_FieldMark = 64770
const KEY_3270_Ident = 64787
const KEY_3270_Jump = 64786
const KEY_3270_KeyClick = 64785
const KEY_3270_Left2 = 64772
const KEY_3270_PA1 = 64778
const KEY_3270_PA2 = 64779
const KEY_3270_PA3 = 64780
const KEY_3270_Play = 64790
const KEY_3270_PrintScreen = 64797
const KEY_3270_Quit = 64777
const KEY_3270_Record = 64792
const KEY_3270_Reset = 64776
const KEY_3270_Right2 = 64771
const KEY_3270_Rule = 64788
const KEY_3270_Setup = 64791
const KEY_3270_Test = 64781
const KEY_4 = 52
const KEY_5 = 53
const KEY_6 = 54
const KEY_7 = 55
const KEY_8 = 56
const KEY_9 = 57
const KEY_A = 65
const KEY_AE = 198
const KEY_Aacute = 193
const KEY_Abelowdot = 16785056
const KEY_Abreve = 451
const KEY_Abreveacute = 16785070
const KEY_Abrevebelowdot = 16785078
const KEY_Abrevegrave = 16785072
const KEY_Abrevehook = 16785074
const KEY_Abrevetilde = 16785076
const KEY_AccessX_Enable = 65136
const KEY_AccessX_Feedback_Enable = 65137
const KEY_Acircumflex = 194
const KEY_Acircumflexacute = 16785060
const KEY_Acircumflexbelowdot = 16785068
const KEY_Acircumflexgrave = 16785062
const KEY_Acircumflexhook = 16785064
const KEY_Acircumflextilde = 16785066
const KEY_AddFavorite = 269025081
const KEY_Adiaeresis = 196
const KEY_Agrave = 192
const KEY_Ahook = 16785058
const KEY_Alt_L = 65513
const KEY_Alt_R = 65514
const KEY_Amacron = 960
const KEY_Aogonek = 417
const KEY_ApplicationLeft = 269025104
const KEY_ApplicationRight = 269025105
const KEY_Arabic_0 = 16778848
const KEY_Arabic_1 = 16778849
const KEY_Arabic_2 = 16778850
const KEY_Arabic_3 = 16778851
const KEY_Arabic_4 = 16778852
const KEY_Arabic_5 = 16778853
const KEY_Arabic_6 = 16778854
const KEY_Arabic_7 = 16778855
const KEY_Arabic_8 = 16778856
const KEY_Arabic_9 = 16778857
const KEY_Arabic_ain = 1497
const KEY_Arabic_alef = 1479
const KEY_Arabic_alefmaksura = 1513
const KEY_Arabic_beh = 1480
const KEY_Arabic_comma = 1452
const KEY_Arabic_dad = 1494
const KEY_Arabic_dal = 1487
const KEY_Arabic_damma = 1519
const KEY_Arabic_dammatan = 1516
const KEY_Arabic_ddal = 16778888
const KEY_Arabic_farsi_yeh = 16778956
const KEY_Arabic_fatha = 1518
const KEY_Arabic_fathatan = 1515
const KEY_Arabic_feh = 1505
const KEY_Arabic_fullstop = 16778964
const KEY_Arabic_gaf = 16778927
const KEY_Arabic_ghain = 1498
const KEY_Arabic_ha = 1511
const KEY_Arabic_hah = 1485
const KEY_Arabic_hamza = 1473
const KEY_Arabic_hamza_above = 16778836
const KEY_Arabic_hamza_below = 16778837
const KEY_Arabic_hamzaonalef = 1475
const KEY_Arabic_hamzaonwaw = 1476
const KEY_Arabic_hamzaonyeh = 1478
const KEY_Arabic_hamzaunderalef = 1477
const KEY_Arabic_heh = 1511
const KEY_Arabic_heh_doachashmee = 16778942
const KEY_Arabic_heh_goal = 16778945
const KEY_Arabic_jeem = 1484
const KEY_Arabic_jeh = 16778904
const KEY_Arabic_kaf = 1507
const KEY_Arabic_kasra = 1520
const KEY_Arabic_kasratan = 1517
const KEY_Arabic_keheh = 16778921
const KEY_Arabic_khah = 1486
const KEY_Arabic_lam = 1508
const KEY_Arabic_madda_above = 16778835
const KEY_Arabic_maddaonalef = 1474
const KEY_Arabic_meem = 1509
const KEY_Arabic_noon = 1510
const KEY_Arabic_noon_ghunna = 16778938
const KEY_Arabic_peh = 16778878
const KEY_Arabic_percent = 16778858
const KEY_Arabic_qaf = 1506
const KEY_Arabic_question_mark = 1471
const KEY_Arabic_ra = 1489
const KEY_Arabic_rreh = 16778897
const KEY_Arabic_sad = 1493
const KEY_Arabic_seen = 1491
const KEY_Arabic_semicolon = 1467
const KEY_Arabic_shadda = 1521
const KEY_Arabic_sheen = 1492
const KEY_Arabic_sukun = 1522
const KEY_Arabic_superscript_alef = 16778864
const KEY_Arabic_switch = 65406
const KEY_Arabic_tah = 1495
const KEY_Arabic_tatweel = 1504
const KEY_Arabic_tcheh = 16778886
const KEY_Arabic_teh = 1482
const KEY_Arabic_tehmarbuta = 1481
const KEY_Arabic_thal = 1488
const KEY_Arabic_theh = 1483
const KEY_Arabic_tteh = 16778873
const KEY_Arabic_veh = 16778916
const KEY_Arabic_waw = 1512
const KEY_Arabic_yeh = 1514
const KEY_Arabic_yeh_baree = 16778962
const KEY_Arabic_zah = 1496
const KEY_Arabic_zain = 1490
const KEY_Aring = 197
const KEY_Armenian_AT = 16778552
const KEY_Armenian_AYB = 16778545
const KEY_Armenian_BEN = 16778546
const KEY_Armenian_CHA = 16778569
const KEY_Armenian_DA = 16778548
const KEY_Armenian_DZA = 16778561
const KEY_Armenian_E = 16778551
const KEY_Armenian_FE = 16778582
const KEY_Armenian_GHAT = 16778562
const KEY_Armenian_GIM = 16778547
const KEY_Armenian_HI = 16778565
const KEY_Armenian_HO = 16778560
const KEY_Armenian_INI = 16778555
const KEY_Armenian_JE = 16778571
const KEY_Armenian_KE = 16778580
const KEY_Armenian_KEN = 16778559
const KEY_Armenian_KHE = 16778557
const KEY_Armenian_LYUN = 16778556
const KEY_Armenian_MEN = 16778564
const KEY_Armenian_NU = 16778566
const KEY_Armenian_O = 16778581
const KEY_Armenian_PE = 16778570
const KEY_Armenian_PYUR = 16778579
const KEY_Armenian_RA = 16778572
const KEY_Armenian_RE = 16778576
const KEY_Armenian_SE = 16778573
const KEY_Armenian_SHA = 16778567
const KEY_Armenian_TCHE = 16778563
const KEY_Armenian_TO = 16778553
const KEY_Armenian_TSA = 16778558
const KEY_Armenian_TSO = 16778577
const KEY_Armenian_TYUN = 16778575
const KEY_Armenian_VEV = 16778574
const KEY_Armenian_VO = 16778568
const KEY_Armenian_VYUN = 16778578
const KEY_Armenian_YECH = 16778549
const KEY_Armenian_ZA = 16778550
const KEY_Armenian_ZHE = 16778554
const KEY_Armenian_accent = 16778587
const KEY_Armenian_amanak = 16778588
const KEY_Armenian_apostrophe = 16778586
const KEY_Armenian_at = 16778600
const KEY_Armenian_ayb = 16778593
const KEY_Armenian_ben = 16778594
const KEY_Armenian_but = 16778589
const KEY_Armenian_cha = 16778617
const KEY_Armenian_da = 16778596
const KEY_Armenian_dza = 16778609
const KEY_Armenian_e = 16778599
const KEY_Armenian_exclam = 16778588
const KEY_Armenian_fe = 16778630
const KEY_Armenian_full_stop = 16778633
const KEY_Armenian_ghat = 16778610
const KEY_Armenian_gim = 16778595
const KEY_Armenian_hi = 16778613
const KEY_Armenian_ho = 16778608
const KEY_Armenian_hyphen = 16778634
const KEY_Armenian_ini = 16778603
const KEY_Armenian_je = 16778619
const KEY_Armenian_ke = 16778628
const KEY_Armenian_ken = 16778607
const KEY_Armenian_khe = 16778605
const KEY_Armenian_ligature_ew = 16778631
const KEY_Armenian_lyun = 16778604
const KEY_Armenian_men = 16778612
const KEY_Armenian_nu = 16778614
const KEY_Armenian_o = 16778629
const KEY_Armenian_paruyk = 16778590
const KEY_Armenian_pe = 16778618
const KEY_Armenian_pyur = 16778627
const KEY_Armenian_question = 16778590
const KEY_Armenian_ra = 16778620
const KEY_Armenian_re = 16778624
const KEY_Armenian_se = 16778621
const KEY_Armenian_separation_mark = 16778589
const KEY_Armenian_sha = 16778615
const KEY_Armenian_shesht = 16778587
const KEY_Armenian_tche = 16778611
const KEY_Armenian_to = 16778601
const KEY_Armenian_tsa = 16778606
const KEY_Armenian_tso = 16778625
const KEY_Armenian_tyun = 16778623
const KEY_Armenian_verjaket = 16778633
const KEY_Armenian_vev = 16778622
const KEY_Armenian_vo = 16778616
const KEY_Armenian_vyun = 16778626
const KEY_Armenian_yech = 16778597
const KEY_Armenian_yentamna = 16778634
const KEY_Armenian_za = 16778598
const KEY_Armenian_zhe = 16778602
const KEY_Atilde = 195
const KEY_AudibleBell_Enable = 65146
const KEY_AudioCycleTrack = 269025179
const KEY_AudioForward = 269025175
const KEY_AudioLowerVolume = 269025041
const KEY_AudioMedia = 269025074
const KEY_AudioMicMute = 269025202
const KEY_AudioMute = 269025042
const KEY_AudioNext = 269025047
const KEY_AudioPause = 269025073
const KEY_AudioPlay = 269025044
const KEY_AudioPreset = 269025206
const KEY_AudioPrev = 269025046
const KEY_AudioRaiseVolume = 269025043
const KEY_AudioRandomPlay = 269025177
const KEY_AudioRecord = 269025052
const KEY_AudioRepeat = 269025176
const KEY_AudioRewind = 269025086
const KEY_AudioStop = 269025045
const KEY_Away = 269025165
const KEY_B = 66
const KEY_Babovedot = 16784898
const KEY_Back = 269025062
const KEY_BackForward = 269025087
const KEY_BackSpace = 65288
const KEY_Battery = 269025171
const KEY_Begin = 65368
const KEY_Blue = 269025190
const KEY_Bluetooth = 269025172
const KEY_Book = 269025106
const KEY_BounceKeys_Enable = 65140
const KEY_Break = 65387
const KEY_BrightnessAdjust = 269025083
const KEY_Byelorussian_SHORTU = 1726
const KEY_Byelorussian_shortu = 1710
const KEY_C = 67
const KEY_CD = 269025107
const KEY_CH = 65186
const KEY_C_H = 65189
const KEY_C_h = 65188
const KEY_Cabovedot = 709
const KEY_Cacute = 454
const KEY_Calculator = 269025053
const KEY_Calendar = 269025056
const KEY_Cancel = 65385
const KEY_Caps_Lock = 65509
const KEY_Ccaron = 456
const KEY_Ccedilla = 199
const KEY_Ccircumflex = 710
const KEY_Ch = 65185
const KEY_Clear = 65291
const KEY_ClearGrab = 269024801
const KEY_Close = 269025110
const KEY_Codeinput = 65335
const KEY_ColonSign = 16785569
const KEY_Community = 269025085
const KEY_ContrastAdjust = 269025058
const KEY_Control_L = 65507
const KEY_Control_R = 65508
const KEY_Copy = 269025111
const KEY_CruzeiroSign = 16785570
const KEY_Cut = 269025112
const KEY_CycleAngle = 269025180
const KEY_Cyrillic_A = 1761
const KEY_Cyrillic_BE = 1762
const KEY_Cyrillic_CHE = 1790
const KEY_Cyrillic_CHE_descender = 16778422
const KEY_Cyrillic_CHE_vertstroke = 16778424
const KEY_Cyrillic_DE = 1764
const KEY_Cyrillic_DZHE = 1727
const KEY_Cyrillic_E = 1788
const KEY_Cyrillic_EF = 1766
const KEY_Cyrillic_EL = 1772
const KEY_Cyrillic_EM = 1773
const KEY_Cyrillic_EN = 1774
const KEY_Cyrillic_EN_descender = 16778402
const KEY_Cyrillic_ER = 1778
const KEY_Cyrillic_ES = 1779
const KEY_Cyrillic_GHE = 1767
const KEY_Cyrillic_GHE_bar = 16778386
const KEY_Cyrillic_HA = 1768
const KEY_Cyrillic_HARDSIGN = 1791
const KEY_Cyrillic_HA_descender = 16778418
const KEY_Cyrillic_I = 1769
const KEY_Cyrillic_IE = 1765
const KEY_Cyrillic_IO = 1715
const KEY_Cyrillic_I_macron = 16778466
const KEY_Cyrillic_JE = 1720
const KEY_Cyrillic_KA = 1771
const KEY_Cyrillic_KA_descender = 16778394
const KEY_Cyrillic_KA_vertstroke = 16778396
const KEY_Cyrillic_LJE = 1721
const KEY_Cyrillic_NJE = 1722
const KEY_Cyrillic_O = 1775
const KEY_Cyrillic_O_bar = 16778472
const KEY_Cyrillic_PE = 1776
const KEY_Cyrillic_SCHWA = 16778456
const KEY_Cyrillic_SHA = 1787
const KEY_Cyrillic_SHCHA = 1789
const KEY_Cyrillic_SHHA = 16778426
const KEY_Cyrillic_SHORTI = 1770
const KEY_Cyrillic_SOFTSIGN = 1784
const KEY_Cyrillic_TE = 1780
const KEY_Cyrillic_TSE = 1763
const KEY_Cyrillic_U = 1781
const KEY_Cyrillic_U_macron = 16778478
const KEY_Cyrillic_U_straight = 16778414
const KEY_Cyrillic_U_straight_bar = 16778416
const KEY_Cyrillic_VE = 1783
const KEY_Cyrillic_YA = 1777
const KEY_Cyrillic_YERU = 1785
const KEY_Cyrillic_YU = 1760
const KEY_Cyrillic_ZE = 1786
const KEY_Cyrillic_ZHE = 1782
const KEY_Cyrillic_ZHE_descender = 16778390
const KEY_Cyrillic_a = 1729
const KEY_Cyrillic_be = 1730
const KEY_Cyrillic_che = 1758
const KEY_Cyrillic_che_descender = 16778423
const KEY_Cyrillic_che_vertstroke = 16778425
const KEY_Cyrillic_de = 1732
const KEY_Cyrillic_dzhe = 1711
const KEY_Cyrillic_e = 1756
const KEY_Cyrillic_ef = 1734
const KEY_Cyrillic_el = 1740
const KEY_Cyrillic_em = 1741
const KEY_Cyrillic_en = 1742
const KEY_Cyrillic_en_descender = 16778403
const KEY_Cyrillic_er = 1746
const KEY_Cyrillic_es = 1747
const KEY_Cyrillic_ghe = 1735
const KEY_Cyrillic_ghe_bar = 16778387
const KEY_Cyrillic_ha = 1736
const KEY_Cyrillic_ha_descender = 16778419
const KEY_Cyrillic_hardsign = 1759
const KEY_Cyrillic_i = 1737
const KEY_Cyrillic_i_macron = 16778467
const KEY_Cyrillic_ie = 1733
const KEY_Cyrillic_io = 1699
const KEY_Cyrillic_je = 1704
const KEY_Cyrillic_ka = 1739
const KEY_Cyrillic_ka_descender = 16778395
const KEY_Cyrillic_ka_vertstroke = 16778397
const KEY_Cyrillic_lje = 1705
const KEY_Cyrillic_nje = 1706
const KEY_Cyrillic_o = 1743
const KEY_Cyrillic_o_bar = 16778473
const KEY_Cyrillic_pe = 1744
const KEY_Cyrillic_schwa = 16778457
const KEY_Cyrillic_sha = 1755
const KEY_Cyrillic_shcha = 1757
const KEY_Cyrillic_shha = 16778427
const KEY_Cyrillic_shorti = 1738
const KEY_Cyrillic_softsign = 1752
const KEY_Cyrillic_te = 1748
const KEY_Cyrillic_tse = 1731
const KEY_Cyrillic_u = 1749
const KEY_Cyrillic_u_macron = 16778479
const KEY_Cyrillic_u_straight = 16778415
const KEY_Cyrillic_u_straight_bar = 16778417
const KEY_Cyrillic_ve = 1751
const KEY_Cyrillic_ya = 1745
const KEY_Cyrillic_yeru = 1753
const KEY_Cyrillic_yu = 1728
const KEY_Cyrillic_ze = 1754
const KEY_Cyrillic_zhe = 1750
const KEY_Cyrillic_zhe_descender = 16778391
const KEY_D = 68
const KEY_DOS = 269025114
const KEY_Dabovedot = 16784906
const KEY_Dcaron = 463
const KEY_Delete = 65535
const KEY_Display = 269025113
const KEY_Documents = 269025115
const KEY_DongSign = 16785579
const KEY_Down = 65364
const KEY_Dstroke = 464
const KEY_E = 69
const KEY_ENG = 957
const KEY_ETH = 208
const KEY_EZH = 16777655
const KEY_Eabovedot = 972
const KEY_Eacute = 201
const KEY_Ebelowdot = 16785080
const KEY_Ecaron = 460
const KEY_Ecircumflex = 202
const KEY_Ecircumflexacute = 16785086
const KEY_Ecircumflexbelowdot = 16785094
const KEY_Ecircumflexgrave = 16785088
const KEY_Ecircumflexhook = 16785090
const KEY_Ecircumflextilde = 16785092
const KEY_EcuSign = 16785568
const KEY_Ediaeresis = 203
const KEY_Egrave = 200
const KEY_Ehook = 16785082
const KEY_Eisu_Shift = 65327
const KEY_Eisu_toggle = 65328
const KEY_Eject = 269025068
const KEY_Emacron = 938
const KEY_End = 65367
const KEY_Eogonek = 458
const KEY_Escape = 65307
const KEY_Eth = 208
const KEY_Etilde = 16785084
const KEY_EuroSign = 8364
const KEY_Excel = 269025116
const KEY_Execute = 65378
const KEY_Explorer = 269025117
const KEY_F = 70
const KEY_F1 = 65470
const KEY_F10 = 65479
const KEY_F11 = 65480
const KEY_F12 = 65481
const KEY_F13 = 65482
const KEY_F14 = 65483
const KEY_F15 = 65484
const KEY_F16 = 65485
const KEY_F17 = 65486
const KEY_F18 = 65487
const KEY_F19 = 65488
const KEY_F2 = 65471
const KEY_F20 = 65489
const KEY_F21 = 65490
const KEY_F22 = 65491
const KEY_F23 = 65492
const KEY_F24 = 65493
const KEY_F25 = 65494
const KEY_F26 = 65495
const KEY_F27 = 65496
const KEY_F28 = 65497
const KEY_F29 = 65498
const KEY_F3 = 65472
const KEY_F30 = 65499
const KEY_F31 = 65500
const KEY_F32 = 65501
const KEY_F33 = 65502
const KEY_F34 = 65503
const KEY_F35 = 65504
const KEY_F4 = 65473
const KEY_F5 = 65474
const KEY_F6 = 65475
const KEY_F7 = 65476
const KEY_F8 = 65477
const KEY_F9 = 65478
const KEY_FFrancSign = 16785571
const KEY_Fabovedot = 16784926
const KEY_Farsi_0 = 16778992
const KEY_Farsi_1 = 16778993
const KEY_Farsi_2 = 16778994
const KEY_Farsi_3 = 16778995
const KEY_Farsi_4 = 16778996
const KEY_Farsi_5 = 16778997
const KEY_Farsi_6 = 16778998
const KEY_Farsi_7 = 16778999
const KEY_Farsi_8 = 16779000
const KEY_Farsi_9 = 16779001
const KEY_Farsi_yeh = 16778956
const KEY_Favorites = 269025072
const KEY_Finance = 269025084
const KEY_Find = 65384
const KEY_First_Virtual_Screen = 65232
const KEY_Forward = 269025063
const KEY_FrameBack = 269025181
const KEY_FrameForward = 269025182
const KEY_G = 71
const KEY_Gabovedot = 725
const KEY_Game = 269025118
const KEY_Gbreve = 683
const KEY_Gcaron = 16777702
const KEY_Gcedilla = 939
const KEY_Gcircumflex = 728
const KEY_Georgian_an = 16781520
const KEY_Georgian_ban = 16781521
const KEY_Georgian_can = 16781546
const KEY_Georgian_char = 16781549
const KEY_Georgian_chin = 16781545
const KEY_Georgian_cil = 16781548
const KEY_Georgian_don = 16781523
const KEY_Georgian_en = 16781524
const KEY_Georgian_fi = 16781558
const KEY_Georgian_gan = 16781522
const KEY_Georgian_ghan = 16781542
const KEY_Georgian_hae = 16781552
const KEY_Georgian_har = 16781556
const KEY_Georgian_he = 16781553
const KEY_Georgian_hie = 16781554
const KEY_Georgian_hoe = 16781557
const KEY_Georgian_in = 16781528
const KEY_Georgian_jhan = 16781551
const KEY_Georgian_jil = 16781547
const KEY_Georgian_kan = 16781529
const KEY_Georgian_khar = 16781541
const KEY_Georgian_las = 16781530
const KEY_Georgian_man = 16781531
const KEY_Georgian_nar = 16781532
const KEY_Georgian_on = 16781533
const KEY_Georgian_par = 16781534
const KEY_Georgian_phar = 16781540
const KEY_Georgian_qar = 16781543
const KEY_Georgian_rae = 16781536
const KEY_Georgian_san = 16781537
const KEY_Georgian_shin = 16781544
const KEY_Georgian_tan = 16781527
const KEY_Georgian_tar = 16781538
const KEY_Georgian_un = 16781539
const KEY_Georgian_vin = 16781525
const KEY_Georgian_we = 16781555
const KEY_Georgian_xan = 16781550
const KEY_Georgian_zen = 16781526
const KEY_Georgian_zhar = 16781535
const KEY_Go = 269025119
const KEY_Greek_ALPHA = 1985
const KEY_Greek_ALPHAaccent = 1953
const KEY_Greek_BETA = 1986
const KEY_Greek_CHI = 2007
const KEY_Greek_DELTA = 1988
const KEY_Greek_EPSILON = 1989
const KEY_Greek_EPSILONaccent = 1954
const KEY_Greek_ETA = 1991
const KEY_Greek_ETAaccent = 1955
const KEY_Greek_GAMMA = 1987
const KEY_Greek_IOTA = 1993
const KEY_Greek_IOTAaccent = 1956
const KEY_Greek_IOTAdiaeresis = 1957
const KEY_Greek_IOTAdieresis = 1957
const KEY_Greek_KAPPA = 1994
const KEY_Greek_LAMBDA = 1995
const KEY_Greek_LAMDA = 1995
const KEY_Greek_MU = 1996
const KEY_Greek_NU = 1997
const KEY_Greek_OMEGA = 2009
const KEY_Greek_OMEGAaccent = 1963
const KEY_Greek_OMICRON = 1999
const KEY_Greek_OMICRONaccent = 1959
const KEY_Greek_PHI = 2006
const KEY_Greek_PI = 2000
const KEY_Greek_PSI = 2008
const KEY_Greek_RHO = 2001
const KEY_Greek_SIGMA = 2002
const KEY_Greek_TAU = 2004
const KEY_Greek_THETA = 1992
const KEY_Greek_UPSILON = 2005
const KEY_Greek_UPSILONaccent = 1960
const KEY_Greek_UPSILONdieresis = 1961
const KEY_Greek_XI = 1998
const KEY_Greek_ZETA = 1990
const KEY_Greek_accentdieresis = 1966
const KEY_Greek_alpha = 2017
const KEY_Greek_alphaaccent = 1969
const KEY_Greek_beta = 2018
const KEY_Greek_chi = 2039
const KEY_Greek_delta = 2020
const KEY_Greek_epsilon = 2021
const KEY_Greek_epsilonaccent = 1970
const KEY_Greek_eta = 2023
const KEY_Greek_etaaccent = 1971
const KEY_Greek_finalsmallsigma = 2035
const KEY_Greek_gamma = 2019
const KEY_Greek_horizbar = 1967
const KEY_Greek_iota = 2025
const KEY_Greek_iotaaccent = 1972
const KEY_Greek_iotaaccentdieresis = 1974
const KEY_Greek_iotadieresis = 1973
const KEY_Greek_kappa = 2026
const KEY_Greek_lambda = 2027
const KEY_Greek_lamda = 2027
const KEY_Greek_mu = 2028
const KEY_Greek_nu = 2029
const KEY_Greek_omega = 2041
const KEY_Greek_omegaaccent = 1979
const KEY_Greek_omicron = 2031
const KEY_Greek_omicronaccent = 1975
const KEY_Greek_phi = 2038
const KEY_Greek_pi = 2032
const KEY_Greek_psi = 2040
const KEY_Greek_rho = 2033
const KEY_Greek_sigma = 2034
const KEY_Greek_switch = 65406
const KEY_Greek_tau = 2036
const KEY_Greek_theta = 2024
const KEY_Greek_upsilon = 2037
const KEY_Greek_upsilonaccent = 1976
const KEY_Greek_upsilonaccentdieresis = 1978
const KEY_Greek_upsilondieresis = 1977
const KEY_Greek_xi = 2030
const KEY_Greek_zeta = 2022
const KEY_Green = 269025188
const KEY_H = 72
const KEY_Hangul = 65329
const KEY_Hangul_A = 3775
const KEY_Hangul_AE = 3776
const KEY_Hangul_AraeA = 3830
const KEY_Hangul_AraeAE = 3831
const KEY_Hangul_Banja = 65337
const KEY_Hangul_Cieuc = 3770
const KEY_Hangul_Codeinput = 65335
const KEY_Hangul_Dikeud = 3751
const KEY_Hangul_E = 3780
const KEY_Hangul_EO = 3779
const KEY_Hangul_EU = 3793
const KEY_Hangul_End = 65331
const KEY_Hangul_Hanja = 65332
const KEY_Hangul_Hieuh = 3774
const KEY_Hangul_I = 3795
const KEY_Hangul_Ieung = 3767
const KEY_Hangul_J_Cieuc = 3818
const KEY_Hangul_J_Dikeud = 3802
const KEY_Hangul_J_Hieuh = 3822
const KEY_Hangul_J_Ieung = 3816
const KEY_Hangul_J_Jieuj = 3817
const KEY_Hangul_J_Khieuq = 3819
const KEY_Hangul_J_Kiyeog = 3796
const KEY_Hangul_J_KiyeogSios = 3798
const KEY_Hangul_J_KkogjiDalrinIeung = 3833
const KEY_Hangul_J_Mieum = 3811
const KEY_Hangul_J_Nieun = 3799
const KEY_Hangul_J_NieunHieuh = 3801
const KEY_Hangul_J_NieunJieuj = 3800
const KEY_Hangul_J_PanSios = 3832
const KEY_Hangul_J_Phieuf = 3821
const KEY_Hangul_J_Pieub = 3812
const KEY_Hangul_J_PieubSios = 3813
const KEY_Hangul_J_Rieul = 3803
const KEY_Hangul_J_RieulHieuh = 3810
const KEY_Hangul_J_RieulKiyeog = 3804
const KEY_Hangul_J_RieulMieum = 3805
const KEY_Hangul_J_RieulPhieuf = 3809
const KEY_Hangul_J_RieulPieub = 3806
const KEY_Hangul_J_RieulSios = 3807
const KEY_Hangul_J_RieulTieut = 3808
const KEY_Hangul_J_Sios = 3814
const KEY_Hangul_J_SsangKiyeog = 3797
const KEY_Hangul_J_SsangSios = 3815
const KEY_Hangul_J_Tieut = 3820
const KEY_Hangul_J_YeorinHieuh = 3834
const KEY_Hangul_Jamo = 65333
const KEY_Hangul_Jeonja = 65336
const KEY_Hangul_Jieuj = 3768
const KEY_Hangul_Khieuq = 3771
const KEY_Hangul_Kiyeog = 3745
const KEY_Hangul_KiyeogSios = 3747
const KEY_Hangul_KkogjiDalrinIeung = 3827
const KEY_Hangul_Mieum = 3761
const KEY_Hangul_MultipleCandidate = 65341
const KEY_Hangul_Nieun = 3748
const KEY_Hangul_NieunHieuh = 3750
const KEY_Hangul_NieunJieuj = 3749
const KEY_Hangul_O = 3783
const KEY_Hangul_OE = 3786
const KEY_Hangul_PanSios = 3826
const KEY_Hangul_Phieuf = 3773
const KEY_Hangul_Pieub = 3762
const KEY_Hangul_PieubSios = 3764
const KEY_Hangul_PostHanja = 65339
const KEY_Hangul_PreHanja = 65338
const KEY_Hangul_PreviousCandidate = 65342
const KEY_Hangul_Rieul = 3753
const KEY_Hangul_RieulHieuh = 3760
const KEY_Hangul_RieulKiyeog = 3754
const KEY_Hangul_RieulMieum = 3755
const KEY_Hangul_RieulPhieuf = 3759
const KEY_Hangul_RieulPieub = 3756
const KEY_Hangul_RieulSios = 3757
const KEY_Hangul_RieulTieut = 3758
const KEY_Hangul_RieulYeorinHieuh = 3823
const KEY_Hangul_Romaja = 65334
const KEY_Hangul_SingleCandidate = 65340
const KEY_Hangul_Sios = 3765
const KEY_Hangul_Special = 65343
const KEY_Hangul_SsangDikeud = 3752
const KEY_Hangul_SsangJieuj = 3769
const KEY_Hangul_SsangKiyeog = 3746
const KEY_Hangul_SsangPieub = 3763
const KEY_Hangul_SsangSios = 3766
const KEY_Hangul_Start = 65330
const KEY_Hangul_SunkyeongeumMieum = 3824
const KEY_Hangul_SunkyeongeumPhieuf = 3828
const KEY_Hangul_SunkyeongeumPieub = 3825
const KEY_Hangul_Tieut = 3772
const KEY_Hangul_U = 3788
const KEY_Hangul_WA = 3784
const KEY_Hangul_WAE = 3785
const KEY_Hangul_WE = 3790
const KEY_Hangul_WEO = 3789
const KEY_Hangul_WI = 3791
const KEY_Hangul_YA = 3777
const KEY_Hangul_YAE = 3778
const KEY_Hangul_YE = 3782
const KEY_Hangul_YEO = 3781
const KEY_Hangul_YI = 3794
const KEY_Hangul_YO = 3787
const KEY_Hangul_YU = 3792
const KEY_Hangul_YeorinHieuh = 3829
const KEY_Hangul_switch = 65406
const KEY_Hankaku = 65321
const KEY_Hcircumflex = 678
const KEY_Hebrew_switch = 65406
const KEY_Help = 65386
const KEY_Henkan = 65315
const KEY_Henkan_Mode = 65315
const KEY_Hibernate = 269025192
const KEY_Hiragana = 65317
const KEY_Hiragana_Katakana = 65319
const KEY_History = 269025079
const KEY_Home = 65360
const KEY_HomePage = 269025048
const KEY_HotLinks = 269025082
const KEY_Hstroke = 673
const KEY_Hyper_L = 65517
const KEY_Hyper_R = 65518
const KEY_I = 73
const KEY_ISO_Center_Object = 65075
const KEY_ISO_Continuous_Underline = 65072
const KEY_ISO_Discontinuous_Underline = 65073
const KEY_ISO_Emphasize = 65074
const KEY_ISO_Enter = 65076
const KEY_ISO_Fast_Cursor_Down = 65071
const KEY_ISO_Fast_Cursor_Left = 65068
const KEY_ISO_Fast_Cursor_Right = 65069
const KEY_ISO_Fast_Cursor_Up = 65070
const KEY_ISO_First_Group = 65036
const KEY_ISO_First_Group_Lock = 65037
const KEY_ISO_Group_Latch = 65030
const KEY_ISO_Group_Lock = 65031
const KEY_ISO_Group_Shift = 65406
const KEY_ISO_Last_Group = 65038
const KEY_ISO_Last_Group_Lock = 65039
const KEY_ISO_Left_Tab = 65056
const KEY_ISO_Level2_Latch = 65026
const KEY_ISO_Level3_Latch = 65028
const KEY_ISO_Level3_Lock = 65029
const KEY_ISO_Level3_Shift = 65027
const KEY_ISO_Level5_Latch = 65042
const KEY_ISO_Level5_Lock = 65043
const KEY_ISO_Level5_Shift = 65041
const KEY_ISO_Lock = 65025
const KEY_ISO_Move_Line_Down = 65058
const KEY_ISO_Move_Line_Up = 65057
const KEY_ISO_Next_Group = 65032
const KEY_ISO_Next_Group_Lock = 65033
const KEY_ISO_Partial_Line_Down = 65060
const KEY_ISO_Partial_Line_Up = 65059
const KEY_ISO_Partial_Space_Left = 65061
const KEY_ISO_Partial_Space_Right = 65062
const KEY_ISO_Prev_Group = 65034
const KEY_ISO_Prev_Group_Lock = 65035
const KEY_ISO_Release_Both_Margins = 65067
const KEY_ISO_Release_Margin_Left = 65065
const KEY_ISO_Release_Margin_Right = 65066
const KEY_ISO_Set_Margin_Left = 65063
const KEY_ISO_Set_Margin_Right = 65064
const KEY_Iabovedot = 681
const KEY_Iacute = 205
const KEY_Ibelowdot = 16785098
const KEY_Ibreve = 16777516
const KEY_Icircumflex = 206
const KEY_Idiaeresis = 207
const KEY_Igrave = 204
const KEY_Ihook = 16785096
const KEY_Imacron = 975
const KEY_Insert = 65379
const KEY_Iogonek = 967
const KEY_Itilde = 933
const KEY_J = 74
const KEY_Jcircumflex = 684
const KEY_K = 75
const KEY_KP_0 = 65456
const KEY_KP_1 = 65457
const KEY_KP_2 = 65458
const KEY_KP_3 = 65459
const KEY_KP_4 = 65460
const KEY_KP_5 = 65461
const KEY_KP_6 = 65462
const KEY_KP_7 = 65463
const KEY_KP_8 = 65464
const KEY_KP_9 = 65465
const KEY_KP_Add = 65451
const KEY_KP_Begin = 65437
const KEY_KP_Decimal = 65454
const KEY_KP_Delete = 65439
const KEY_KP_Divide = 65455
const KEY_KP_Down = 65433
const KEY_KP_End = 65436
const KEY_KP_Enter = 65421
const KEY_KP_Equal = 65469
const KEY_KP_F1 = 65425
const KEY_KP_F2 = 65426
const KEY_KP_F3 = 65427
const KEY_KP_F4 = 65428
const KEY_KP_Home = 65429
const KEY_KP_Insert = 65438
const KEY_KP_Left = 65430
const KEY_KP_Multiply = 65450
const KEY_KP_Next = 65435
const KEY_KP_Page_Down = 65435
const KEY_KP_Page_Up = 65434
const KEY_KP_Prior = 65434
const KEY_KP_Right = 65432
const KEY_KP_Separator = 65452
const KEY_KP_Space = 65408
const KEY_KP_Subtract = 65453
const KEY_KP_Tab = 65417
const KEY_KP_Up = 65431
const KEY_Kana_Lock = 65325
const KEY_Kana_Shift = 65326
const KEY_Kanji = 65313
const KEY_Kanji_Bangou = 65335
const KEY_Katakana = 65318
const KEY_KbdBrightnessDown = 269025030
const KEY_KbdBrightnessUp = 269025029
const KEY_KbdLightOnOff = 269025028
const KEY_Kcedilla = 979
const KEY_Keyboard = 269025203
const KEY_Korean_Won = 3839
const KEY_L = 76
const KEY_L1 = 65480
const KEY_L10 = 65489
const KEY_L2 = 65481
const KEY_L3 = 65482
const KEY_L4 = 65483
const KEY_L5 = 65484
const KEY_L6 = 65485
const KEY_L7 = 65486
const KEY_L8 = 65487
const KEY_L9 = 65488
const KEY_Lacute = 453
const KEY_Last_Virtual_Screen = 65236
const KEY_Launch0 = 269025088
const KEY_Launch1 = 269025089
const KEY_Launch2 = 269025090
const KEY_Launch3 = 269025091
const KEY_Launch4 = 269025092
const KEY_Launch5 = 269025093
const KEY_Launch6 = 269025094
const KEY_Launch7 = 269025095
const KEY_Launch8 = 269025096
const KEY_Launch9 = 269025097
const KEY_LaunchA = 269025098
const KEY_LaunchB = 269025099
const KEY_LaunchC = 269025100
const KEY_LaunchD = 269025101
const KEY_LaunchE = 269025102
const KEY_LaunchF = 269025103
const KEY_Lbelowdot = 16784950
const KEY_Lcaron = 421
const KEY_Lcedilla = 934
const KEY_Left = 65361
const KEY_LightBulb = 269025077
const KEY_Linefeed = 65290
const KEY_LiraSign = 16785572
const KEY_LogGrabInfo = 269024805
const KEY_LogOff = 269025121
const KEY_LogWindowTree = 269024804
const KEY_Lstroke = 419
const KEY_M = 77
const KEY_Mabovedot = 16784960
const KEY_Macedonia_DSE = 1717
const KEY_Macedonia_GJE = 1714
const KEY_Macedonia_KJE = 1724
const KEY_Macedonia_dse = 1701
const KEY_Macedonia_gje = 1698
const KEY_Macedonia_kje = 1708
const KEY_Mae_Koho = 65342
const KEY_Mail = 269025049
const KEY_MailForward = 269025168
const KEY_Market = 269025122
const KEY_Massyo = 65324
const KEY_Meeting = 269025123
const KEY_Memo = 269025054
const KEY_Menu = 65383
const KEY_MenuKB = 269025125
const KEY_MenuPB = 269025126
const KEY_Messenger = 269025166
const KEY_Meta_L = 65511
const KEY_Meta_R = 65512
const KEY_MillSign = 16785573
const KEY_ModeLock = 269025025
const KEY_Mode_switch = 65406
const KEY_MonBrightnessDown = 269025027
const KEY_MonBrightnessUp = 269025026
const KEY_MouseKeys_Accel_Enable = 65143
const KEY_MouseKeys_Enable = 65142
const KEY_Muhenkan = 65314
const KEY_Multi_key = 65312
const KEY_MultipleCandidate = 65341
const KEY_Music = 269025170
const KEY_MyComputer = 269025075
const KEY_MySites = 269025127
const KEY_N = 78
const KEY_Nacute = 465
const KEY_NairaSign = 16785574
const KEY_Ncaron = 466
const KEY_Ncedilla = 977
const KEY_New = 269025128
const KEY_NewSheqelSign = 16785578
const KEY_News = 269025129
const KEY_Next = 65366
const KEY_Next_VMode = 269024802
const KEY_Next_Virtual_Screen = 65234
const KEY_Ntilde = 209
const KEY_Num_Lock = 65407
const KEY_O = 79
const KEY_OE = 5052
const KEY_Oacute = 211
const KEY_Obarred = 16777631
const KEY_Obelowdot = 16785100
const KEY_Ocaron = 16777681
const KEY_Ocircumflex = 212
const KEY_Ocircumflexacute = 16785104
const KEY_Ocircumflexbelowdot = 16785112
const KEY_Ocircumflexgrave = 16785106
const KEY_Ocircumflexhook = 16785108
const KEY_Ocircumflextilde = 16785110
const KEY_Odiaeresis = 214
const KEY_Odoubleacute = 469
const KEY_OfficeHome = 269025130
const KEY_Ograve = 210
const KEY_Ohook = 16785102
const KEY_Ohorn = 16777632
const KEY_Ohornacute = 16785114
const KEY_Ohornbelowdot = 16785122
const KEY_Ohorngrave = 16785116
const KEY_Ohornhook = 16785118
const KEY_Ohorntilde = 16785120
const KEY_Omacron = 978
const KEY_Ooblique = 216
const KEY_Open = 269025131
const KEY_OpenURL = 269025080
const KEY_Option = 269025132
const KEY_Oslash = 216
const KEY_Otilde = 213
const KEY_Overlay1_Enable = 65144
const KEY_Overlay2_Enable = 65145
const KEY_P = 80
const KEY_Pabovedot = 16784982
const KEY_Page_Down = 65366
const KEY_Page_Up = 65365
const KEY_Paste = 269025133
const KEY_Pause = 65299
const KEY_PesetaSign = 16785575
const KEY_Phone = 269025134
const KEY_Pictures = 269025169
const KEY_Pointer_Accelerate = 65274
const KEY_Pointer_Button1 = 65257
const KEY_Pointer_Button2 = 65258
const KEY_Pointer_Button3 = 65259
const KEY_Pointer_Button4 = 65260
const KEY_Pointer_Button5 = 65261
const KEY_Pointer_Button_Dflt = 65256
const KEY_Pointer_DblClick1 = 65263
const KEY_Pointer_DblClick2 = 65264
const KEY_Pointer_DblClick3 = 65265
const KEY_Pointer_DblClick4 = 65266
const KEY_Pointer_DblClick5 = 65267
const KEY_Pointer_DblClick_Dflt = 65262
const KEY_Pointer_DfltBtnNext = 65275
const KEY_Pointer_DfltBtnPrev = 65276
const KEY_Pointer_Down = 65251
const KEY_Pointer_DownLeft = 65254
const KEY_Pointer_DownRight = 65255
const KEY_Pointer_Drag1 = 65269
const KEY_Pointer_Drag2 = 65270
const KEY_Pointer_Drag3 = 65271
const KEY_Pointer_Drag4 = 65272
const KEY_Pointer_Drag5 = 65277
const KEY_Pointer_Drag_Dflt = 65268
const KEY_Pointer_EnableKeys = 65273
const KEY_Pointer_Left = 65248
const KEY_Pointer_Right = 65249
const KEY_Pointer_Up = 65250
const KEY_Pointer_UpLeft = 65252
const KEY_Pointer_UpRight = 65253
const KEY_PowerDown = 269025057
const KEY_PowerOff = 269025066
const KEY_Prev_VMode = 269024803
const KEY_Prev_Virtual_Screen = 65233
const KEY_PreviousCandidate = 65342
const KEY_Print = 65377
const KEY_Prior = 65365
const KEY_Q = 81
const KEY_R = 82
const KEY_R1 = 65490
const KEY_R10 = 65499
const KEY_R11 = 65500
const KEY_R12 = 65501
const KEY_R13 = 65502
const KEY_R14 = 65503
const KEY_R15 = 65504
const KEY_R2 = 65491
const KEY_R3 = 65492
const KEY_R4 = 65493
const KEY_R5 = 65494
const KEY_R6 = 65495
const KEY_R7 = 65496
const KEY_R8 = 65497
const KEY_R9 = 65498
const KEY_RFKill = 269025205
const KEY_Racute = 448
const KEY_Rcaron = 472
const KEY_Rcedilla = 931
const KEY_Red = 269025187
const KEY_Redo = 65382
const KEY_Refresh = 269025065
const KEY_Reload = 269025139
const KEY_RepeatKeys_Enable = 65138
const KEY_Reply = 269025138
const KEY_Return = 65293
const KEY_Right = 65363
const KEY_RockerDown = 269025060
const KEY_RockerEnter = 269025061
const KEY_RockerUp = 269025059
const KEY_Romaji = 65316
const KEY_RotateWindows = 269025140
const KEY_RotationKB = 269025142
const KEY_RotationPB = 269025141
const KEY_RupeeSign = 16785576
const KEY_S = 83
const KEY_SCHWA = 16777615
const KEY_Sabovedot = 16784992
const KEY_Sacute = 422
const KEY_Save = 269025143
const KEY_Scaron = 425
const KEY_Scedilla = 426
const KEY_Scircumflex = 734
const KEY_ScreenSaver = 269025069
const KEY_ScrollClick = 269025146
const KEY_ScrollDown = 269025145
const KEY_ScrollUp = 269025144
const KEY_Scroll_Lock = 65300
const KEY_Search = 269025051
const KEY_Select = 65376
const KEY_SelectButton = 269025184
const KEY_Send = 269025147
const KEY_Serbian_DJE = 1713
const KEY_Serbian_DZE = 1727
const KEY_Serbian_JE = 1720
const KEY_Serbian_LJE = 1721
const KEY_Serbian_NJE = 1722
const KEY_Serbian_TSHE = 1723
const KEY_Serbian_dje = 1697
const KEY_Serbian_dze = 1711
const KEY_Serbian_je = 1704
const KEY_Serbian_lje = 1705
const KEY_Serbian_nje = 1706
const KEY_Serbian_tshe = 1707
const KEY_Shift_L = 65505
const KEY_Shift_Lock = 65510
const KEY_Shift_R = 65506
const KEY_Shop = 269025078
const KEY_SingleCandidate = 65340
const KEY_Sinh_a = 16780677
const KEY_Sinh_aa = 16780678
const KEY_Sinh_aa2 = 16780751
const KEY_Sinh_ae = 16780679
const KEY_Sinh_ae2 = 16780752
const KEY_Sinh_aee = 16780680
const KEY_Sinh_aee2 = 16780753
const KEY_Sinh_ai = 16780691
const KEY_Sinh_ai2 = 16780763
const KEY_Sinh_al = 16780746
const KEY_Sinh_au = 16780694
const KEY_Sinh_au2 = 16780766
const KEY_Sinh_ba = 16780726
const KEY_Sinh_bha = 16780727
const KEY_Sinh_ca = 16780704
const KEY_Sinh_cha = 16780705
const KEY_Sinh_dda = 16780713
const KEY_Sinh_ddha = 16780714
const KEY_Sinh_dha = 16780719
const KEY_Sinh_dhha = 16780720
const KEY_Sinh_e = 16780689
const KEY_Sinh_e2 = 16780761
const KEY_Sinh_ee = 16780690
const KEY_Sinh_ee2 = 16780762
const KEY_Sinh_fa = 16780742
const KEY_Sinh_ga = 16780700
const KEY_Sinh_gha = 16780701
const KEY_Sinh_h2 = 16780675
const KEY_Sinh_ha = 16780740
const KEY_Sinh_i = 16780681
const KEY_Sinh_i2 = 16780754
const KEY_Sinh_ii = 16780682
const KEY_Sinh_ii2 = 16780755
const KEY_Sinh_ja = 16780706
const KEY_Sinh_jha = 16780707
const KEY_Sinh_jnya = 16780709
const KEY_Sinh_ka = 16780698
const KEY_Sinh_kha = 16780699
const KEY_Sinh_kunddaliya = 16780788
const KEY_Sinh_la = 16780733
const KEY_Sinh_lla = 16780741
const KEY_Sinh_lu = 16780687
const KEY_Sinh_lu2 = 16780767
const KEY_Sinh_luu = 16780688
const KEY_Sinh_luu2 = 16780787
const KEY_Sinh_ma = 16780728
const KEY_Sinh_mba = 16780729
const KEY_Sinh_na = 16780721
const KEY_Sinh_ndda = 16780716
const KEY_Sinh_ndha = 16780723
const KEY_Sinh_ng = 16780674
const KEY_Sinh_ng2 = 16780702
const KEY_Sinh_nga = 16780703
const KEY_Sinh_nja = 16780710
const KEY_Sinh_nna = 16780715
const KEY_Sinh_nya = 16780708
const KEY_Sinh_o = 16780692
const KEY_Sinh_o2 = 16780764
const KEY_Sinh_oo = 16780693
const KEY_Sinh_oo2 = 16780765
const KEY_Sinh_pa = 16780724
const KEY_Sinh_pha = 16780725
const KEY_Sinh_ra = 16780731
const KEY_Sinh_ri = 16780685
const KEY_Sinh_rii = 16780686
const KEY_Sinh_ru2 = 16780760
const KEY_Sinh_ruu2 = 16780786
const KEY_Sinh_sa = 16780739
const KEY_Sinh_sha = 16780737
const KEY_Sinh_ssha = 16780738
const KEY_Sinh_tha = 16780717
const KEY_Sinh_thha = 16780718
const KEY_Sinh_tta = 16780711
const KEY_Sinh_ttha = 16780712
const KEY_Sinh_u = 16780683
const KEY_Sinh_u2 = 16780756
const KEY_Sinh_uu = 16780684
const KEY_Sinh_uu2 = 16780758
const KEY_Sinh_va = 16780736
const KEY_Sinh_ya = 16780730
const KEY_Sleep = 269025071
const KEY_SlowKeys_Enable = 65139
const KEY_Spell = 269025148
const KEY_SplitScreen = 269025149
const KEY_Standby = 269025040
const KEY_Start = 269025050
const KEY_StickyKeys_Enable = 65141
const KEY_Stop = 269025064
const KEY_Subtitle = 269025178
const KEY_Super_L = 65515
const KEY_Super_R = 65516
const KEY_Support = 269025150
const KEY_Suspend = 269025191
const KEY_Switch_VT_1 = 269024769
const KEY_Switch_VT_10 = 269024778
const KEY_Switch_VT_11 = 269024779
const KEY_Switch_VT_12 = 269024780
const KEY_Switch_VT_2 = 269024770
const KEY_Switch_VT_3 = 269024771
const KEY_Switch_VT_4 = 269024772
const KEY_Switch_VT_5 = 269024773
const KEY_Switch_VT_6 = 269024774
const KEY_Switch_VT_7 = 269024775
const KEY_Switch_VT_8 = 269024776
const KEY_Switch_VT_9 = 269024777
const KEY_Sys_Req = 65301
const KEY_T = 84
const KEY_THORN = 222
const KEY_Tab = 65289
const KEY_Tabovedot = 16785002
const KEY_TaskPane = 269025151
const KEY_Tcaron = 427
const KEY_Tcedilla = 478
const KEY_Terminal = 269025152
const KEY_Terminate_Server = 65237
const KEY_Thai_baht = 3551
const KEY_Thai_bobaimai = 3514
const KEY_Thai_chochan = 3496
const KEY_Thai_chochang = 3498
const KEY_Thai_choching = 3497
const KEY_Thai_chochoe = 3500
const KEY_Thai_dochada = 3502
const KEY_Thai_dodek = 3508
const KEY_Thai_fofa = 3517
const KEY_Thai_fofan = 3519
const KEY_Thai_hohip = 3531
const KEY_Thai_honokhuk = 3534
const KEY_Thai_khokhai = 3490
const KEY_Thai_khokhon = 3493
const KEY_Thai_khokhuat = 3491
const KEY_Thai_khokhwai = 3492
const KEY_Thai_khorakhang = 3494
const KEY_Thai_kokai = 3489
const KEY_Thai_lakkhangyao = 3557
const KEY_Thai_lekchet = 3575
const KEY_Thai_lekha = 3573
const KEY_Thai_lekhok = 3574
const KEY_Thai_lekkao = 3577
const KEY_Thai_leknung = 3569
const KEY_Thai_lekpaet = 3576
const KEY_Thai_leksam = 3571
const KEY_Thai_leksi = 3572
const KEY_Thai_leksong = 3570
const KEY_Thai_leksun = 3568
const KEY_Thai_lochula = 3532
const KEY_Thai_loling = 3525
const KEY_Thai_lu = 3526
const KEY_Thai_maichattawa = 3563
const KEY_Thai_maiek = 3560
const KEY_Thai_maihanakat = 3537
const KEY_Thai_maihanakat_maitho = 3550
const KEY_Thai_maitaikhu = 3559
const KEY_Thai_maitho = 3561
const KEY_Thai_maitri = 3562
const KEY_Thai_maiyamok = 3558
const KEY_Thai_moma = 3521
const KEY_Thai_ngongu = 3495
const KEY_Thai_nikhahit = 3565
const KEY_Thai_nonen = 3507
const KEY_Thai_nonu = 3513
const KEY_Thai_oang = 3533
const KEY_Thai_paiyannoi = 3535
const KEY_Thai_phinthu = 3546
const KEY_Thai_phophan = 3518
const KEY_Thai_phophung = 3516
const KEY_Thai_phosamphao = 3520
const KEY_Thai_popla = 3515
const KEY_Thai_rorua = 3523
const KEY_Thai_ru = 3524
const KEY_Thai_saraa = 3536
const KEY_Thai_saraaa = 3538
const KEY_Thai_saraae = 3553
const KEY_Thai_saraaimaimalai = 3556
const KEY_Thai_saraaimaimuan = 3555
const KEY_Thai_saraam = 3539
const KEY_Thai_sarae = 3552
const KEY_Thai_sarai = 3540
const KEY_Thai_saraii = 3541
const KEY_Thai_sarao = 3554
const KEY_Thai_sarau = 3544
const KEY_Thai_saraue = 3542
const KEY_Thai_sarauee = 3543
const KEY_Thai_sarauu = 3545
const KEY_Thai_sorusi = 3529
const KEY_Thai_sosala = 3528
const KEY_Thai_soso = 3499
const KEY_Thai_sosua = 3530
const KEY_Thai_thanthakhat = 3564
const KEY_Thai_thonangmontho = 3505
const KEY_Thai_thophuthao = 3506
const KEY_Thai_thothahan = 3511
const KEY_Thai_thothan = 3504
const KEY_Thai_thothong = 3512
const KEY_Thai_thothung = 3510
const KEY_Thai_topatak = 3503
const KEY_Thai_totao = 3509
const KEY_Thai_wowaen = 3527
const KEY_Thai_yoyak = 3522
const KEY_Thai_yoying = 3501
const KEY_Thorn = 222
const KEY_Time = 269025183
const KEY_ToDoList = 269025055
const KEY_Tools = 269025153
const KEY_TopMenu = 269025186
const KEY_TouchpadOff = 269025201
const KEY_TouchpadOn = 269025200
const KEY_TouchpadToggle = 269025193
const KEY_Touroku = 65323
const KEY_Travel = 269025154
const KEY_Tslash = 940
const KEY_U = 85
const KEY_UWB = 269025174
const KEY_Uacute = 218
const KEY_Ubelowdot = 16785124
const KEY_Ubreve = 733
const KEY_Ucircumflex = 219
const KEY_Udiaeresis = 220
const KEY_Udoubleacute = 475
const KEY_Ugrave = 217
const KEY_Uhook = 16785126
const KEY_Uhorn = 16777647
const KEY_Uhornacute = 16785128
const KEY_Uhornbelowdot = 16785136
const KEY_Uhorngrave = 16785130
const KEY_Uhornhook = 16785132
const KEY_Uhorntilde = 16785134
const KEY_Ukrainian_GHE_WITH_UPTURN = 1725
const KEY_Ukrainian_I = 1718
const KEY_Ukrainian_IE = 1716
const KEY_Ukrainian_YI = 1719
const KEY_Ukrainian_ghe_with_upturn = 1709
const KEY_Ukrainian_i = 1702
const KEY_Ukrainian_ie = 1700
const KEY_Ukrainian_yi = 1703
const KEY_Ukranian_I = 1718
const KEY_Ukranian_JE = 1716
const KEY_Ukranian_YI = 1719
const KEY_Ukranian_i = 1702
const KEY_Ukranian_je = 1700
const KEY_Ukranian_yi = 1703
const KEY_Umacron = 990
const KEY_Undo = 65381
const KEY_Ungrab = 269024800
const KEY_Uogonek = 985
const KEY_Up = 65362
const KEY_Uring = 473
const KEY_User1KB = 269025157
const KEY_User2KB = 269025158
const KEY_UserPB = 269025156
const KEY_Utilde = 989
const KEY_V = 86
const KEY_VendorHome = 269025076
const KEY_Video = 269025159
const KEY_View = 269025185
const KEY_VoidSymbol = 16777215
const KEY_W = 87
const KEY_WLAN = 269025173
const KEY_WWAN = 269025204
const KEY_WWW = 269025070
const KEY_Wacute = 16785026
const KEY_WakeUp = 269025067
const KEY_Wcircumflex = 16777588
const KEY_Wdiaeresis = 16785028
const KEY_WebCam = 269025167
const KEY_Wgrave = 16785024
const KEY_WheelButton = 269025160
const KEY_WindowClear = 269025109
const KEY_WonSign = 16785577
const KEY_Word = 269025161
const KEY_X = 88
const KEY_Xabovedot = 16785034
const KEY_Xfer = 269025162
const KEY_Y = 89
const KEY_Yacute = 221
const KEY_Ybelowdot = 16785140
const KEY_Ycircumflex = 16777590
const KEY_Ydiaeresis = 5054
const KEY_Yellow = 269025189
const KEY_Ygrave = 16785138
const KEY_Yhook = 16785142
const KEY_Ytilde = 16785144
const KEY_Z = 90
const KEY_Zabovedot = 431
const KEY_Zacute = 428
const KEY_Zcaron = 430
const KEY_Zen_Koho = 65341
const KEY_Zenkaku = 65320
const KEY_Zenkaku_Hankaku = 65322
const KEY_ZoomIn = 269025163
const KEY_ZoomOut = 269025164
const KEY_Zstroke = 16777653
const KEY_a = 97
const KEY_aacute = 225
const KEY_abelowdot = 16785057
const KEY_abovedot = 511
const KEY_abreve = 483
const KEY_abreveacute = 16785071
const KEY_abrevebelowdot = 16785079
const KEY_abrevegrave = 16785073
const KEY_abrevehook = 16785075
const KEY_abrevetilde = 16785077
const KEY_acircumflex = 226
const KEY_acircumflexacute = 16785061
const KEY_acircumflexbelowdot = 16785069
const KEY_acircumflexgrave = 16785063
const KEY_acircumflexhook = 16785065
const KEY_acircumflextilde = 16785067
const KEY_acute = 180
const KEY_adiaeresis = 228
const KEY_ae = 230
const KEY_agrave = 224
const KEY_ahook = 16785059
const KEY_amacron = 992
const KEY_ampersand = 38
const KEY_aogonek = 433
const KEY_apostrophe = 39
const KEY_approxeq = 16785992
const KEY_approximate = 2248
const KEY_aring = 229
const KEY_asciicircum = 94
const KEY_asciitilde = 126
const KEY_asterisk = 42
const KEY_at = 64
const KEY_atilde = 227
const KEY_b = 98
const KEY_babovedot = 16784899
const KEY_backslash = 92
const KEY_ballotcross = 2804
const KEY_bar = 124
const KEY_because = 16785973
const KEY_blank = 2527
const KEY_botintegral = 2213
const KEY_botleftparens = 2220
const KEY_botleftsqbracket = 2216
const KEY_botleftsummation = 2226
const KEY_botrightparens = 2222
const KEY_botrightsqbracket = 2218
const KEY_botrightsummation = 2230
const KEY_bott = 2550
const KEY_botvertsummationconnector = 2228
const KEY_braceleft = 123
const KEY_braceright = 125
const KEY_bracketleft = 91
const KEY_bracketright = 93
const KEY_braille_blank = 16787456
const KEY_braille_dot_1 = 65521
const KEY_braille_dot_10 = 65530
const KEY_braille_dot_2 = 65522
const KEY_braille_dot_3 = 65523
const KEY_braille_dot_4 = 65524
const KEY_braille_dot_5 = 65525
const KEY_braille_dot_6 = 65526
const KEY_braille_dot_7 = 65527
const KEY_braille_dot_8 = 65528
const KEY_braille_dot_9 = 65529
const KEY_braille_dots_1 = 16787457
const KEY_braille_dots_12 = 16787459
const KEY_braille_dots_123 = 16787463
const KEY_braille_dots_1234 = 16787471
const KEY_braille_dots_12345 = 16787487
const KEY_braille_dots_123456 = 16787519
const KEY_braille_dots_1234567 = 16787583
const KEY_braille_dots_12345678 = 16787711
const KEY_braille_dots_1234568 = 16787647
const KEY_braille_dots_123457 = 16787551
const KEY_braille_dots_1234578 = 16787679
const KEY_braille_dots_123458 = 16787615
const KEY_braille_dots_12346 = 16787503
const KEY_braille_dots_123467 = 16787567
const KEY_braille_dots_1234678 = 16787695
const KEY_braille_dots_123468 = 16787631
const KEY_braille_dots_12347 = 16787535
const KEY_braille_dots_123478 = 16787663
const KEY_braille_dots_12348 = 16787599
const KEY_braille_dots_1235 = 16787479
const KEY_braille_dots_12356 = 16787511
const KEY_braille_dots_123567 = 16787575
const KEY_braille_dots_1235678 = 16787703
const KEY_braille_dots_123568 = 16787639
const KEY_braille_dots_12357 = 16787543
const KEY_braille_dots_123578 = 16787671
const KEY_braille_dots_12358 = 16787607
const KEY_braille_dots_1236 = 16787495
const KEY_braille_dots_12367 = 16787559
const KEY_braille_dots_123678 = 16787687
const KEY_braille_dots_12368 = 16787623
const KEY_braille_dots_1237 = 16787527
const KEY_braille_dots_12378 = 16787655
const KEY_braille_dots_1238 = 16787591
const KEY_braille_dots_124 = 16787467
const KEY_braille_dots_1245 = 16787483
const KEY_braille_dots_12456 = 16787515
const KEY_braille_dots_124567 = 16787579
const KEY_braille_dots_1245678 = 16787707
const KEY_braille_dots_124568 = 16787643
const KEY_braille_dots_12457 = 16787547
const KEY_braille_dots_124578 = 16787675
const KEY_braille_dots_12458 = 16787611
const KEY_braille_dots_1246 = 16787499
const KEY_braille_dots_12467 = 16787563
const KEY_braille_dots_124678 = 16787691
const KEY_braille_dots_12468 = 16787627
const KEY_braille_dots_1247 = 16787531
const KEY_braille_dots_12478 = 16787659
const KEY_braille_dots_1248 = 16787595
const KEY_braille_dots_125 = 16787475
const KEY_braille_dots_1256 = 16787507
const KEY_braille_dots_12567 = 16787571
const KEY_braille_dots_125678 = 16787699
const KEY_braille_dots_12568 = 16787635
const KEY_braille_dots_1257 = 16787539
const KEY_braille_dots_12578 = 16787667
const KEY_braille_dots_1258 = 16787603
const KEY_braille_dots_126 = 16787491
const KEY_braille_dots_1267 = 16787555
const KEY_braille_dots_12678 = 16787683
const KEY_braille_dots_1268 = 16787619
const KEY_braille_dots_127 = 16787523
const KEY_braille_dots_1278 = 16787651
const KEY_braille_dots_128 = 16787587
const KEY_braille_dots_13 = 16787461
const KEY_braille_dots_134 = 16787469
const KEY_braille_dots_1345 = 16787485
const KEY_braille_dots_13456 = 16787517
const KEY_braille_dots_134567 = 16787581
const KEY_braille_dots_1345678 = 16787709
const KEY_braille_dots_134568 = 16787645
const KEY_braille_dots_13457 = 16787549
const KEY_braille_dots_134578 = 16787677
const KEY_braille_dots_13458 = 16787613
const KEY_braille_dots_1346 = 16787501
const KEY_braille_dots_13467 = 16787565
const KEY_braille_dots_134678 = 16787693
const KEY_braille_dots_13468 = 16787629
const KEY_braille_dots_1347 = 16787533
const KEY_braille_dots_13478 = 16787661
const KEY_braille_dots_1348 = 16787597
const KEY_braille_dots_135 = 16787477
const KEY_braille_dots_1356 = 16787509
const KEY_braille_dots_13567 = 16787573
const KEY_braille_dots_135678 = 16787701
const KEY_braille_dots_13568 = 16787637
const KEY_braille_dots_1357 = 16787541
const KEY_braille_dots_13578 = 16787669
const KEY_braille_dots_1358 = 16787605
const KEY_braille_dots_136 = 16787493
const KEY_braille_dots_1367 = 16787557
const KEY_braille_dots_13678 = 16787685
const KEY_braille_dots_1368 = 16787621
const KEY_braille_dots_137 = 16787525
const KEY_braille_dots_1378 = 16787653
const KEY_braille_dots_138 = 16787589
const KEY_braille_dots_14 = 16787465
const KEY_braille_dots_145 = 16787481
const KEY_braille_dots_1456 = 16787513
const KEY_braille_dots_14567 = 16787577
const KEY_braille_dots_145678 = 16787705
const KEY_braille_dots_14568 = 16787641
const KEY_braille_dots_1457 = 16787545
const KEY_braille_dots_14578 = 16787673
const KEY_braille_dots_1458 = 16787609
const KEY_braille_dots_146 = 16787497
const KEY_braille_dots_1467 = 16787561
const KEY_braille_dots_14678 = 16787689
const KEY_braille_dots_1468 = 16787625
const KEY_braille_dots_147 = 16787529
const KEY_braille_dots_1478 = 16787657
const KEY_braille_dots_148 = 16787593
const KEY_braille_dots_15 = 16787473
const KEY_braille_dots_156 = 16787505
const KEY_braille_dots_1567 = 16787569
const KEY_braille_dots_15678 = 16787697
const KEY_braille_dots_1568 = 16787633
const KEY_braille_dots_157 = 16787537
const KEY_braille_dots_1578 = 16787665
const KEY_braille_dots_158 = 16787601
const KEY_braille_dots_16 = 16787489
const KEY_braille_dots_167 = 16787553
const KEY_braille_dots_1678 = 16787681
const KEY_braille_dots_168 = 16787617
const KEY_braille_dots_17 = 16787521
const KEY_braille_dots_178 = 16787649
const KEY_braille_dots_18 = 16787585
const KEY_braille_dots_2 = 16787458
const KEY_braille_dots_23 = 16787462
const KEY_braille_dots_234 = 16787470
const KEY_braille_dots_2345 = 16787486
const KEY_braille_dots_23456 = 16787518
const KEY_braille_dots_234567 = 16787582
const KEY_braille_dots_2345678 = 16787710
const KEY_braille_dots_234568 = 16787646
const KEY_braille_dots_23457 = 16787550
const KEY_braille_dots_234578 = 16787678
const KEY_braille_dots_23458 = 16787614
const KEY_braille_dots_2346 = 16787502
const KEY_braille_dots_23467 = 16787566
const KEY_braille_dots_234678 = 16787694
const KEY_braille_dots_23468 = 16787630
const KEY_braille_dots_2347 = 16787534
const KEY_braille_dots_23478 = 16787662
const KEY_braille_dots_2348 = 16787598
const KEY_braille_dots_235 = 16787478
const KEY_braille_dots_2356 = 16787510
const KEY_braille_dots_23567 = 16787574
const KEY_braille_dots_235678 = 16787702
const KEY_braille_dots_23568 = 16787638
const KEY_braille_dots_2357 = 16787542
const KEY_braille_dots_23578 = 16787670
const KEY_braille_dots_2358 = 16787606
const KEY_braille_dots_236 = 16787494
const KEY_braille_dots_2367 = 16787558
const KEY_braille_dots_23678 = 16787686
const KEY_braille_dots_2368 = 16787622
const KEY_braille_dots_237 = 16787526
const KEY_braille_dots_2378 = 16787654
const KEY_braille_dots_238 = 16787590
const KEY_braille_dots_24 = 16787466
const KEY_braille_dots_245 = 16787482
const KEY_braille_dots_2456 = 16787514
const KEY_braille_dots_24567 = 16787578
const KEY_braille_dots_245678 = 16787706
const KEY_braille_dots_24568 = 16787642
const KEY_braille_dots_2457 = 16787546
const KEY_braille_dots_24578 = 16787674
const KEY_braille_dots_2458 = 16787610
const KEY_braille_dots_246 = 16787498
const KEY_braille_dots_2467 = 16787562
const KEY_braille_dots_24678 = 16787690
const KEY_braille_dots_2468 = 16787626
const KEY_braille_dots_247 = 16787530
const KEY_braille_dots_2478 = 16787658
const KEY_braille_dots_248 = 16787594
const KEY_braille_dots_25 = 16787474
const KEY_braille_dots_256 = 16787506
const KEY_braille_dots_2567 = 16787570
const KEY_braille_dots_25678 = 16787698
const KEY_braille_dots_2568 = 16787634
const KEY_braille_dots_257 = 16787538
const KEY_braille_dots_2578 = 16787666
const KEY_braille_dots_258 = 16787602
const KEY_braille_dots_26 = 16787490
const KEY_braille_dots_267 = 16787554
const KEY_braille_dots_2678 = 16787682
const KEY_braille_dots_268 = 16787618
const KEY_braille_dots_27 = 16787522
const KEY_braille_dots_278 = 16787650
const KEY_braille_dots_28 = 16787586
const KEY_braille_dots_3 = 16787460
const KEY_braille_dots_34 = 16787468
const KEY_braille_dots_345 = 16787484
const KEY_braille_dots_3456 = 16787516
const KEY_braille_dots_34567 = 16787580
const KEY_braille_dots_345678 = 16787708
const KEY_braille_dots_34568 = 16787644
const KEY_braille_dots_3457 = 16787548
const KEY_braille_dots_34578 = 16787676
const KEY_braille_dots_3458 = 16787612
const KEY_braille_dots_346 = 16787500
const KEY_braille_dots_3467 = 16787564
const KEY_braille_dots_34678 = 16787692
const KEY_braille_dots_3468 = 16787628
const KEY_braille_dots_347 = 16787532
const KEY_braille_dots_3478 = 16787660
const KEY_braille_dots_348 = 16787596
const KEY_braille_dots_35 = 16787476
const KEY_braille_dots_356 = 16787508
const KEY_braille_dots_3567 = 16787572
const KEY_braille_dots_35678 = 16787700
const KEY_braille_dots_3568 = 16787636
const KEY_braille_dots_357 = 16787540
const KEY_braille_dots_3578 = 16787668
const KEY_braille_dots_358 = 16787604
const KEY_braille_dots_36 = 16787492
const KEY_braille_dots_367 = 16787556
const KEY_braille_dots_3678 = 16787684
const KEY_braille_dots_368 = 16787620
const KEY_braille_dots_37 = 16787524
const KEY_braille_dots_378 = 16787652
const KEY_braille_dots_38 = 16787588
const KEY_braille_dots_4 = 16787464
const KEY_braille_dots_45 = 16787480
const KEY_braille_dots_456 = 16787512
const KEY_braille_dots_4567 = 16787576
const KEY_braille_dots_45678 = 16787704
const KEY_braille_dots_4568 = 16787640
const KEY_braille_dots_457 = 16787544
const KEY_braille_dots_4578 = 16787672
const KEY_braille_dots_458 = 16787608
const KEY_braille_dots_46 = 16787496
const KEY_braille_dots_467 = 16787560
const KEY_braille_dots_4678 = 16787688
const KEY_braille_dots_468 = 16787624
const KEY_braille_dots_47 = 16787528
const KEY_braille_dots_478 = 16787656
const KEY_braille_dots_48 = 16787592
const KEY_braille_dots_5 = 16787472
const KEY_braille_dots_56 = 16787504
const KEY_braille_dots_567 = 16787568
const KEY_braille_dots_5678 = 16787696
const KEY_braille_dots_568 = 16787632
const KEY_braille_dots_57 = 16787536
const KEY_braille_dots_578 = 16787664
const KEY_braille_dots_58 = 16787600
const KEY_braille_dots_6 = 16787488
const KEY_braille_dots_67 = 16787552
const KEY_braille_dots_678 = 16787680
const KEY_braille_dots_68 = 16787616
const KEY_braille_dots_7 = 16787520
const KEY_braille_dots_78 = 16787648
const KEY_braille_dots_8 = 16787584
const KEY_breve = 418
const KEY_brokenbar = 166
const KEY_c = 99
const KEY_c_h = 65187
const KEY_cabovedot = 741
const KEY_cacute = 486
const KEY_careof = 2744
const KEY_caret = 2812
const KEY_caron = 439
const KEY_ccaron = 488
const KEY_ccedilla = 231
const KEY_ccircumflex = 742
const KEY_cedilla = 184
const KEY_cent = 162
const KEY_ch = 65184
const KEY_checkerboard = 2529
const KEY_checkmark = 2803
const KEY_circle = 3023
const KEY_club = 2796
const KEY_colon = 58
const KEY_comma = 44
const KEY_containsas = 16785931
const KEY_copyright = 169
const KEY_cr = 2532
const KEY_crossinglines = 2542
const KEY_cuberoot = 16785947
const KEY_currency = 164
const KEY_cursor = 2815
const KEY_d = 100
const KEY_dabovedot = 16784907
const KEY_dagger = 2801
const KEY_dcaron = 495
const KEY_dead_A = 65153
const KEY_dead_E = 65155
const KEY_dead_I = 65157
const KEY_dead_O = 65159
const KEY_dead_U = 65161
const KEY_dead_a = 65152
const KEY_dead_abovecomma = 65124
const KEY_dead_abovedot = 65110
const KEY_dead_abovereversedcomma = 65125
const KEY_dead_abovering = 65112
const KEY_dead_aboveverticalline = 65169
const KEY_dead_acute = 65105
const KEY_dead_belowbreve = 65131
const KEY_dead_belowcircumflex = 65129
const KEY_dead_belowcomma = 65134
const KEY_dead_belowdiaeresis = 65132
const KEY_dead_belowdot = 65120
const KEY_dead_belowmacron = 65128
const KEY_dead_belowring = 65127
const KEY_dead_belowtilde = 65130
const KEY_dead_belowverticalline = 65170
const KEY_dead_breve = 65109
const KEY_dead_capital_schwa = 65163
const KEY_dead_caron = 65114
const KEY_dead_cedilla = 65115
const KEY_dead_circumflex = 65106
const KEY_dead_currency = 65135
const KEY_dead_dasia = 65125
const KEY_dead_diaeresis = 65111
const KEY_dead_doubleacute = 65113
const KEY_dead_doublegrave = 65126
const KEY_dead_e = 65154
const KEY_dead_grave = 65104
const KEY_dead_greek = 65164
const KEY_dead_hook = 65121
const KEY_dead_horn = 65122
const KEY_dead_i = 65156
const KEY_dead_invertedbreve = 65133
const KEY_dead_iota = 65117
const KEY_dead_longsolidusoverlay = 65171
const KEY_dead_lowline = 65168
const KEY_dead_macron = 65108
const KEY_dead_o = 65158
const KEY_dead_ogonek = 65116
const KEY_dead_perispomeni = 65107
const KEY_dead_psili = 65124
const KEY_dead_semivoiced_sound = 65119
const KEY_dead_small_schwa = 65162
const KEY_dead_stroke = 65123
const KEY_dead_tilde = 65107
const KEY_dead_u = 65160
const KEY_dead_voiced_sound = 65118
const KEY_decimalpoint = 2749
const KEY_degree = 176
const KEY_diaeresis = 168
const KEY_diamond = 2797
const KEY_digitspace = 2725
const KEY_dintegral = 16785964
const KEY_division = 247
const KEY_dollar = 36
const KEY_doubbaselinedot = 2735
const KEY_doubleacute = 445
const KEY_doubledagger = 2802
const KEY_doublelowquotemark = 2814
const KEY_downarrow = 2302
const KEY_downcaret = 2984
const KEY_downshoe = 3030
const KEY_downstile = 3012
const KEY_downtack = 3010
const KEY_dstroke = 496
const KEY_e = 101
const KEY_eabovedot = 1004
const KEY_eacute = 233
const KEY_ebelowdot = 16785081
const KEY_ecaron = 492
const KEY_ecircumflex = 234
const KEY_ecircumflexacute = 16785087
const KEY_ecircumflexbelowdot = 16785095
const KEY_ecircumflexgrave = 16785089
const KEY_ecircumflexhook = 16785091
const KEY_ecircumflextilde = 16785093
const KEY_ediaeresis = 235
const KEY_egrave = 232
const KEY_ehook = 16785083
const KEY_eightsubscript = 16785544
const KEY_eightsuperior = 16785528
const KEY_elementof = 16785928
const KEY_ellipsis = 2734
const KEY_em3space = 2723
const KEY_em4space = 2724
const KEY_emacron = 954
const KEY_emdash = 2729
const KEY_emfilledcircle = 2782
const KEY_emfilledrect = 2783
const KEY_emopencircle = 2766
const KEY_emopenrectangle = 2767
const KEY_emptyset = 16785925
const KEY_emspace = 2721
const KEY_endash = 2730
const KEY_enfilledcircbullet = 2790
const KEY_enfilledsqbullet = 2791
const KEY_eng = 959
const KEY_enopencircbullet = 2784
const KEY_enopensquarebullet = 2785
const KEY_enspace = 2722
const KEY_eogonek = 490
const KEY_equal = 61
const KEY_eth = 240
const KEY_etilde = 16785085
const KEY_exclam = 33
const KEY_exclamdown = 161
const KEY_ezh = 16777874
const KEY_f = 102
const KEY_fabovedot = 16784927
const KEY_femalesymbol = 2808
const KEY_ff = 2531
const KEY_figdash = 2747
const KEY_filledlefttribullet = 2780
const KEY_filledrectbullet = 2779
const KEY_filledrighttribullet = 2781
const KEY_filledtribulletdown = 2793
const KEY_filledtribulletup = 2792
const KEY_fiveeighths = 2757
const KEY_fivesixths = 2743
const KEY_fivesubscript = 16785541
const KEY_fivesuperior = 16785525
const KEY_fourfifths = 2741
const KEY_foursubscript = 16785540
const KEY_foursuperior = 16785524
const KEY_fourthroot = 16785948
const KEY_function = 2294
const KEY_g = 103
const KEY_gabovedot = 757
const KEY_gbreve = 699
const KEY_gcaron = 16777703
const KEY_gcedilla = 955
const KEY_gcircumflex = 760
const KEY_grave = 96
const KEY_greater = 62
const KEY_greaterthanequal = 2238
const KEY_guillemotleft = 171
const KEY_guillemotright = 187
const KEY_h = 104
const KEY_hairspace = 2728
const KEY_hcircumflex = 694
const KEY_heart = 2798
const KEY_hebrew_aleph = 3296
const KEY_hebrew_ayin = 3314
const KEY_hebrew_bet = 3297
const KEY_hebrew_beth = 3297
const KEY_hebrew_chet = 3303
const KEY_hebrew_dalet = 3299
const KEY_hebrew_daleth = 3299
const KEY_hebrew_doublelowline = 3295
const KEY_hebrew_finalkaph = 3306
const KEY_hebrew_finalmem = 3309
const KEY_hebrew_finalnun = 3311
const KEY_hebrew_finalpe = 3315
const KEY_hebrew_finalzade = 3317
const KEY_hebrew_finalzadi = 3317
const KEY_hebrew_gimel = 3298
const KEY_hebrew_gimmel = 3298
const KEY_hebrew_he = 3300
const KEY_hebrew_het = 3303
const KEY_hebrew_kaph = 3307
const KEY_hebrew_kuf = 3319
const KEY_hebrew_lamed = 3308
const KEY_hebrew_mem = 3310
const KEY_hebrew_nun = 3312
const KEY_hebrew_pe = 3316
const KEY_hebrew_qoph = 3319
const KEY_hebrew_resh = 3320
const KEY_hebrew_samech = 3313
const KEY_hebrew_samekh = 3313
const KEY_hebrew_shin = 3321
const KEY_hebrew_taf = 3322
const KEY_hebrew_taw = 3322
const KEY_hebrew_tet = 3304
const KEY_hebrew_teth = 3304
const KEY_hebrew_waw = 3301
const KEY_hebrew_yod = 3305
const KEY_hebrew_zade = 3318
const KEY_hebrew_zadi = 3318
const KEY_hebrew_zain = 3302
const KEY_hebrew_zayin = 3302
const KEY_hexagram = 2778
const KEY_horizconnector = 2211
const KEY_horizlinescan1 = 2543
const KEY_horizlinescan3 = 2544
const KEY_horizlinescan5 = 2545
const KEY_horizlinescan7 = 2546
const KEY_horizlinescan9 = 2547
const KEY_hstroke = 689
const KEY_ht = 2530
const KEY_hyphen = 173
const KEY_i = 105
const KEY_iTouch = 269025120
const KEY_iacute = 237
const KEY_ibelowdot = 16785099
const KEY_ibreve = 16777517
const KEY_icircumflex = 238
const KEY_identical = 2255
const KEY_idiaeresis = 239
const KEY_idotless = 697
const KEY_ifonlyif = 2253
const KEY_igrave = 236
const KEY_ihook = 16785097
const KEY_imacron = 1007
const KEY_implies = 2254
const KEY_includedin = 2266
const KEY_includes = 2267
const KEY_infinity = 2242
const KEY_integral = 2239
const KEY_intersection = 2268
const KEY_iogonek = 999
const KEY_itilde = 949
const KEY_j = 106
const KEY_jcircumflex = 700
const KEY_jot = 3018
const KEY_k = 107
const KEY_kana_A = 1201
const KEY_kana_CHI = 1217
const KEY_kana_E = 1204
const KEY_kana_FU = 1228
const KEY_kana_HA = 1226
const KEY_kana_HE = 1229
const KEY_kana_HI = 1227
const KEY_kana_HO = 1230
const KEY_kana_HU = 1228
const KEY_kana_I = 1202
const KEY_kana_KA = 1206
const KEY_kana_KE = 1209
const KEY_kana_KI = 1207
const KEY_kana_KO = 1210
const KEY_kana_KU = 1208
const KEY_kana_MA = 1231
const KEY_kana_ME = 1234
const KEY_kana_MI = 1232
const KEY_kana_MO = 1235
const KEY_kana_MU = 1233
const KEY_kana_N = 1245
const KEY_kana_NA = 1221
const KEY_kana_NE = 1224
const KEY_kana_NI = 1222
const KEY_kana_NO = 1225
const KEY_kana_NU = 1223
const KEY_kana_O = 1205
const KEY_kana_RA = 1239
const KEY_kana_RE = 1242
const KEY_kana_RI = 1240
const KEY_kana_RO = 1243
const KEY_kana_RU = 1241
const KEY_kana_SA = 1211
const KEY_kana_SE = 1214
const KEY_kana_SHI = 1212
const KEY_kana_SO = 1215
const KEY_kana_SU = 1213
const KEY_kana_TA = 1216
const KEY_kana_TE = 1219
const KEY_kana_TI = 1217
const KEY_kana_TO = 1220
const KEY_kana_TSU = 1218
const KEY_kana_TU = 1218
const KEY_kana_U = 1203
const KEY_kana_WA = 1244
const KEY_kana_WO = 1190
const KEY_kana_YA = 1236
const KEY_kana_YO = 1238
const KEY_kana_YU = 1237
const KEY_kana_a = 1191
const KEY_kana_closingbracket = 1187
const KEY_kana_comma = 1188
const KEY_kana_conjunctive = 1189
const KEY_kana_e = 1194
const KEY_kana_fullstop = 1185
const KEY_kana_i = 1192
const KEY_kana_middledot = 1189
const KEY_kana_o = 1195
const KEY_kana_openingbracket = 1186
const KEY_kana_switch = 65406
const KEY_kana_tsu = 1199
const KEY_kana_tu = 1199
const KEY_kana_u = 1193
const KEY_kana_ya = 1196
const KEY_kana_yo = 1198
const KEY_kana_yu = 1197
const KEY_kappa = 930
const KEY_kcedilla = 1011
const KEY_kra = 930
const KEY_l = 108
const KEY_lacute = 485
const KEY_latincross = 2777
const KEY_lbelowdot = 16784951
const KEY_lcaron = 437
const KEY_lcedilla = 950
const KEY_leftanglebracket = 2748
const KEY_leftarrow = 2299
const KEY_leftcaret = 2979
const KEY_leftdoublequotemark = 2770
const KEY_leftmiddlecurlybrace = 2223
const KEY_leftopentriangle = 2764
const KEY_leftpointer = 2794
const KEY_leftradical = 2209
const KEY_leftshoe = 3034
const KEY_leftsinglequotemark = 2768
const KEY_leftt = 2548
const KEY_lefttack = 3036
const KEY_less = 60
const KEY_lessthanequal = 2236
const KEY_lf = 2533
const KEY_logicaland = 2270
const KEY_logicalor = 2271
const KEY_lowleftcorner = 2541
const KEY_lowrightcorner = 2538
const KEY_lstroke = 435
const KEY_m = 109
const KEY_mabovedot = 16784961
const KEY_macron = 175
const KEY_malesymbol = 2807
const KEY_maltesecross = 2800
const KEY_marker = 2751
const KEY_masculine = 186
const KEY_minus = 45
const KEY_minutes = 2774
const KEY_mu = 181
const KEY_multiply = 215
const KEY_musicalflat = 2806
const KEY_musicalsharp = 2805
const KEY_n = 110
const KEY_nabla = 2245
const KEY_nacute = 497
const KEY_ncaron = 498
const KEY_ncedilla = 1009
const KEY_ninesubscript = 16785545
const KEY_ninesuperior = 16785529
const KEY_nl = 2536
const KEY_nobreakspace = 160
const KEY_notapproxeq = 16785991
const KEY_notelementof = 16785929
const KEY_notequal = 2237
const KEY_notidentical = 16786018
const KEY_notsign = 172
const KEY_ntilde = 241
const KEY_numbersign = 35
const KEY_numerosign = 1712
const KEY_o = 111
const KEY_oacute = 243
const KEY_obarred = 16777845
const KEY_obelowdot = 16785101
const KEY_ocaron = 16777682
const KEY_ocircumflex = 244
const KEY_ocircumflexacute = 16785105
const KEY_ocircumflexbelowdot = 16785113
const KEY_ocircumflexgrave = 16785107
const KEY_ocircumflexhook = 16785109
const KEY_ocircumflextilde = 16785111
const KEY_odiaeresis = 246
const KEY_odoubleacute = 501
const KEY_oe = 5053
const KEY_ogonek = 434
const KEY_ograve = 242
const KEY_ohook = 16785103
const KEY_ohorn = 16777633
const KEY_ohornacute = 16785115
const KEY_ohornbelowdot = 16785123
const KEY_ohorngrave = 16785117
const KEY_ohornhook = 16785119
const KEY_ohorntilde = 16785121
const KEY_omacron = 1010
const KEY_oneeighth = 2755
const KEY_onefifth = 2738
const KEY_onehalf = 189
const KEY_onequarter = 188
const KEY_onesixth = 2742
const KEY_onesubscript = 16785537
const KEY_onesuperior = 185
const KEY_onethird = 2736
const KEY_ooblique = 248
const KEY_openrectbullet = 2786
const KEY_openstar = 2789
const KEY_opentribulletdown = 2788
const KEY_opentribulletup = 2787
const KEY_ordfeminine = 170
const KEY_oslash = 248
const KEY_otilde = 245
const KEY_overbar = 3008
const KEY_overline = 1150
const KEY_p = 112
const KEY_pabovedot = 16784983
const KEY_paragraph = 182
const KEY_parenleft = 40
const KEY_parenright = 41
const KEY_partdifferential = 16785922
const KEY_partialderivative = 2287
const KEY_percent = 37
const KEY_period = 46
const KEY_periodcentered = 183
const KEY_permille = 2773
const KEY_phonographcopyright = 2811
const KEY_plus = 43
const KEY_plusminus = 177
const KEY_prescription = 2772
const KEY_prolongedsound = 1200
const KEY_punctspace = 2726
const KEY_q = 113
const KEY_quad = 3020
const KEY_question = 63
const KEY_questiondown = 191
const KEY_quotedbl = 34
const KEY_quoteleft = 96
const KEY_quoteright = 39
const KEY_r = 114
const KEY_racute = 480
const KEY_radical = 2262
const KEY_rcaron = 504
const KEY_rcedilla = 947
const KEY_registered = 174
const KEY_rightanglebracket = 2750
const KEY_rightarrow = 2301
const KEY_rightcaret = 2982
const KEY_rightdoublequotemark = 2771
const KEY_rightmiddlecurlybrace = 2224
const KEY_rightmiddlesummation = 2231
const KEY_rightopentriangle = 2765
const KEY_rightpointer = 2795
const KEY_rightshoe = 3032
const KEY_rightsinglequotemark = 2769
const KEY_rightt = 2549
const KEY_righttack = 3068
const KEY_s = 115
const KEY_sabovedot = 16784993
const KEY_sacute = 438
const KEY_scaron = 441
const KEY_scedilla = 442
const KEY_schwa = 16777817
const KEY_scircumflex = 766
const KEY_script_switch = 65406
const KEY_seconds = 2775
const KEY_section = 167
const KEY_semicolon = 59
const KEY_semivoicedsound = 1247
const KEY_seveneighths = 2758
const KEY_sevensubscript = 16785543
const KEY_sevensuperior = 16785527
const KEY_signaturemark = 2762
const KEY_signifblank = 2732
const KEY_similarequal = 2249
const KEY_singlelowquotemark = 2813
const KEY_sixsubscript = 16785542
const KEY_sixsuperior = 16785526
const KEY_slash = 47
const KEY_soliddiamond = 2528
const KEY_space = 32
const KEY_squareroot = 16785946
const KEY_ssharp = 223
const KEY_sterling = 163
const KEY_stricteq = 16786019
const KEY_t = 116
const KEY_tabovedot = 16785003
const KEY_tcaron = 443
const KEY_tcedilla = 510
const KEY_telephone = 2809
const KEY_telephonerecorder = 2810
const KEY_therefore = 2240
const KEY_thinspace = 2727
const KEY_thorn = 254
const KEY_threeeighths = 2756
const KEY_threefifths = 2740
const KEY_threequarters = 190
const KEY_threesubscript = 16785539
const KEY_threesuperior = 179
const KEY_tintegral = 16785965
const KEY_topintegral = 2212
const KEY_topleftparens = 2219
const KEY_topleftradical = 2210
const KEY_topleftsqbracket = 2215
const KEY_topleftsummation = 2225
const KEY_toprightparens = 2221
const KEY_toprightsqbracket = 2217
const KEY_toprightsummation = 2229
const KEY_topt = 2551
const KEY_topvertsummationconnector = 2227
const KEY_trademark = 2761
const KEY_trademarkincircle = 2763
const KEY_tslash = 956
const KEY_twofifths = 2739
const KEY_twosubscript = 16785538
const KEY_twosuperior = 178
const KEY_twothirds = 2737
const KEY_u = 117
const KEY_uacute = 250
const KEY_ubelowdot = 16785125
const KEY_ubreve = 765
const KEY_ucircumflex = 251
const KEY_udiaeresis = 252
const KEY_udoubleacute = 507
const KEY_ugrave = 249
const KEY_uhook = 16785127
const KEY_uhorn = 16777648
const KEY_uhornacute = 16785129
const KEY_uhornbelowdot = 16785137
const KEY_uhorngrave = 16785131
const KEY_uhornhook = 16785133
const KEY_uhorntilde = 16785135
const KEY_umacron = 1022
const KEY_underbar = 3014
const KEY_underscore = 95
const KEY_union = 2269
const KEY_uogonek = 1017
const KEY_uparrow = 2300
const KEY_upcaret = 2985
const KEY_upleftcorner = 2540
const KEY_uprightcorner = 2539
const KEY_upshoe = 3011
const KEY_upstile = 3027
const KEY_uptack = 3022
const KEY_uring = 505
const KEY_utilde = 1021
const KEY_v = 118
const KEY_variation = 2241
const KEY_vertbar = 2552
const KEY_vertconnector = 2214
const KEY_voicedsound = 1246
const KEY_vt = 2537
const KEY_w = 119
const KEY_wacute = 16785027
const KEY_wcircumflex = 16777589
const KEY_wdiaeresis = 16785029
const KEY_wgrave = 16785025
const KEY_x = 120
const KEY_xabovedot = 16785035
const KEY_y = 121
const KEY_yacute = 253
const KEY_ybelowdot = 16785141
const KEY_ycircumflex = 16777591
const KEY_ydiaeresis = 255
const KEY_yen = 165
const KEY_ygrave = 16785139
const KEY_yhook = 16785143
const KEY_ytilde = 16785145
const KEY_z = 122
const KEY_zabovedot = 447
const KEY_zacute = 444
const KEY_zcaron = 446
const KEY_zerosubscript = 16785536
const KEY_zerosuperior = 16785520
const KEY_zstroke = 16777654

// MODIFIER_MASK: mask covering all entries in GdkModifierType.
const MODIFIER_MASK = 469769999

// PRIORITY_REDRAW: this is the priority that the idle handler processing
// surface updates is given in the main loop.
const PRIORITY_REDRAW = 120

// AxisUse defines how device axes are interpreted by GTK.
//
// Note that the X and Y axes are not really needed; pointer devices report
// their location via the x/y members of events regardless. Whether X and Y are
// present as axes depends on the GDK backend.
type AxisUse C.gint

const (
	// AxisIgnore axis is ignored.
	AxisIgnore AxisUse = iota
	// AxisX axis is used as the x axis.
	AxisX
	// AxisY axis is used as the y axis.
	AxisY
	// AxisDeltaX axis is used as the scroll x delta.
	AxisDeltaX
	// AxisDeltaY axis is used as the scroll y delta.
	AxisDeltaY
	// AxisPressure axis is used for pressure information.
	AxisPressure
	// AxisXtilt axis is used for x tilt information.
	AxisXtilt
	// AxisYtilt axis is used for y tilt information.
	AxisYtilt
	// AxisWheel axis is used for wheel information.
	AxisWheel
	// AxisDistance axis is used for pen/tablet distance information.
	AxisDistance
	// AxisRotation axis is used for pen rotation information.
	AxisRotation
	// AxisSlider axis is used for pen slider information.
	AxisSlider
	// AxisLast: constant equal to the numerically highest axis value.
	AxisLast
)

func marshalAxisUse(p uintptr) (interface{}, error) {
	return AxisUse(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AxisUse.
func (a AxisUse) String() string {
	switch a {
	case AxisIgnore:
		return "Ignore"
	case AxisX:
		return "X"
	case AxisY:
		return "Y"
	case AxisDeltaX:
		return "DeltaX"
	case AxisDeltaY:
		return "DeltaY"
	case AxisPressure:
		return "Pressure"
	case AxisXtilt:
		return "Xtilt"
	case AxisYtilt:
		return "Ytilt"
	case AxisWheel:
		return "Wheel"
	case AxisDistance:
		return "Distance"
	case AxisRotation:
		return "Rotation"
	case AxisSlider:
		return "Slider"
	case AxisLast:
		return "Last"
	default:
		return fmt.Sprintf("AxisUse(%d)", a)
	}
}

// CrossingMode specifies the crossing mode for enter and leave events.
type CrossingMode C.gint

const (
	// CrossingNormal: crossing because of pointer motion.
	CrossingNormal CrossingMode = iota
	// CrossingGrab: crossing because a grab is activated.
	CrossingGrab
	// CrossingUngrab: crossing because a grab is deactivated.
	CrossingUngrab
	// CrossingGTKGrab: crossing because a GTK grab is activated.
	CrossingGTKGrab
	// CrossingGTKUngrab: crossing because a GTK grab is deactivated.
	CrossingGTKUngrab
	// CrossingStateChanged: crossing because a GTK widget changed state (e.g.
	// sensitivity).
	CrossingStateChanged
	// CrossingTouchBegin: crossing because a touch sequence has begun, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingTouchBegin
	// CrossingTouchEnd: crossing because a touch sequence has ended, this event
	// is synthetic as the pointer might have not left the surface.
	CrossingTouchEnd
	// CrossingDeviceSwitch: crossing because of a device switch (i.e.
	// a mouse taking control of the pointer after a touch device), this event
	// is synthetic as the pointer didn’t leave the surface.
	CrossingDeviceSwitch
)

func marshalCrossingMode(p uintptr) (interface{}, error) {
	return CrossingMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CrossingMode.
func (c CrossingMode) String() string {
	switch c {
	case CrossingNormal:
		return "Normal"
	case CrossingGrab:
		return "Grab"
	case CrossingUngrab:
		return "Ungrab"
	case CrossingGTKGrab:
		return "GTKGrab"
	case CrossingGTKUngrab:
		return "GTKUngrab"
	case CrossingStateChanged:
		return "StateChanged"
	case CrossingTouchBegin:
		return "TouchBegin"
	case CrossingTouchEnd:
		return "TouchEnd"
	case CrossingDeviceSwitch:
		return "DeviceSwitch"
	default:
		return fmt.Sprintf("CrossingMode(%d)", c)
	}
}

// DevicePadFeature: pad feature.
type DevicePadFeature C.gint

const (
	// DevicePadFeatureButton: button.
	DevicePadFeatureButton DevicePadFeature = iota
	// DevicePadFeatureRing: ring-shaped interactive area.
	DevicePadFeatureRing
	// DevicePadFeatureStrip: straight interactive area.
	DevicePadFeatureStrip
)

func marshalDevicePadFeature(p uintptr) (interface{}, error) {
	return DevicePadFeature(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DevicePadFeature.
func (d DevicePadFeature) String() string {
	switch d {
	case DevicePadFeatureButton:
		return "Button"
	case DevicePadFeatureRing:
		return "Ring"
	case DevicePadFeatureStrip:
		return "Strip"
	default:
		return fmt.Sprintf("DevicePadFeature(%d)", d)
	}
}

// DeviceToolType indicates the specific type of tool being used being a tablet.
// Such as an airbrush, pencil, etc.
type DeviceToolType C.gint

const (
	// DeviceToolTypeUnknown: tool is of an unknown type.
	DeviceToolTypeUnknown DeviceToolType = iota
	// DeviceToolTypePen: tool is a standard tablet stylus.
	DeviceToolTypePen
	// DeviceToolTypeEraser: tool is standard tablet eraser.
	DeviceToolTypeEraser
	// DeviceToolTypeBrush: tool is a brush stylus.
	DeviceToolTypeBrush
	// DeviceToolTypePencil: tool is a pencil stylus.
	DeviceToolTypePencil
	// DeviceToolTypeAirbrush: tool is an airbrush stylus.
	DeviceToolTypeAirbrush
	// DeviceToolTypeMouse: tool is a mouse.
	DeviceToolTypeMouse
	// DeviceToolTypeLens: tool is a lens cursor.
	DeviceToolTypeLens
)

func marshalDeviceToolType(p uintptr) (interface{}, error) {
	return DeviceToolType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DeviceToolType.
func (d DeviceToolType) String() string {
	switch d {
	case DeviceToolTypeUnknown:
		return "Unknown"
	case DeviceToolTypePen:
		return "Pen"
	case DeviceToolTypeEraser:
		return "Eraser"
	case DeviceToolTypeBrush:
		return "Brush"
	case DeviceToolTypePencil:
		return "Pencil"
	case DeviceToolTypeAirbrush:
		return "Airbrush"
	case DeviceToolTypeMouse:
		return "Mouse"
	case DeviceToolTypeLens:
		return "Lens"
	default:
		return fmt.Sprintf("DeviceToolType(%d)", d)
	}
}

// DmabufError: error enumeration for GdkDmabufTexture.
type DmabufError C.gint

const (
	// DmabufErrorNotAvailable: dmabuf support is not available, because the OS
	// is not Linux, or it was explicitly disabled at compile- or runtime.
	DmabufErrorNotAvailable DmabufError = iota
	// DmabufErrorUnsupportedFormat: requested format is not supported.
	DmabufErrorUnsupportedFormat
	// DmabufErrorCreationFailed: GTK failed to create the resource for other
	// reasons.
	DmabufErrorCreationFailed
)

func marshalDmabufError(p uintptr) (interface{}, error) {
	return DmabufError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DmabufError.
func (d DmabufError) String() string {
	switch d {
	case DmabufErrorNotAvailable:
		return "NotAvailable"
	case DmabufErrorUnsupportedFormat:
		return "UnsupportedFormat"
	case DmabufErrorCreationFailed:
		return "CreationFailed"
	default:
		return fmt.Sprintf("DmabufError(%d)", d)
	}
}

func DmabufErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gdk_dmabuf_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// DragCancelReason: used in GdkDrag to the reason of a cancelled DND operation.
type DragCancelReason C.gint

const (
	// DragCancelNoTarget: there is no suitable drop target.
	DragCancelNoTarget DragCancelReason = iota
	// DragCancelUserCancelled: drag cancelled by the user.
	DragCancelUserCancelled
	// DragCancelError: unspecified error.
	DragCancelError
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DragCancelReason.
func (d DragCancelReason) String() string {
	switch d {
	case DragCancelNoTarget:
		return "NoTarget"
	case DragCancelUserCancelled:
		return "UserCancelled"
	case DragCancelError:
		return "Error"
	default:
		return fmt.Sprintf("DragCancelReason(%d)", d)
	}
}

// EventType specifies the type of the event.
type EventType C.gint

const (
	// Delete: window manager has requested that the toplevel surface be hidden
	// or destroyed, usually when the user clicks on a special icon in the title
	// bar.
	Delete EventType = iota
	// MotionNotify: pointer (usually a mouse) has moved.
	MotionNotify
	// ButtonPress: mouse button has been pressed.
	ButtonPress
	// ButtonRelease: mouse button has been released.
	ButtonRelease
	// KeyPress: key has been pressed.
	KeyPress
	// KeyRelease: key has been released.
	KeyRelease
	// EnterNotify: pointer has entered the surface.
	EnterNotify
	// LeaveNotify: pointer has left the surface.
	LeaveNotify
	// FocusChange: keyboard focus has entered or left the surface.
	FocusChange
	// ProximityIn: input device has moved into contact with a sensing surface
	// (e.g. a touchscreen or graphics tablet).
	ProximityIn
	// ProximityOut: input device has moved out of contact with a sensing
	// surface.
	ProximityOut
	// DragEnter: mouse has entered the surface while a drag is in progress.
	DragEnter
	// DragLeave: mouse has left the surface while a drag is in progress.
	DragLeave
	// DragMotion: mouse has moved in the surface while a drag is in progress.
	DragMotion
	// DropStart: drop operation onto the surface has started.
	DropStart
	// Scroll: scroll wheel was turned.
	Scroll
	// GrabBroken: pointer or keyboard grab was broken.
	GrabBroken
	// TouchBegin: new touch event sequence has just started.
	TouchBegin
	// TouchUpdate: touch event sequence has been updated.
	TouchUpdate
	// TouchEnd: touch event sequence has finished.
	TouchEnd
	// TouchCancel: touch event sequence has been canceled.
	TouchCancel
	// TouchpadSwipe: touchpad swipe gesture event, the current state is
	// determined by its phase field.
	TouchpadSwipe
	// TouchpadPinch: touchpad pinch gesture event, the current state is
	// determined by its phase field.
	TouchpadPinch
	// PadButtonPress: tablet pad button press event.
	PadButtonPress
	// PadButtonRelease: tablet pad button release event.
	PadButtonRelease
	// PadRing: tablet pad axis event from a "ring".
	PadRing
	// PadStrip: tablet pad axis event from a "strip".
	PadStrip
	// PadGroupMode: tablet pad group mode change.
	PadGroupMode
	// TouchpadHold: touchpad hold gesture event, the current state is
	// determined by its phase field.
	TouchpadHold
	// EventLast marks the end of the GdkEventType enumeration.
	EventLast
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EventType.
func (e EventType) String() string {
	switch e {
	case Delete:
		return "Delete"
	case MotionNotify:
		return "MotionNotify"
	case ButtonPress:
		return "ButtonPress"
	case ButtonRelease:
		return "ButtonRelease"
	case KeyPress:
		return "KeyPress"
	case KeyRelease:
		return "KeyRelease"
	case EnterNotify:
		return "EnterNotify"
	case LeaveNotify:
		return "LeaveNotify"
	case FocusChange:
		return "FocusChange"
	case ProximityIn:
		return "ProximityIn"
	case ProximityOut:
		return "ProximityOut"
	case DragEnter:
		return "DragEnter"
	case DragLeave:
		return "DragLeave"
	case DragMotion:
		return "DragMotion"
	case DropStart:
		return "DropStart"
	case Scroll:
		return "Scroll"
	case GrabBroken:
		return "GrabBroken"
	case TouchBegin:
		return "TouchBegin"
	case TouchUpdate:
		return "TouchUpdate"
	case TouchEnd:
		return "TouchEnd"
	case TouchCancel:
		return "TouchCancel"
	case TouchpadSwipe:
		return "TouchpadSwipe"
	case TouchpadPinch:
		return "TouchpadPinch"
	case PadButtonPress:
		return "PadButtonPress"
	case PadButtonRelease:
		return "PadButtonRelease"
	case PadRing:
		return "PadRing"
	case PadStrip:
		return "PadStrip"
	case PadGroupMode:
		return "PadGroupMode"
	case TouchpadHold:
		return "TouchpadHold"
	case EventLast:
		return "EventLast"
	default:
		return fmt.Sprintf("EventType(%d)", e)
	}
}

// FullscreenMode indicates which monitor a surface should span over when in
// fullscreen mode.
type FullscreenMode C.gint

const (
	// FullscreenOnCurrentMonitor: fullscreen on current monitor only.
	FullscreenOnCurrentMonitor FullscreenMode = iota
	// FullscreenOnAllMonitors: span across all monitors when fullscreen.
	FullscreenOnAllMonitors
)

func marshalFullscreenMode(p uintptr) (interface{}, error) {
	return FullscreenMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FullscreenMode.
func (f FullscreenMode) String() string {
	switch f {
	case FullscreenOnCurrentMonitor:
		return "CurrentMonitor"
	case FullscreenOnAllMonitors:
		return "AllMonitors"
	default:
		return fmt.Sprintf("FullscreenMode(%d)", f)
	}
}

// GLError: error enumeration for GdkGLContext.
type GLError C.gint

const (
	// GLErrorNotAvailable: openGL support is not available.
	GLErrorNotAvailable GLError = iota
	// GLErrorUnsupportedFormat: requested visual format is not supported.
	GLErrorUnsupportedFormat
	// GLErrorUnsupportedProfile: requested profile is not supported.
	GLErrorUnsupportedProfile
	// GLErrorCompilationFailed: shader compilation failed.
	GLErrorCompilationFailed
	// GLErrorLinkFailed: shader linking failed.
	GLErrorLinkFailed
)

func marshalGLError(p uintptr) (interface{}, error) {
	return GLError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLError.
func (g GLError) String() string {
	switch g {
	case GLErrorNotAvailable:
		return "NotAvailable"
	case GLErrorUnsupportedFormat:
		return "UnsupportedFormat"
	case GLErrorUnsupportedProfile:
		return "UnsupportedProfile"
	case GLErrorCompilationFailed:
		return "CompilationFailed"
	case GLErrorLinkFailed:
		return "LinkFailed"
	default:
		return fmt.Sprintf("GLError(%d)", g)
	}
}

func GLErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gdk_gl_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// Gravity defines the reference point of a surface and is used in
// GdkPopupLayout.
type Gravity C.gint

const (
	// GravityNorthWest: reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: reference point is at the center of the surface.
	GravityCenter Gravity = 5
	// GravityEast: reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: reference point is at the top left corner of the surface
	// itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Gravity.
func (g Gravity) String() string {
	switch g {
	case GravityNorthWest:
		return "NorthWest"
	case GravityNorth:
		return "North"
	case GravityNorthEast:
		return "NorthEast"
	case GravityWest:
		return "West"
	case GravityCenter:
		return "Center"
	case GravityEast:
		return "East"
	case GravitySouthWest:
		return "SouthWest"
	case GravitySouth:
		return "South"
	case GravitySouthEast:
		return "SouthEast"
	case GravityStatic:
		return "Static"
	default:
		return fmt.Sprintf("Gravity(%d)", g)
	}
}

// InputSource: enumeration describing the type of an input device in general
// terms.
type InputSource C.gint

const (
	// SourceMouse: device is a mouse. (This will be reported for the core
	// pointer, even if it is something else, such as a trackball.).
	SourceMouse InputSource = iota
	// SourcePen: device is a stylus of a graphics tablet or similar device.
	SourcePen
	// SourceKeyboard: device is a keyboard.
	SourceKeyboard
	// SourceTouchscreen: device is a direct-input touch device, such as a
	// touchscreen or tablet.
	SourceTouchscreen
	// SourceTouchpad: device is an indirect touch device, such as a touchpad.
	SourceTouchpad
	// SourceTrackpoint: device is a trackpoint.
	SourceTrackpoint
	// SourceTabletPad: device is a "pad", a collection of buttons, rings and
	// strips found in drawing tablets.
	SourceTabletPad
)

func marshalInputSource(p uintptr) (interface{}, error) {
	return InputSource(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InputSource.
func (i InputSource) String() string {
	switch i {
	case SourceMouse:
		return "Mouse"
	case SourcePen:
		return "Pen"
	case SourceKeyboard:
		return "Keyboard"
	case SourceTouchscreen:
		return "Touchscreen"
	case SourceTouchpad:
		return "Touchpad"
	case SourceTrackpoint:
		return "Trackpoint"
	case SourceTabletPad:
		return "TabletPad"
	default:
		return fmt.Sprintf("InputSource(%d)", i)
	}
}

// KeyMatch describes how well an event matches a given keyval and modifiers.
//
// GdkKeyMatch values are returned by gdk.KeyEvent.Matches().
type KeyMatch C.gint

const (
	// KeyMatchNone: key event does not match.
	KeyMatchNone KeyMatch = iota
	// KeyMatchPartial: key event matches if keyboard state (specifically,
	// the currently active group) is ignored.
	KeyMatchPartial
	// KeyMatchExact: key event matches.
	KeyMatchExact
)

func marshalKeyMatch(p uintptr) (interface{}, error) {
	return KeyMatch(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for KeyMatch.
func (k KeyMatch) String() string {
	switch k {
	case KeyMatchNone:
		return "None"
	case KeyMatchPartial:
		return "Partial"
	case KeyMatchExact:
		return "Exact"
	default:
		return fmt.Sprintf("KeyMatch(%d)", k)
	}
}

// MemoryFormat: GdkMemoryFormat describes formats that image data can have in
// memory.
//
// It describes formats by listing the contents of the memory passed to it. So
// GDK_MEMORY_A8R8G8B8 will be 1 byte (8 bits) of alpha, followed by a byte each
// of red, green and blue. It is not endian-dependent, so CAIRO_FORMAT_ARGB32
// is represented by different GdkMemoryFormats on architectures with different
// endiannesses.
//
// Its naming is modelled after VkFormat
// (https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.htmlFormat)
// for details).
type MemoryFormat C.gint

const (
	// MemoryB8G8R8A8Premultiplied: 4 bytes; for blue, green, red, alpha.
	// The color values are premultiplied with the alpha value.
	MemoryB8G8R8A8Premultiplied MemoryFormat = iota
	// MemoryA8R8G8B8Premultiplied: 4 bytes; for alpha, red, green, blue.
	// The color values are premultiplied with the alpha value.
	MemoryA8R8G8B8Premultiplied
	// MemoryR8G8B8A8Premultiplied: 4 bytes; for red, green, blue, alpha The
	// color values are premultiplied with the alpha value.
	MemoryR8G8B8A8Premultiplied
	// MemoryB8G8R8A8: 4 bytes; for blue, green, red, alpha.
	MemoryB8G8R8A8
	// MemoryA8R8G8B8: 4 bytes; for alpha, red, green, blue.
	MemoryA8R8G8B8
	// MemoryR8G8B8A8: 4 bytes; for red, green, blue, alpha.
	MemoryR8G8B8A8
	// MemoryA8B8G8R8: 4 bytes; for alpha, blue, green, red.
	MemoryA8B8G8R8
	// MemoryR8G8B8: 3 bytes; for red, green, blue. The data is opaque.
	MemoryR8G8B8
	// MemoryB8G8R8: 3 bytes; for blue, green, red. The data is opaque.
	MemoryB8G8R8
	// MemoryR16G16B16: 3 guint16 values; for red, green, blue.
	MemoryR16G16B16
	// MemoryR16G16B16A16Premultiplied: 4 guint16 values; for red, green, blue,
	// alpha. The color values are premultiplied with the alpha value.
	MemoryR16G16B16A16Premultiplied
	// MemoryR16G16B16A16: 4 guint16 values; for red, green, blue, alpha.
	MemoryR16G16B16A16
	// MemoryR16G16B16Float: 3 half-float values; for red, green, blue. The data
	// is opaque.
	MemoryR16G16B16Float
	// MemoryR16G16B16A16FloatPremultiplied: 4 half-float values; for red,
	// green, blue and alpha. The color values are premultiplied with the alpha
	// value.
	MemoryR16G16B16A16FloatPremultiplied
	// MemoryR16G16B16A16Float: 4 half-float values; for red, green, blue and
	// alpha.
	MemoryR16G16B16A16Float
	// MemoryR32G32B32Float: 3 float values; for red, green, blue.
	MemoryR32G32B32Float
	// MemoryR32G32B32A32FloatPremultiplied: 4 float values; for red, green,
	// blue and alpha. The color values are premultiplied with the alpha value.
	MemoryR32G32B32A32FloatPremultiplied
	// MemoryR32G32B32A32Float: 4 float values; for red, green, blue and alpha.
	MemoryR32G32B32A32Float
	// MemoryG8A8Premultiplied: 2 bytes; for grayscale, alpha. The color values
	// are premultiplied with the alpha value.
	MemoryG8A8Premultiplied
	// MemoryG8A8: 2 bytes; for grayscale, alpha.
	MemoryG8A8
	// MemoryG8: one byte; for grayscale. The data is opaque.
	MemoryG8
	// MemoryG16A16Premultiplied: 2 guint16 values; for grayscale, alpha.
	// The color values are premultiplied with the alpha value.
	MemoryG16A16Premultiplied
	// MemoryG16A16: 2 guint16 values; for grayscale, alpha.
	MemoryG16A16
	// MemoryG16: one guint16 value; for grayscale. The data is opaque.
	MemoryG16
	// MemoryA8: one byte; for alpha.
	MemoryA8
	// MemoryA16: one guint16 value; for alpha.
	MemoryA16
	// MemoryA16Float: one half-float value; for alpha.
	MemoryA16Float
	// MemoryA32Float: one float value; for alpha.
	MemoryA32Float
	// MemoryA8B8G8R8Premultiplied: 4 bytes; for alpha, blue, green, red,
	// The color values are premultiplied with the alpha value.
	MemoryA8B8G8R8Premultiplied
	// MemoryB8G8R8X8: 4 bytes; for blue, green, red, unused.
	MemoryB8G8R8X8
	// MemorYX8R8G8B8: 4 bytes; for unused, red, green, blue.
	MemorYX8R8G8B8
	// MemoryR8G8B8X8: 4 bytes; for red, green, blue, unused.
	MemoryR8G8B8X8
	// MemorYX8B8G8R8: 4 bytes; for unused, blue, green, red.
	MemorYX8B8G8R8
	// MemoryNFormats: number of formats. This value will change as more formats
	// get added, so do not rely on its concrete integer.
	MemoryNFormats
)

func marshalMemoryFormat(p uintptr) (interface{}, error) {
	return MemoryFormat(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MemoryFormat.
func (m MemoryFormat) String() string {
	switch m {
	case MemoryB8G8R8A8Premultiplied:
		return "B8G8R8A8Premultiplied"
	case MemoryA8R8G8B8Premultiplied:
		return "A8R8G8B8Premultiplied"
	case MemoryR8G8B8A8Premultiplied:
		return "R8G8B8A8Premultiplied"
	case MemoryB8G8R8A8:
		return "B8G8R8A8"
	case MemoryA8R8G8B8:
		return "A8R8G8B8"
	case MemoryR8G8B8A8:
		return "R8G8B8A8"
	case MemoryA8B8G8R8:
		return "A8B8G8R8"
	case MemoryR8G8B8:
		return "R8G8B8"
	case MemoryB8G8R8:
		return "B8G8R8"
	case MemoryR16G16B16:
		return "R16G16B16"
	case MemoryR16G16B16A16Premultiplied:
		return "R16G16B16A16Premultiplied"
	case MemoryR16G16B16A16:
		return "R16G16B16A16"
	case MemoryR16G16B16Float:
		return "R16G16B16Float"
	case MemoryR16G16B16A16FloatPremultiplied:
		return "R16G16B16A16FloatPremultiplied"
	case MemoryR16G16B16A16Float:
		return "R16G16B16A16Float"
	case MemoryR32G32B32Float:
		return "R32G32B32Float"
	case MemoryR32G32B32A32FloatPremultiplied:
		return "R32G32B32A32FloatPremultiplied"
	case MemoryR32G32B32A32Float:
		return "R32G32B32A32Float"
	case MemoryG8A8Premultiplied:
		return "G8A8Premultiplied"
	case MemoryG8A8:
		return "G8A8"
	case MemoryG8:
		return "G8"
	case MemoryG16A16Premultiplied:
		return "G16A16Premultiplied"
	case MemoryG16A16:
		return "G16A16"
	case MemoryG16:
		return "G16"
	case MemoryA8:
		return "A8"
	case MemoryA16:
		return "A16"
	case MemoryA16Float:
		return "A16Float"
	case MemoryA32Float:
		return "A32Float"
	case MemoryA8B8G8R8Premultiplied:
		return "A8B8G8R8Premultiplied"
	case MemoryB8G8R8X8:
		return "B8G8R8X8"
	case MemorYX8R8G8B8:
		return "X8R8G8B8"
	case MemoryR8G8B8X8:
		return "R8G8B8X8"
	case MemorYX8B8G8R8:
		return "X8B8G8R8"
	case MemoryNFormats:
		return "NFormats"
	default:
		return fmt.Sprintf("MemoryFormat(%d)", m)
	}
}

// NotifyType specifies the kind of crossing for enter and leave events.
//
// See the X11 protocol specification of LeaveNotify for full details of
// crossing event generation.
type NotifyType C.gint

const (
	// NotifyAncestor: surface is entered from an ancestor or left towards an
	// ancestor.
	NotifyAncestor NotifyType = iota
	// NotifyVirtual: pointer moves between an ancestor and an inferior of the
	// surface.
	NotifyVirtual
	// NotifyInferior: surface is entered from an inferior or left towards an
	// inferior.
	NotifyInferior
	// NotifyNonlinear: surface is entered from or left towards a surface which
	// is neither an ancestor nor an inferior.
	NotifyNonlinear
	// NotifyNonlinearVirtual: pointer moves between two surfaces which are not
	// ancestors of each other and the surface is part of the ancestor chain
	// between one of these surfaces and their least common ancestor.
	NotifyNonlinearVirtual
	// NotifyUnknown: unknown type of enter/leave event occurred.
	NotifyUnknown
)

func marshalNotifyType(p uintptr) (interface{}, error) {
	return NotifyType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NotifyType.
func (n NotifyType) String() string {
	switch n {
	case NotifyAncestor:
		return "Ancestor"
	case NotifyVirtual:
		return "Virtual"
	case NotifyInferior:
		return "Inferior"
	case NotifyNonlinear:
		return "Nonlinear"
	case NotifyNonlinearVirtual:
		return "NonlinearVirtual"
	case NotifyUnknown:
		return "Unknown"
	default:
		return fmt.Sprintf("NotifyType(%d)", n)
	}
}

// ScrollDirection specifies the direction for scroll events.
type ScrollDirection C.gint

const (
	// ScrollUp: surface is scrolled up.
	ScrollUp ScrollDirection = iota
	// ScrollDown: surface is scrolled down.
	ScrollDown
	// ScrollLeft: surface is scrolled to the left.
	ScrollLeft
	// ScrollRight: surface is scrolled to the right.
	ScrollRight
	// ScrollSmooth: scrolling is determined by the delta values in scroll
	// events. See gdk_scroll_event_get_deltas().
	ScrollSmooth
)

func marshalScrollDirection(p uintptr) (interface{}, error) {
	return ScrollDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollDirection.
func (s ScrollDirection) String() string {
	switch s {
	case ScrollUp:
		return "Up"
	case ScrollDown:
		return "Down"
	case ScrollLeft:
		return "Left"
	case ScrollRight:
		return "Right"
	case ScrollSmooth:
		return "Smooth"
	default:
		return fmt.Sprintf("ScrollDirection(%d)", s)
	}
}

// ScrollUnit specifies the unit of scroll deltas.
//
// When you get GDK_SCROLL_UNIT_WHEEL, a delta of 1.0 means 1 wheel detent
// click in the south direction, 2.0 means 2 wheel detent clicks in the south
// direction... This is the same logic for negative values but in the north
// direction.
//
// If you get GDK_SCROLL_UNIT_SURFACE, are managing a scrollable view and get
// a value of 123, you have to scroll 123 surface logical pixels right if it's
// delta_x or down if it's delta_y. This is the same logic for negative values
// but you have to scroll left instead of right if it's delta_x and up instead
// of down if it's delta_y.
//
// 1 surface logical pixel is equal to 1 real screen pixel multiplied by the
// final scale factor of your graphical interface (the product of the desktop
// scale factor and eventually a custom scale factor in your app).
type ScrollUnit C.gint

const (
	// ScrollUnitWheel: delta is in number of wheel clicks.
	ScrollUnitWheel ScrollUnit = iota
	// ScrollUnitSurface: delta is in surface pixels to scroll directly on
	// screen.
	ScrollUnitSurface
)

func marshalScrollUnit(p uintptr) (interface{}, error) {
	return ScrollUnit(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollUnit.
func (s ScrollUnit) String() string {
	switch s {
	case ScrollUnitWheel:
		return "Wheel"
	case ScrollUnitSurface:
		return "Surface"
	default:
		return fmt.Sprintf("ScrollUnit(%d)", s)
	}
}

// SubpixelLayout: this enumeration describes how the red, green and blue
// components of physical pixels on an output device are laid out.
type SubpixelLayout C.gint

const (
	// SubpixelLayoutUnknown: layout is not known.
	SubpixelLayoutUnknown SubpixelLayout = iota
	// SubpixelLayoutNone: not organized in this way.
	SubpixelLayoutNone
	// SubpixelLayoutHorizontalRGB: layout is horizontal, the order is RGB.
	SubpixelLayoutHorizontalRGB
	// SubpixelLayoutHorizontalBGR: layout is horizontal, the order is BGR.
	SubpixelLayoutHorizontalBGR
	// SubpixelLayoutVerticalRGB: layout is vertical, the order is RGB.
	SubpixelLayoutVerticalRGB
	// SubpixelLayoutVerticalBGR: layout is vertical, the order is BGR.
	SubpixelLayoutVerticalBGR
)

func marshalSubpixelLayout(p uintptr) (interface{}, error) {
	return SubpixelLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SubpixelLayout.
func (s SubpixelLayout) String() string {
	switch s {
	case SubpixelLayoutUnknown:
		return "Unknown"
	case SubpixelLayoutNone:
		return "None"
	case SubpixelLayoutHorizontalRGB:
		return "HorizontalRGB"
	case SubpixelLayoutHorizontalBGR:
		return "HorizontalBGR"
	case SubpixelLayoutVerticalRGB:
		return "VerticalRGB"
	case SubpixelLayoutVerticalBGR:
		return "VerticalBGR"
	default:
		return fmt.Sprintf("SubpixelLayout(%d)", s)
	}
}

// SurfaceEdge determines a surface edge or corner.
type SurfaceEdge C.gint

const (
	// SurfaceEdgeNorthWest: top left corner.
	SurfaceEdgeNorthWest SurfaceEdge = iota
	// SurfaceEdgeNorth: top edge.
	SurfaceEdgeNorth
	// SurfaceEdgeNorthEast: top right corner.
	SurfaceEdgeNorthEast
	// SurfaceEdgeWest: left edge.
	SurfaceEdgeWest
	// SurfaceEdgeEast: right edge.
	SurfaceEdgeEast
	// SurfaceEdgeSouthWest: lower left corner.
	SurfaceEdgeSouthWest
	// SurfaceEdgeSouth: lower edge.
	SurfaceEdgeSouth
	// SurfaceEdgeSouthEast: lower right corner.
	SurfaceEdgeSouthEast
)

func marshalSurfaceEdge(p uintptr) (interface{}, error) {
	return SurfaceEdge(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SurfaceEdge.
func (s SurfaceEdge) String() string {
	switch s {
	case SurfaceEdgeNorthWest:
		return "NorthWest"
	case SurfaceEdgeNorth:
		return "North"
	case SurfaceEdgeNorthEast:
		return "NorthEast"
	case SurfaceEdgeWest:
		return "West"
	case SurfaceEdgeEast:
		return "East"
	case SurfaceEdgeSouthWest:
		return "SouthWest"
	case SurfaceEdgeSouth:
		return "South"
	case SurfaceEdgeSouthEast:
		return "SouthEast"
	default:
		return fmt.Sprintf("SurfaceEdge(%d)", s)
	}
}

// TextureError: possible errors that can be returned by GdkTexture
// constructors.
type TextureError C.gint

const (
	// TextureErrorTooLarge: not enough memory to handle this image.
	TextureErrorTooLarge TextureError = iota
	// TextureErrorCorruptImage: image data appears corrupted.
	TextureErrorCorruptImage
	// TextureErrorUnsupportedContent: image contains features that cannot be
	// loaded.
	TextureErrorUnsupportedContent
	// TextureErrorUnsupportedFormat: image format is not supported.
	TextureErrorUnsupportedFormat
)

func marshalTextureError(p uintptr) (interface{}, error) {
	return TextureError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextureError.
func (t TextureError) String() string {
	switch t {
	case TextureErrorTooLarge:
		return "TooLarge"
	case TextureErrorCorruptImage:
		return "CorruptImage"
	case TextureErrorUnsupportedContent:
		return "UnsupportedContent"
	case TextureErrorUnsupportedFormat:
		return "UnsupportedFormat"
	default:
		return fmt.Sprintf("TextureError(%d)", t)
	}
}

func TextureErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gdk_texture_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type TitlebarGesture C.gint

const (
	TitlebarGestureDoubleClick TitlebarGesture = 1
	TitlebarGestureRightClick  TitlebarGesture = 2
	TitlebarGestureMiddleClick TitlebarGesture = 3
)

func marshalTitlebarGesture(p uintptr) (interface{}, error) {
	return TitlebarGesture(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TitlebarGesture.
func (t TitlebarGesture) String() string {
	switch t {
	case TitlebarGestureDoubleClick:
		return "DoubleClick"
	case TitlebarGestureRightClick:
		return "RightClick"
	case TitlebarGestureMiddleClick:
		return "MiddleClick"
	default:
		return fmt.Sprintf("TitlebarGesture(%d)", t)
	}
}

// TouchpadGesturePhase specifies the current state of a touchpad gesture.
//
// All gestures are guaranteed to begin with an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events with phase
// GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is considered
// successful, this should be used as the hint to perform any permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware
// or the compositor, or due to the gesture recognition layers hinting the
// gesture did not finish resolutely (eg. a 3rd finger being added during
// a pinch gesture). In these cases, the last event will report the phase
// GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint to undo
// any visible/permanent changes that were done throughout the progress of the
// gesture.
type TouchpadGesturePhase C.gint

const (
	// TouchpadGesturePhaseBegin: gesture has begun.
	TouchpadGesturePhaseBegin TouchpadGesturePhase = iota
	// TouchpadGesturePhaseUpdate: gesture has been updated.
	TouchpadGesturePhaseUpdate
	// TouchpadGesturePhaseEnd: gesture was finished, changes should be
	// permanently applied.
	TouchpadGesturePhaseEnd
	// TouchpadGesturePhaseCancel: gesture was cancelled, all changes should be
	// undone.
	TouchpadGesturePhaseCancel
)

func marshalTouchpadGesturePhase(p uintptr) (interface{}, error) {
	return TouchpadGesturePhase(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TouchpadGesturePhase.
func (t TouchpadGesturePhase) String() string {
	switch t {
	case TouchpadGesturePhaseBegin:
		return "Begin"
	case TouchpadGesturePhaseUpdate:
		return "Update"
	case TouchpadGesturePhaseEnd:
		return "End"
	case TouchpadGesturePhaseCancel:
		return "Cancel"
	default:
		return fmt.Sprintf("TouchpadGesturePhase(%d)", t)
	}
}

// VulkanError: error enumeration for GdkVulkanContext.
type VulkanError C.gint

const (
	// VulkanErrorUnsupported: vulkan is not supported on this backend or has
	// not been compiled in.
	VulkanErrorUnsupported VulkanError = iota
	// VulkanErrorNotAvailable: vulkan support is not available on this Surface.
	VulkanErrorNotAvailable
)

func marshalVulkanError(p uintptr) (interface{}, error) {
	return VulkanError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VulkanError.
func (v VulkanError) String() string {
	switch v {
	case VulkanErrorUnsupported:
		return "Unsupported"
	case VulkanErrorNotAvailable:
		return "NotAvailable"
	default:
		return fmt.Sprintf("VulkanError(%d)", v)
	}
}

func VulkanErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gdk_vulkan_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// AnchorHints: positioning hints for aligning a surface relative to a
// rectangle.
//
// These hints determine how the surface should be positioned in the case that
// the surface would fall off-screen if placed in its ideal position.
//
// For example, GDK_ANCHOR_FLIP_X will replace GDK_GRAVITY_NORTH_WEST with
// GDK_GRAVITY_NORTH_EAST and vice versa if the surface extends beyond the left
// or right edges of the monitor.
//
// If GDK_ANCHOR_SLIDE_X is set, the surface can be shifted horizontally to
// fit on-screen. If GDK_ANCHOR_RESIZE_X is set, the surface can be shrunken
// horizontally to fit.
//
// In general, when multiple flags are set, flipping should take precedence over
// sliding, which should take precedence over resizing.
type AnchorHints C.guint

const (
	// AnchorFlipX: allow flipping anchors horizontally.
	AnchorFlipX AnchorHints = 0b1
	// AnchorFlipY: allow flipping anchors vertically.
	AnchorFlipY AnchorHints = 0b10
	// AnchorSlideX: allow sliding surface horizontally.
	AnchorSlideX AnchorHints = 0b100
	// AnchorSlideY: allow sliding surface vertically.
	AnchorSlideY AnchorHints = 0b1000
	// AnchorResizeX: allow resizing surface horizontally.
	AnchorResizeX AnchorHints = 0b10000
	// AnchorResizeY: allow resizing surface vertically.
	AnchorResizeY AnchorHints = 0b100000
	// AnchorFlip: allow flipping anchors on both axes.
	AnchorFlip AnchorHints = 0b11
	// AnchorSlide: allow sliding surface on both axes.
	AnchorSlide AnchorHints = 0b1100
	// AnchorResize: allow resizing surface on both axes.
	AnchorResize AnchorHints = 0b110000
)

func marshalAnchorHints(p uintptr) (interface{}, error) {
	return AnchorHints(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AnchorHints.
func (a AnchorHints) String() string {
	if a == 0 {
		return "AnchorHints(0)"
	}

	var builder strings.Builder
	builder.Grow(113)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AnchorFlipX:
			builder.WriteString("FlipX|")
		case AnchorFlipY:
			builder.WriteString("FlipY|")
		case AnchorSlideX:
			builder.WriteString("SlideX|")
		case AnchorSlideY:
			builder.WriteString("SlideY|")
		case AnchorResizeX:
			builder.WriteString("ResizeX|")
		case AnchorResizeY:
			builder.WriteString("ResizeY|")
		case AnchorFlip:
			builder.WriteString("Flip|")
		case AnchorSlide:
			builder.WriteString("Slide|")
		case AnchorResize:
			builder.WriteString("Resize|")
		default:
			builder.WriteString(fmt.Sprintf("AnchorHints(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AnchorHints) Has(other AnchorHints) bool {
	return (a & other) == other
}

// AxisFlags flags describing the current capabilities of a device/tool.
type AxisFlags C.guint

const (
	// AxisFlagX: x axis is present.
	AxisFlagX AxisFlags = 0b10
	// AxisFlagY: y axis is present.
	AxisFlagY AxisFlags = 0b100
	// AxisFlagDeltaX: scroll X delta axis is present.
	AxisFlagDeltaX AxisFlags = 0b1000
	// AxisFlagDeltaY: scroll Y delta axis is present.
	AxisFlagDeltaY AxisFlags = 0b10000
	// AxisFlagPressure: pressure axis is present.
	AxisFlagPressure AxisFlags = 0b100000
	// AxisFlagXtilt: x tilt axis is present.
	AxisFlagXtilt AxisFlags = 0b1000000
	// AxisFlagYtilt: y tilt axis is present.
	AxisFlagYtilt AxisFlags = 0b10000000
	// AxisFlagWheel: wheel axis is present.
	AxisFlagWheel AxisFlags = 0b100000000
	// AxisFlagDistance: distance axis is present.
	AxisFlagDistance AxisFlags = 0b1000000000
	// AxisFlagRotation z-axis rotation is present.
	AxisFlagRotation AxisFlags = 0b10000000000
	// AxisFlagSlider: slider axis is present.
	AxisFlagSlider AxisFlags = 0b100000000000
)

func marshalAxisFlags(p uintptr) (interface{}, error) {
	return AxisFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AxisFlags.
func (a AxisFlags) String() string {
	if a == 0 {
		return "AxisFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(157)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AxisFlagX:
			builder.WriteString("X|")
		case AxisFlagY:
			builder.WriteString("Y|")
		case AxisFlagDeltaX:
			builder.WriteString("DeltaX|")
		case AxisFlagDeltaY:
			builder.WriteString("DeltaY|")
		case AxisFlagPressure:
			builder.WriteString("Pressure|")
		case AxisFlagXtilt:
			builder.WriteString("Xtilt|")
		case AxisFlagYtilt:
			builder.WriteString("Ytilt|")
		case AxisFlagWheel:
			builder.WriteString("Wheel|")
		case AxisFlagDistance:
			builder.WriteString("Distance|")
		case AxisFlagRotation:
			builder.WriteString("Rotation|")
		case AxisFlagSlider:
			builder.WriteString("Slider|")
		default:
			builder.WriteString(fmt.Sprintf("AxisFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AxisFlags) Has(other AxisFlags) bool {
	return (a & other) == other
}

// DragAction: used in GdkDrop and GdkDrag to indicate the actions that the
// destination can and should do with the dropped data.
type DragAction C.guint

const (
	// ActionCopy: copy the data.
	ActionCopy DragAction = 0b1
	// ActionMove: move the data, i.e. first copy it, then delete it from the
	// source using the DELETE target of the X selection protocol.
	ActionMove DragAction = 0b10
	// ActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means, and is not supported on
	// all platforms.
	ActionLink DragAction = 0b100
	// ActionAsk: ask the user what to do with the data.
	ActionAsk DragAction = 0b1000
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DragAction.
func (d DragAction) String() string {
	if d == 0 {
		return "DragAction(0)"
	}

	var builder strings.Builder
	builder.Grow(42)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case ActionCopy:
			builder.WriteString("Copy|")
		case ActionMove:
			builder.WriteString("Move|")
		case ActionLink:
			builder.WriteString("Link|")
		case ActionAsk:
			builder.WriteString("Ask|")
		default:
			builder.WriteString(fmt.Sprintf("DragAction(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DragAction) Has(other DragAction) bool {
	return (d & other) == other
}

// DragActionIsUnique checks if action represents a single action or includes
// multiple actions.
//
// When action is 0 - ie no action was given, TRUE is returned.
//
// The function takes the following parameters:
//
//   - action: GdkDragAction.
//
// The function returns the following values:
//
//   - ok: TRUE if exactly one action was given.
func DragActionIsUnique(action DragAction) bool {
	var _arg1 C.GdkDragAction // out
	var _cret C.gboolean      // in

	_arg1 = C.GdkDragAction(action)

	_cret = C.gdk_drag_action_is_unique(_arg1)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FrameClockPhase: used to represent the different paint clock phases that can
// be requested.
//
// The elements of the enumeration correspond to the signals of GdkFrameClock.
type FrameClockPhase C.guint

const (
	// FrameClockPhaseNone: no phase.
	FrameClockPhaseNone FrameClockPhase = 0b0
	// FrameClockPhaseFlushEvents corresponds to GdkFrameClock::flush-events.
	// Should not be handled by applications.
	FrameClockPhaseFlushEvents FrameClockPhase = 0b1
	// FrameClockPhaseBeforePaint corresponds to GdkFrameClock::before-paint.
	// Should not be handled by applications.
	FrameClockPhaseBeforePaint FrameClockPhase = 0b10
	// FrameClockPhaseUpdate corresponds to GdkFrameClock::update.
	FrameClockPhaseUpdate FrameClockPhase = 0b100
	// FrameClockPhaseLayout corresponds to GdkFrameClock::layout. Should not be
	// handled by applications.
	FrameClockPhaseLayout FrameClockPhase = 0b1000
	// FrameClockPhasePaint corresponds to GdkFrameClock::paint.
	FrameClockPhasePaint FrameClockPhase = 0b10000
	// FrameClockPhaseResumeEvents corresponds to GdkFrameClock::resume-events.
	// Should not be handled by applications.
	FrameClockPhaseResumeEvents FrameClockPhase = 0b100000
	// FrameClockPhaseAfterPaint corresponds to GdkFrameClock::after-paint.
	// Should not be handled by applications.
	FrameClockPhaseAfterPaint FrameClockPhase = 0b1000000
)

func marshalFrameClockPhase(p uintptr) (interface{}, error) {
	return FrameClockPhase(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FrameClockPhase.
func (f FrameClockPhase) String() string {
	if f == 0 {
		return "FrameClockPhase(0)"
	}

	var builder strings.Builder
	builder.Grow(192)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FrameClockPhaseNone:
			builder.WriteString("None|")
		case FrameClockPhaseFlushEvents:
			builder.WriteString("FlushEvents|")
		case FrameClockPhaseBeforePaint:
			builder.WriteString("BeforePaint|")
		case FrameClockPhaseUpdate:
			builder.WriteString("Update|")
		case FrameClockPhaseLayout:
			builder.WriteString("Layout|")
		case FrameClockPhasePaint:
			builder.WriteString("Paint|")
		case FrameClockPhaseResumeEvents:
			builder.WriteString("ResumeEvents|")
		case FrameClockPhaseAfterPaint:
			builder.WriteString("AfterPaint|")
		default:
			builder.WriteString(fmt.Sprintf("FrameClockPhase(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FrameClockPhase) Has(other FrameClockPhase) bool {
	return (f & other) == other
}

// GLAPI: list of the different APIs that GdkGLContext can potentially support.
type GLAPI C.guint

const (
	// GLApiGL: openGL API.
	GLApiGL GLAPI = 0b1
	// GLApiGles: openGL ES API.
	GLApiGles GLAPI = 0b10
)

func marshalGLAPI(p uintptr) (interface{}, error) {
	return GLAPI(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GLAPI.
func (g GLAPI) String() string {
	if g == 0 {
		return "GLAPI(0)"
	}

	var builder strings.Builder
	builder.Grow(17)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GLApiGL:
			builder.WriteString("GL|")
		case GLApiGles:
			builder.WriteString("Gles|")
		default:
			builder.WriteString(fmt.Sprintf("GLAPI(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GLAPI) Has(other GLAPI) bool {
	return (g & other) == other
}

// ModifierType flags to indicate the state of modifier keys and mouse buttons
// in events.
//
// Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose,
// Apple, CapsLock or ShiftLock.
//
// Note that GDK may add internal values to events which include values outside
// of this enumeration. Your code should preserve and ignore them. You can use
// GDK_MODIFIER_MASK to remove all private values.
type ModifierType C.guint

const (
	// NoModifierMask: no modifier.
	NoModifierMask ModifierType = 0b0
	// ShiftMask: shift key.
	ShiftMask ModifierType = 0b1
	// LockMask: lock key (depending on the modifier mapping of the X server
	// this may either be CapsLock or ShiftLock).
	LockMask ModifierType = 0b10
	// ControlMask: control key.
	ControlMask ModifierType = 0b100
	// AltMask: fourth modifier key (it depends on the modifier mapping of the X
	// server which key is interpreted as this modifier, but normally it is the
	// Alt key).
	AltMask ModifierType = 0b1000
	// Button1Mask: first mouse button.
	Button1Mask ModifierType = 0b100000000
	// Button2Mask: second mouse button.
	Button2Mask ModifierType = 0b1000000000
	// Button3Mask: third mouse button.
	Button3Mask ModifierType = 0b10000000000
	// Button4Mask: fourth mouse button.
	Button4Mask ModifierType = 0b100000000000
	// Button5Mask: fifth mouse button.
	Button5Mask ModifierType = 0b1000000000000
	// SuperMask: super modifier.
	SuperMask ModifierType = 0b100000000000000000000000000
	// HyperMask: hyper modifier.
	HyperMask ModifierType = 0b1000000000000000000000000000
	// MetaMask: meta modifier.
	MetaMask ModifierType = 0b10000000000000000000000000000
)

func marshalModifierType(p uintptr) (interface{}, error) {
	return ModifierType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ModifierType.
func (m ModifierType) String() string {
	if m == 0 {
		return "ModifierType(0)"
	}

	var builder strings.Builder
	builder.Grow(142)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case NoModifierMask:
			builder.WriteString("NoModifierMask|")
		case ShiftMask:
			builder.WriteString("ShiftMask|")
		case LockMask:
			builder.WriteString("LockMask|")
		case ControlMask:
			builder.WriteString("ControlMask|")
		case AltMask:
			builder.WriteString("AltMask|")
		case Button1Mask:
			builder.WriteString("Button1Mask|")
		case Button2Mask:
			builder.WriteString("Button2Mask|")
		case Button3Mask:
			builder.WriteString("Button3Mask|")
		case Button4Mask:
			builder.WriteString("Button4Mask|")
		case Button5Mask:
			builder.WriteString("Button5Mask|")
		case SuperMask:
			builder.WriteString("SuperMask|")
		case HyperMask:
			builder.WriteString("HyperMask|")
		case MetaMask:
			builder.WriteString("MetaMask|")
		default:
			builder.WriteString(fmt.Sprintf("ModifierType(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m ModifierType) Has(other ModifierType) bool {
	return (m & other) == other
}

// PaintableFlags flags about a paintable object.
//
// Implementations use these for optimizations such as caching.
type PaintableFlags C.guint

const (
	// PaintableStaticSize: size is immutable. The
	// gdk.Paintable::invalidate-size signal will never be emitted.
	PaintableStaticSize PaintableFlags = 0b1
	// PaintableStaticContents: content is immutable. The
	// gdk.Paintable::invalidate-contents signal will never be emitted.
	PaintableStaticContents PaintableFlags = 0b10
)

func marshalPaintableFlags(p uintptr) (interface{}, error) {
	return PaintableFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PaintableFlags.
func (p PaintableFlags) String() string {
	if p == 0 {
		return "PaintableFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(43)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PaintableStaticSize:
			builder.WriteString("Size|")
		case PaintableStaticContents:
			builder.WriteString("Contents|")
		default:
			builder.WriteString(fmt.Sprintf("PaintableFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PaintableFlags) Has(other PaintableFlags) bool {
	return (p & other) == other
}

// SeatCapabilities flags describing the seat capabilities.
type SeatCapabilities C.guint

const (
	// SeatCapabilityNone: no input capabilities.
	SeatCapabilityNone SeatCapabilities = 0b0
	// SeatCapabilityPointer: seat has a pointer (e.g. mouse).
	SeatCapabilityPointer SeatCapabilities = 0b1
	// SeatCapabilityTouch: seat has touchscreen(s) attached.
	SeatCapabilityTouch SeatCapabilities = 0b10
	// SeatCapabilityTabletStylus: seat has drawing tablet(s) attached.
	SeatCapabilityTabletStylus SeatCapabilities = 0b100
	// SeatCapabilityKeyboard: seat has keyboard(s) attached.
	SeatCapabilityKeyboard SeatCapabilities = 0b1000
	// SeatCapabilityTabletPad: seat has drawing tablet pad(s) attached.
	SeatCapabilityTabletPad SeatCapabilities = 0b10000
	// SeatCapabilityAllPointing: union of all pointing capabilities.
	SeatCapabilityAllPointing SeatCapabilities = 0b111
	// SeatCapabilityAll: union of all capabilities.
	SeatCapabilityAll SeatCapabilities = 0b11111
)

func marshalSeatCapabilities(p uintptr) (interface{}, error) {
	return SeatCapabilities(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SeatCapabilities.
func (s SeatCapabilities) String() string {
	if s == 0 {
		return "SeatCapabilities(0)"
	}

	var builder strings.Builder
	builder.Grow(178)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SeatCapabilityNone:
			builder.WriteString("None|")
		case SeatCapabilityPointer:
			builder.WriteString("Pointer|")
		case SeatCapabilityTouch:
			builder.WriteString("Touch|")
		case SeatCapabilityTabletStylus:
			builder.WriteString("TabletStylus|")
		case SeatCapabilityKeyboard:
			builder.WriteString("Keyboard|")
		case SeatCapabilityTabletPad:
			builder.WriteString("TabletPad|")
		case SeatCapabilityAllPointing:
			builder.WriteString("AllPointing|")
		case SeatCapabilityAll:
			builder.WriteString("All|")
		default:
			builder.WriteString(fmt.Sprintf("SeatCapabilities(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SeatCapabilities) Has(other SeatCapabilities) bool {
	return (s & other) == other
}

// ToplevelState specifies the state of a toplevel surface.
//
// On platforms that support information about individual edges, the
// GDK_TOPLEVEL_STATE_TILED state will be set whenever any of the individual
// tiled states is set. On platforms that lack that support, the tiled state
// will give an indication of tiledness without any of the per-edge states being
// set.
type ToplevelState C.guint

const (
	// ToplevelStateMinimized: surface is minimized.
	ToplevelStateMinimized ToplevelState = 0b1
	// ToplevelStateMaximized: surface is maximized.
	ToplevelStateMaximized ToplevelState = 0b10
	// ToplevelStateSticky: surface is sticky.
	ToplevelStateSticky ToplevelState = 0b100
	// ToplevelStateFullscreen: surface is maximized without decorations.
	ToplevelStateFullscreen ToplevelState = 0b1000
	// ToplevelStateAbove: surface is kept above other surfaces.
	ToplevelStateAbove ToplevelState = 0b10000
	// ToplevelStateBelow: surface is kept below other surfaces.
	ToplevelStateBelow ToplevelState = 0b100000
	// ToplevelStateFocused: surface is presented as focused (with active
	// decorations).
	ToplevelStateFocused ToplevelState = 0b1000000
	// ToplevelStateTiled: surface is in a tiled state.
	ToplevelStateTiled ToplevelState = 0b10000000
	// ToplevelStateTopTiled: whether the top edge is tiled.
	ToplevelStateTopTiled ToplevelState = 0b100000000
	// ToplevelStateTopResizable: whether the top edge is resizable.
	ToplevelStateTopResizable ToplevelState = 0b1000000000
	// ToplevelStateRightTiled: whether the right edge is tiled.
	ToplevelStateRightTiled ToplevelState = 0b10000000000
	// ToplevelStateRightResizable: whether the right edge is resizable.
	ToplevelStateRightResizable ToplevelState = 0b100000000000
	// ToplevelStateBottomTiled: whether the bottom edge is tiled.
	ToplevelStateBottomTiled ToplevelState = 0b1000000000000
	// ToplevelStateBottomResizable: whether the bottom edge is resizable.
	ToplevelStateBottomResizable ToplevelState = 0b10000000000000
	// ToplevelStateLeftTiled: whether the left edge is tiled.
	ToplevelStateLeftTiled ToplevelState = 0b100000000000000
	// ToplevelStateLeftResizable: whether the left edge is resizable.
	ToplevelStateLeftResizable ToplevelState = 0b1000000000000000
	// ToplevelStateSuspended: surface is not visible to the user.
	ToplevelStateSuspended ToplevelState = 0b10000000000000000
)

func marshalToplevelState(p uintptr) (interface{}, error) {
	return ToplevelState(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ToplevelState.
func (t ToplevelState) String() string {
	if t == 0 {
		return "ToplevelState(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case ToplevelStateMinimized:
			builder.WriteString("Minimized|")
		case ToplevelStateMaximized:
			builder.WriteString("Maximized|")
		case ToplevelStateSticky:
			builder.WriteString("Sticky|")
		case ToplevelStateFullscreen:
			builder.WriteString("Fullscreen|")
		case ToplevelStateAbove:
			builder.WriteString("Above|")
		case ToplevelStateBelow:
			builder.WriteString("Below|")
		case ToplevelStateFocused:
			builder.WriteString("Focused|")
		case ToplevelStateTiled:
			builder.WriteString("Tiled|")
		case ToplevelStateTopTiled:
			builder.WriteString("TopTiled|")
		case ToplevelStateTopResizable:
			builder.WriteString("TopResizable|")
		case ToplevelStateRightTiled:
			builder.WriteString("RightTiled|")
		case ToplevelStateRightResizable:
			builder.WriteString("RightResizable|")
		case ToplevelStateBottomTiled:
			builder.WriteString("BottomTiled|")
		case ToplevelStateBottomResizable:
			builder.WriteString("BottomResizable|")
		case ToplevelStateLeftTiled:
			builder.WriteString("LeftTiled|")
		case ToplevelStateLeftResizable:
			builder.WriteString("LeftResizable|")
		case ToplevelStateSuspended:
			builder.WriteString("Suspended|")
		default:
			builder.WriteString(fmt.Sprintf("ToplevelState(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t ToplevelState) Has(other ToplevelState) bool {
	return (t & other) == other
}

// CairoDrawFromGL: main way to not draw GL content in GTK.
//
// It takes a render buffer ID (source_type == GL_RENDERBUFFER) or a texture
// id (source_type == GL_TEXTURE) and draws it onto cr with an OVER operation,
// respecting the current clip. The top left corner of the rectangle specified
// by x, y, width and height will be drawn at the current (0,0) position of the
// cairo_t.
//
// This will work for *all* cairo_t, as long as surface is realized, but the
// fallback implementation that reads back the pixels from the buffer may be
// used in the general case. In the case of direct drawing to a surface with no
// special effects applied to cr it will however use a more efficient approach.
//
// For GL_RENDERBUFFER the code will always fall back to software for buffers
// with alpha components, so make sure you use GL_TEXTURE if using alpha.
//
// Calling this may change the current GL context.
//
// Deprecated: The function is overly complex and produces broken output in
// various combinations of arguments. If you want to draw with GL textures
// in GTK, use gdk.GLTexture.New; if you want to use that texture in Cairo,
// use gdk.Texture.Download() to download the data into a Cairo image surface.
//
// The function takes the following parameters:
//
//   - cr: cairo context.
//   - surface we're rendering for (not necessarily into).
//   - source: GL ID of the source buffer.
//   - sourceType: type of the source.
//   - bufferScale: scale-factor that the source buffer is allocated for.
//   - x: source x position in source to start copying from in GL coordinates.
//   - y: source y position in source to start copying from in GL coordinates.
//   - width of the region to draw.
//   - height of the region to draw.
func CairoDrawFromGL(cr *cairo.Context, surface Surfacer, source, sourceType, bufferScale, x, y, width, height int) {
	var _arg1 *C.cairo_t    // out
	var _arg2 *C.GdkSurface // out
	var _arg3 C.int         // out
	var _arg4 C.int         // out
	var _arg5 C.int         // out
	var _arg6 C.int         // out
	var _arg7 C.int         // out
	var _arg8 C.int         // out
	var _arg9 C.int         // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg3 = C.int(source)
	_arg4 = C.int(sourceType)
	_arg5 = C.int(bufferScale)
	_arg6 = C.int(x)
	_arg7 = C.int(y)
	_arg8 = C.int(width)
	_arg9 = C.int(height)

	C.gdk_cairo_draw_from_gl(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(source)
	runtime.KeepAlive(sourceType)
	runtime.KeepAlive(bufferScale)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// CairoRectangle adds the given rectangle to the current path of cr.
//
// The function takes the following parameters:
//
//   - cr: cairo context.
//   - rectangle: GdkRectangle.
func CairoRectangle(cr *cairo.Context, rectangle *Rectangle) {
	var _arg1 *C.cairo_t      // out
	var _arg2 *C.GdkRectangle // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(rectangle)))

	C.gdk_cairo_rectangle(_arg1, _arg2)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(rectangle)
}

// CairoRegion adds the given region to the current path of cr.
//
// The function takes the following parameters:
//
//   - cr: cairo context.
//   - region: cairo_region_t.
func CairoRegion(cr *cairo.Context, region *cairo.Region) {
	var _arg1 *C.cairo_t        // out
	var _arg2 *C.cairo_region_t // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_cairo_region(_arg1, _arg2)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(region)
}

// CairoRegionCreateFromSurface creates region that covers the area where the
// given surface is more than 50% opaque.
//
// This function takes into account device offsets that might be set with
// cairo_surface_set_device_offset().
//
// The function takes the following parameters:
//
//   - surface: cairo surface.
//
// The function returns the following values:
//
//   - region: cairo_region_t.
func CairoRegionCreateFromSurface(surface *cairo.Surface) *cairo.Region {
	var _arg1 *C.cairo_surface_t // out
	var _cret *C.cairo_region_t  // in

	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	_cret = C.gdk_cairo_region_create_from_surface(_arg1)
	runtime.KeepAlive(surface)

	var _region *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
		_region = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	runtime.SetFinalizer(_region, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
	})

	return _region
}

// CairoSetSourcePixbuf sets the given pixbuf as the source pattern for cr.
//
// The pattern has an extend mode of CAIRO_EXTEND_NONE and is aligned so that
// the origin of pixbuf is pixbuf_x, pixbuf_y.
//
// The function takes the following parameters:
//
//   - cr: cairo context.
//   - pixbuf: GdkPixbuf.
//   - pixbufX: x coordinate of location to place upper left corner of pixbuf.
//   - pixbufY: y coordinate of location to place upper left corner of pixbuf.
func CairoSetSourcePixbuf(cr *cairo.Context, pixbuf *gdkpixbuf.Pixbuf, pixbufX, pixbufY float64) {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GdkPixbuf // out
	var _arg3 C.double     // out
	var _arg4 C.double     // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	_arg3 = C.double(pixbufX)
	_arg4 = C.double(pixbufY)

	C.gdk_cairo_set_source_pixbuf(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(pixbufX)
	runtime.KeepAlive(pixbufY)
}

// CairoSetSourceRGBA sets the specified GdkRGBA as the source color of cr.
//
// The function takes the following parameters:
//
//   - cr: cairo context.
//   - rgba: GdkRGBA.
func CairoSetSourceRGBA(cr *cairo.Context, rgba *RGBA) {
	var _arg1 *C.cairo_t // out
	var _arg2 *C.GdkRGBA // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	C.gdk_cairo_set_source_rgba(_arg1, _arg2)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(rgba)
}

// ContentDeserializeAsync: read content from the given input stream and
// deserialize it, asynchronously.
//
// The default I/O priority is G_PRIORITY_DEFAULT (i.e. 0), and lower numbers
// indicate a higher priority.
//
// When the operation is finished, callback will be called. You must then call
// gdk.ContentDeserializeFinish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object.
//   - stream: GInputStream to read the serialized content from.
//   - mimeType: mime type to deserialize from.
//   - typ: GType to deserialize from.
//   - ioPriority: i/O priority of the operation.
//   - callback (optional) to call when the operation is done.
func ContentDeserializeAsync(ctx context.Context, stream gio.InputStreamer, mimeType string, typ coreglib.Type, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.GInputStream       // out
	var _arg2 *C.char               // out
	var _arg3 C.GType               // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GType(typ)
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_content_deserialize_async(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(mimeType)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ContentDeserializeFinish finishes a content deserialization operation.
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
//
// The function returns the following values:
//
//   - value: return location for the result of the operation.
func ContentDeserializeFinish(result gio.AsyncResulter) (coreglib.Value, error) {
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.GValue        // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.gdk_content_deserialize_finish(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(result)

	var _value coreglib.Value // out
	var _goerr error          // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg2)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// ContentSerializeAsync: serialize content and write it to the given output
// stream, asynchronously.
//
// The default I/O priority is G_PRIORITY_DEFAULT (i.e. 0), and lower numbers
// indicate a higher priority.
//
// When the operation is finished, callback will be called. You must then call
// gdk.ContentSerializeFinish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object.
//   - stream: GOutputStream to write the serialized content to.
//   - mimeType: mime type to serialize to.
//   - value: content to serialize.
//   - ioPriority: i/O priority of the operation.
//   - callback (optional) to call when the operation is done.
func ContentSerializeAsync(ctx context.Context, stream gio.OutputStreamer, mimeType string, value *coreglib.Value, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.GOutputStream      // out
	var _arg2 *C.char               // out
	var _arg3 *C.GValue             // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_content_serialize_async(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(mimeType)
	runtime.KeepAlive(value)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ContentSerializeFinish finishes a content serialization operation.
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
func ContentSerializeFinish(result gio.AsyncResulter) error {
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.gdk_content_serialize_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func DragSurfaceSizeGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gdk_drag_surface_size_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// EventsGetAngle returns the relative angle from event1 to event2.
//
// The relative angle is the angle between the X axis and the line through both
// events' positions. The rotation direction for positive angles is from the
// positive X axis towards the positive Y axis.
//
// This assumes that both events have X/Y information. If not, this function
// returns FALSE.
//
// The function takes the following parameters:
//
//   - event1: first GdkEvent.
//   - event2: second GdkEvent.
//
// The function returns the following values:
//
//   - angle: return location for the relative angle between both events.
//   - ok: TRUE if the angle could be calculated.
func EventsGetAngle(event1, event2 Eventer) (float64, bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.double    // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event1).Native()))
	_arg2 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event2).Native()))

	_cret = C.gdk_events_get_angle(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _angle float64 // out
	var _ok bool       // out

	_angle = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _angle, _ok
}

// EventsGetCenter returns the point halfway between the events' positions.
//
// This assumes that both events have X/Y information. If not, this function
// returns FALSE.
//
// The function takes the following parameters:
//
//   - event1: first GdkEvent.
//   - event2: second GdkEvent.
//
// The function returns the following values:
//
//   - x: return location for the X coordinate of the center.
//   - y: return location for the Y coordinate of the center.
//   - ok: TRUE if the center could be calculated.
func EventsGetCenter(event1, event2 Eventer) (x, y float64, ok bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.double    // in
	var _arg4 C.double    // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event1).Native()))
	_arg2 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event2).Native()))

	_cret = C.gdk_events_get_center(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg3)
	_y = float64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// EventsGetDistance returns the distance between the event locations.
//
// This assumes that both events have X/Y information. If not, this function
// returns FALSE.
//
// The function takes the following parameters:
//
//   - event1: first GdkEvent.
//   - event2: second GdkEvent.
//
// The function returns the following values:
//
//   - distance: return location for the distance.
//   - ok: TRUE if the distance could be calculated.
func EventsGetDistance(event1, event2 Eventer) (float64, bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.double    // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event1).Native()))
	_arg2 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event2).Native()))

	_cret = C.gdk_events_get_distance(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(event1)
	runtime.KeepAlive(event2)

	var _distance float64 // out
	var _ok bool          // out

	_distance = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _distance, _ok
}

// InternMIMEType canonicalizes the given mime type and interns the result.
//
// If string is not a valid mime type, NULL is returned instead. See RFC 2048
// for the syntax if mime types.
//
// The function takes the following parameters:
//
//   - str: string of a potential mime type.
//
// The function returns the following values:
//
//   - utf8 (optional): interned string for the canonicalized mime type or NULL
//     if the string wasn't a valid mime type.
func InternMIMEType(str string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_intern_mime_type(_arg1)
	runtime.KeepAlive(str)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// KeyvalConvertCase obtains the upper- and lower-case versions of the keyval
// symbol.
//
// Examples of keyvals are GDK_KEY_a, GDK_KEY_Enter, GDK_KEY_F1, etc.
//
// The function takes the following parameters:
//
//   - symbol: keyval.
//
// The function returns the following values:
//
//   - lower: return location for lowercase version of symbol.
//   - upper: return location for uppercase version of symbol.
func KeyvalConvertCase(symbol uint) (lower, upper uint) {
	var _arg1 C.guint // out
	var _arg2 C.guint // in
	var _arg3 C.guint // in

	_arg1 = C.guint(symbol)

	C.gdk_keyval_convert_case(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(symbol)

	var _lower uint // out
	var _upper uint // out

	_lower = uint(_arg2)
	_upper = uint(_arg3)

	return _lower, _upper
}

// KeyvalFromName converts a key name to a key value.
//
// The names are the same as those in the gdk/gdkkeysyms.h header file but
// without the leading “GDK_KEY_”.
//
// The function takes the following parameters:
//
//   - keyvalName: key name.
//
// The function returns the following values:
//
//   - guint: corresponding key value, or GDK_KEY_VoidSymbol if the key name is
//     not a valid key.
func KeyvalFromName(keyvalName string) uint {
	var _arg1 *C.char // out
	var _cret C.guint // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(keyvalName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_keyval_from_name(_arg1)
	runtime.KeepAlive(keyvalName)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalIsLower returns TRUE if the given key value is in lower case.
//
// The function takes the following parameters:
//
//   - keyval: key value.
//
// The function returns the following values:
//
//   - ok: TRUE if keyval is in lower case, or if keyval is not subject to case
//     conversion.
func KeyvalIsLower(keyval uint) bool {
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_is_lower(_arg1)
	runtime.KeepAlive(keyval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalIsUpper returns TRUE if the given key value is in upper case.
//
// The function takes the following parameters:
//
//   - keyval: key value.
//
// The function returns the following values:
//
//   - ok: TRUE if keyval is in upper case, or if keyval is not subject to case
//     conversion.
func KeyvalIsUpper(keyval uint) bool {
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_is_upper(_arg1)
	runtime.KeepAlive(keyval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalName converts a key value into a symbolic name.
//
// The names are the same as those in the gdk/gdkkeysyms.h header file but
// without the leading “GDK_KEY_”.
//
// The function takes the following parameters:
//
//   - keyval: key value.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the name of the key.
func KeyvalName(keyval uint) string {
	var _arg1 C.guint // out
	var _cret *C.char // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_name(_arg1)
	runtime.KeepAlive(keyval)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// KeyvalToLower converts a key value to lower case, if applicable.
//
// The function takes the following parameters:
//
//   - keyval: key value.
//
// The function returns the following values:
//
//   - guint: lower case form of keyval, or keyval itself if it is already in
//     lower case or it is not subject to case conversion.
func KeyvalToLower(keyval uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_lower(_arg1)
	runtime.KeepAlive(keyval)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalToUnicode: convert from a GDK key symbol to the corresponding Unicode
// character.
//
// Note that the conversion does not take the current locale into consideration,
// which might be expected for particular keyvals, such as GDK_KEY_KP_Decimal.
//
// The function takes the following parameters:
//
//   - keyval: GDK key symbol.
//
// The function returns the following values:
//
//   - guint32: corresponding unicode character, or 0 if there is no
//     corresponding character.
func KeyvalToUnicode(keyval uint) uint32 {
	var _arg1 C.guint   // out
	var _cret C.guint32 // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_unicode(_arg1)
	runtime.KeepAlive(keyval)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// KeyvalToUpper converts a key value to upper case, if applicable.
//
// The function takes the following parameters:
//
//   - keyval: key value.
//
// The function returns the following values:
//
//   - guint: upper case form of keyval, or keyval itself if it is already in
//     upper case or it is not subject to case conversion.
func KeyvalToUpper(keyval uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_upper(_arg1)
	runtime.KeepAlive(keyval)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PixbufGetFromSurface transfers image data from a cairo_surface_t and converts
// it to a GdkPixbuf.
//
// This allows you to efficiently read individual pixels from cairo surfaces.
//
// This function will create an RGB pixbuf with 8 bits per channel. The pixbuf
// will contain an alpha channel if the surface contains one.
//
// Deprecated: Use gdk.Texture and subclasses instead cairo surfaces and
// pixbufs.
//
// The function takes the following parameters:
//
//   - surface to copy from.
//   - srcX: source X coordinate within surface.
//   - srcY: source Y coordinate within surface.
//   - width: width in pixels of region to get.
//   - height: height in pixels of region to get.
//
// The function returns the following values:
//
//   - pixbuf (optional): newly-created pixbuf with a reference count of 1.
func PixbufGetFromSurface(surface *cairo.Surface, srcX, srcY, width, height int) *gdkpixbuf.Pixbuf {
	var _arg1 *C.cairo_surface_t // out
	var _arg2 C.int              // out
	var _arg3 C.int              // out
	var _arg4 C.int              // out
	var _arg5 C.int              // out
	var _cret *C.GdkPixbuf       // in

	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))
	_arg2 = C.int(srcX)
	_arg3 = C.int(srcY)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	_cret = C.gdk_pixbuf_get_from_surface(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(srcX)
	runtime.KeepAlive(srcY)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// PixbufGetFromTexture creates a new pixbuf from texture.
//
// This should generally not be used in newly written code as later stages will
// almost certainly convert the pixbuf back into a texture to draw it on screen.
//
// Deprecated: Use gdk.Texture and subclasses instead cairo surfaces and
// pixbufs.
//
// The function takes the following parameters:
//
//   - texture: GdkTexture.
//
// The function returns the following values:
//
//   - pixbuf (optional): new GdkPixbuf.
func PixbufGetFromTexture(texture Texturer) *gdkpixbuf.Pixbuf {
	var _arg1 *C.GdkTexture // out
	var _cret *C.GdkPixbuf  // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	_cret = C.gdk_pixbuf_get_from_texture(_arg1)
	runtime.KeepAlive(texture)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// SetAllowedBackends sets a list of backends that GDK should try to use.
//
// This can be useful if your application does not work with certain GDK
// backends.
//
// By default, GDK tries all included backends.
//
// For example:
//
//	gdk_set_allowed_backends ("wayland,macos,*");
//
// instructs GDK to try the Wayland backend first, followed by the MacOs
// backend, and then all others.
//
// If the GDK_BACKEND environment variable is set, it determines what backends
// are tried in what order, while still respecting the set of allowed backends
// that are specified by this function.
//
// The possible backend names are:
//
//   - broadway
//   - macos
//   - wayland.
//   - win32
//   - x11
//
// You can also include a * in the list to try all remaining backends.
//
// This call must happen prior to functions that open a display, such as
// gdk.Display().Open, gtk_init(), or gtk_init_check() in order to take effect.
//
// The function takes the following parameters:
//
//   - backends: comma-separated list of backends.
func SetAllowedBackends(backends string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(backends)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_set_allowed_backends(_arg1)
	runtime.KeepAlive(backends)
}

func ToplevelSizeGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gdk_toplevel_size_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// UnicodeToKeyval: convert from a Unicode character to a key symbol.
//
// The function takes the following parameters:
//
//   - wc: unicode character.
//
// The function returns the following values:
//
//   - guint: corresponding GDK key symbol, if one exists. or, if there is no
//     corresponding symbol, wc | 0x01000000.
func UnicodeToKeyval(wc uint32) uint {
	var _arg1 C.guint32 // out
	var _cret C.guint   // in

	_arg1 = C.guint32(wc)

	_cret = C.gdk_unicode_to_keyval(_arg1)
	runtime.KeepAlive(wc)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DevicePad: GdkDevicePad is an interface implemented by devices of type
// GDK_SOURCE_TABLET_PAD
//
// It allows querying the features provided by the pad device.
//
// Tablet pads may contain one or more groups, each containing a subset of
// the buttons/rings/strips available. gdk.DevicePad.GetNGroups() can be
// used to obtain the number of groups, gdk.DevicePad.GetNFeatures() and
// gdk.DevicePad.GetFeatureGroup() can be combined to find out the number of
// buttons/rings/strips the device has, and how are they grouped.
//
// Each of those groups have different modes, which may be used to map each
// individual pad feature to multiple actions. Only one mode is effective
// (current) for each given group, different groups may have different current
// modes. The number of available modes in a group can be found out through
// gdk.DevicePad.GetGroupNModes(), and the current mode for a given group will
// be notified through events of type GDK_PAD_GROUP_MODE.
//
// DevicePad wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DevicePad struct {
	_ [0]func() // equal guard
	Device
}

var (
	_ Devicer = (*DevicePad)(nil)
)

// DevicePadder describes DevicePad's interface methods.
type DevicePadder interface {
	coreglib.Objector

	// FeatureGroup returns the group the given feature and idx belong to.
	FeatureGroup(feature DevicePadFeature, featureIdx int) int
	// GroupNModes returns the number of modes that group may have.
	GroupNModes(groupIdx int) int
	// NFeatures returns the number of features a tablet pad has.
	NFeatures(feature DevicePadFeature) int
	// NGroups returns the number of groups this pad device has.
	NGroups() int
}

var _ DevicePadder = (*DevicePad)(nil)

func wrapDevicePad(obj *coreglib.Object) *DevicePad {
	return &DevicePad{
		Device: Device{
			Object: obj,
		},
	}
}

func marshalDevicePad(p uintptr) (interface{}, error) {
	return wrapDevicePad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FeatureGroup returns the group the given feature and idx belong to.
//
// f the feature or index do not exist in pad, -1 is returned.
//
// The function takes the following parameters:
//
//   - feature type to get the group from.
//   - featureIdx: index of the feature to get the group from.
//
// The function returns the following values:
//
//   - gint: group number of the queried pad feature.
func (pad *DevicePad) FeatureGroup(feature DevicePadFeature, featureIdx int) int {
	var _arg0 *C.GdkDevicePad       // out
	var _arg1 C.GdkDevicePadFeature // out
	var _arg2 C.int                 // out
	var _cret C.int                 // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GdkDevicePadFeature(feature)
	_arg2 = C.int(featureIdx)

	_cret = C.gdk_device_pad_get_feature_group(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(featureIdx)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// GroupNModes returns the number of modes that group may have.
//
// The function takes the following parameters:
//
//   - groupIdx: group to get the number of available modes from.
//
// The function returns the following values:
//
//   - gint: number of modes available in group.
func (pad *DevicePad) GroupNModes(groupIdx int) int {
	var _arg0 *C.GdkDevicePad // out
	var _arg1 C.int           // out
	var _cret C.int           // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.int(groupIdx)

	_cret = C.gdk_device_pad_get_group_n_modes(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(groupIdx)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NFeatures returns the number of features a tablet pad has.
//
// The function takes the following parameters:
//
//   - feature: pad feature.
//
// The function returns the following values:
//
//   - gint: amount of elements of type feature that this pad has.
func (pad *DevicePad) NFeatures(feature DevicePadFeature) int {
	var _arg0 *C.GdkDevicePad       // out
	var _arg1 C.GdkDevicePadFeature // out
	var _cret C.int                 // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GdkDevicePadFeature(feature)

	_cret = C.gdk_device_pad_get_n_features(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(feature)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NGroups returns the number of groups this pad device has.
//
// Pads have at least one group. A pad group is a subcollection of
// buttons/strip/rings that is affected collectively by a same current mode.
//
// The function returns the following values:
//
//   - gint: number of button/ring/strip groups in the pad.
func (pad *DevicePad) NGroups() int {
	var _arg0 *C.GdkDevicePad // out
	var _cret C.int           // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gdk_device_pad_get_n_groups(_arg0)
	runtime.KeepAlive(pad)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DragSurface: GdkDragSurface is an interface for surfaces used during DND.
//
// DragSurface wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DragSurface struct {
	_ [0]func() // equal guard
	Surface
}

var (
	_ Surfacer = (*DragSurface)(nil)
)

// DragSurfacer describes DragSurface's interface methods.
type DragSurfacer interface {
	coreglib.Objector

	// Present drag_surface.
	Present(width, height int) bool
}

var _ DragSurfacer = (*DragSurface)(nil)

func wrapDragSurface(obj *coreglib.Object) *DragSurface {
	return &DragSurface{
		Surface: Surface{
			Object: obj,
		},
	}
}

func marshalDragSurface(p uintptr) (interface{}, error) {
	return wrapDragSurface(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Present drag_surface.
//
// The function takes the following parameters:
//
//   - width: unconstrained drag_surface width to layout.
//   - height: unconstrained drag_surface height to layout.
//
// The function returns the following values:
//
//   - ok: FALSE if it failed to be presented, otherwise TRUE.
func (dragSurface *DragSurface) Present(width, height int) bool {
	var _arg0 *C.GdkDragSurface // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDragSurface)(unsafe.Pointer(coreglib.InternObject(dragSurface).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	_cret = C.gdk_drag_surface_present(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dragSurface)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Paintable: GdkPaintable is a simple interface used by GTK to represent
// content that can be painted.
//
// The content of a GdkPaintable can be painted anywhere at any
// size without requiring any sort of layout. The interface is
// inspired by similar concepts elsewhere, such as ClutterContent
// (https://developer.gnome.org/clutter/stable/ClutterContent.html),
// HTML/CSS Paint Sources (https://www.w3.org/TR/css-images-4/#paint-source),
// or SVG Paint Servers (https://www.w3.org/TR/SVG2/pservers.html).
//
// A GdkPaintable can be snapshot at any time and size using
// gdk.Paintable.Snapshot(). How the paintable interprets that size and if it
// scales or centers itself into the given rectangle is implementation defined,
// though if you are implementing a GdkPaintable and don't know what to do,
// it is suggested that you scale your paintable ignoring any potential aspect
// ratio.
//
// The contents that a GdkPaintable produces may depend on the gdk.Snapshot
// passed to it. For example, paintables may decide to use more detailed images
// on higher resolution screens or when OpenGL is available. A GdkPaintable will
// however always produce the same output for the same snapshot.
//
// A GdkPaintable may change its contents, meaning that it will now
// produce a different output with the same snapshot. Once that happens,
// it will call gdk.Paintable.InvalidateContents() which will emit the
// gdk.Paintable::invalidate-contents signal. If a paintable is known to
// never change its contents, it will set the GDK_PAINTABLE_STATIC_CONTENTS
// flag. If a consumer cannot deal with changing contents, it may call
// gdk.Paintable.GetCurrentImage() which will return a static paintable and use
// that.
//
// A paintable can report an intrinsic (or preferred) size or aspect ratio
// it wishes to be rendered at, though it doesn't have to. Consumers of the
// interface can use this information to layout thepaintable appropriately.
// Just like the contents, the size of a paintable can change. A paintable
// will indicate this by calling gdk.Paintable.InvalidateSize() which will
// emit the gdk.Paintable::invalidate-size signal. And just like for contents,
// if a paintable is known to never change its size, it will set the
// GDK_PAINTABLE_STATIC_SIZE flag.
//
// Besides API for applications, there are some functions that are only
// useful for implementing subclasses and should not be used by applications:
// gdk.Paintable.InvalidateContents(), gdk.Paintable.InvalidateSize(),
// gdk.Paintable().NewEmpty.
//
// Paintable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Paintable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Paintable)(nil)
)

// Paintabler describes Paintable's interface methods.
type Paintabler interface {
	coreglib.Objector

	// ComputeConcreteSize: compute a concrete size for the GdkPaintable.
	ComputeConcreteSize(specifiedWidth, specifiedHeight, defaultWidth, defaultHeight float64) (concreteWidth, concreteHeight float64)
	// CurrentImage gets an immutable paintable for the current contents
	// displayed by paintable.
	CurrentImage() *Paintable
	// Flags: get flags for the paintable.
	Flags() PaintableFlags
	// IntrinsicAspectRatio gets the preferred aspect ratio the paintable would
	// like to be displayed at.
	IntrinsicAspectRatio() float64
	// IntrinsicHeight gets the preferred height the paintable would like to be
	// displayed at.
	IntrinsicHeight() int
	// IntrinsicWidth gets the preferred width the paintable would like to be
	// displayed at.
	IntrinsicWidth() int
	// InvalidateContents: called by implementations of GdkPaintable to
	// invalidate their contents.
	InvalidateContents()
	// InvalidateSize: called by implementations of GdkPaintable to invalidate
	// their size.
	InvalidateSize()
	// Snapshot snapshots the given paintable with the given width and height.
	Snapshot(snapshot Snapshotter, width, height float64)

	// Invalidate-contents is emitted when the contents of the paintable change.
	ConnectInvalidateContents(func()) coreglib.SignalHandle
	// Invalidate-size is emitted when the intrinsic size of the paintable
	// changes.
	ConnectInvalidateSize(func()) coreglib.SignalHandle
}

var _ Paintabler = (*Paintable)(nil)

func wrapPaintable(obj *coreglib.Object) *Paintable {
	return &Paintable{
		Object: obj,
	}
}

func marshalPaintable(p uintptr) (interface{}, error) {
	return wrapPaintable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectInvalidateContents is emitted when the contents of the paintable
// change.
//
// Examples for such an event would be videos changing to the next frame or the
// icon theme for an icon changing.
func (paintable *Paintable) ConnectInvalidateContents(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paintable, "invalidate-contents", false, unsafe.Pointer(C._gotk4_gdk4_Paintable_ConnectInvalidateContents), f)
}

// ConnectInvalidateSize is emitted when the intrinsic size of the paintable
// changes.
//
// This means the values reported by at least one of
// gdk.Paintable.GetIntrinsicWidth(), gdk.Paintable.GetIntrinsicHeight() or
// gdk.Paintable.GetIntrinsicAspectRatio() has changed.
//
// Examples for such an event would be a paintable displaying the contents of a
// toplevel surface being resized.
func (paintable *Paintable) ConnectInvalidateSize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paintable, "invalidate-size", false, unsafe.Pointer(C._gotk4_gdk4_Paintable_ConnectInvalidateSize), f)
}

// ComputeConcreteSize: compute a concrete size for the GdkPaintable.
//
// Applies the sizing algorithm outlined in the CSS Image spec
// (https://drafts.csswg.org/css-images-3/#default-sizing) to the given
// paintable. See that link for more details.
//
// It is not necessary to call this function when both specified_width and
// specified_height are known, but it is useful to call this function in
// GtkWidget:measure implementations to compute the other dimension when only
// one dimension is given.
//
// The function takes the following parameters:
//
//   - specifiedWidth: width paintable could be drawn into or 0.0 if unknown.
//   - specifiedHeight: height paintable could be drawn into or 0.0 if unknown.
//   - defaultWidth: width paintable would be drawn into if no other constraints
//     were given.
//   - defaultHeight: height paintable would be drawn into if no other
//     constraints were given.
//
// The function returns the following values:
//
//   - concreteWidth will be set to the concrete width computed.
//   - concreteHeight will be set to the concrete height computed.
func (paintable *Paintable) ComputeConcreteSize(specifiedWidth, specifiedHeight, defaultWidth, defaultHeight float64) (concreteWidth, concreteHeight float64) {
	var _arg0 *C.GdkPaintable // out
	var _arg1 C.double        // out
	var _arg2 C.double        // out
	var _arg3 C.double        // out
	var _arg4 C.double        // out
	var _arg5 C.double        // in
	var _arg6 C.double        // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	_arg1 = C.double(specifiedWidth)
	_arg2 = C.double(specifiedHeight)
	_arg3 = C.double(defaultWidth)
	_arg4 = C.double(defaultHeight)

	C.gdk_paintable_compute_concrete_size(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(paintable)
	runtime.KeepAlive(specifiedWidth)
	runtime.KeepAlive(specifiedHeight)
	runtime.KeepAlive(defaultWidth)
	runtime.KeepAlive(defaultHeight)

	var _concreteWidth float64  // out
	var _concreteHeight float64 // out

	_concreteWidth = float64(_arg5)
	_concreteHeight = float64(_arg6)

	return _concreteWidth, _concreteHeight
}

// CurrentImage gets an immutable paintable for the current contents displayed
// by paintable.
//
// This is useful when you want to retain the current state of an animation,
// for example to take a screenshot of a running animation.
//
// If the paintable is already immutable, it will return itself.
//
// The function returns the following values:
//
//   - ret: immutable paintable for the current contents of paintable.
func (paintable *Paintable) CurrentImage() *Paintable {
	var _arg0 *C.GdkPaintable // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C.gdk_paintable_get_current_image(_arg0)
	runtime.KeepAlive(paintable)

	var _ret *Paintable // out

	_ret = wrapPaintable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// Flags: get flags for the paintable.
//
// This is oftentimes useful for optimizations.
//
// See gdk.PaintableFlags for the flags and what they mean.
//
// The function returns the following values:
//
//   - paintableFlags: GdkPaintableFlags for this paintable.
func (paintable *Paintable) Flags() PaintableFlags {
	var _arg0 *C.GdkPaintable     // out
	var _cret C.GdkPaintableFlags // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C.gdk_paintable_get_flags(_arg0)
	runtime.KeepAlive(paintable)

	var _paintableFlags PaintableFlags // out

	_paintableFlags = PaintableFlags(_cret)

	return _paintableFlags
}

// IntrinsicAspectRatio gets the preferred aspect ratio the paintable would like
// to be displayed at.
//
// The aspect ratio is the width divided by the height, so a value of 0.5 means
// that the paintable prefers to be displayed twice as high as it is wide.
// Consumers of this interface can use this to preserve aspect ratio when
// displaying the paintable.
//
// This is a purely informational value and does not in any way limit the values
// that may be passed to gdk.Paintable.Snapshot().
//
// Usually when a paintable returns nonzero values from
// gdk.Paintable.GetIntrinsicWidth() and gdk.Paintable.GetIntrinsicHeight() the
// aspect ratio should conform to those values, though that is not required.
//
// If the paintable does not have a preferred aspect ratio, it returns 0.
// Negative values are never returned.
//
// The function returns the following values:
//
//   - gdouble: intrinsic aspect ratio of paintable or 0 if none.
func (paintable *Paintable) IntrinsicAspectRatio() float64 {
	var _arg0 *C.GdkPaintable // out
	var _cret C.double        // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C.gdk_paintable_get_intrinsic_aspect_ratio(_arg0)
	runtime.KeepAlive(paintable)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// IntrinsicHeight gets the preferred height the paintable would like to be
// displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw the
// paintable.
//
// This is a purely informational value and does not in any way limit the values
// that may be passed to gdk.Paintable.Snapshot().
//
// If the paintable does not have a preferred height, it returns 0. Negative
// values are never returned.
//
// The function returns the following values:
//
//   - gint: intrinsic height of paintable or 0 if none.
func (paintable *Paintable) IntrinsicHeight() int {
	var _arg0 *C.GdkPaintable // out
	var _cret C.int           // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C.gdk_paintable_get_intrinsic_height(_arg0)
	runtime.KeepAlive(paintable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IntrinsicWidth gets the preferred width the paintable would like to be
// displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw the
// paintable.
//
// This is a purely informational value and does not in any way limit the values
// that may be passed to gdk.Paintable.Snapshot().
//
// If the paintable does not have a preferred width, it returns 0. Negative
// values are never returned.
//
// The function returns the following values:
//
//   - gint: intrinsic width of paintable or 0 if none.
func (paintable *Paintable) IntrinsicWidth() int {
	var _arg0 *C.GdkPaintable // out
	var _cret C.int           // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C.gdk_paintable_get_intrinsic_width(_arg0)
	runtime.KeepAlive(paintable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InvalidateContents: called by implementations of GdkPaintable to invalidate
// their contents.
//
// Unless the contents are invalidated, implementations must guarantee that
// multiple calls of gdk.Paintable.Snapshot() produce the same output.
//
// This function will emit the gdk.Paintable::invalidate-contents signal.
//
// If a paintable reports the GDK_PAINTABLE_STATIC_CONTENTS flag, it must not
// call this function.
func (paintable *Paintable) InvalidateContents() {
	var _arg0 *C.GdkPaintable // out

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	C.gdk_paintable_invalidate_contents(_arg0)
	runtime.KeepAlive(paintable)
}

// InvalidateSize: called by implementations of GdkPaintable to invalidate their
// size.
//
// As long as the size is not invalidated, paintable must return the same values
// for its intrinsic width, height and aspect ratio.
//
// This function will emit the gdk.Paintable::invalidate-size signal.
//
// If a paintable reports the GDK_PAINTABLE_STATIC_SIZE flag, it must not call
// this function.
func (paintable *Paintable) InvalidateSize() {
	var _arg0 *C.GdkPaintable // out

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	C.gdk_paintable_invalidate_size(_arg0)
	runtime.KeepAlive(paintable)
}

// Snapshot snapshots the given paintable with the given width and height.
//
// The paintable is drawn at the current (0,0) offset of the snapshot. If width
// and height are not larger than zero, this function will do nothing.
//
// The function takes the following parameters:
//
//   - snapshot: GdkSnapshot to snapshot to.
//   - width to snapshot in.
//   - height to snapshot in.
func (paintable *Paintable) Snapshot(snapshot Snapshotter, width, height float64) {
	var _arg0 *C.GdkPaintable // out
	var _arg1 *C.GdkSnapshot  // out
	var _arg2 C.double        // out
	var _arg3 C.double        // out

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	_arg1 = (*C.GdkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg2 = C.double(width)
	_arg3 = C.double(height)

	C.gdk_paintable_snapshot(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(paintable)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// currentImage gets an immutable paintable for the current contents displayed
// by paintable.
//
// This is useful when you want to retain the current state of an animation,
// for example to take a screenshot of a running animation.
//
// If the paintable is already immutable, it will return itself.
//
// The function returns the following values:
//
//   - ret: immutable paintable for the current contents of paintable.
func (paintable *Paintable) currentImage() *Paintable {
	gclass := (*C.GdkPaintableInterface)(coreglib.PeekParentClass(paintable))
	fnarg := gclass.get_current_image

	var _arg0 *C.GdkPaintable // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C._gotk4_gdk4_Paintable_virtual_get_current_image(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(paintable)

	var _ret *Paintable // out

	_ret = wrapPaintable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// Flags: get flags for the paintable.
//
// This is oftentimes useful for optimizations.
//
// See gdk.PaintableFlags for the flags and what they mean.
//
// The function returns the following values:
//
//   - paintableFlags: GdkPaintableFlags for this paintable.
func (paintable *Paintable) flags() PaintableFlags {
	gclass := (*C.GdkPaintableInterface)(coreglib.PeekParentClass(paintable))
	fnarg := gclass.get_flags

	var _arg0 *C.GdkPaintable     // out
	var _cret C.GdkPaintableFlags // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C._gotk4_gdk4_Paintable_virtual_get_flags(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(paintable)

	var _paintableFlags PaintableFlags // out

	_paintableFlags = PaintableFlags(_cret)

	return _paintableFlags
}

// intrinsicAspectRatio gets the preferred aspect ratio the paintable would like
// to be displayed at.
//
// The aspect ratio is the width divided by the height, so a value of 0.5 means
// that the paintable prefers to be displayed twice as high as it is wide.
// Consumers of this interface can use this to preserve aspect ratio when
// displaying the paintable.
//
// This is a purely informational value and does not in any way limit the values
// that may be passed to gdk.Paintable.Snapshot().
//
// Usually when a paintable returns nonzero values from
// gdk.Paintable.GetIntrinsicWidth() and gdk.Paintable.GetIntrinsicHeight() the
// aspect ratio should conform to those values, though that is not required.
//
// If the paintable does not have a preferred aspect ratio, it returns 0.
// Negative values are never returned.
//
// The function returns the following values:
//
//   - gdouble: intrinsic aspect ratio of paintable or 0 if none.
func (paintable *Paintable) intrinsicAspectRatio() float64 {
	gclass := (*C.GdkPaintableInterface)(coreglib.PeekParentClass(paintable))
	fnarg := gclass.get_intrinsic_aspect_ratio

	var _arg0 *C.GdkPaintable // out
	var _cret C.double        // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C._gotk4_gdk4_Paintable_virtual_get_intrinsic_aspect_ratio(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(paintable)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// intrinsicHeight gets the preferred height the paintable would like to be
// displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw the
// paintable.
//
// This is a purely informational value and does not in any way limit the values
// that may be passed to gdk.Paintable.Snapshot().
//
// If the paintable does not have a preferred height, it returns 0. Negative
// values are never returned.
//
// The function returns the following values:
//
//   - gint: intrinsic height of paintable or 0 if none.
func (paintable *Paintable) intrinsicHeight() int {
	gclass := (*C.GdkPaintableInterface)(coreglib.PeekParentClass(paintable))
	fnarg := gclass.get_intrinsic_height

	var _arg0 *C.GdkPaintable // out
	var _cret C.int           // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C._gotk4_gdk4_Paintable_virtual_get_intrinsic_height(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(paintable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// intrinsicWidth gets the preferred width the paintable would like to be
// displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw the
// paintable.
//
// This is a purely informational value and does not in any way limit the values
// that may be passed to gdk.Paintable.Snapshot().
//
// If the paintable does not have a preferred width, it returns 0. Negative
// values are never returned.
//
// The function returns the following values:
//
//   - gint: intrinsic width of paintable or 0 if none.
func (paintable *Paintable) intrinsicWidth() int {
	gclass := (*C.GdkPaintableInterface)(coreglib.PeekParentClass(paintable))
	fnarg := gclass.get_intrinsic_width

	var _arg0 *C.GdkPaintable // out
	var _cret C.int           // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	_cret = C._gotk4_gdk4_Paintable_virtual_get_intrinsic_width(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(paintable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Snapshot snapshots the given paintable with the given width and height.
//
// The paintable is drawn at the current (0,0) offset of the snapshot. If width
// and height are not larger than zero, this function will do nothing.
//
// The function takes the following parameters:
//
//   - snapshot: GdkSnapshot to snapshot to.
//   - width to snapshot in.
//   - height to snapshot in.
func (paintable *Paintable) snapshot(snapshot Snapshotter, width, height float64) {
	gclass := (*C.GdkPaintableInterface)(coreglib.PeekParentClass(paintable))
	fnarg := gclass.snapshot

	var _arg0 *C.GdkPaintable // out
	var _arg1 *C.GdkSnapshot  // out
	var _arg2 C.double        // out
	var _arg3 C.double        // out

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	_arg1 = (*C.GdkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg2 = C.double(width)
	_arg3 = C.double(height)

	C._gotk4_gdk4_Paintable_virtual_snapshot(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(paintable)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// NewPaintableEmpty returns a paintable that has the given intrinsic size and
// draws nothing.
//
// This is often useful for implementing the gdk.Paintable.GetCurrentImage()
// virtual function when the paintable is in an incomplete state (like a
// GtkMediaStream (../gtk4/class.MediaStream.html) before receiving the first
// frame).
//
// The function takes the following parameters:
//
//   - intrinsicWidth: intrinsic width to report. Can be 0 for no width.
//   - intrinsicHeight: intrinsic height to report. Can be 0 for no height.
//
// The function returns the following values:
//
//   - paintable: GdkPaintable.
func NewPaintableEmpty(intrinsicWidth, intrinsicHeight int) *Paintable {
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _cret *C.GdkPaintable // in

	_arg1 = C.int(intrinsicWidth)
	_arg2 = C.int(intrinsicHeight)

	_cret = C.gdk_paintable_new_empty(_arg1, _arg2)
	runtime.KeepAlive(intrinsicWidth)
	runtime.KeepAlive(intrinsicHeight)

	var _paintable *Paintable // out

	_paintable = wrapPaintable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _paintable
}

// Popup: GdkPopup is a surface that is attached to another surface.
//
// The GdkPopup is positioned relative to its parent surface.
//
// GdkPopups are typically used to implement menus and similar popups. They can
// be modal, which is indicated by the gdk.Popup:autohide property.
//
// Popup wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Popup struct {
	_ [0]func() // equal guard
	Surface
}

var (
	_ Surfacer = (*Popup)(nil)
)

// Popupper describes Popup's interface methods.
type Popupper interface {
	coreglib.Objector

	// Autohide returns whether this popup is set to hide on outside clicks.
	Autohide() bool
	// Parent returns the parent surface of a popup.
	Parent() Surfacer
	// PositionX obtains the position of the popup relative to its parent.
	PositionX() int
	// PositionY obtains the position of the popup relative to its parent.
	PositionY() int
	// RectAnchor gets the current popup rectangle anchor.
	RectAnchor() Gravity
	// SurfaceAnchor gets the current popup surface anchor.
	SurfaceAnchor() Gravity
	// Present popup after having processed the GdkPopupLayout rules.
	Present(width, height int, layout *PopupLayout) bool
}

var _ Popupper = (*Popup)(nil)

func wrapPopup(obj *coreglib.Object) *Popup {
	return &Popup{
		Surface: Surface{
			Object: obj,
		},
	}
}

func marshalPopup(p uintptr) (interface{}, error) {
	return wrapPopup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Autohide returns whether this popup is set to hide on outside clicks.
//
// The function returns the following values:
//
//   - ok: TRUE if popup will autohide.
func (popup *Popup) Autohide() bool {
	var _arg0 *C.GdkPopup // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(coreglib.InternObject(popup).Native()))

	_cret = C.gdk_popup_get_autohide(_arg0)
	runtime.KeepAlive(popup)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Parent returns the parent surface of a popup.
//
// The function returns the following values:
//
//   - surface (optional): parent surface.
func (popup *Popup) Parent() Surfacer {
	var _arg0 *C.GdkPopup   // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(coreglib.InternObject(popup).Native()))

	_cret = C.gdk_popup_get_parent(_arg0)
	runtime.KeepAlive(popup)

	var _surface Surfacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Surfacer)
				return ok
			})
			rv, ok := casted.(Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _surface
}

// PositionX obtains the position of the popup relative to its parent.
//
// The function returns the following values:
//
//   - gint: x coordinate of popup position.
func (popup *Popup) PositionX() int {
	var _arg0 *C.GdkPopup // out
	var _cret C.int       // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(coreglib.InternObject(popup).Native()))

	_cret = C.gdk_popup_get_position_x(_arg0)
	runtime.KeepAlive(popup)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PositionY obtains the position of the popup relative to its parent.
//
// The function returns the following values:
//
//   - gint: y coordinate of popup position.
func (popup *Popup) PositionY() int {
	var _arg0 *C.GdkPopup // out
	var _cret C.int       // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(coreglib.InternObject(popup).Native()))

	_cret = C.gdk_popup_get_position_y(_arg0)
	runtime.KeepAlive(popup)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RectAnchor gets the current popup rectangle anchor.
//
// The value returned may change after calling gdk.Popup.Present(), or after the
// gdk.Surface::layout signal is emitted.
//
// The function returns the following values:
//
//   - gravity: current rectangle anchor value of popup.
func (popup *Popup) RectAnchor() Gravity {
	var _arg0 *C.GdkPopup  // out
	var _cret C.GdkGravity // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(coreglib.InternObject(popup).Native()))

	_cret = C.gdk_popup_get_rect_anchor(_arg0)
	runtime.KeepAlive(popup)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// SurfaceAnchor gets the current popup surface anchor.
//
// The value returned may change after calling gdk.Popup.Present(), or after the
// gdk.Surface::layout signal is emitted.
//
// The function returns the following values:
//
//   - gravity: current surface anchor value of popup.
func (popup *Popup) SurfaceAnchor() Gravity {
	var _arg0 *C.GdkPopup  // out
	var _cret C.GdkGravity // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(coreglib.InternObject(popup).Native()))

	_cret = C.gdk_popup_get_surface_anchor(_arg0)
	runtime.KeepAlive(popup)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// Present popup after having processed the GdkPopupLayout rules.
//
// If the popup was previously now showing, it will be showed, otherwise it will
// change position according to layout.
//
// After calling this function, the result should be handled in response to
// the gdk.Surface::layout signal being emitted. The resulting popup position
// can be queried using gdk.Popup.GetPositionX(), gdk.Popup.GetPositionY(),
// and the resulting size will be sent as parameters in the layout signal.
// Use gdk.Popup.GetRectAnchor() and gdk.Popup.GetSurfaceAnchor() to get the
// resulting anchors.
//
// Presenting may fail, for example if the popup is set to autohide and
// is immediately hidden upon being presented. If presenting failed, the
// gdk.Surface::layout signal will not me emitted.
//
// The function takes the following parameters:
//
//   - width: unconstrained popup width to layout.
//   - height: unconstrained popup height to layout.
//   - layout: GdkPopupLayout object used to layout.
//
// The function returns the following values:
//
//   - ok: FALSE if it failed to be presented, otherwise TRUE.
func (popup *Popup) Present(width, height int, layout *PopupLayout) bool {
	var _arg0 *C.GdkPopup       // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out
	var _arg3 *C.GdkPopupLayout // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(coreglib.InternObject(popup).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)
	_arg3 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_popup_present(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(popup)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Toplevel: GdkToplevel is a freestanding toplevel surface.
//
// The GdkToplevel interface provides useful APIs for interacting with the
// windowing system, such as controlling maximization and size of the surface,
// setting icons and transient parents for dialogs.
//
// Toplevel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Toplevel struct {
	_ [0]func() // equal guard
	Surface
}

var (
	_ Surfacer = (*Toplevel)(nil)
)

// Topleveller describes Toplevel's interface methods.
type Topleveller interface {
	coreglib.Objector

	// BeginMove begins an interactive move operation.
	BeginMove(device Devicer, button int, x, y float64, timestamp uint32)
	// BeginResize begins an interactive resize operation.
	BeginResize(edge SurfaceEdge, device Devicer, button int, x, y float64, timestamp uint32)
	// Focus sets keyboard focus to surface.
	Focus(timestamp uint32)
	// State gets the bitwise or of the currently active surface state flags,
	// from the GdkToplevelState enumeration.
	State() ToplevelState
	// InhibitSystemShortcuts requests that the toplevel inhibit the system
	// shortcuts.
	InhibitSystemShortcuts(event Eventer)
	// Lower asks to lower the toplevel below other windows.
	Lower() bool
	// Minimize asks to minimize the toplevel.
	Minimize() bool
	// Present toplevel after having processed the GdkToplevelLayout rules.
	Present(layout *ToplevelLayout)
	// RestoreSystemShortcuts: restore default system keyboard shortcuts which
	// were previously inhibited.
	RestoreSystemShortcuts()
	// SetDecorated sets the toplevel to be decorated.
	SetDecorated(decorated bool)
	// SetDeletable sets the toplevel to be deletable.
	SetDeletable(deletable bool)
	// SetIconList sets a list of icons for the surface.
	SetIconList(surfaces []Texturer)
	// SetModal sets the toplevel to be modal.
	SetModal(modal bool)
	// SetStartupID sets the startup notification ID.
	SetStartupID(startupId string)
	// SetTitle sets the title of a toplevel surface.
	SetTitle(title string)
	// SetTransientFor sets a transient-for parent.
	SetTransientFor(parent Surfacer)
	// ShowWindowMenu asks the windowing system to show the window menu.
	ShowWindowMenu(event Eventer) bool
	// SupportsEdgeConstraints returns whether the desktop environment supports
	// tiled window states.
	SupportsEdgeConstraints() bool
	TitlebarGesture(gesture TitlebarGesture) bool
}

var _ Topleveller = (*Toplevel)(nil)

func wrapToplevel(obj *coreglib.Object) *Toplevel {
	return &Toplevel{
		Surface: Surface{
			Object: obj,
		},
	}
}

func marshalToplevel(p uintptr) (interface{}, error) {
	return wrapToplevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// BeginMove begins an interactive move operation.
//
// You might use this function to implement draggable titlebars.
//
// The function takes the following parameters:
//
//   - device used for the operation.
//   - button being used to drag, or 0 for a keyboard-initiated drag.
//   - x: surface X coordinate of mouse click that began the drag.
//   - y: surface Y coordinate of mouse click that began the drag.
//   - timestamp of mouse click that began the drag (use gdk.Event.GetTime()).
func (toplevel *Toplevel) BeginMove(device Devicer, button int, x, y float64, timestamp uint32) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.int          // out
	var _arg3 C.double       // out
	var _arg4 C.double       // out
	var _arg5 C.guint32      // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = C.int(button)
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.guint32(timestamp)

	C.gdk_toplevel_begin_move(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(device)
	runtime.KeepAlive(button)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(timestamp)
}

// BeginResize begins an interactive resize operation.
//
// You might use this function to implement a “window resize grip.”.
//
// The function takes the following parameters:
//
//   - edge or corner from which the drag is started.
//   - device (optional) used for the operation.
//   - button being used to drag, or 0 for a keyboard-initiated drag.
//   - x: surface X coordinate of mouse click that began the drag.
//   - y: surface Y coordinate of mouse click that began the drag.
//   - timestamp of mouse click that began the drag (use gdk.Event.GetTime()).
func (toplevel *Toplevel) BeginResize(edge SurfaceEdge, device Devicer, button int, x, y float64, timestamp uint32) {
	var _arg0 *C.GdkToplevel   // out
	var _arg1 C.GdkSurfaceEdge // out
	var _arg2 *C.GdkDevice     // out
	var _arg3 C.int            // out
	var _arg4 C.double         // out
	var _arg5 C.double         // out
	var _arg6 C.guint32        // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = C.GdkSurfaceEdge(edge)
	if device != nil {
		_arg2 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	}
	_arg3 = C.int(button)
	_arg4 = C.double(x)
	_arg5 = C.double(y)
	_arg6 = C.guint32(timestamp)

	C.gdk_toplevel_begin_resize(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(edge)
	runtime.KeepAlive(device)
	runtime.KeepAlive(button)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(timestamp)
}

// Focus sets keyboard focus to surface.
//
// In most cases, gtk_window_present_with_time()
// (../gtk4/method.Window.present_with_time.html) should be used on a GtkWindow
// (../gtk4/class.Window.html), rather than calling this function.
//
// The function takes the following parameters:
//
//   - timestamp of the event triggering the surface focus.
func (toplevel *Toplevel) Focus(timestamp uint32) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.guint32      // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = C.guint32(timestamp)

	C.gdk_toplevel_focus(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(timestamp)
}

// State gets the bitwise or of the currently active surface state flags,
// from the GdkToplevelState enumeration.
//
// The function returns the following values:
//
//   - toplevelState: surface state bitfield.
func (toplevel *Toplevel) State() ToplevelState {
	var _arg0 *C.GdkToplevel     // out
	var _cret C.GdkToplevelState // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))

	_cret = C.gdk_toplevel_get_state(_arg0)
	runtime.KeepAlive(toplevel)

	var _toplevelState ToplevelState // out

	_toplevelState = ToplevelState(_cret)

	return _toplevelState
}

// InhibitSystemShortcuts requests that the toplevel inhibit the system
// shortcuts.
//
// This is asking the desktop environment/windowing system to let all keyboard
// events reach the surface, as long as it is focused, instead of triggering
// system actions.
//
// If granted, the rerouting remains active until the default shortcuts
// processing is restored with gdk.Toplevel.RestoreSystemShortcuts(), or the
// request is revoked by the desktop environment, windowing system or the user.
//
// A typical use case for this API is remote desktop or virtual machine viewers
// which need to inhibit the default system keyboard shortcuts so that the
// remote session or virtual host gets those instead of the local environment.
//
// The windowing system or desktop environment may ask the user to grant or deny
// the request or even choose to ignore the request entirely.
//
// The caller can be notified whenever the request is granted or revoked by
// listening to the gdk.Toplevel:shortcuts-inhibited property.
//
// The function takes the following parameters:
//
//   - event (optional): GdkEvent that is triggering the inhibit request,
//     or NULL if none is available.
func (toplevel *Toplevel) InhibitSystemShortcuts(event Eventer) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkEvent    // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	if event != nil {
		_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	}

	C.gdk_toplevel_inhibit_system_shortcuts(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(event)
}

// Lower asks to lower the toplevel below other windows.
//
// The windowing system may choose to ignore the request.
//
// The function returns the following values:
//
//   - ok: TRUE if the surface was lowered.
func (toplevel *Toplevel) Lower() bool {
	var _arg0 *C.GdkToplevel // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))

	_cret = C.gdk_toplevel_lower(_arg0)
	runtime.KeepAlive(toplevel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Minimize asks to minimize the toplevel.
//
// The windowing system may choose to ignore the request.
//
// The function returns the following values:
//
//   - ok: TRUE if the surface was minimized.
func (toplevel *Toplevel) Minimize() bool {
	var _arg0 *C.GdkToplevel // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))

	_cret = C.gdk_toplevel_minimize(_arg0)
	runtime.KeepAlive(toplevel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Present toplevel after having processed the GdkToplevelLayout rules.
//
// If the toplevel was previously not showing, it will be showed, otherwise it
// will change layout according to layout.
//
// GDK may emit the gdk.Toplevel::compute-size signal to let the user of this
// toplevel compute the preferred size of the toplevel surface.
//
// Presenting is asynchronous and the specified layout parameters are not
// guaranteed to be respected.
//
// The function takes the following parameters:
//
//   - layout: GdkToplevelLayout object used to layout.
func (toplevel *Toplevel) Present(layout *ToplevelLayout) {
	var _arg0 *C.GdkToplevel       // out
	var _arg1 *C.GdkToplevelLayout // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	C.gdk_toplevel_present(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(layout)
}

// RestoreSystemShortcuts: restore default system keyboard shortcuts which were
// previously inhibited.
//
// This undoes the effect of gdk.Toplevel.InhibitSystemShortcuts().
func (toplevel *Toplevel) RestoreSystemShortcuts() {
	var _arg0 *C.GdkToplevel // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))

	C.gdk_toplevel_restore_system_shortcuts(_arg0)
	runtime.KeepAlive(toplevel)
}

// SetDecorated sets the toplevel to be decorated.
//
// Setting decorated to FALSE hints the desktop environment that the surface has
// its own, client-side decorations and does not need to have window decorations
// added.
//
// The function takes the following parameters:
//
//   - decorated: TRUE to request decorations.
func (toplevel *Toplevel) SetDecorated(decorated bool) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	if decorated {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_set_decorated(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(decorated)
}

// SetDeletable sets the toplevel to be deletable.
//
// Setting deletable to TRUE hints the desktop environment that it should offer
// the user a way to close the surface.
//
// The function takes the following parameters:
//
//   - deletable: TRUE to request a delete button.
func (toplevel *Toplevel) SetDeletable(deletable bool) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	if deletable {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_set_deletable(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(deletable)
}

// SetIconList sets a list of icons for the surface.
//
// One of these will be used to represent the surface in iconic form. The icon
// may be shown in window lists or task bars. Which icon size is shown depends
// on the window manager. The window manager can scale the icon but setting
// several size icons can give better image quality.
//
// Note that some platforms don't support surface icons.
//
// The function takes the following parameters:
//
//   - surfaces: A list of textures to use as icon, of different sizes.
func (toplevel *Toplevel) SetIconList(surfaces []Texturer) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GList       // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	for i := len(surfaces) - 1; i >= 0; i-- {
		src := surfaces[i]
		var dst *C.GdkTexture // out
		dst = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	C.gdk_toplevel_set_icon_list(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(surfaces)
}

// SetModal sets the toplevel to be modal.
//
// The application can use this hint to tell the window manager that a certain
// surface has modal behaviour. The window manager can use this information to
// handle modal surfaces in a special way.
//
// You should only use this on surfaces for which you have previously called
// gdk.Toplevel.SetTransientFor().
//
// The function takes the following parameters:
//
//   - modal: TRUE if the surface is modal, FALSE otherwise.
func (toplevel *Toplevel) SetModal(modal bool) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_set_modal(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(modal)
}

// SetStartupID sets the startup notification ID.
//
// When using GTK, typically you should use gtk_window_set_startup_id()
// (../gtk4/method.Window.set_startup_id.html) instead of this low-level
// function.
//
// The function takes the following parameters:
//
//   - startupId: string with startup-notification identifier.
func (toplevel *Toplevel) SetStartupID(startupId string) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_toplevel_set_startup_id(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(startupId)
}

// SetTitle sets the title of a toplevel surface.
//
// The title maybe be displayed in the titlebar, in lists of windows, etc.
//
// The function takes the following parameters:
//
//   - title of surface.
func (toplevel *Toplevel) SetTitle(title string) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_toplevel_set_title(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(title)
}

// SetTransientFor sets a transient-for parent.
//
// Indicates to the window manager that surface is a transient dialog associated
// with the application surface parent. This allows the window manager to do
// things like center surface on parent and keep surface above parent.
//
// See gtk_window_set_transient_for()
// (../gtk4/method.Window.set_transient_for.html) if you’re using GtkWindow
// (../gtk4/class.Window.html).
//
// The function takes the following parameters:
//
//   - parent: another toplevel GdkSurface.
func (toplevel *Toplevel) SetTransientFor(parent Surfacer) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkSurface  // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	C.gdk_toplevel_set_transient_for(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(parent)
}

// ShowWindowMenu asks the windowing system to show the window menu.
//
// The window menu is the menu shown when right-clicking the titlebar on
// traditional windows managed by the window manager. This is useful for windows
// using client-side decorations, activating it with a right-click on the window
// decorations.
//
// The function takes the following parameters:
//
//   - event: GdkEvent to show the menu for.
//
// The function returns the following values:
//
//   - ok: TRUE if the window menu was shown and FALSE otherwise.
func (toplevel *Toplevel) ShowWindowMenu(event Eventer) bool {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkEvent    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_toplevel_show_window_menu(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsEdgeConstraints returns whether the desktop environment supports
// tiled window states.
//
// The function returns the following values:
//
//   - ok: TRUE if the desktop environment supports tiled window states.
func (toplevel *Toplevel) SupportsEdgeConstraints() bool {
	var _arg0 *C.GdkToplevel // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))

	_cret = C.gdk_toplevel_supports_edge_constraints(_arg0)
	runtime.KeepAlive(toplevel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - gesture: GdkTitlebarGesture.
func (toplevel *Toplevel) TitlebarGesture(gesture TitlebarGesture) bool {
	var _arg0 *C.GdkToplevel       // out
	var _arg1 C.GdkTitlebarGesture // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(coreglib.InternObject(toplevel).Native()))
	_arg1 = C.GdkTitlebarGesture(gesture)

	_cret = C.gdk_toplevel_titlebar_gesture(_arg0, _arg1)
	runtime.KeepAlive(toplevel)
	runtime.KeepAlive(gesture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppLaunchContext: GdkAppLaunchContext handles launching an application in a
// graphical context.
//
// It is an implementation of GAppLaunchContext that provides startup
// notification and allows to launch applications on a specific workspace.
//
// Launching an application
//
//	GdkAppLaunchContext *context;
//
//	context = gdk_display_get_app_launch_context (display);
//
//	gdk_app_launch_context_set_timestamp (gdk_event_get_time (event));
//
//	if (!g_app_info_launch_default_for_uri ("http://www.gtk.org", context, &error))
//	  g_warning ("Launching failed: s\n", error->message);
//
//	g_object_unref (context);.
type AppLaunchContext struct {
	_ [0]func() // equal guard
	gio.AppLaunchContext
}

var (
	_ coreglib.Objector = (*AppLaunchContext)(nil)
)

func wrapAppLaunchContext(obj *coreglib.Object) *AppLaunchContext {
	return &AppLaunchContext{
		AppLaunchContext: gio.AppLaunchContext{
			Object: obj,
		},
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	return wrapAppLaunchContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Display gets the GdkDisplay that context is for.
//
// The function returns the following values:
//
//   - display of context.
func (context *AppLaunchContext) Display() *Display {
	var _arg0 *C.GdkAppLaunchContext // out
	var _cret *C.GdkDisplay          // in

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_app_launch_context_get_display(_arg0)
	runtime.KeepAlive(context)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// SetDesktop sets the workspace on which applications will be launched.
//
// This only works when running under a window manager that supports
// multiple workspaces, as described in the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec). Specifically this sets the
// _NET_WM_DESKTOP property described in that spec.
//
// This only works when using the X11 backend.
//
// When the workspace is not specified or desktop is set to -1, it is up to the
// window manager to pick one, typically it will be the current workspace.
//
// The function takes the following parameters:
//
//   - desktop: number of a workspace, or -1.
func (context *AppLaunchContext) SetDesktop(desktop int) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(desktop)

	C.gdk_app_launch_context_set_desktop(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desktop)
}

// SetIcon sets the icon for applications that are launched with this context.
//
// Window Managers can use this information when displaying startup
// notification.
//
// See also gdk.AppLaunchContext.SetIconName().
//
// The function takes the following parameters:
//
//   - icon (optional): GIcon.
func (context *AppLaunchContext) SetIcon(icon gio.Iconner) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 *C.GIcon               // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if icon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	}

	C.gdk_app_launch_context_set_icon(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(icon)
}

// SetIconName sets the icon for applications that are launched with this
// context.
//
// The icon_name will be interpreted in the same way as the Icon field in
// desktop files. See also gdk.AppLaunchContext.SetIcon().
//
// If both icon and icon_name are set, the icon_name takes priority.
// If neither icon or icon_name is set, the icon is taken from either the file
// that is passed to launched application or from the GAppInfo for the launched
// application itself.
//
// The function takes the following parameters:
//
//   - iconName (optional): icon name.
func (context *AppLaunchContext) SetIconName(iconName string) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if iconName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gdk_app_launch_context_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(iconName)
}

// SetTimestamp sets the timestamp of context.
//
// The timestamp should ideally be taken from the event that triggered the
// launch.
//
// Window managers can use this information to avoid moving the focus to the
// newly launched application when the user is busy typing in another window.
// This is also known as 'focus stealing prevention'.
//
// The function takes the following parameters:
//
//   - timestamp: timestamp.
func (context *AppLaunchContext) SetTimestamp(timestamp uint32) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 C.guint32              // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.guint32(timestamp)

	C.gdk_app_launch_context_set_timestamp(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(timestamp)
}

// ButtonEvent: event related to a button on a pointer device.
type ButtonEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*ButtonEvent)(nil)
)

func wrapButtonEvent(obj *coreglib.Object) *ButtonEvent {
	return &ButtonEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalButtonEvent(p uintptr) (interface{}, error) {
	return wrapButtonEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Button: extract the button number from a button event.
//
// The function returns the following values:
//
//   - guint: button of event.
func (event *ButtonEvent) Button() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_button_event_get_button(_arg0)
	runtime.KeepAlive(event)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CairoContext: GdkCairoContext is an object representing the platform-specific
// draw context.
//
// GdkCairoContexts are created for a surface using
// gdk.Surface.CreateCairoContext(), and the context can then be used to draw on
// that surface.
type CairoContext struct {
	_ [0]func() // equal guard
	DrawContext
}

var (
	_ DrawContexter = (*CairoContext)(nil)
)

// CairoContexter describes types inherited from class CairoContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type CairoContexter interface {
	coreglib.Objector
	baseCairoContext() *CairoContext
}

var _ CairoContexter = (*CairoContext)(nil)

func wrapCairoContext(obj *coreglib.Object) *CairoContext {
	return &CairoContext{
		DrawContext: DrawContext{
			Object: obj,
		},
	}
}

func marshalCairoContext(p uintptr) (interface{}, error) {
	return wrapCairoContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *CairoContext) baseCairoContext() *CairoContext {
	return self
}

// BaseCairoContext returns the underlying base object.
func BaseCairoContext(obj CairoContexter) *CairoContext {
	return obj.baseCairoContext()
}

// CairoCreate retrieves a Cairo context to be used to draw on the GdkSurface of
// context.
//
// A call to gdk.DrawContext.BeginFrame() with this context must have been done
// or this function will return NULL.
//
// The returned context is guaranteed to be valid until
// gdk.DrawContext.EndFrame() is called.
//
// The function returns the following values:
//
//   - context (optional): cairo context to draw on `GdkSurface.
func (self *CairoContext) CairoCreate() *cairo.Context {
	var _arg0 *C.GdkCairoContext // out
	var _cret *C.cairo_t         // in

	_arg0 = (*C.GdkCairoContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_cairo_context_cairo_create(_arg0)
	runtime.KeepAlive(self)

	var _context *cairo.Context // out

	if _cret != nil {
		_context = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(_context, func(v *cairo.Context) {
			C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
		})
	}

	return _context
}

// Clipboard: GdkClipboard object represents data shared between applications or
// inside an application.
//
// To get a GdkClipboard object, use gdk.Display.GetClipboard() or
// gdk.Display.GetPrimaryClipboard(). You can find out about the data that is
// currently available in a clipboard using gdk.Clipboard.GetFormats().
//
// To make text or image data available in a clipboard, use
// gdk.Clipboard.SetText() or gdk.Clipboard.SetTexture(). For other data, you
// can use gdk.Clipboard.SetContent(), which takes a gdk.ContentProvider object.
//
// To read textual or image data from a clipboard, use
// gdk.Clipboard.ReadTextAsync() or gdk.Clipboard.ReadTextureAsync(). For other
// data, use gdk.Clipboard.ReadAsync(), which provides a GInputStream object.
type Clipboard struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Clipboard)(nil)
)

func wrapClipboard(obj *coreglib.Object) *Clipboard {
	return &Clipboard{
		Object: obj,
	}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	return wrapClipboard(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the clipboard changes ownership.
func (clipboard *Clipboard) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(clipboard, "changed", false, unsafe.Pointer(C._gotk4_gdk4_Clipboard_ConnectChanged), f)
}

// Content returns the GdkContentProvider currently set on clipboard.
//
// If the clipboard is empty or its contents are not owned by the current
// process, NULL will be returned.
//
// The function returns the following values:
//
//   - contentProvider (optional): content of a clipboard if the clipboard does
//     not maintain any content.
func (clipboard *Clipboard) Content() *ContentProvider {
	var _arg0 *C.GdkClipboard       // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	_cret = C.gdk_clipboard_get_content(_arg0)
	runtime.KeepAlive(clipboard)

	var _contentProvider *ContentProvider // out

	if _cret != nil {
		_contentProvider = wrapContentProvider(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _contentProvider
}

// Display gets the GdkDisplay that the clipboard was created for.
//
// The function returns the following values:
//
//   - display: GdkDisplay.
func (clipboard *Clipboard) Display() *Display {
	var _arg0 *C.GdkClipboard // out
	var _cret *C.GdkDisplay   // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	_cret = C.gdk_clipboard_get_display(_arg0)
	runtime.KeepAlive(clipboard)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// Formats gets the formats that the clipboard can provide its current contents
// in.
//
// The function returns the following values:
//
//   - contentFormats formats of the clipboard.
func (clipboard *Clipboard) Formats() *ContentFormats {
	var _arg0 *C.GdkClipboard      // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	_cret = C.gdk_clipboard_get_formats(_arg0)
	runtime.KeepAlive(clipboard)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gdk_content_formats_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// IsLocal returns if the clipboard is local.
//
// A clipboard is considered local if it was last claimed by the running
// application.
//
// Note that gdk.Clipboard.GetContent() may return NULL even on a local
// clipboard. In this case the clipboard is empty.
//
// The function returns the following values:
//
//   - ok: TRUE if the clipboard is local.
func (clipboard *Clipboard) IsLocal() bool {
	var _arg0 *C.GdkClipboard // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	_cret = C.gdk_clipboard_is_local(_arg0)
	runtime.KeepAlive(clipboard)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReadAsync: asynchronously requests an input stream to read the clipboard's
// contents from.
//
// When the operation is finished callback will be called. You must then call
// gdk.Clipboard.ReadFinish() to get the result of the operation.
//
// The clipboard will choose the most suitable mime type from the given list to
// fulfill the request, preferring the ones listed first.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object.
//   - mimeTypes: NULL-terminated array of mime types to choose from.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to call when the request is satisfied.
func (clipboard *Clipboard) ReadAsync(ctx context.Context, mimeTypes []string, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkClipboard       // out
	var _arg3 *C.GCancellable       // out
	var _arg1 **C.char              // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(mimeTypes) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(mimeTypes)+1)
			var zero *C.char
			out[len(mimeTypes)] = zero
			for i := range mimeTypes {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(mimeTypes[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_clipboard_read_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(mimeTypes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadFinish finishes an asynchronous clipboard read.
//
// See gdk.Clipboard.ReadAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
//
// The function returns the following values:
//
//   - outMimeType (optional): location to store the chosen mime type.
//   - inputStream (optional): GInputStream.
func (clipboard *Clipboard) ReadFinish(result gio.AsyncResulter) (string, gio.InputStreamer, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.gdk_clipboard_read_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(result)

	var _outMimeType string            // out
	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	if _arg2 != nil {
		_outMimeType = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	}
	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.InputStreamer)
				return ok
			})
			rv, ok := casted.(gio.InputStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
			}
			_inputStream = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outMimeType, _inputStream, _goerr
}

// ReadTextAsync: asynchronously request the clipboard contents converted to a
// string.
//
// When the operation is finished callback will be called. You must then call
// gdk.Clipboard.ReadTextFinish() to get the result.
//
// This is a simple wrapper around gdk.Clipboard.ReadValueAsync(). Use that
// function or gdk.Clipboard.ReadAsync() directly if you need more control over
// the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object.
//   - callback (optional) to call when the request is satisfied.
func (clipboard *Clipboard) ReadTextAsync(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkClipboard       // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_clipboard_read_text_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// ReadTextFinish finishes an asynchronous clipboard read.
//
// See gdk.Clipboard.ReadTextAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
//
// The function returns the following values:
//
//   - utf8 (optional): new string.
func (clipboard *Clipboard) ReadTextFinish(result gio.AsyncResulter) (string, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.gdk_clipboard_read_text_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(result)

	var _utf8 string // out
	var _goerr error // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// ReadTextureAsync: asynchronously request the clipboard contents converted to
// a GdkPixbuf.
//
// When the operation is finished callback will be called. You must then call
// gdk.Clipboard.ReadTextureFinish() to get the result.
//
// This is a simple wrapper around gdk.Clipboard.ReadValueAsync(). Use that
// function or gdk.Clipboard.ReadAsync() directly if you need more control over
// the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object, NULL to ignore.
//   - callback (optional) to call when the request is satisfied.
func (clipboard *Clipboard) ReadTextureAsync(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkClipboard       // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_clipboard_read_texture_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// ReadTextureFinish finishes an asynchronous clipboard read.
//
// See gdk.Clipboard.ReadTextureAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
//
// The function returns the following values:
//
//   - texture (optional): new GdkTexture.
func (clipboard *Clipboard) ReadTextureFinish(result gio.AsyncResulter) (Texturer, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GdkTexture   // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.gdk_clipboard_read_texture_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(result)

	var _texture Texturer // out
	var _goerr error      // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Texturer)
				return ok
			})
			rv, ok := casted.(Texturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
			}
			_texture = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _texture, _goerr
}

// ReadValueAsync: asynchronously request the clipboard contents converted to
// the given type.
//
// When the operation is finished callback will be called. You must then call
// gdk.Clipboard.ReadValueFinish() to get the resulting GValue.
//
// For local clipboard contents that are available in the given GType,
// the value will be copied directly. Otherwise, GDK will try to use
// content_deserialize_async to convert the clipboard's data.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object.
//   - typ: GType to read.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to call when the request is satisfied.
func (clipboard *Clipboard) ReadValueAsync(ctx context.Context, typ coreglib.Type, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkClipboard       // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GType               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GType(typ)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_clipboard_read_value_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadValueFinish finishes an asynchronous clipboard read.
//
// See gdk.Clipboard.ReadValueAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
//
// The function returns the following values:
//
//   - value: GValue containing the result.
func (clipboard *Clipboard) ReadValueFinish(result gio.AsyncResulter) (*coreglib.Value, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GValue       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.gdk_clipboard_read_value_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(result)

	var _value *coreglib.Value // out
	var _goerr error           // out

	_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// SetContent sets a new content provider on clipboard.
//
// The clipboard will claim the GdkDisplay's resources and advertise these new
// contents to other applications.
//
// In the rare case of a failure, this function will return FALSE. The clipboard
// will then continue reporting its old contents and ignore provider.
//
// If the contents are read by either an external application or the clipboard's
// read functions, clipboard will select the best format to transfer the
// contents and then request that format from provider.
//
// The function takes the following parameters:
//
//   - provider (optional): new contents of clipboard or NULL to clear the
//     clipboard.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the clipboard succeeded.
func (clipboard *Clipboard) SetContent(provider *ContentProvider) bool {
	var _arg0 *C.GdkClipboard       // out
	var _arg1 *C.GdkContentProvider // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if provider != nil {
		_arg1 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	}

	_cret = C.gdk_clipboard_set_content(_arg0, _arg1)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(provider)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetText puts the given text into the clipboard.
//
// The function takes the following parameters:
//
//   - text: text to put into the clipboard.
func (clipboard *Clipboard) SetText(text string) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_clipboard_set_text(_arg0, _arg1)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(text)
}

// SetTexture puts the given texture into the clipboard.
//
// The function takes the following parameters:
//
//   - texture: GdkTexture to put into the clipboard.
func (clipboard *Clipboard) SetTexture(texture Texturer) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GdkTexture   // out

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	C.gdk_clipboard_set_texture(_arg0, _arg1)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(texture)
}

// Set sets the clipboard to contain the given value.
//
// The function takes the following parameters:
//
//   - value: GValue to set.
func (clipboard *Clipboard) Set(value *coreglib.Value) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GValue       // out

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gdk_clipboard_set_value(_arg0, _arg1)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(value)
}

// StoreAsync: asynchronously instructs the clipboard to store its contents
// remotely.
//
// If the clipboard is not local, this function does nothing but report success.
//
// The callback must call gdk.Clipboard.StoreFinish().
//
// The purpose of this call is to preserve clipboard contents beyond the
// lifetime of an application, so this function is typically called on exit.
// Depending on the platform, the functionality may not be available unless a
// "clipboard manager" is running.
//
// This function is called automatically when a GtkApplication
// (../gtk4/class.Application.html) is shut down, so you likely don't need to
// call it.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to call when the request is satisfied.
func (clipboard *Clipboard) StoreAsync(ctx context.Context, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkClipboard       // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_clipboard_store_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// StoreFinish finishes an asynchronous clipboard store.
//
// See gdk.Clipboard.StoreAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
func (clipboard *Clipboard) StoreFinish(result gio.AsyncResulter) error {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.gdk_clipboard_store_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ContentDeserializer: GdkContentDeserializer is used to deserialize content
// received via inter-application data transfers.
//
// The GdkContentDeserializer transforms serialized content that is identified
// by a mime type into an object identified by a GType.
//
// GTK provides serializers and deserializers for common data types such as
// text, colors, images or file lists. To register your own deserialization
// functions, use content_register_deserializer.
//
// Also see gdk.ContentSerializer.
type ContentDeserializer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.AsyncResult
}

var (
	_ coreglib.Objector = (*ContentDeserializer)(nil)
)

func wrapContentDeserializer(obj *coreglib.Object) *ContentDeserializer {
	return &ContentDeserializer{
		Object: obj,
		AsyncResult: gio.AsyncResult{
			Object: obj,
		},
	}
}

func marshalContentDeserializer(p uintptr) (interface{}, error) {
	return wrapContentDeserializer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Cancellable gets the cancellable for the current operation.
//
// This is the GCancellable that was passed to gdk.ContentDeserializeAsync().
//
// The function returns the following values:
//
//   - cancellable (optional) for the current operation.
func (deserializer *ContentDeserializer) Cancellable() *gio.Cancellable {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.GCancellable           // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_cancellable(_arg0)
	runtime.KeepAlive(deserializer)

	var _cancellable *gio.Cancellable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_cancellable = &gio.Cancellable{
				Object: obj,
			}
		}
	}

	return _cancellable
}

// GType gets the GType to create an instance of.
//
// The function returns the following values:
//
//   - gType: GType for the current operation.
func (deserializer *ContentDeserializer) GType() coreglib.Type {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret C.GType                   // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_gtype(_arg0)
	runtime.KeepAlive(deserializer)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// InputStream gets the input stream for the current operation.
//
// This is the stream that was passed to gdk.ContentDeserializeAsync().
//
// The function returns the following values:
//
//   - inputStream: input stream for the current operation.
func (deserializer *ContentDeserializer) InputStream() gio.InputStreamer {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.GInputStream           // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_input_stream(_arg0)
	runtime.KeepAlive(deserializer)

	var _inputStream gio.InputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.InputStreamer)
			return ok
		})
		rv, ok := casted.(gio.InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}

	return _inputStream
}

// MIMEType gets the mime type to deserialize from.
//
// The function returns the following values:
//
//   - utf8: mime type for the current operation.
func (deserializer *ContentDeserializer) MIMEType() string {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.char                   // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_mime_type(_arg0)
	runtime.KeepAlive(deserializer)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Priority gets the I/O priority for the current operation.
//
// This is the priority that was passed to gdk.ContentDeserializeAsync().
//
// The function returns the following values:
//
//   - gint: i/O priority for the current operation.
func (deserializer *ContentDeserializer) Priority() int {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret C.int                     // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_priority(_arg0)
	runtime.KeepAlive(deserializer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TaskData gets the data that was associated with the current operation.
//
// See gdk.ContentDeserializer.SetTaskData().
//
// The function returns the following values:
//
//   - gpointer (optional): task data for deserializer.
func (deserializer *ContentDeserializer) TaskData() unsafe.Pointer {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret C.gpointer                // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_task_data(_arg0)
	runtime.KeepAlive(deserializer)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// UserData gets the user data that was passed when the deserializer was
// registered.
//
// The function returns the following values:
//
//   - gpointer (optional): user data for this deserializer.
func (deserializer *ContentDeserializer) UserData() unsafe.Pointer {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret C.gpointer                // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_user_data(_arg0)
	runtime.KeepAlive(deserializer)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Value gets the GValue to store the deserialized object in.
//
// The function returns the following values:
//
//   - value: GValue for the current operation.
func (deserializer *ContentDeserializer) Value() *coreglib.Value {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.GValue                 // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	_cret = C.gdk_content_deserializer_get_value(_arg0)
	runtime.KeepAlive(deserializer)

	var _value *coreglib.Value // out

	_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _value
}

// ReturnError: indicate that the deserialization has ended with an error.
//
// This function consumes error.
//
// The function takes the following parameters:
//
//   - err: GError.
func (deserializer *ContentDeserializer) ReturnError(err error) {
	var _arg0 *C.GdkContentDeserializer // out
	var _arg1 *C.GError                 // out

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	C.gdk_content_deserializer_return_error(_arg0, _arg1)
	runtime.KeepAlive(deserializer)
	runtime.KeepAlive(err)
}

// ReturnSuccess: indicate that the deserialization has been successfully
// completed.
func (deserializer *ContentDeserializer) ReturnSuccess() {
	var _arg0 *C.GdkContentDeserializer // out

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(coreglib.InternObject(deserializer).Native()))

	C.gdk_content_deserializer_return_success(_arg0)
	runtime.KeepAlive(deserializer)
}

// ContentProviderOverrides contains methods that are overridable.
type ContentProviderOverrides struct {
	AttachClipboard func(clipboard *Clipboard)
	// ContentChanged emits the ::content-changed signal.
	ContentChanged  func()
	DetachClipboard func(clipboard *Clipboard)
	// Value gets the contents of provider stored in value.
	//
	// The value will have been initialized to the GType the value should be
	// provided in. This given GType does not need to be listed in the formats
	// returned by gdk.ContentProvider.RefFormats(). However, if the given GType
	// is not supported, this operation can fail and G_IO_ERROR_NOT_SUPPORTED
	// will be reported.
	//
	// The function returns the following values:
	//
	//   - value: GValue to fill.
	Value func() (coreglib.Value, error)
	// RefFormats gets the formats that the provider can provide its current
	// contents in.
	//
	// The function returns the following values:
	//
	//   - contentFormats formats of the provider.
	RefFormats func() *ContentFormats
	// RefStorableFormats gets the formats that the provider suggests other
	// applications to store the data in.
	//
	// An example of such an application would be a clipboard manager.
	//
	// This can be assumed to be a subset of gdk.ContentProvider.RefFormats().
	//
	// The function returns the following values:
	//
	//   - contentFormats: storable formats of the provider.
	RefStorableFormats func() *ContentFormats
	// WriteMIMETypeFinish finishes an asynchronous write operation.
	//
	// See gdk.ContentProvider.WriteMIMETypeAsync().
	//
	// The function takes the following parameters:
	//
	//   - result: GAsyncResult.
	WriteMIMETypeFinish func(result gio.AsyncResulter) error
}

func defaultContentProviderOverrides(v *ContentProvider) ContentProviderOverrides {
	return ContentProviderOverrides{
		AttachClipboard:     v.attachClipboard,
		ContentChanged:      v.contentChanged,
		DetachClipboard:     v.detachClipboard,
		Value:               v.value,
		RefFormats:          v.refFormats,
		RefStorableFormats:  v.refStorableFormats,
		WriteMIMETypeFinish: v.writeMIMETypeFinish,
	}
}

// ContentProvider: GdkContentProvider is used to provide content for the
// clipboard or for drag-and-drop operations in a number of formats.
//
// To create a GdkContentProvider, use gdk.ContentProvider.NewForValue or
// gdk.ContentProvider.NewForBytes.
//
// GDK knows how to handle common text and image formats out-of-the-box. See
// gdk.ContentSerializer and gdk.ContentDeserializer if you want to add support
// for application-specific data formats.
type ContentProvider struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ContentProvider)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ContentProvider, *ContentProviderClass, ContentProviderOverrides](
		GTypeContentProvider,
		initContentProviderClass,
		wrapContentProvider,
		defaultContentProviderOverrides,
	)
}

func initContentProviderClass(gclass unsafe.Pointer, overrides ContentProviderOverrides, classInitFunc func(*ContentProviderClass)) {
	pclass := (*C.GdkContentProviderClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeContentProvider))))

	if overrides.AttachClipboard != nil {
		pclass.attach_clipboard = (*[0]byte)(C._gotk4_gdk4_ContentProviderClass_attach_clipboard)
	}

	if overrides.ContentChanged != nil {
		pclass.content_changed = (*[0]byte)(C._gotk4_gdk4_ContentProviderClass_content_changed)
	}

	if overrides.DetachClipboard != nil {
		pclass.detach_clipboard = (*[0]byte)(C._gotk4_gdk4_ContentProviderClass_detach_clipboard)
	}

	if overrides.Value != nil {
		pclass.get_value = (*[0]byte)(C._gotk4_gdk4_ContentProviderClass_get_value)
	}

	if overrides.RefFormats != nil {
		pclass.ref_formats = (*[0]byte)(C._gotk4_gdk4_ContentProviderClass_ref_formats)
	}

	if overrides.RefStorableFormats != nil {
		pclass.ref_storable_formats = (*[0]byte)(C._gotk4_gdk4_ContentProviderClass_ref_storable_formats)
	}

	if overrides.WriteMIMETypeFinish != nil {
		pclass.write_mime_type_finish = (*[0]byte)(C._gotk4_gdk4_ContentProviderClass_write_mime_type_finish)
	}

	if classInitFunc != nil {
		class := (*ContentProviderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapContentProvider(obj *coreglib.Object) *ContentProvider {
	return &ContentProvider{
		Object: obj,
	}
}

func marshalContentProvider(p uintptr) (interface{}, error) {
	return wrapContentProvider(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectContentChanged is emitted whenever the content provided by this
// provider has changed.
func (provider *ContentProvider) ConnectContentChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(provider, "content-changed", false, unsafe.Pointer(C._gotk4_gdk4_ContentProvider_ConnectContentChanged), f)
}

// NewContentProviderForBytes: create a content provider that provides the given
// bytes as data for the given mime_type.
//
// The function takes the following parameters:
//
//   - mimeType: mime type.
//   - bytes: GBytes with the data for mime_type.
//
// The function returns the following values:
//
//   - contentProvider: new GdkContentProvider.
func NewContentProviderForBytes(mimeType string, bytes *glib.Bytes) *ContentProvider {
	var _arg1 *C.char               // out
	var _arg2 *C.GBytes             // out
	var _cret *C.GdkContentProvider // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.gdk_content_provider_new_for_bytes(_arg1, _arg2)
	runtime.KeepAlive(mimeType)
	runtime.KeepAlive(bytes)

	var _contentProvider *ContentProvider // out

	_contentProvider = wrapContentProvider(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _contentProvider
}

// NewContentProviderForValue: create a content provider that provides the given
// value.
//
// The function takes the following parameters:
//
//   - value: GValue.
//
// The function returns the following values:
//
//   - contentProvider: new GdkContentProvider.
func NewContentProviderForValue(value *coreglib.Value) *ContentProvider {
	var _arg1 *C.GValue             // out
	var _cret *C.GdkContentProvider // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gdk_content_provider_new_for_value(_arg1)
	runtime.KeepAlive(value)

	var _contentProvider *ContentProvider // out

	_contentProvider = wrapContentProvider(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _contentProvider
}

// NewContentProviderUnion creates a content provider that represents all the
// given providers.
//
// Whenever data needs to be written, the union provider will try the given
// providers in the given order and the first one supporting a format will be
// chosen to provide it.
//
// This allows an easy way to support providing data in different formats.
// For example, an image may be provided by its file and by the image contents
// with a call such as
//
//	gdk_content_provider_new_union ((GdkContentProvider *[2]) {
//	                                  gdk_content_provider_new_typed (G_TYPE_FILE, file),
//	                                  gdk_content_provider_new_typed (G_TYPE_TEXTURE, texture)
//	                                }, 2);.
//
// The function takes the following parameters:
//
//   - providers (optional): The GdkContentProviders to present the union of.
//
// The function returns the following values:
//
//   - contentProvider: new GdkContentProvider.
func NewContentProviderUnion(providers []*ContentProvider) *ContentProvider {
	var _arg1 **C.GdkContentProvider // out
	var _arg2 C.gsize
	var _cret *C.GdkContentProvider // in

	if providers != nil {
		_arg2 = (C.gsize)(len(providers))
		_arg1 = (**C.GdkContentProvider)(C.calloc(C.size_t(len(providers)), C.size_t(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice((**C.GdkContentProvider)(_arg1), len(providers))
			for i := range providers {
				out[i] = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(providers[i]).Native()))
				C.g_object_ref(C.gpointer(coreglib.InternObject(providers[i]).Native()))
			}
		}
	}

	_cret = C.gdk_content_provider_new_union(_arg1, _arg2)
	runtime.KeepAlive(providers)

	var _contentProvider *ContentProvider // out

	_contentProvider = wrapContentProvider(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _contentProvider
}

// ContentChanged emits the ::content-changed signal.
func (provider *ContentProvider) ContentChanged() {
	var _arg0 *C.GdkContentProvider // out

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C.gdk_content_provider_content_changed(_arg0)
	runtime.KeepAlive(provider)
}

// Value gets the contents of provider stored in value.
//
// The value will have been initialized to the GType the value should be
// provided in. This given GType does not need to be listed in the formats
// returned by gdk.ContentProvider.RefFormats(). However, if the given GType is
// not supported, this operation can fail and G_IO_ERROR_NOT_SUPPORTED will be
// reported.
//
// The function returns the following values:
//
//   - value: GValue to fill.
func (provider *ContentProvider) Value() (coreglib.Value, error) {
	var _arg0 *C.GdkContentProvider // out
	var _arg1 C.GValue              // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C.gdk_content_provider_get_value(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(provider)

	var _value coreglib.Value // out
	var _goerr error          // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// RefFormats gets the formats that the provider can provide its current
// contents in.
//
// The function returns the following values:
//
//   - contentFormats formats of the provider.
func (provider *ContentProvider) RefFormats() *ContentFormats {
	var _arg0 *C.GdkContentProvider // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gdk_content_provider_ref_formats(_arg0)
	runtime.KeepAlive(provider)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// RefStorableFormats gets the formats that the provider suggests other
// applications to store the data in.
//
// An example of such an application would be a clipboard manager.
//
// This can be assumed to be a subset of gdk.ContentProvider.RefFormats().
//
// The function returns the following values:
//
//   - contentFormats: storable formats of the provider.
func (provider *ContentProvider) RefStorableFormats() *ContentFormats {
	var _arg0 *C.GdkContentProvider // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gdk_content_provider_ref_storable_formats(_arg0)
	runtime.KeepAlive(provider)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// WriteMIMETypeAsync: asynchronously writes the contents of provider to stream
// in the given mime_type.
//
// When the operation is finished callback will be called. You must then call
// gdk.ContentProvider.WriteMIMETypeFinish() to get the result of the operation.
//
// The given mime type does not need to be listed in the formats returned
// by gdk.ContentProvider.RefFormats(). However, if the given GType is not
// supported, G_IO_ERROR_NOT_SUPPORTED will be reported.
//
// The given stream will not be closed.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object, NULL to ignore.
//   - mimeType: mime type to provide the data in.
//   - stream: GOutputStream to write to.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to call when the request is satisfied.
func (provider *ContentProvider) WriteMIMETypeAsync(ctx context.Context, mimeType string, stream gio.OutputStreamer, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkContentProvider // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 *C.GOutputStream      // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_content_provider_write_mime_type_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(mimeType)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WriteMIMETypeFinish finishes an asynchronous write operation.
//
// See gdk.ContentProvider.WriteMIMETypeAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
func (provider *ContentProvider) WriteMIMETypeFinish(result gio.AsyncResulter) error {
	var _arg0 *C.GdkContentProvider // out
	var _arg1 *C.GAsyncResult       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.gdk_content_provider_write_mime_type_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (provider *ContentProvider) attachClipboard(clipboard *Clipboard) {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.attach_clipboard

	var _arg0 *C.GdkContentProvider // out
	var _arg1 *C.GdkClipboard       // out

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C._gotk4_gdk4_ContentProvider_virtual_attach_clipboard(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(clipboard)
}

// contentChanged emits the ::content-changed signal.
func (provider *ContentProvider) contentChanged() {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.content_changed

	var _arg0 *C.GdkContentProvider // out

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C._gotk4_gdk4_ContentProvider_virtual_content_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(provider)
}

func (provider *ContentProvider) detachClipboard(clipboard *Clipboard) {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.detach_clipboard

	var _arg0 *C.GdkContentProvider // out
	var _arg1 *C.GdkClipboard       // out

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C._gotk4_gdk4_ContentProvider_virtual_detach_clipboard(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(clipboard)
}

// Value gets the contents of provider stored in value.
//
// The value will have been initialized to the GType the value should be
// provided in. This given GType does not need to be listed in the formats
// returned by gdk.ContentProvider.RefFormats(). However, if the given GType is
// not supported, this operation can fail and G_IO_ERROR_NOT_SUPPORTED will be
// reported.
//
// The function returns the following values:
//
//   - value: GValue to fill.
func (provider *ContentProvider) value() (coreglib.Value, error) {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.get_value

	var _arg0 *C.GdkContentProvider // out
	var _arg1 C.GValue              // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C._gotk4_gdk4_ContentProvider_virtual_get_value(unsafe.Pointer(fnarg), _arg0, &_arg1, &_cerr)
	runtime.KeepAlive(provider)

	var _value coreglib.Value // out
	var _goerr error          // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// refFormats gets the formats that the provider can provide its current
// contents in.
//
// The function returns the following values:
//
//   - contentFormats formats of the provider.
func (provider *ContentProvider) refFormats() *ContentFormats {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.ref_formats

	var _arg0 *C.GdkContentProvider // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C._gotk4_gdk4_ContentProvider_virtual_ref_formats(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(provider)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// refStorableFormats gets the formats that the provider suggests other
// applications to store the data in.
//
// An example of such an application would be a clipboard manager.
//
// This can be assumed to be a subset of gdk.ContentProvider.RefFormats().
//
// The function returns the following values:
//
//   - contentFormats: storable formats of the provider.
func (provider *ContentProvider) refStorableFormats() *ContentFormats {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.ref_storable_formats

	var _arg0 *C.GdkContentProvider // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C._gotk4_gdk4_ContentProvider_virtual_ref_storable_formats(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(provider)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// writeMIMETypeAsync: asynchronously writes the contents of provider to stream
// in the given mime_type.
//
// When the operation is finished callback will be called. You must then call
// gdk.ContentProvider.WriteMIMETypeFinish() to get the result of the operation.
//
// The given mime type does not need to be listed in the formats returned
// by gdk.ContentProvider.RefFormats(). However, if the given GType is not
// supported, G_IO_ERROR_NOT_SUPPORTED will be reported.
//
// The given stream will not be closed.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object, NULL to ignore.
//   - mimeType: mime type to provide the data in.
//   - stream: GOutputStream to write to.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to call when the request is satisfied.
func (provider *ContentProvider) writeMIMETypeAsync(ctx context.Context, mimeType string, stream gio.OutputStreamer, ioPriority int, callback gio.AsyncReadyCallback) {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.write_mime_type_async

	var _arg0 *C.GdkContentProvider // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 *C.GOutputStream      // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gdk4_ContentProvider_virtual_write_mime_type_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(mimeType)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// writeMIMETypeFinish finishes an asynchronous write operation.
//
// See gdk.ContentProvider.WriteMIMETypeAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
func (provider *ContentProvider) writeMIMETypeFinish(result gio.AsyncResulter) error {
	gclass := (*C.GdkContentProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.write_mime_type_finish

	var _arg0 *C.GdkContentProvider // out
	var _arg1 *C.GAsyncResult       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gdk4_ContentProvider_virtual_write_mime_type_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ContentSerializer: GdkContentSerializer is used to serialize content for
// inter-application data transfers.
//
// The GdkContentSerializer transforms an object that is identified by a GType
// into a serialized form (i.e. a byte stream) that is identified by a mime
// type.
//
// GTK provides serializers and deserializers for common data types such as
// text, colors, images or file lists. To register your own serialization
// functions, use gdk.ContentRegisterSerializer().
//
// Also see gdk.ContentDeserializer.
type ContentSerializer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.AsyncResult
}

var (
	_ coreglib.Objector = (*ContentSerializer)(nil)
)

func wrapContentSerializer(obj *coreglib.Object) *ContentSerializer {
	return &ContentSerializer{
		Object: obj,
		AsyncResult: gio.AsyncResult{
			Object: obj,
		},
	}
}

func marshalContentSerializer(p uintptr) (interface{}, error) {
	return wrapContentSerializer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Cancellable gets the cancellable for the current operation.
//
// This is the GCancellable that was passed to content_serialize_async.
//
// The function returns the following values:
//
//   - cancellable (optional) for the current operation.
func (serializer *ContentSerializer) Cancellable() *gio.Cancellable {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.GCancellable         // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_cancellable(_arg0)
	runtime.KeepAlive(serializer)

	var _cancellable *gio.Cancellable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_cancellable = &gio.Cancellable{
				Object: obj,
			}
		}
	}

	return _cancellable
}

// GType gets the GType to of the object to serialize.
//
// The function returns the following values:
//
//   - gType: GType for the current operation.
func (serializer *ContentSerializer) GType() coreglib.Type {
	var _arg0 *C.GdkContentSerializer // out
	var _cret C.GType                 // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_gtype(_arg0)
	runtime.KeepAlive(serializer)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// MIMEType gets the mime type to serialize to.
//
// The function returns the following values:
//
//   - utf8: mime type for the current operation.
func (serializer *ContentSerializer) MIMEType() string {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.char                 // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_mime_type(_arg0)
	runtime.KeepAlive(serializer)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// OutputStream gets the output stream for the current operation.
//
// This is the stream that was passed to content_serialize_async.
//
// The function returns the following values:
//
//   - outputStream: output stream for the current operation.
func (serializer *ContentSerializer) OutputStream() gio.OutputStreamer {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.GOutputStream        // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_output_stream(_arg0)
	runtime.KeepAlive(serializer)

	var _outputStream gio.OutputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.OutputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.OutputStreamer)
			return ok
		})
		rv, ok := casted.(gio.OutputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.OutputStreamer")
		}
		_outputStream = rv
	}

	return _outputStream
}

// Priority gets the I/O priority for the current operation.
//
// This is the priority that was passed to content_serialize_async.
//
// The function returns the following values:
//
//   - gint: i/O priority for the current operation.
func (serializer *ContentSerializer) Priority() int {
	var _arg0 *C.GdkContentSerializer // out
	var _cret C.int                   // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_priority(_arg0)
	runtime.KeepAlive(serializer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TaskData gets the data that was associated with the current operation.
//
// See gdk.ContentSerializer.SetTaskData().
//
// The function returns the following values:
//
//   - gpointer (optional): task data for serializer.
func (serializer *ContentSerializer) TaskData() unsafe.Pointer {
	var _arg0 *C.GdkContentSerializer // out
	var _cret C.gpointer              // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_task_data(_arg0)
	runtime.KeepAlive(serializer)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// UserData gets the user data that was passed when the serializer was
// registered.
//
// The function returns the following values:
//
//   - gpointer (optional): user data for this serializer.
func (serializer *ContentSerializer) UserData() unsafe.Pointer {
	var _arg0 *C.GdkContentSerializer // out
	var _cret C.gpointer              // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_user_data(_arg0)
	runtime.KeepAlive(serializer)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Value gets the GValue to read the object to serialize from.
//
// The function returns the following values:
//
//   - value: GValue for the current operation.
func (serializer *ContentSerializer) Value() *coreglib.Value {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.GValue               // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	_cret = C.gdk_content_serializer_get_value(_arg0)
	runtime.KeepAlive(serializer)

	var _value *coreglib.Value // out

	_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _value
}

// ReturnError: indicate that the serialization has ended with an error.
//
// This function consumes error.
//
// The function takes the following parameters:
//
//   - err: GError.
func (serializer *ContentSerializer) ReturnError(err error) {
	var _arg0 *C.GdkContentSerializer // out
	var _arg1 *C.GError               // out

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	C.gdk_content_serializer_return_error(_arg0, _arg1)
	runtime.KeepAlive(serializer)
	runtime.KeepAlive(err)
}

// ReturnSuccess: indicate that the serialization has been successfully
// completed.
func (serializer *ContentSerializer) ReturnSuccess() {
	var _arg0 *C.GdkContentSerializer // out

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(coreglib.InternObject(serializer).Native()))

	C.gdk_content_serializer_return_success(_arg0)
	runtime.KeepAlive(serializer)
}

// CrossingEvent: event caused by a pointing device moving between surfaces.
type CrossingEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*CrossingEvent)(nil)
)

func wrapCrossingEvent(obj *coreglib.Object) *CrossingEvent {
	return &CrossingEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalCrossingEvent(p uintptr) (interface{}, error) {
	return wrapCrossingEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Detail extracts the notify detail from a crossing event.
//
// The function returns the following values:
//
//   - notifyType: notify detail of event.
func (event *CrossingEvent) Detail() NotifyType {
	var _arg0 *C.GdkEvent     // out
	var _cret C.GdkNotifyType // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_crossing_event_get_detail(_arg0)
	runtime.KeepAlive(event)

	var _notifyType NotifyType // out

	_notifyType = NotifyType(_cret)

	return _notifyType
}

// Focus checks if the event surface is the focus surface.
//
// The function returns the following values:
//
//   - ok: TRUE if the surface is the focus surface.
func (event *CrossingEvent) Focus() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_crossing_event_get_focus(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Mode extracts the crossing mode from a crossing event.
//
// The function returns the following values:
//
//   - crossingMode: mode of event.
func (event *CrossingEvent) Mode() CrossingMode {
	var _arg0 *C.GdkEvent       // out
	var _cret C.GdkCrossingMode // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_crossing_event_get_mode(_arg0)
	runtime.KeepAlive(event)

	var _crossingMode CrossingMode // out

	_crossingMode = CrossingMode(_cret)

	return _crossingMode
}

// Cursor: GdkCursor is used to create and destroy cursors.
//
// Cursors are immutable objects, so once you created them, there is no way to
// modify them later. You should create a new cursor when you want to change
// something about it.
//
// Cursors by themselves are not very interesting: they must be bound to a
// window for users to see them. This is done with gdk.Surface.SetCursor()
// or gdk.Surface.SetDeviceCursor(). Applications will typically
// use higher-level GTK functions such as gtk_widget_set_cursor()
// (../gtk4/method.Widget.set_cursor.html) instead.
//
// Cursors are not bound to a given gdk.Display, so they can be shared. However,
// the appearance of cursors may vary when used on different platforms.
//
// # Named and texture cursors
//
// There are multiple ways to create cursors. The platform's own cursors can
// be created with gdk.Cursor.NewFromName. That function lists the commonly
// available names that are shared with the CSS specification. Other names
// may be available, depending on the platform in use. On some platforms,
// what images are used for named cursors may be influenced by the cursor theme.
//
// Another option to create a cursor is to use gdk.Cursor.NewFromTexture and
// provide an image to use for the cursor.
//
// To ease work with unsupported cursors, a fallback cursor can be provided.
// If a gdk.Surface cannot use a cursor because of the reasons mentioned above,
// it will try the fallback cursor. Fallback cursors can themselves have
// fallback cursors again, so it is possible to provide a chain of progressively
// easier to support cursors. If none of the provided cursors can be supported,
// the default cursor will be the ultimate fallback.
type Cursor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Cursor)(nil)
)

func wrapCursor(obj *coreglib.Object) *Cursor {
	return &Cursor{
		Object: obj,
	}
}

func marshalCursor(p uintptr) (interface{}, error) {
	return wrapCursor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCursorFromName creates a new cursor by looking up name in the current
// cursor theme.
//
// A recommended set of cursor names that will work across different platforms
// can be found in the CSS specification:
//
// | | | | | | --- | --- | ---- | --- | | "none" | ! (default_cursor.png)
// "default" | ! (help_cursor.png) "help" | ! (pointer_cursor.png) "pointer"
// | | ! (context_menu_cursor.png) "context-menu" | ! (progress_cursor.png)
// "progress" | ! (wait_cursor.png) "wait" | ! (cell_cursor.png) "cell"
// | | ! (crosshair_cursor.png) "crosshair" | ! (text_cursor.png) "text"
// | ! (vertical_text_cursor.png) "vertical-text" | ! (alias_cursor.png)
// "alias" | | ! (copy_cursor.png) "copy" | ! (no_drop_cursor.png) "no-drop"
// | ! (move_cursor.png) "move" | ! (not_allowed_cursor.png) "not-allowed"
// | | ! (grab_cursor.png) "grab" | ! (grabbing_cursor.png) "grabbing"
// | ! (all_scroll_cursor.png) "all-scroll" | ! (col_resize_cursor.png)
// "col-resize" | | ! (row_resize_cursor.png) "row-resize" | !
// (n_resize_cursor.png) "n-resize" | ! (e_resize_cursor.png) "e-resize" | !
// (s_resize_cursor.png) "s-resize" | | ! (w_resize_cursor.png) "w-resize" | !
// (ne_resize_cursor.png) "ne-resize" | ! (nw_resize_cursor.png) "nw-resize" | !
// (sw_resize_cursor.png) "sw-resize" | | ! (se_resize_cursor.png) "se-resize" |
// ! (ew_resize_cursor.png) "ew-resize" | ! (ns_resize_cursor.png) "ns-resize"
// | ! (nesw_resize_cursor.png) "nesw-resize" | | ! (nwse_resize_cursor.png)
// "nwse-resize" | ! (zoom_in_cursor.png) "zoom-in" | ! (zoom_out_cursor.png)
// "zoom-out" | |.
//
// The function takes the following parameters:
//
//   - name of the cursor.
//   - fallback (optional): NULL or the GdkCursor to fall back to when this one
//     cannot be supported.
//
// The function returns the following values:
//
//   - cursor (optional): new GdkCursor, or NULL if there is no cursor with the
//     given name.
func NewCursorFromName(name string, fallback *Cursor) *Cursor {
	var _arg1 *C.char      // out
	var _arg2 *C.GdkCursor // out
	var _cret *C.GdkCursor // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if fallback != nil {
		_arg2 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(fallback).Native()))
	}

	_cret = C.gdk_cursor_new_from_name(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(fallback)

	var _cursor *Cursor // out

	if _cret != nil {
		_cursor = wrapCursor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _cursor
}

// NewCursorFromTexture creates a new cursor from a GdkTexture.
//
// The function takes the following parameters:
//
//   - texture providing the pixel data.
//   - hotspotX: horizontal offset of the “hotspot” of the cursor.
//   - hotspotY: vertical offset of the “hotspot” of the cursor.
//   - fallback (optional): GdkCursor to fall back to when this one cannot be
//     supported.
//
// The function returns the following values:
//
//   - cursor: new GdkCursor.
func NewCursorFromTexture(texture Texturer, hotspotX, hotspotY int, fallback *Cursor) *Cursor {
	var _arg1 *C.GdkTexture // out
	var _arg2 C.int         // out
	var _arg3 C.int         // out
	var _arg4 *C.GdkCursor  // out
	var _cret *C.GdkCursor  // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	_arg2 = C.int(hotspotX)
	_arg3 = C.int(hotspotY)
	if fallback != nil {
		_arg4 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(fallback).Native()))
	}

	_cret = C.gdk_cursor_new_from_texture(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(hotspotX)
	runtime.KeepAlive(hotspotY)
	runtime.KeepAlive(fallback)

	var _cursor *Cursor // out

	_cursor = wrapCursor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cursor
}

// Fallback returns the fallback for this cursor.
//
// The fallback will be used if this cursor is not available on a given
// GdkDisplay. For named cursors, this can happen when using nonstandard names
// or when using an incomplete cursor theme. For textured cursors, this can
// happen when the texture is too large or when the GdkDisplay it is used on
// does not support textured cursors.
//
// The function returns the following values:
//
//   - ret (optional): fallback of the cursor or NULL to use the default cursor
//     as fallback.
func (cursor *Cursor) Fallback() *Cursor {
	var _arg0 *C.GdkCursor // out
	var _cret *C.GdkCursor // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))

	_cret = C.gdk_cursor_get_fallback(_arg0)
	runtime.KeepAlive(cursor)

	var _ret *Cursor // out

	if _cret != nil {
		_ret = wrapCursor(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ret
}

// HotspotX returns the horizontal offset of the hotspot.
//
// The hotspot indicates the pixel that will be directly above the cursor.
//
// Note that named cursors may have a nonzero hotspot, but this function
// will only return the hotspot position for cursors created with
// gdk.Cursor.NewFromTexture.
//
// The function returns the following values:
//
//   - gint: horizontal offset of the hotspot or 0 for named cursors.
func (cursor *Cursor) HotspotX() int {
	var _arg0 *C.GdkCursor // out
	var _cret C.int        // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))

	_cret = C.gdk_cursor_get_hotspot_x(_arg0)
	runtime.KeepAlive(cursor)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// HotspotY returns the vertical offset of the hotspot.
//
// The hotspot indicates the pixel that will be directly above the cursor.
//
// Note that named cursors may have a nonzero hotspot, but this function
// will only return the hotspot position for cursors created with
// gdk.Cursor.NewFromTexture.
//
// The function returns the following values:
//
//   - gint: vertical offset of the hotspot or 0 for named cursors.
func (cursor *Cursor) HotspotY() int {
	var _arg0 *C.GdkCursor // out
	var _cret C.int        // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))

	_cret = C.gdk_cursor_get_hotspot_y(_arg0)
	runtime.KeepAlive(cursor)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Name returns the name of the cursor.
//
// If the cursor is not a named cursor, NULL will be returned.
//
// The function returns the following values:
//
//   - utf8 (optional): name of the cursor or NULL if it is not a named cursor.
func (cursor *Cursor) Name() string {
	var _arg0 *C.GdkCursor // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))

	_cret = C.gdk_cursor_get_name(_arg0)
	runtime.KeepAlive(cursor)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Texture returns the texture for the cursor.
//
// If the cursor is a named cursor, NULL will be returned.
//
// The function returns the following values:
//
//   - texture (optional) for cursor or NULL if it is a named cursor.
func (cursor *Cursor) Texture() Texturer {
	var _arg0 *C.GdkCursor  // out
	var _cret *C.GdkTexture // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))

	_cret = C.gdk_cursor_get_texture(_arg0)
	runtime.KeepAlive(cursor)

	var _texture Texturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Texturer)
				return ok
			})
			rv, ok := casted.(Texturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
			}
			_texture = rv
		}
	}

	return _texture
}

// DNDEvent: event related to drag and drop operations.
type DNDEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*DNDEvent)(nil)
)

func wrapDNDEvent(obj *coreglib.Object) *DNDEvent {
	return &DNDEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalDNDEvent(p uintptr) (interface{}, error) {
	return wrapDNDEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Drop gets the GdkDrop object from a DND event.
//
// The function returns the following values:
//
//   - drop (optional): drop.
func (event *DNDEvent) Drop() Dropper {
	var _arg0 *C.GdkEvent // out
	var _cret *C.GdkDrop  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_dnd_event_get_drop(_arg0)
	runtime.KeepAlive(event)

	var _drop Dropper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Dropper)
				return ok
			})
			rv, ok := casted.(Dropper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Dropper")
			}
			_drop = rv
		}
	}

	return _drop
}

// DeleteEvent: event related to closing a top-level surface.
type DeleteEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*DeleteEvent)(nil)
)

func wrapDeleteEvent(obj *coreglib.Object) *DeleteEvent {
	return &DeleteEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalDeleteEvent(p uintptr) (interface{}, error) {
	return wrapDeleteEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Device: GdkDevice object represents an input device, such as a keyboard,
// a mouse, or a touchpad.
//
// See the gdk.Seat documentation for more information about the various kinds
// of devices, and their relationships.
type Device struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Device)(nil)
)

// Devicer describes types inherited from class Device.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Devicer interface {
	coreglib.Objector
	baseDevice() *Device
}

var _ Devicer = (*Device)(nil)

func wrapDevice(obj *coreglib.Object) *Device {
	return &Device{
		Object: obj,
	}
}

func marshalDevice(p uintptr) (interface{}, error) {
	return wrapDevice(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (device *Device) baseDevice() *Device {
	return device
}

// BaseDevice returns the underlying base object.
func BaseDevice(obj Devicer) *Device {
	return obj.baseDevice()
}

// ConnectChanged is emitted either when the number of either axes or keys
// changes.
//
// On X11 this will normally happen when the physical device routing events
// through the logical device changes (for example, user switches from the USB
// mouse to a tablet); in that case the logical device will change to reflect
// the axes and keys on the new physical device.
func (device *Device) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(device, "changed", false, unsafe.Pointer(C._gotk4_gdk4_Device_ConnectChanged), f)
}

// ConnectToolChanged is emitted on pen/eraser devices whenever tools enter or
// leave proximity.
func (device *Device) ConnectToolChanged(f func(tool *DeviceTool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(device, "tool-changed", false, unsafe.Pointer(C._gotk4_gdk4_Device_ConnectToolChanged), f)
}

// CapsLockState retrieves whether the Caps Lock modifier of the keyboard is
// locked.
//
// This is only relevant for keyboard devices.
//
// The function returns the following values:
//
//   - ok: TRUE if Caps Lock is on for device.
func (device *Device) CapsLockState() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_caps_lock_state(_arg0)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceTool retrieves the current tool for device.
//
// The function returns the following values:
//
//   - deviceTool (optional): GdkDeviceTool.
func (device *Device) DeviceTool() *DeviceTool {
	var _arg0 *C.GdkDevice     // out
	var _cret *C.GdkDeviceTool // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_device_tool(_arg0)
	runtime.KeepAlive(device)

	var _deviceTool *DeviceTool // out

	if _cret != nil {
		_deviceTool = wrapDeviceTool(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _deviceTool
}

// Direction returns the direction of effective layout of the keyboard.
//
// This is only relevant for keyboard devices.
//
// The direction of a layout is the direction of the majority of its symbols.
// See pango.UnicharDirection().
//
// The function returns the following values:
//
//   - direction: PANGO_DIRECTION_LTR or PANGO_DIRECTION_RTL if it can determine
//     the direction. PANGO_DIRECTION_NEUTRAL otherwise.
func (device *Device) Direction() pango.Direction {
	var _arg0 *C.GdkDevice     // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_direction(_arg0)
	runtime.KeepAlive(device)

	var _direction pango.Direction // out

	_direction = pango.Direction(_cret)

	return _direction
}

// Display returns the GdkDisplay to which device pertains.
//
// The function returns the following values:
//
//   - display: GdkDisplay.
func (device *Device) Display() *Display {
	var _arg0 *C.GdkDevice  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_display(_arg0)
	runtime.KeepAlive(device)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// HasCursor determines whether the pointer follows device motion.
//
// This is not meaningful for keyboard devices, which don't have a pointer.
//
// The function returns the following values:
//
//   - ok: TRUE if the pointer follows device motion.
func (device *Device) HasCursor() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_has_cursor(_arg0)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModifierState retrieves the current modifier state of the keyboard.
//
// This is only relevant for keyboard devices.
//
// The function returns the following values:
//
//   - modifierType: current modifier state.
func (device *Device) ModifierState() ModifierType {
	var _arg0 *C.GdkDevice      // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_modifier_state(_arg0)
	runtime.KeepAlive(device)

	var _modifierType ModifierType // out

	_modifierType = ModifierType(_cret)

	return _modifierType
}

// Name: name of the device, suitable for showing in a user interface.
//
// The function returns the following values:
//
//   - utf8: name.
func (device *Device) Name() string {
	var _arg0 *C.GdkDevice // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_name(_arg0)
	runtime.KeepAlive(device)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NumLockState retrieves whether the Num Lock modifier of the keyboard is
// locked.
//
// This is only relevant for keyboard devices.
//
// The function returns the following values:
//
//   - ok: TRUE if Num Lock is on for device.
func (device *Device) NumLockState() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_num_lock_state(_arg0)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NumTouches retrieves the number of touch points associated to device.
//
// The function returns the following values:
//
//   - guint: number of touch points.
func (device *Device) NumTouches() uint {
	var _arg0 *C.GdkDevice // out
	var _cret C.guint      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_num_touches(_arg0)
	runtime.KeepAlive(device)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ProductID returns the product ID of this device.
//
// This ID is retrieved from the device, and does not change. See
// gdk.Device.GetVendorID() for more information.
//
// The function returns the following values:
//
//   - utf8 (optional): product ID.
func (device *Device) ProductID() string {
	var _arg0 *C.GdkDevice // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_product_id(_arg0)
	runtime.KeepAlive(device)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ScrollLockState retrieves whether the Scroll Lock modifier of the keyboard is
// locked.
//
// This is only relevant for keyboard devices.
//
// The function returns the following values:
//
//   - ok: TRUE if Scroll Lock is on for device.
func (device *Device) ScrollLockState() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_scroll_lock_state(_arg0)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Seat returns the GdkSeat the device belongs to.
//
// The function returns the following values:
//
//   - seat: GdkSeat.
func (device *Device) Seat() Seater {
	var _arg0 *C.GdkDevice // out
	var _cret *C.GdkSeat   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_seat(_arg0)
	runtime.KeepAlive(device)

	var _seat Seater // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Seater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Seater)
			return ok
		})
		rv, ok := casted.(Seater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
		}
		_seat = rv
	}

	return _seat
}

// Source determines the type of the device.
//
// The function returns the following values:
//
//   - inputSource: GdkInputSource.
func (device *Device) Source() InputSource {
	var _arg0 *C.GdkDevice     // out
	var _cret C.GdkInputSource // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_source(_arg0)
	runtime.KeepAlive(device)

	var _inputSource InputSource // out

	_inputSource = InputSource(_cret)

	return _inputSource
}

// SurfaceAtPosition obtains the surface underneath device, returning the
// location of the device in win_x and win_y.
//
// Returns NULL if the surface tree under device is not known to GDK (for
// example, belongs to another application).
//
// The function returns the following values:
//
//   - winX (optional): return location for the X coordinate of the device
//     location relative to the surface origin.
//   - winY (optional): return location for the Y coordinate of the device
//     location relative to the surface origin.
//   - surface (optional): GdkSurface under the device position.
func (device *Device) SurfaceAtPosition() (winX, winY float64, surface Surfacer) {
	var _arg0 *C.GdkDevice  // out
	var _arg1 C.double      // in
	var _arg2 C.double      // in
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_surface_at_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(device)

	var _winX float64     // out
	var _winY float64     // out
	var _surface Surfacer // out

	_winX = float64(_arg1)
	_winY = float64(_arg2)
	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Surfacer)
				return ok
			})
			rv, ok := casted.(Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _winX, _winY, _surface
}

// Timestamp returns the timestamp of the last activity for this device.
//
// In practice, this means the timestamp of the last event that was received
// from the OS for this device. (GTK may occasionally produce events for a
// device that are not received from the OS, and will not update the timestamp).
//
// The function returns the following values:
//
//   - guint32: timestamp of the last activity for this device.
func (device *Device) Timestamp() uint32 {
	var _arg0 *C.GdkDevice // out
	var _cret C.guint32    // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_timestamp(_arg0)
	runtime.KeepAlive(device)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// VendorID returns the vendor ID of this device.
//
// This ID is retrieved from the device, and does not change.
//
// This function, together with gdk.Device.GetProductID(), can be used to eg.
// compose GSettings paths to store settings for this device.
//
//	static GSettings *
//	get_device_settings (GdkDevice *device)
//	{
//	  const char *vendor, *product;
//	  GSettings *settings;
//	  GdkDevice *device;
//	  char *path;
//
//	  vendor = gdk_device_get_vendor_id (device);
//	  product = gdk_device_get_product_id (device);
//
//	  path = g_strdup_printf ("/org/example/app/devices/s:s/", vendor, product);
//	  settings = g_settings_new_with_path (DEVICE_SCHEMA, path);
//	  g_free (path);
//
//	  return settings;
//	}.
//
// The function returns the following values:
//
//   - utf8 (optional): vendor ID.
func (device *Device) VendorID() string {
	var _arg0 *C.GdkDevice // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_vendor_id(_arg0)
	runtime.KeepAlive(device)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// HasBidiLayouts determines if layouts for both right-to-left and left-to-right
// languages are in use on the keyboard.
//
// This is only relevant for keyboard devices.
//
// The function returns the following values:
//
//   - ok: TRUE if there are layouts with both directions, FALSE otherwise.
func (device *Device) HasBidiLayouts() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_has_bidi_layouts(_arg0)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceTool: physical tool associated to a GdkDevice.
type DeviceTool struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DeviceTool)(nil)
)

func wrapDeviceTool(obj *coreglib.Object) *DeviceTool {
	return &DeviceTool{
		Object: obj,
	}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	return wrapDeviceTool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Axes gets the axes of the tool.
//
// The function returns the following values:
//
//   - axisFlags axes of tool.
func (tool *DeviceTool) Axes() AxisFlags {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.GdkAxisFlags   // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(coreglib.InternObject(tool).Native()))

	_cret = C.gdk_device_tool_get_axes(_arg0)
	runtime.KeepAlive(tool)

	var _axisFlags AxisFlags // out

	_axisFlags = AxisFlags(_cret)

	return _axisFlags
}

// HardwareID gets the hardware ID of this tool, or 0 if it's not known.
//
// When non-zero, the identifier is unique for the given tool model, meaning
// that two identical tools will share the same hardware_id, but will have
// different serial numbers (see gdk.DeviceTool.GetSerial()).
//
// This is a more concrete (and device specific) method to identify a
// GdkDeviceTool than gdk.DeviceTool.GetToolType(), as a tablet may support
// multiple devices with the same GdkDeviceToolType, but different hardware
// identifiers.
//
// The function returns the following values:
//
//   - guint64: hardware identifier of this tool.
func (tool *DeviceTool) HardwareID() uint64 {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.guint64        // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(coreglib.InternObject(tool).Native()))

	_cret = C.gdk_device_tool_get_hardware_id(_arg0)
	runtime.KeepAlive(tool)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Serial gets the serial number of this tool.
//
// This value can be used to identify a physical tool (eg. a tablet pen) across
// program executions.
//
// The function returns the following values:
//
//   - guint64: serial ID for this tool.
func (tool *DeviceTool) Serial() uint64 {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.guint64        // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(coreglib.InternObject(tool).Native()))

	_cret = C.gdk_device_tool_get_serial(_arg0)
	runtime.KeepAlive(tool)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToolType gets the GdkDeviceToolType of the tool.
//
// The function returns the following values:
//
//   - deviceToolType: physical type for this tool. This can be used to figure
//     out what sort of pen is being used, such as an airbrush or a pencil.
func (tool *DeviceTool) ToolType() DeviceToolType {
	var _arg0 *C.GdkDeviceTool    // out
	var _cret C.GdkDeviceToolType // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(coreglib.InternObject(tool).Native()))

	_cret = C.gdk_device_tool_get_tool_type(_arg0)
	runtime.KeepAlive(tool)

	var _deviceToolType DeviceToolType // out

	_deviceToolType = DeviceToolType(_cret)

	return _deviceToolType
}

// Display: GdkDisplay objects are the GDK representation of a workstation.
//
// Their purpose are two-fold:
//
// - To manage and provide information about input devices (pointers, keyboards,
// etc)
//
// - To manage and provide information about output devices (monitors,
// projectors, etc)
//
// Most of the input device handling has been factored out into separate
// gdk.Seat objects. Every display has a one or more seats, which can be
// accessed with gdk.Display.GetDefaultSeat() and gdk.Display.ListSeats().
//
// Output devices are represented by gdk.Monitor objects, which can be accessed
// with gdk.Display.GetMonitorAtSurface() and similar APIs.
type Display struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Display)(nil)
)

func wrapDisplay(obj *coreglib.Object) *Display {
	return &Display{
		Object: obj,
	}
}

func marshalDisplay(p uintptr) (interface{}, error) {
	return wrapDisplay(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClosed is emitted when the connection to the windowing system for
// display is closed.
func (display *Display) ConnectClosed(f func(isError bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "closed", false, unsafe.Pointer(C._gotk4_gdk4_Display_ConnectClosed), f)
}

// ConnectOpened is emitted when the connection to the windowing system for
// display is opened.
func (display *Display) ConnectOpened(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "opened", false, unsafe.Pointer(C._gotk4_gdk4_Display_ConnectOpened), f)
}

// ConnectSeatAdded is emitted whenever a new seat is made known to the
// windowing system.
func (display *Display) ConnectSeatAdded(f func(seat Seater)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "seat-added", false, unsafe.Pointer(C._gotk4_gdk4_Display_ConnectSeatAdded), f)
}

// ConnectSeatRemoved is emitted whenever a seat is removed by the windowing
// system.
func (display *Display) ConnectSeatRemoved(f func(seat Seater)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "seat-removed", false, unsafe.Pointer(C._gotk4_gdk4_Display_ConnectSeatRemoved), f)
}

// ConnectSettingChanged is emitted whenever a setting changes its value.
func (display *Display) ConnectSettingChanged(f func(setting string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "setting-changed", false, unsafe.Pointer(C._gotk4_gdk4_Display_ConnectSettingChanged), f)
}

// Beep emits a short beep on display.
func (display *Display) Beep() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_beep(_arg0)
	runtime.KeepAlive(display)
}

// Close closes the connection to the windowing system for the given display.
//
// This cleans up associated resources.
func (display *Display) Close() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_close(_arg0)
	runtime.KeepAlive(display)
}

// CreateGLContext creates a new GdkGLContext for the GdkDisplay.
//
// The context is disconnected from any particular surface or surface and cannot
// be used to draw to any surface. It can only be used to draw to non-surface
// framebuffers like textures.
//
// If the creation of the GdkGLContext failed, error will be set. Before using
// the returned GdkGLContext, you will need to call gdk.GLContext.MakeCurrent()
// or gdk.GLContext.Realize().
//
// The function returns the following values:
//
//   - glContext: newly created GdkGLContext.
func (self *Display) CreateGLContext() (GLContexter, error) {
	var _arg0 *C.GdkDisplay   // out
	var _cret *C.GdkGLContext // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_display_create_gl_context(_arg0, &_cerr)
	runtime.KeepAlive(self)

	var _glContext GLContexter // out
	var _goerr error           // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_glContext = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _glContext, _goerr
}

// DeviceIsGrabbed returns TRUE if there is an ongoing grab on device for
// display.
//
// The function takes the following parameters:
//
//   - device: GdkDevice.
//
// The function returns the following values:
//
//   - ok: TRUE if there is a grab in effect for device.
func (display *Display) DeviceIsGrabbed(device Devicer) bool {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.GdkDevice  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_display_device_is_grabbed(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Flush flushes any requests queued for the windowing system.
//
// This happens automatically when the main loop blocks waiting for new events,
// but if your application is drawing without returning control to the main
// loop, you may need to call this function explicitly. A common case where
// this function needs to be called is when an application is executing drawing
// commands from a thread other than the thread where the main loop is running.
//
// This is most useful for X11. On windowing systems where requests are handled
// synchronously, this function will do nothing.
func (display *Display) Flush() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_flush(_arg0)
	runtime.KeepAlive(display)
}

// AppLaunchContext returns a GdkAppLaunchContext suitable for launching
// applications on the given display.
//
// The function returns the following values:
//
//   - appLaunchContext: new GdkAppLaunchContext for display.
func (display *Display) AppLaunchContext() *AppLaunchContext {
	var _arg0 *C.GdkDisplay          // out
	var _cret *C.GdkAppLaunchContext // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_app_launch_context(_arg0)
	runtime.KeepAlive(display)

	var _appLaunchContext *AppLaunchContext // out

	_appLaunchContext = wrapAppLaunchContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appLaunchContext
}

// Clipboard gets the clipboard used for copy/paste operations.
//
// The function returns the following values:
//
//   - clipboard display's clipboard.
func (display *Display) Clipboard() *Clipboard {
	var _arg0 *C.GdkDisplay   // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_clipboard(_arg0)
	runtime.KeepAlive(display)

	var _clipboard *Clipboard // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(_cret)))

	return _clipboard
}

// DefaultSeat returns the default GdkSeat for this display.
//
// Note that a display may not have a seat. In this case, this function will
// return NULL.
//
// The function returns the following values:
//
//   - seat (optional): default seat.
func (display *Display) DefaultSeat() Seater {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GdkSeat    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_default_seat(_arg0)
	runtime.KeepAlive(display)

	var _seat Seater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Seater)
				return ok
			})
			rv, ok := casted.(Seater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
			}
			_seat = rv
		}
	}

	return _seat
}

// DmabufFormats returns the dma-buf formats that are supported on this display.
//
// GTK may use OpenGL or Vulkan to support some formats. Calling this function
// will then initialize them if they aren't yet.
//
// The formats returned by this function can be used for negotiating buffer
// formats with producers such as v4l, pipewire or GStreamer.
//
// To learn more about dma-bufs, see gdk.DmabufTextureBuilder.
//
// The function returns the following values:
//
//   - dmabufFormats: GdkDmabufFormats object.
func (display *Display) DmabufFormats() *DmabufFormats {
	var _arg0 *C.GdkDisplay       // out
	var _cret *C.GdkDmabufFormats // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_dmabuf_formats(_arg0)
	runtime.KeepAlive(display)

	var _dmabufFormats *DmabufFormats // out

	_dmabufFormats = (*DmabufFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gdk_dmabuf_formats_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dmabufFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_dmabuf_formats_unref((*C.GdkDmabufFormats)(intern.C))
		},
	)

	return _dmabufFormats
}

// MonitorAtSurface gets the monitor in which the largest area of surface
// resides.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface.
//
// The function returns the following values:
//
//   - monitor (optional) with the largest overlap with surface.
func (display *Display) MonitorAtSurface(surface Surfacer) *Monitor {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.GdkSurface // out
	var _cret *C.GdkMonitor // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_display_get_monitor_at_surface(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(surface)

	var _monitor *Monitor // out

	if _cret != nil {
		_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _monitor
}

// Monitors gets the list of monitors associated with this display.
//
// Subsequent calls to this function will always return the same list for the
// same display.
//
// You can listen to the GListModel::items-changed signal on this list to
// monitor changes to the monitor of this display.
//
// The function returns the following values:
//
//   - listModel: GListModel of GdkMonitor.
func (self *Display) Monitors() *gio.ListModel {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_display_get_monitors(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// Name gets the name of the display.
//
// The function returns the following values:
//
//   - utf8: string representing the display name. This string is owned by GDK
//     and should not be modified or freed.
func (display *Display) Name() string {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_name(_arg0)
	runtime.KeepAlive(display)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PrimaryClipboard gets the clipboard used for the primary selection.
//
// On backends where the primary clipboard is not supported natively, GDK
// emulates this clipboard locally.
//
// The function returns the following values:
//
//   - clipboard: primary clipboard.
func (display *Display) PrimaryClipboard() *Clipboard {
	var _arg0 *C.GdkDisplay   // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_primary_clipboard(_arg0)
	runtime.KeepAlive(display)

	var _clipboard *Clipboard // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(_cret)))

	return _clipboard
}

// Setting retrieves a desktop-wide setting such as double-click time for the
// display.
//
// The function takes the following parameters:
//
//   - name of the setting.
//   - value: location to store the value of the setting.
//
// The function returns the following values:
//
//   - ok: TRUE if the setting existed and a value was stored in value, FALSE
//     otherwise.
func (display *Display) Setting(name string, value *coreglib.Value) bool {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.char       // out
	var _arg2 *C.GValue     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gdk_display_get_setting(_arg0, _arg1, _arg2)
	runtime.KeepAlive(display)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartupNotificationID gets the startup notification ID for a Wayland display,
// or NULL if no ID has been defined.
//
// Deprecated: since version 4.10.
//
// The function returns the following values:
//
//   - utf8 (optional): startup notification ID for display.
func (display *Display) StartupNotificationID() string {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_startup_notification_id(_arg0)
	runtime.KeepAlive(display)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IsClosed finds out if the display has been closed.
//
// The function returns the following values:
//
//   - ok: TRUE if the display is closed.
func (display *Display) IsClosed() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_is_closed(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsComposited returns whether surfaces can reasonably be expected to have
// their alpha channel drawn correctly on the screen.
//
// Check gdk.Display.IsRGBA() for whether the display supports an alpha channel.
//
// On X11 this function returns whether a compositing manager is compositing on
// display.
//
// On modern displays, this value is always TRUE.
//
// The function returns the following values:
//
//   - ok: whether surfaces with RGBA visuals can reasonably be expected to have
//     their alpha channels drawn correctly on the screen.
func (display *Display) IsComposited() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_is_composited(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRGBA returns whether surfaces on this display are created with an alpha
// channel.
//
// Even if a TRUE is returned, it is possible that the surface’s alpha channel
// won’t be honored when displaying the surface on the screen: in particular,
// for X an appropriate windowing manager and compositing manager must be
// running to provide appropriate display. Use gdk.Display.IsComposited() to
// check if that is the case.
//
// On modern displays, this value is always TRUE.
//
// The function returns the following values:
//
//   - ok: TRUE if surfaces are created with an alpha channel or FALSE if the
//     display does not support this functionality.
func (display *Display) IsRGBA() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_is_rgba(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListSeats returns the list of seats known to display.
//
// The function returns the following values:
//
//   - list: the list of seats known to the GdkDisplay.
func (display *Display) ListSeats() []Seater {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GList      // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_list_seats(_arg0)
	runtime.KeepAlive(display)

	var _list []Seater // out

	_list = make([]Seater, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GdkSeat)(v)
		var dst Seater // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gdk.Seater is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Seater)
				return ok
			})
			rv, ok := casted.(Seater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// MapKeycode returns the keyvals bound to keycode.
//
// The Nth GdkKeymapKey in keys is bound to the Nth keyval in keyvals.
//
// When a keycode is pressed by the user, the keyval from this list of entries
// is selected by considering the effective keyboard group and level.
//
// Free the returned arrays with g_free().
//
// The function takes the following parameters:
//
//   - keycode: keycode.
//
// The function returns the following values:
//
//   - keys (optional): return location for array of GdkKeymapKey.
//   - keyvals (optional): return location for array of keyvals.
//   - ok: TRUE if there were any entries.
func (display *Display) MapKeycode(keycode uint) ([]KeymapKey, []uint, bool) {
	var _arg0 *C.GdkDisplay   // out
	var _arg1 C.guint         // out
	var _arg2 *C.GdkKeymapKey // in
	var _arg4 C.int           // in
	var _arg3 *C.guint        // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.guint(keycode)

	_cret = C.gdk_display_map_keycode(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(display)
	runtime.KeepAlive(keycode)

	var _keys []KeymapKey // out
	var _keyvals []uint   // out
	var _ok bool          // out

	if _arg2 != nil {
		defer C.free(unsafe.Pointer(_arg2))
		{
			src := unsafe.Slice((*C.GdkKeymapKey)(_arg2), _arg4)
			_keys = make([]KeymapKey, _arg4)
			for i := 0; i < int(_arg4); i++ {
				_keys[i] = *(*KeymapKey)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
				runtime.SetFinalizer(
					gextras.StructIntern(unsafe.Pointer(&_keys[i])),
					func(intern *struct{ C unsafe.Pointer }) {
						C.free(intern.C)
					},
				)
			}
		}
	}
	if _arg3 != nil {
		defer C.free(unsafe.Pointer(_arg3))
		{
			src := unsafe.Slice((*C.guint)(_arg3), _arg4)
			_keyvals = make([]uint, _arg4)
			for i := 0; i < int(_arg4); i++ {
				_keyvals[i] = uint(src[i])
			}
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _keys, _keyvals, _ok
}

// MapKeyval obtains a list of keycode/group/level combinations that will
// generate keyval.
//
// Groups and levels are two kinds of keyboard mode; in general, the level
// determines whether the top or bottom symbol on a key is used, and the group
// determines whether the left or right symbol is used.
//
// On US keyboards, the shift key changes the keyboard level, and there are no
// groups. A group switch key might convert a keyboard between Hebrew to English
// modes, for example.
//
// GdkEventKey contains a group field that indicates the active keyboard group.
// The level is computed from the modifier mask.
//
// The returned array should be freed with g_free().
//
// The function takes the following parameters:
//
//   - keyval: keyval, such as GDK_KEY_a, GDK_KEY_Up, GDK_KEY_Return, etc.
//
// The function returns the following values:
//
//   - keys: return location for an array of GdkKeymapKey.
//   - ok: TRUE if keys were found and returned.
func (display *Display) MapKeyval(keyval uint) ([]KeymapKey, bool) {
	var _arg0 *C.GdkDisplay   // out
	var _arg1 C.guint         // out
	var _arg2 *C.GdkKeymapKey // in
	var _arg3 C.int           // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.guint(keyval)

	_cret = C.gdk_display_map_keyval(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(display)
	runtime.KeepAlive(keyval)

	var _keys []KeymapKey // out
	var _ok bool          // out

	defer C.free(unsafe.Pointer(_arg2))
	{
		src := unsafe.Slice((*C.GdkKeymapKey)(_arg2), _arg3)
		_keys = make([]KeymapKey, _arg3)
		for i := 0; i < int(_arg3); i++ {
			_keys[i] = *(*KeymapKey)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(&_keys[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.free(intern.C)
				},
			)
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _keys, _ok
}

// NotifyStartupComplete indicates to the GUI environment that the application
// has finished loading, using a given identifier.
//
// GTK will call this function automatically for GtkWindow
// (../gtk4/class.Window.html) with custom startup-notification
// identifier unless gtk_window_set_auto_startup_notification()
// (../gtk4/method.Window.set_auto_startup_notification.html) is called to
// disable that feature.
//
// Deprecated: Using gdk.Toplevel.SetStartupID() is sufficient.
//
// The function takes the following parameters:
//
//   - startupId: startup-notification identifier, for which notification
//     process should be completed.
func (display *Display) NotifyStartupComplete(startupId string) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_display_notify_startup_complete(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(startupId)
}

// PrepareGL checks that OpenGL is available for self and ensures that it is
// properly initialized. When this fails, an error will be set describing the
// error and this function returns FALSE.
//
// Note that even if this function succeeds, creating a GdkGLContext may still
// fail.
//
// This function is idempotent. Calling it multiple times will just return the
// same value or error.
//
// You never need to call this function, GDK will call it automatically as
// needed. But you can use it as a check when setting up code that might make
// use of OpenGL.
func (self *Display) PrepareGL() error {
	var _arg0 *C.GdkDisplay // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gdk_display_prepare_gl(_arg0, &_cerr)
	runtime.KeepAlive(self)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutEvent adds the given event to the event queue for display.
//
// Deprecated: This function is only useful in very special situations and
// should not be used by applications.
//
// The function takes the following parameters:
//
//   - event: GdkEvent.
func (display *Display) PutEvent(event Eventer) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.GdkEvent   // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	C.gdk_display_put_event(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(event)
}

// SupportsInputShapes returns TRUE if the display supports input shapes.
//
// This means that gdk.Surface.SetInputRegion() can be used to modify the input
// shape of surfaces on display.
//
// On modern displays, this value is always TRUE.
//
// The function returns the following values:
//
//   - ok: TRUE if surfaces with modified input shape are supported.
func (display *Display) SupportsInputShapes() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_supports_input_shapes(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsShadowWidth returns whether it's possible for a surface to draw
// outside of the window area.
//
// If TRUE is returned the application decides if it wants to draw shadows.
// If FALSE is returned, the compositor decides if it wants to draw shadows.
//
// The function returns the following values:
//
//   - ok: TRUE if surfaces can draw shadows or FALSE if the display does not
//     support this functionality.
func (display *Display) SupportsShadowWidth() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_supports_shadow_width(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Sync flushes any requests queued for the windowing system and waits until all
// requests have been handled.
//
// This is often used for making sure that the display is synchronized
// with the current state of the program. Calling gdk.Display.Sync() before
// gdkx11.Display.ErrorTrapPop() makes sure that any errors generated from
// earlier requests are handled before the error trap is removed.
//
// This is most useful for X11. On windowing systems where requests are handled
// synchronously, this function will do nothing.
func (display *Display) Sync() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_sync(_arg0)
	runtime.KeepAlive(display)
}

// TranslateKey translates the contents of a GdkEventKey into a keyval,
// effective group, and level.
//
// Modifiers that affected the translation and are thus unavailable for
// application use are returned in consumed_modifiers.
//
// The effective_group is the group that was actually used for the translation;
// some keys such as Enter are not affected by the active keyboard group.
// The level is derived from state.
//
// consumed_modifiers gives modifiers that should be masked out from state
// when comparing this key press to a keyboard shortcut. For instance, on a
// US keyboard, the plus symbol is shifted, so when comparing a key press to a
// <Control>plus accelerator <Shift> should be masked out.
//
// This function should rarely be needed, since GdkEventKey already contains
// the translated keyval. It is exported for the benefit of virtualized test
// environments.
//
// The function takes the following parameters:
//
//   - keycode: keycode.
//   - state: modifier state.
//   - group: active keyboard group.
//
// The function returns the following values:
//
//   - keyval (optional): return location for keyval.
//   - effectiveGroup (optional): return location for effective group.
//   - level (optional): return location for level.
//   - consumed (optional): return location for modifiers that were used to
//     determine the group or level.
//   - ok: TRUE if there was a keyval bound to keycode/state/group.
func (display *Display) TranslateKey(keycode uint, state ModifierType, group int) (keyval uint, effectiveGroup, level int, consumed ModifierType, ok bool) {
	var _arg0 *C.GdkDisplay     // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _arg3 C.int             // out
	var _arg4 C.guint           // in
	var _arg5 C.int             // in
	var _arg6 C.int             // in
	var _arg7 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.guint(keycode)
	_arg2 = C.GdkModifierType(state)
	_arg3 = C.int(group)

	_cret = C.gdk_display_translate_key(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(display)
	runtime.KeepAlive(keycode)
	runtime.KeepAlive(state)
	runtime.KeepAlive(group)

	var _keyval uint           // out
	var _effectiveGroup int    // out
	var _level int             // out
	var _consumed ModifierType // out
	var _ok bool               // out

	_keyval = uint(_arg4)
	_effectiveGroup = int(_arg5)
	_level = int(_arg6)
	_consumed = ModifierType(_arg7)
	if _cret != 0 {
		_ok = true
	}

	return _keyval, _effectiveGroup, _level, _consumed, _ok
}

// DisplayGetDefault gets the default GdkDisplay.
//
// This is a convenience function for:
//
//	gdk_display_manager_get_default_display (gdk_display_manager_get ()).
//
// The function returns the following values:
//
//   - display (optional): GdkDisplay, or NULL if there is no default display.
func DisplayGetDefault() *Display {
	var _cret *C.GdkDisplay // in

	_cret = C.gdk_display_get_default()

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// DisplayOpen opens a display.
//
// If opening the display fails, NULL is returned.
//
// The function takes the following parameters:
//
//   - displayName (optional): name of the display to open.
//
// The function returns the following values:
//
//   - display (optional): GdkDisplay.
func DisplayOpen(displayName string) *Display {
	var _arg1 *C.char       // out
	var _cret *C.GdkDisplay // in

	if displayName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gdk_display_open(_arg1)
	runtime.KeepAlive(displayName)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// DisplayManager: singleton object that offers notification when displays
// appear or disappear.
//
// You can use gdk.DisplayManager().Get to obtain the GdkDisplayManager
// singleton, but that should be rarely necessary. Typically, initializing
// GTK opens a display that you can work with without ever accessing the
// GdkDisplayManager.
//
// The GDK library can be built with support for multiple backends. The
// GdkDisplayManager object determines which backend is used at runtime.
//
// In the rare case that you need to influence which of the backends is being
// used, you can use gdk.SetAllowedBackends(). Note that you need to call this
// function before initializing GTK.
//
// # Backend-specific code
//
// When writing backend-specific code that is supposed to work with multiple
// GDK backends, you have to consider both compile time and runtime.
// At compile time, use the GDK_WINDOWING_X11, GDK_WINDOWING_WIN32 macros,
// etc. to find out which backends are present in the GDK library you are
// building your application against. At runtime, use type-check macros like
// GDK_IS_X11_DISPLAY() to find out which backend is in use:
//
//	#ifdef GDK_WINDOWING_X11
//	  if (GDK_IS_X11_DISPLAY (display))
//	    {
//	      // make X11-specific calls here
//	    }
//	  else
//	#endif
//	#ifdef GDK_WINDOWING_MACOS
//	  if (GDK_IS_MACOS_DISPLAY (display))
//	    {
//	      // make Quartz-specific calls here
//	    }
//	  else
//	#endif
//	  g_error ("Unsupported GDK backend");.
type DisplayManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DisplayManager)(nil)
)

func wrapDisplayManager(obj *coreglib.Object) *DisplayManager {
	return &DisplayManager{
		Object: obj,
	}
}

func marshalDisplayManager(p uintptr) (interface{}, error) {
	return wrapDisplayManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDisplayOpened is emitted when a display is opened.
func (manager *DisplayManager) ConnectDisplayOpened(f func(display *Display)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "display-opened", false, unsafe.Pointer(C._gotk4_gdk4_DisplayManager_ConnectDisplayOpened), f)
}

// DefaultDisplay gets the default GdkDisplay.
//
// The function returns the following values:
//
//   - display (optional): GdkDisplay.
func (manager *DisplayManager) DefaultDisplay() *Display {
	var _arg0 *C.GdkDisplayManager // out
	var _cret *C.GdkDisplay        // in

	_arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gdk_display_manager_get_default_display(_arg0)
	runtime.KeepAlive(manager)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// ListDisplays: list all currently open displays.
//
// The function returns the following values:
//
//   - sList: newly allocated GSList of GdkDisplay objects.
func (manager *DisplayManager) ListDisplays() []*Display {
	var _arg0 *C.GdkDisplayManager // out
	var _cret *C.GSList            // in

	_arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gdk_display_manager_list_displays(_arg0)
	runtime.KeepAlive(manager)

	var _sList []*Display // out

	_sList = make([]*Display, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GdkDisplay)(v)
		var dst *Display // out
		dst = wrapDisplay(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// OpenDisplay opens a display.
//
// The function takes the following parameters:
//
//   - name (optional) of the display to open.
//
// The function returns the following values:
//
//   - display (optional): GdkDisplay, or NULL if the display could not be
//     opened.
func (manager *DisplayManager) OpenDisplay(name string) *Display {
	var _arg0 *C.GdkDisplayManager // out
	var _arg1 *C.char              // out
	var _cret *C.GdkDisplay        // in

	_arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gdk_display_manager_open_display(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(name)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// SetDefaultDisplay sets display as the default display.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
func (manager *DisplayManager) SetDefaultDisplay(display *Display) {
	var _arg0 *C.GdkDisplayManager // out
	var _arg1 *C.GdkDisplay        // out

	_arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_manager_set_default_display(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(display)
}

// DisplayManagerGet gets the singleton GdkDisplayManager object.
//
// When called for the first time, this function consults the GDK_BACKEND
// environment variable to find out which of the supported GDK backends to use
// (in case GDK has been compiled with multiple backends).
//
// Applications can use set_allowed_backends to limit what backends will be
// used.
//
// The function returns the following values:
//
//   - displayManager: global GdkDisplayManager singleton.
func DisplayManagerGet() *DisplayManager {
	var _cret *C.GdkDisplayManager // in

	_cret = C.gdk_display_manager_get()

	var _displayManager *DisplayManager // out

	_displayManager = wrapDisplayManager(coreglib.Take(unsafe.Pointer(_cret)))

	return _displayManager
}

// DmabufTexture: GdkTexture representing a DMA buffer.
//
// To create a GdkDmabufTexture, use the auxiliary gdk.DmabufTextureBuilder
// object.
//
// Dma-buf textures can only be created on Linux.
type DmabufTexture struct {
	_ [0]func() // equal guard
	Texture
}

var (
	_ Texturer = (*DmabufTexture)(nil)
)

func wrapDmabufTexture(obj *coreglib.Object) *DmabufTexture {
	return &DmabufTexture{
		Texture: Texture{
			Object: obj,
			Paintable: Paintable{
				Object: obj,
			},
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		},
	}
}

func marshalDmabufTexture(p uintptr) (interface{}, error) {
	return wrapDmabufTexture(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DmabufTextureBuilder: GdkDmabufTextureBuilder is a builder used to construct
// gdk.Texture objects from DMA buffers.
//
// DMA buffers are commonly called **_dma-bufs_**.
//
// DMA buffers are a feature of the Linux kernel to enable efficient buffer
// and memory sharing between hardware such as codecs, GPUs, displays, cameras
// and the kernel drivers controlling them. For example, a decoder may want its
// output to be directly shared with the display server for rendering without a
// copy.
//
// Any device driver which participates in DMA buffer sharing, can do so as
// either the exporter or importer of buffers (or both).
//
// The memory that is shared via DMA buffers is usually stored in non-system
// memory (maybe in device's local memory or something else not directly
// accessible by the CPU), and accessing this memory from the CPU may have
// higher-than-usual overhead.
//
// In particular for graphics data, it is not uncommon that data consists
// of multiple separate blocks of memory, for example one block for each of
// the red, green and blue channels. These blocks are called **_planes_**.
// DMA buffers can have up to four planes. Even if the memory is a single block,
// the data can be organized in multiple planes, by specifying offsets from the
// beginning of the data.
//
// DMA buffers are exposed to user-space as file descriptors allowing to pass
// them between processes. If a DMA buffer has multiple planes, there is one
// file descriptor per plane.
//
// The format of the data (for graphics data, essentially its colorspace) is
// described by a 32-bit integer. These format identifiers are defined in the
// header file drm_fourcc.h and commonly referred to as **_fourcc_** values,
// since they are identified by 4 ASCII characters. Additionally, each DMA
// buffer has a **_modifier_**, which is a 64-bit integer that describes
// driver-specific details of the memory layout, such as tiling or compression.
//
// For historical reasons, some producers of dma-bufs don't provide an explicit
// modifier, but instead return DMA_FORMAT_MOD_INVALID to indicate that their
// modifier is **_implicit_**. GTK tries to accommodate this situation by
// accepting DMA_FORMAT_MOD_INVALID as modifier.
//
// The operation of GdkDmabufTextureBuilder is quite simple: Create a
// texture builder, set all the necessary properties, and then call
// gdk.DmabufTextureBuilder.Build() to create the new texture.
//
// The required properties for a dma-buf texture are
//
//   - The width and height in pixels
//
//   - The fourcc code and modifier which identify the format and memory layout
//     of the dma-buf
//
//   - The file descriptor, offset and stride for each of the planes
//
// GdkDmabufTextureBuilder can be used for quick one-shot construction of
// textures as well as kept around and reused to construct multiple textures.
//
// # For further information, see
//
// * The Linux kernel documentation
// (https://docs.kernel.org/driver-api/dma-buf.html)
//
// * The header file drm_fourcc.h
// (https://gitlab.freedesktop.org/mesa/drm/-/blob/main/include/drm/drm_fourcc.h).
type DmabufTextureBuilder struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DmabufTextureBuilder)(nil)
)

func wrapDmabufTextureBuilder(obj *coreglib.Object) *DmabufTextureBuilder {
	return &DmabufTextureBuilder{
		Object: obj,
	}
}

func marshalDmabufTextureBuilder(p uintptr) (interface{}, error) {
	return wrapDmabufTextureBuilder(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDmabufTextureBuilder creates a new texture builder.
//
// The function returns the following values:
//
//   - dmabufTextureBuilder: new GdkTextureBuilder.
func NewDmabufTextureBuilder() *DmabufTextureBuilder {
	var _cret *C.GdkDmabufTextureBuilder // in

	_cret = C.gdk_dmabuf_texture_builder_new()

	var _dmabufTextureBuilder *DmabufTextureBuilder // out

	_dmabufTextureBuilder = wrapDmabufTextureBuilder(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dmabufTextureBuilder
}

// Display returns the display that this texture builder is associated with.
//
// The function returns the following values:
//
//   - display: display.
func (self *DmabufTextureBuilder) Display() *Display {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret *C.GdkDisplay              // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_display(_arg0)
	runtime.KeepAlive(self)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// Fd gets the file descriptor for a plane.
//
// The function takes the following parameters:
//
//   - plane to get the fd for.
//
// The function returns the following values:
//
//   - gint: file descriptor.
func (self *DmabufTextureBuilder) Fd(plane uint) int {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out
	var _cret C.int                      // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(plane)

	_cret = C.gdk_dmabuf_texture_builder_get_fd(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(plane)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Fourcc gets the format previously set via
// gdk_dmabuf_texture_builder_set_fourcc() or 0 if the format wasn't set.
//
// The format is specified as a fourcc code.
//
// The function returns the following values:
//
//   - guint32: format.
func (self *DmabufTextureBuilder) Fourcc() uint32 {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret C.guint32                  // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_fourcc(_arg0)
	runtime.KeepAlive(self)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Height gets the height previously set via
// gdk_dmabuf_texture_builder_set_height() or 0 if the height wasn't set.
//
// The function returns the following values:
//
//   - guint: height.
func (self *DmabufTextureBuilder) Height() uint {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret C.uint                     // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_height(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Modifier gets the modifier value.
//
// The function returns the following values:
//
//   - guint64: modifier.
func (self *DmabufTextureBuilder) Modifier() uint64 {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret C.guint64                  // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_modifier(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// NPlanes gets the number of planes.
//
// The function returns the following values:
//
//   - guint: number of planes.
func (self *DmabufTextureBuilder) NPlanes() uint {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret C.uint                     // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_n_planes(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Offset gets the offset value for a plane.
//
// The function takes the following parameters:
//
//   - plane to get the offset for.
//
// The function returns the following values:
//
//   - guint: offset.
func (self *DmabufTextureBuilder) Offset(plane uint) uint {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out
	var _cret C.uint                     // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(plane)

	_cret = C.gdk_dmabuf_texture_builder_get_offset(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(plane)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Premultiplied: whether the data is premultiplied.
//
// The function returns the following values:
//
//   - ok: whether the data is premultiplied.
func (self *DmabufTextureBuilder) Premultiplied() bool {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_premultiplied(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stride gets the stride value for a plane.
//
// The function takes the following parameters:
//
//   - plane to get the stride for.
//
// The function returns the following values:
//
//   - guint: stride.
func (self *DmabufTextureBuilder) Stride(plane uint) uint {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out
	var _cret C.uint                     // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(plane)

	_cret = C.gdk_dmabuf_texture_builder_get_stride(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(plane)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UpdateRegion gets the region previously set via
// gdk_dmabuf_texture_builder_set_update_region() or NULL if none was set.
//
// The function returns the following values:
//
//   - region (optional): region.
func (self *DmabufTextureBuilder) UpdateRegion() *cairo.Region {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret *C.cairo_region_t          // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_update_region(_arg0)
	runtime.KeepAlive(self)

	var _region *cairo.Region // out

	if _cret != nil {
		{
			_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
			_region = (*cairo.Region)(unsafe.Pointer(_pp))
		}
		C.cairo_region_reference(_cret)
		runtime.SetFinalizer(_region, func(v *cairo.Region) {
			C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
		})
	}

	return _region
}

// UpdateTexture gets the texture previously set via
// gdk_dmabuf_texture_builder_set_update_texture() or NULL if none was set.
//
// The function returns the following values:
//
//   - texture (optional): texture.
func (self *DmabufTextureBuilder) UpdateTexture() Texturer {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret *C.GdkTexture              // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_update_texture(_arg0)
	runtime.KeepAlive(self)

	var _texture Texturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Texturer)
				return ok
			})
			rv, ok := casted.(Texturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
			}
			_texture = rv
		}
	}

	return _texture
}

// Width gets the width previously set via
// gdk_dmabuf_texture_builder_set_width() or 0 if the width wasn't set.
//
// The function returns the following values:
//
//   - guint: width.
func (self *DmabufTextureBuilder) Width() uint {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _cret C.uint                     // in

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_dmabuf_texture_builder_get_width(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetDisplay sets the display that this texture builder is associated with.
//
// The display is used to determine the supported dma-buf formats.
//
// The function takes the following parameters:
//
//   - display: display.
func (self *DmabufTextureBuilder) SetDisplay(display *Display) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 *C.GdkDisplay              // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_dmabuf_texture_builder_set_display(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(display)
}

// SetFd sets the file descriptor for a plane.
//
// The function takes the following parameters:
//
//   - plane to set the fd for.
//   - fd: file descriptor.
func (self *DmabufTextureBuilder) SetFd(plane uint, fd int) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out
	var _arg2 C.int                      // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(plane)
	_arg2 = C.int(fd)

	C.gdk_dmabuf_texture_builder_set_fd(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(plane)
	runtime.KeepAlive(fd)
}

// SetFourcc sets the format of the texture.
//
// The format is specified as a fourcc code.
//
// The format must be set before calling gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - fourcc texture's format or 0 to unset.
func (self *DmabufTextureBuilder) SetFourcc(fourcc uint32) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.guint32                  // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint32(fourcc)

	C.gdk_dmabuf_texture_builder_set_fourcc(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(fourcc)
}

// SetHeight sets the height of the texture.
//
// The height must be set before calling gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - height texture's height or 0 to unset.
func (self *DmabufTextureBuilder) SetHeight(height uint) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(height)

	C.gdk_dmabuf_texture_builder_set_height(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(height)
}

// SetModifier sets the modifier.
//
// The function takes the following parameters:
//
//   - modifier value.
func (self *DmabufTextureBuilder) SetModifier(modifier uint64) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.guint64                  // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint64(modifier)

	C.gdk_dmabuf_texture_builder_set_modifier(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(modifier)
}

// SetNPlanes sets the number of planes of the texture.
//
// The function takes the following parameters:
//
//   - nPlanes: number of planes.
func (self *DmabufTextureBuilder) SetNPlanes(nPlanes uint) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(nPlanes)

	C.gdk_dmabuf_texture_builder_set_n_planes(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(nPlanes)
}

// SetOffset sets the offset for a plane.
//
// The function takes the following parameters:
//
//   - plane to set the offset for.
//   - offset value.
func (self *DmabufTextureBuilder) SetOffset(plane, offset uint) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out
	var _arg2 C.uint                     // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(plane)
	_arg2 = C.uint(offset)

	C.gdk_dmabuf_texture_builder_set_offset(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(plane)
	runtime.KeepAlive(offset)
}

// SetPremultiplied sets whether the data is premultiplied.
//
// Unless otherwise specified, all formats including alpha channels are assumed
// to be premultiplied.
//
// The function takes the following parameters:
//
//   - premultiplied: whether the data is premultiplied.
func (self *DmabufTextureBuilder) SetPremultiplied(premultiplied bool) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.gboolean                 // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if premultiplied {
		_arg1 = C.TRUE
	}

	C.gdk_dmabuf_texture_builder_set_premultiplied(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(premultiplied)
}

// SetStride sets the stride for a plane.
//
// The stride must be set for all planes before calling
// gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - plane to set the stride for.
//   - stride value.
func (self *DmabufTextureBuilder) SetStride(plane, stride uint) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out
	var _arg2 C.uint                     // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(plane)
	_arg2 = C.uint(stride)

	C.gdk_dmabuf_texture_builder_set_stride(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(plane)
	runtime.KeepAlive(stride)
}

// SetUpdateRegion sets the region to be updated by this texture. Together
// with gdk.DmabufTextureBuilder:update-texture this describes an update of a
// previous texture.
//
// When rendering animations of large textures, it is possible that consecutive
// textures are only updating contents in parts of the texture. It is then
// possible to describe this update via these two properties, so that GTK can
// avoid rerendering parts that did not change.
//
// An example would be a screen recording where only the mouse pointer moves.
//
// The function takes the following parameters:
//
//   - region (optional) to update.
func (self *DmabufTextureBuilder) SetUpdateRegion(region *cairo.Region) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 *C.cairo_region_t          // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if region != nil {
		_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gdk_dmabuf_texture_builder_set_update_region(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(region)
}

// SetUpdateTexture sets the texture to be updated by this texture. See
// gdk.DmabufTextureBuilder.SetUpdateRegion() for an explanation.
//
// The function takes the following parameters:
//
//   - texture (optional) to update.
func (self *DmabufTextureBuilder) SetUpdateTexture(texture Texturer) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 *C.GdkTexture              // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if texture != nil {
		_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	}

	C.gdk_dmabuf_texture_builder_set_update_texture(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(texture)
}

// SetWidth sets the width of the texture.
//
// The width must be set before calling gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - width texture's width or 0 to unset.
func (self *DmabufTextureBuilder) SetWidth(width uint) {
	var _arg0 *C.GdkDmabufTextureBuilder // out
	var _arg1 C.uint                     // out

	_arg0 = (*C.GdkDmabufTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.uint(width)

	C.gdk_dmabuf_texture_builder_set_width(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(width)
}

// Drag: GdkDrag object represents the source of an ongoing DND operation.
//
// A GdkDrag is created when a drag is started, and stays alive for duration
// of the DND operation. After a drag has been started with gdk.Drag().Begin,
// the caller gets informed about the status of the ongoing drag operation with
// signals on the GdkDrag object.
//
// GTK provides a higher level abstraction based on top of these functions,
// and so they are not normally needed in GTK applications. See the "Drag and
// Drop" section of the GTK documentation for more information.
type Drag struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Drag)(nil)
)

// Dragger describes types inherited from class Drag.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Dragger interface {
	coreglib.Objector
	baseDrag() *Drag
}

var _ Dragger = (*Drag)(nil)

func wrapDrag(obj *coreglib.Object) *Drag {
	return &Drag{
		Object: obj,
	}
}

func marshalDrag(p uintptr) (interface{}, error) {
	return wrapDrag(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (drag *Drag) baseDrag() *Drag {
	return drag
}

// BaseDrag returns the underlying base object.
func BaseDrag(obj Dragger) *Drag {
	return obj.baseDrag()
}

// ConnectCancel is emitted when the drag operation is cancelled.
func (drag *Drag) ConnectCancel(f func(reason DragCancelReason)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(drag, "cancel", false, unsafe.Pointer(C._gotk4_gdk4_Drag_ConnectCancel), f)
}

// ConnectDNDFinished is emitted when the destination side has finished reading
// all data.
//
// The drag object can now free all miscellaneous data.
func (drag *Drag) ConnectDNDFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(drag, "dnd-finished", false, unsafe.Pointer(C._gotk4_gdk4_Drag_ConnectDNDFinished), f)
}

// ConnectDropPerformed is emitted when the drop operation is performed on an
// accepting client.
func (drag *Drag) ConnectDropPerformed(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(drag, "drop-performed", false, unsafe.Pointer(C._gotk4_gdk4_Drag_ConnectDropPerformed), f)
}

// DropDone informs GDK that the drop ended.
//
// Passing FALSE for success may trigger a drag cancellation animation.
//
// This function is called by the drag source, and should be the last call
// before dropping the reference to the drag.
//
// The GdkDrag will only take the first gdk.Drag.DropDone() call as effective,
// if this function is called multiple times, all subsequent calls will be
// ignored.
//
// The function takes the following parameters:
//
//   - success: whether the drag was ultimatively successful.
func (drag *Drag) DropDone(success bool) {
	var _arg0 *C.GdkDrag // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))
	if success {
		_arg1 = C.TRUE
	}

	C.gdk_drag_drop_done(_arg0, _arg1)
	runtime.KeepAlive(drag)
	runtime.KeepAlive(success)
}

// Actions determines the bitmask of possible actions proposed by the source.
//
// The function returns the following values:
//
//   - dragAction: GdkDragAction flags.
func (drag *Drag) Actions() DragAction {
	var _arg0 *C.GdkDrag      // out
	var _cret C.GdkDragAction // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_actions(_arg0)
	runtime.KeepAlive(drag)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

// Content returns the GdkContentProvider associated to the GdkDrag object.
//
// The function returns the following values:
//
//   - contentProvider: GdkContentProvider associated to drag.
func (drag *Drag) Content() *ContentProvider {
	var _arg0 *C.GdkDrag            // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_content(_arg0)
	runtime.KeepAlive(drag)

	var _contentProvider *ContentProvider // out

	_contentProvider = wrapContentProvider(coreglib.Take(unsafe.Pointer(_cret)))

	return _contentProvider
}

// Device returns the GdkDevice associated to the GdkDrag object.
//
// The function returns the following values:
//
//   - device: GdkDevice associated to drag.
func (drag *Drag) Device() Devicer {
	var _arg0 *C.GdkDrag   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_device(_arg0)
	runtime.KeepAlive(drag)

	var _device Devicer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		_device = rv
	}

	return _device
}

// Display gets the GdkDisplay that the drag object was created for.
//
// The function returns the following values:
//
//   - display: GdkDisplay.
func (drag *Drag) Display() *Display {
	var _arg0 *C.GdkDrag    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_display(_arg0)
	runtime.KeepAlive(drag)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// DragSurface returns the surface on which the drag icon should be rendered
// during the drag operation.
//
// Note that the surface may not be available until the drag operation has
// begun. GDK will move the surface in accordance with the ongoing drag
// operation. The surface is owned by drag and will be destroyed when the drag
// operation is over.
//
// The function returns the following values:
//
//   - surface (optional): drag surface.
func (drag *Drag) DragSurface() Surfacer {
	var _arg0 *C.GdkDrag    // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_drag_surface(_arg0)
	runtime.KeepAlive(drag)

	var _surface Surfacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Surfacer)
				return ok
			})
			rv, ok := casted.(Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _surface
}

// Formats retrieves the formats supported by this GdkDrag object.
//
// The function returns the following values:
//
//   - contentFormats: GdkContentFormats.
func (drag *Drag) Formats() *ContentFormats {
	var _arg0 *C.GdkDrag           // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_formats(_arg0)
	runtime.KeepAlive(drag)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gdk_content_formats_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// SelectedAction determines the action chosen by the drag destination.
//
// The function returns the following values:
//
//   - dragAction: GdkDragAction value.
func (drag *Drag) SelectedAction() DragAction {
	var _arg0 *C.GdkDrag      // out
	var _cret C.GdkDragAction // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_selected_action(_arg0)
	runtime.KeepAlive(drag)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

// Surface returns the GdkSurface where the drag originates.
//
// The function returns the following values:
//
//   - surface: GdkSurface where the drag originates.
func (drag *Drag) Surface() Surfacer {
	var _arg0 *C.GdkDrag    // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gdk_drag_get_surface(_arg0)
	runtime.KeepAlive(drag)

	var _surface Surfacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Surfacer)
			return ok
		})
		rv, ok := casted.(Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	return _surface
}

// SetHotspot sets the position of the drag surface that will be kept under the
// cursor hotspot.
//
// Initially, the hotspot is at the top left corner of the drag surface.
//
// The function takes the following parameters:
//
//   - hotX: x coordinate of the drag surface hotspot.
//   - hotY: y coordinate of the drag surface hotspot.
func (drag *Drag) SetHotspot(hotX, hotY int) {
	var _arg0 *C.GdkDrag // out
	var _arg1 C.int      // out
	var _arg2 C.int      // out

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))
	_arg1 = C.int(hotX)
	_arg2 = C.int(hotY)

	C.gdk_drag_set_hotspot(_arg0, _arg1, _arg2)
	runtime.KeepAlive(drag)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DragBegin starts a drag and creates a new drag context for it.
//
// This function is called by the drag source. After this call,
// you probably want to set up the drag icon using the surface returned by
// gdk.Drag.GetDragSurface().
//
// This function returns a reference to the gdk.Drag object, but GTK keeps its
// own reference as well, as long as the DND operation is going on.
//
// Note: if actions include GDK_ACTION_MOVE, you need to listen for the
// gdk.Drag::dnd-finished signal and delete the data at the source if
// gdk.Drag.GetSelectedAction() returns GDK_ACTION_MOVE.
//
// The function takes the following parameters:
//
//   - surface: source surface for this drag.
//   - device that controls this drag.
//   - content: offered content.
//   - actions supported by this drag.
//   - dx: x offset to device's position where the drag nominally started.
//   - dy: y offset to device's position where the drag nominally started.
//
// The function returns the following values:
//
//   - drag (optional): newly created GdkDrag.
func DragBegin(surface Surfacer, device Devicer, content *ContentProvider, actions DragAction, dx, dy float64) Dragger {
	var _arg1 *C.GdkSurface         // out
	var _arg2 *C.GdkDevice          // out
	var _arg3 *C.GdkContentProvider // out
	var _arg4 C.GdkDragAction       // out
	var _arg5 C.double              // out
	var _arg6 C.double              // out
	var _cret *C.GdkDrag            // in

	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg2 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg3 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(content).Native()))
	_arg4 = C.GdkDragAction(actions)
	_arg5 = C.double(dx)
	_arg6 = C.double(dy)

	_cret = C.gdk_drag_begin(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(device)
	runtime.KeepAlive(content)
	runtime.KeepAlive(actions)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)

	var _drag Dragger // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Dragger)
				return ok
			})
			rv, ok := casted.(Dragger)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Dragger")
			}
			_drag = rv
		}
	}

	return _drag
}

// DrawContext: base class for objects implementing different rendering methods.
//
// GdkDrawContext is the base object used by contexts implementing different
// rendering methods, such as gdk.CairoContext or gdk.GLContext. It provides
// shared functionality between those contexts.
//
// You will always interact with one of those subclasses.
//
// A GdkDrawContext is always associated with a single toplevel surface.
type DrawContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DrawContext)(nil)
)

// DrawContexter describes types inherited from class DrawContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type DrawContexter interface {
	coreglib.Objector
	baseDrawContext() *DrawContext
}

var _ DrawContexter = (*DrawContext)(nil)

func wrapDrawContext(obj *coreglib.Object) *DrawContext {
	return &DrawContext{
		Object: obj,
	}
}

func marshalDrawContext(p uintptr) (interface{}, error) {
	return wrapDrawContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (context *DrawContext) baseDrawContext() *DrawContext {
	return context
}

// BaseDrawContext returns the underlying base object.
func BaseDrawContext(obj DrawContexter) *DrawContext {
	return obj.baseDrawContext()
}

// BeginFrame indicates that you are beginning the process of redrawing region
// on the context's surface.
//
// Calling this function begins a drawing operation using context on the surface
// that context was created from. The actual requirements and guarantees
// for the drawing operation vary for different implementations of drawing,
// so a gdk.CairoContext and a gdk.GLContext need to be treated differently.
//
// A call to this function is a requirement for drawing and must be followed
// by a call to gdk.DrawContext.EndFrame(), which will complete the drawing
// operation and ensure the contents become visible on screen.
//
// Note that the region passed to this function is the minimum region that needs
// to be drawn and depending on implementation, windowing system and hardware in
// use, it might be necessary to draw a larger region. Drawing implementation
// must use gdk.DrawContext.GetFrameRegion() to query the region that must be
// drawn.
//
// When using GTK, the widget system automatically places calls to
// gdk_draw_context_begin_frame() and gdk_draw_context_end_frame() via the use
// of GskRenderer (../gsk4/class.Renderer.html)s, so application code does not
// need to call these functions explicitly.
//
// The function takes the following parameters:
//
//   - region: minimum region that should be drawn.
func (context *DrawContext) BeginFrame(region *cairo.Region) {
	var _arg0 *C.GdkDrawContext // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_draw_context_begin_frame(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(region)
}

// EndFrame ends a drawing operation started with
// gdk_draw_context_begin_frame().
//
// This makes the drawing available on screen. See gdk.DrawContext.BeginFrame()
// for more details about drawing.
//
// When using a gdk.GLContext, this function may call glFlush() implicitly
// before returning; it is not recommended to call glFlush() explicitly before
// calling this function.
func (context *DrawContext) EndFrame() {
	var _arg0 *C.GdkDrawContext // out

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gdk_draw_context_end_frame(_arg0)
	runtime.KeepAlive(context)
}

// Display retrieves the GdkDisplay the context is created for.
//
// The function returns the following values:
//
//   - display (optional): GdkDisplay.
func (context *DrawContext) Display() *Display {
	var _arg0 *C.GdkDrawContext // out
	var _cret *C.GdkDisplay     // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_draw_context_get_display(_arg0)
	runtime.KeepAlive(context)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// FrameRegion retrieves the region that is currently being repainted.
//
// After a call to gdk.DrawContext.BeginFrame() this function will return a
// union of the region passed to that function and the area of the surface that
// the context determined needs to be repainted.
//
// If context is not in between calls to gdk.DrawContext.BeginFrame() and
// gdk.DrawContext.EndFrame(), NULL will be returned.
//
// The function returns the following values:
//
//   - region (optional): cairo region.
func (context *DrawContext) FrameRegion() *cairo.Region {
	var _arg0 *C.GdkDrawContext // out
	var _cret *C.cairo_region_t // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_draw_context_get_frame_region(_arg0)
	runtime.KeepAlive(context)

	var _region *cairo.Region // out

	if _cret != nil {
		{
			_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
			_region = (*cairo.Region)(unsafe.Pointer(_pp))
		}
		C.cairo_region_reference(_cret)
		runtime.SetFinalizer(_region, func(v *cairo.Region) {
			C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
		})
	}

	return _region
}

// Surface retrieves the surface that context is bound to.
//
// The function returns the following values:
//
//   - surface (optional): GdkSurface.
func (context *DrawContext) Surface() Surfacer {
	var _arg0 *C.GdkDrawContext // out
	var _cret *C.GdkSurface     // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_draw_context_get_surface(_arg0)
	runtime.KeepAlive(context)

	var _surface Surfacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Surfacer)
				return ok
			})
			rv, ok := casted.(Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _surface
}

// IsInFrame returns TRUE if context is in the process of drawing to its
// surface.
//
// This is the case between calls to gdk.DrawContext.BeginFrame() and
// gdk.DrawContext.EndFrame(). In this situation, drawing commands may be
// effecting the contents of the context's surface.
//
// The function returns the following values:
//
//   - ok: TRUE if the context is between gdk.DrawContext.BeginFrame() and
//     gdk.DrawContext.EndFrame() calls.
func (context *DrawContext) IsInFrame() bool {
	var _arg0 *C.GdkDrawContext // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_draw_context_is_in_frame(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Drop: GdkDrop object represents the target of an ongoing DND operation.
//
// Possible drop sites get informed about the status of the ongoing drag
// operation with events of type GDK_DRAG_ENTER, GDK_DRAG_LEAVE, GDK_DRAG_MOTION
// and GDK_DROP_START. The GdkDrop object can be obtained from these gdk.Event
// types using gdk.DNDEvent.GetDrop().
//
// The actual data transfer is initiated from the target side via an async read,
// using one of the GdkDrop methods for this purpose: gdk.Drop.ReadAsync() or
// gdk.Drop.ReadValueAsync().
//
// GTK provides a higher level abstraction based on top of these functions,
// and so they are not normally needed in GTK applications. See the "Drag and
// Drop" section of the GTK documentation for more information.
type Drop struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Drop)(nil)
)

// Dropper describes types inherited from class Drop.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Dropper interface {
	coreglib.Objector
	baseDrop() *Drop
}

var _ Dropper = (*Drop)(nil)

func wrapDrop(obj *coreglib.Object) *Drop {
	return &Drop{
		Object: obj,
	}
}

func marshalDrop(p uintptr) (interface{}, error) {
	return wrapDrop(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *Drop) baseDrop() *Drop {
	return self
}

// BaseDrop returns the underlying base object.
func BaseDrop(obj Dropper) *Drop {
	return obj.baseDrop()
}

// Finish ends the drag operation after a drop.
//
// The action must be a single action selected from the actions available via
// gdk.Drop.GetActions().
//
// The function takes the following parameters:
//
//   - action performed by the destination or 0 if the drop failed.
func (self *Drop) Finish(action DragAction) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 C.GdkDragAction // out

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GdkDragAction(action)

	C.gdk_drop_finish(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(action)
}

// Actions returns the possible actions for this GdkDrop.
//
// If this value contains multiple actions - i.e. gdk.DragAction().IsUnique
// returns FALSE for the result - gdk.Drop.Finish() must choose the action
// to use when accepting the drop. This will only happen if you passed
// GDK_ACTION_ASK as one of the possible actions in gdk.Drop.Status().
// GDK_ACTION_ASK itself will not be included in the actions returned by this
// function.
//
// This value may change over the lifetime of the gdk.Drop both as a response
// to source side actions as well as to calls to gdk.Drop.Status() or
// gdk.Drop.Finish(). The source side will not change this value anymore once a
// drop has started.
//
// The function returns the following values:
//
//   - dragAction: possible GdkDragActions.
func (self *Drop) Actions() DragAction {
	var _arg0 *C.GdkDrop      // out
	var _cret C.GdkDragAction // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_drop_get_actions(_arg0)
	runtime.KeepAlive(self)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

// Device returns the GdkDevice performing the drop.
//
// The function returns the following values:
//
//   - device: GdkDevice performing the drop.
func (self *Drop) Device() Devicer {
	var _arg0 *C.GdkDrop   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_drop_get_device(_arg0)
	runtime.KeepAlive(self)

	var _device Devicer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		_device = rv
	}

	return _device
}

// Display gets the GdkDisplay that self was created for.
//
// The function returns the following values:
//
//   - display: GdkDisplay.
func (self *Drop) Display() *Display {
	var _arg0 *C.GdkDrop    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_drop_get_display(_arg0)
	runtime.KeepAlive(self)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// Drag: if this is an in-app drag-and-drop operation, returns the GdkDrag that
// corresponds to this drop.
//
// If it is not, NULL is returned.
//
// The function returns the following values:
//
//   - drag (optional): corresponding GdkDrag.
func (self *Drop) Drag() Dragger {
	var _arg0 *C.GdkDrop // out
	var _cret *C.GdkDrag // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_drop_get_drag(_arg0)
	runtime.KeepAlive(self)

	var _drag Dragger // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Dragger)
				return ok
			})
			rv, ok := casted.(Dragger)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Dragger")
			}
			_drag = rv
		}
	}

	return _drag
}

// Formats returns the GdkContentFormats that the drop offers the data to be
// read in.
//
// The function returns the following values:
//
//   - contentFormats: possible GdkContentFormats.
func (self *Drop) Formats() *ContentFormats {
	var _arg0 *C.GdkDrop           // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_drop_get_formats(_arg0)
	runtime.KeepAlive(self)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gdk_content_formats_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// Surface returns the GdkSurface performing the drop.
//
// The function returns the following values:
//
//   - surface: GdkSurface performing the drop.
func (self *Drop) Surface() Surfacer {
	var _arg0 *C.GdkDrop    // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_drop_get_surface(_arg0)
	runtime.KeepAlive(self)

	var _surface Surfacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Surfacer)
			return ok
		})
		rv, ok := casted.(Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	return _surface
}

// ReadAsync: asynchronously read the dropped data from a GdkDrop in a format
// that complies with one of the mime types.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object.
//   - mimeTypes: pointer to an array of mime types.
//   - ioPriority: i/O priority for the read operation.
//   - callback (optional): GAsyncReadyCallback to call when the request is
//     satisfied.
func (self *Drop) ReadAsync(ctx context.Context, mimeTypes []string, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkDrop            // out
	var _arg3 *C.GCancellable       // out
	var _arg1 **C.char              // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(mimeTypes) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(mimeTypes)+1)
			var zero *C.char
			out[len(mimeTypes)] = zero
			for i := range mimeTypes {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(mimeTypes[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_drop_read_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(mimeTypes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadFinish finishes an async drop read operation.
//
// Note that you must not use blocking read calls on the returned stream
// in the GTK thread, since some platforms might require communication
// with GTK to complete the data transfer. You can use async APIs such as
// g_input_stream_read_bytes_async().
//
// See gdk.Drop.ReadAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
//
// The function returns the following values:
//
//   - outMimeType: return location for the used mime type.
//   - inputStream (optional): GInputStream.
func (self *Drop) ReadFinish(result gio.AsyncResulter) (string, gio.InputStreamer, error) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.gdk_drop_read_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _outMimeType string            // out
	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	_outMimeType = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.InputStreamer)
				return ok
			})
			rv, ok := casted.(gio.InputStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
			}
			_inputStream = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outMimeType, _inputStream, _goerr
}

// ReadValueAsync: asynchronously request the drag operation's contents
// converted to the given type.
//
// When the operation is finished callback will be called. You must then call
// gdk.Drop.ReadValueFinish() to get the resulting GValue.
//
// For local drag-and-drop operations that are available in the given GType,
// the value will be copied directly. Otherwise, GDK will try to use
// gdk.ContentDeserializeAsync() to convert the data.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional GCancellable object, NULL to ignore.
//   - typ: GType to read.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to call when the request is satisfied.
func (self *Drop) ReadValueAsync(ctx context.Context, typ coreglib.Type, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkDrop            // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GType               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GType(typ)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_drop_read_value_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadValueFinish finishes an async drop read.
//
// See gdk.Drop.ReadValueAsync().
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
//
// The function returns the following values:
//
//   - value: GValue containing the result.
func (self *Drop) ReadValueFinish(result gio.AsyncResulter) (*coreglib.Value, error) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GValue       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.gdk_drop_read_value_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _value *coreglib.Value // out
	var _goerr error           // out

	_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// Status selects all actions that are potentially supported by the destination.
//
// When calling this function, do not restrict the passed in actions to the ones
// provided by gdk.Drop.GetActions(). Those actions may change in the future,
// even depending on the actions you provide here.
//
// The preferred action is a hint to the drag-and-drop mechanism about which
// action to use when multiple actions are possible.
//
// This function should be called by drag destinations in response to
// GDK_DRAG_ENTER or GDK_DRAG_MOTION events. If the destination does not yet
// know the exact actions it supports, it should set any possible actions first
// and then later call this function again.
//
// The function takes the following parameters:
//
//   - actions: supported actions of the destination, or 0 to indicate that a
//     drop will not be accepted.
//   - preferred: unique action that's a member of actions indicating the
//     preferred action.
func (self *Drop) Status(actions, preferred DragAction) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 C.GdkDragAction // out
	var _arg2 C.GdkDragAction // out

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GdkDragAction(actions)
	_arg2 = C.GdkDragAction(preferred)

	C.gdk_drop_status(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(actions)
	runtime.KeepAlive(preferred)
}

// Event GdkEvents are immutable data structures, created by GDK to represent
// windowing system events.
//
// In GTK applications the events are handled automatically by toplevel widgets
// and passed on to the event controllers of appropriate widgets, so using
// GdkEvent and its related API is rarely needed.
type Event struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Event)(nil)
)

// Eventer describes types inherited from class Event.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Eventer interface {
	coreglib.Objector
	baseEvent() *Event
}

var _ Eventer = (*Event)(nil)

func wrapEvent(obj *coreglib.Object) *Event {
	return &Event{
		Object: obj,
	}
}

func marshalEvent(p uintptr) (interface{}, error) {
	return wrapEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (event *Event) baseEvent() *Event {
	return event
}

// BaseEvent returns the underlying base object.
func BaseEvent(obj Eventer) *Event {
	return obj.baseEvent()
}

// Axes extracts all axis values from an event.
//
// To find out which axes are used, use gdk.DeviceTool.GetAxes() on the device
// tool returned by gdk.Event.GetDeviceTool().
//
// The function returns the following values:
//
//   - axes: array of values for all axes.
//   - ok: TRUE on success, otherwise FALSE.
func (event *Event) Axes() ([]float64, bool) {
	var _arg0 *C.GdkEvent // out
	var _arg1 *C.double   // in
	var _arg2 C.guint     // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_axes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _axes []float64 // out
	var _ok bool        // out

	_axes = make([]float64, _arg2)
	copy(_axes, unsafe.Slice((*float64)(unsafe.Pointer(_arg1)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _axes, _ok
}

// Axis: extract the axis value for a particular axis use from an event
// structure.
//
// To find out which axes are used, use gdk.DeviceTool.GetAxes() on the device
// tool returned by gdk.Event.GetDeviceTool().
//
// The function takes the following parameters:
//
//   - axisUse axis use to look for.
//
// The function returns the following values:
//
//   - value: location to store the value found.
//   - ok: TRUE if the specified axis was found, otherwise FALSE.
func (event *Event) Axis(axisUse AxisUse) (float64, bool) {
	var _arg0 *C.GdkEvent  // out
	var _arg1 C.GdkAxisUse // out
	var _arg2 C.double     // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	_arg1 = C.GdkAxisUse(axisUse)

	_cret = C.gdk_event_get_axis(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(event)
	runtime.KeepAlive(axisUse)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Device returns the device of an event.
//
// The function returns the following values:
//
//   - device (optional): GdkDevice.
func (event *Event) Device() Devicer {
	var _arg0 *C.GdkEvent  // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_device(_arg0)
	runtime.KeepAlive(event)

	var _device Devicer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// DeviceTool returns a GdkDeviceTool representing the tool that caused the
// event.
//
// If the was not generated by a device that supports different tools (such as a
// tablet), this function will return NULL.
//
// Note: the GdkDeviceTool will be constant during the application
// lifetime, if settings must be stored persistently across runs, see
// gdk.DeviceTool.GetSerial().
//
// The function returns the following values:
//
//   - deviceTool (optional): current device tool.
func (event *Event) DeviceTool() *DeviceTool {
	var _arg0 *C.GdkEvent      // out
	var _cret *C.GdkDeviceTool // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_device_tool(_arg0)
	runtime.KeepAlive(event)

	var _deviceTool *DeviceTool // out

	if _cret != nil {
		_deviceTool = wrapDeviceTool(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _deviceTool
}

// Display retrieves the display associated to the event.
//
// The function returns the following values:
//
//   - display (optional): GdkDisplay.
func (event *Event) Display() *Display {
	var _arg0 *C.GdkEvent   // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_display(_arg0)
	runtime.KeepAlive(event)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// EventSequence returns the event sequence to which the event belongs.
//
// Related touch events are connected in a sequence. Other events typically
// don't have event sequence information.
//
// The function returns the following values:
//
//   - eventSequence: event sequence that the event belongs to.
func (event *Event) EventSequence() *EventSequence {
	var _arg0 *C.GdkEvent         // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_event_sequence(_arg0)
	runtime.KeepAlive(event)

	var _eventSequence *EventSequence // out

	_eventSequence = (*EventSequence)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _eventSequence
}

// EventType retrieves the type of the event.
//
// The function returns the following values:
//
//   - eventType: GdkEventType.
func (event *Event) EventType() EventType {
	var _arg0 *C.GdkEvent    // out
	var _cret C.GdkEventType // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_event_type(_arg0)
	runtime.KeepAlive(event)

	var _eventType EventType // out

	_eventType = EventType(_cret)

	return _eventType
}

// History retrieves the history of the device that event is for, as a list of
// time and coordinates.
//
// The history includes positions that are not delivered as separate events to
// the application because they occurred in the same frame as event.
//
// Note that only motion and scroll events record history, and motion events do
// it only if one of the mouse buttons is down, or the device has a tool.
//
// The function returns the following values:
//
//   - timeCoords (optional): an array of time and coordinates.
func (event *Event) History() []TimeCoord {
	var _arg0 *C.GdkEvent     // out
	var _cret *C.GdkTimeCoord // in
	var _arg1 C.guint         // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_history(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _timeCoords []TimeCoord // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			src := unsafe.Slice((*C.GdkTimeCoord)(_cret), _arg1)
			_timeCoords = make([]TimeCoord, _arg1)
			for i := 0; i < int(_arg1); i++ {
				_timeCoords[i] = *(*TimeCoord)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
			}
		}
	}

	return _timeCoords
}

// ModifierState returns the modifier state field of an event.
//
// The function returns the following values:
//
//   - modifierType: modifier state of event.
func (event *Event) ModifierState() ModifierType {
	var _arg0 *C.GdkEvent       // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_modifier_state(_arg0)
	runtime.KeepAlive(event)

	var _modifierType ModifierType // out

	_modifierType = ModifierType(_cret)

	return _modifierType
}

// PointerEmulated returns whether this event is an 'emulated' pointer event.
//
// Emulated pointer events typically originate from a touch events.
//
// The function returns the following values:
//
//   - ok: TRUE if this event is emulated.
func (event *Event) PointerEmulated() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_pointer_emulated(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Position: extract the event surface relative x/y coordinates from an event.
//
// This position is in surface coordinates (coordinates.html).
//
// The function returns the following values:
//
//   - x: location to put event surface x coordinate.
//   - y: location to put event surface y coordinate.
//   - ok
func (event *Event) Position() (x, y float64, ok bool) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.double    // in
	var _arg2 C.double    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg1)
	_y = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// Seat returns the seat that originated the event.
//
// The function returns the following values:
//
//   - seat (optional): GdkSeat.
func (event *Event) Seat() Seater {
	var _arg0 *C.GdkEvent // out
	var _cret *C.GdkSeat  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_seat(_arg0)
	runtime.KeepAlive(event)

	var _seat Seater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Seater)
				return ok
			})
			rv, ok := casted.(Seater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
			}
			_seat = rv
		}
	}

	return _seat
}

// Surface extracts the surface associated with an event.
//
// The function returns the following values:
//
//   - surface (optional): GdkSurface associated with the event.
func (event *Event) Surface() Surfacer {
	var _arg0 *C.GdkEvent   // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_surface(_arg0)
	runtime.KeepAlive(event)

	var _surface Surfacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Surfacer)
				return ok
			})
			rv, ok := casted.(Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _surface
}

// Time returns the timestamp of event.
//
// Not all events have timestamps. In that case, this function returns
// GDK_CURRENT_TIME.
//
// The function returns the following values:
//
//   - guint32: timestamp field from event.
func (event *Event) Time() uint32 {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint32   // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_get_time(_arg0)
	runtime.KeepAlive(event)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// TriggersContextMenu returns whether a GdkEvent should trigger a context menu,
// according to platform conventions.
//
// The right mouse button typically triggers context menus.
//
// This function should always be used instead of simply checking for
// event->button == GDK_BUTTON_SECONDARY.
//
// The function returns the following values:
//
//   - ok: TRUE if the event should trigger a context menu.
func (event *Event) TriggersContextMenu() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_event_triggers_context_menu(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FocusEvent: event related to a keyboard focus change.
type FocusEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*FocusEvent)(nil)
)

func wrapFocusEvent(obj *coreglib.Object) *FocusEvent {
	return &FocusEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalFocusEvent(p uintptr) (interface{}, error) {
	return wrapFocusEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// In extracts whether this event is about focus entering or leaving the
// surface.
//
// The function returns the following values:
//
//   - ok: TRUE of the focus is entering.
func (event *FocusEvent) In() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_focus_event_get_in(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FrameClock: GdkFrameClock tells the application when to update and repaint a
// surface.
//
// This may be synced to the vertical refresh rate of the monitor, for example.
// Even when the frame clock uses a simple timer rather than a hardware-based
// vertical sync, the frame clock helps because it ensures everything paints at
// the same time (reducing the total number of frames).
//
// The frame clock can also automatically stop painting when it knows the frames
// will not be visible, or scale back animation framerates.
//
// GdkFrameClock is designed to be compatible with an OpenGL-based
// implementation or with mozRequestAnimationFrame in Firefox, for example.
//
// A frame clock is idle until someone requests a frame with
// gdk.FrameClock.RequestPhase(). At some later point that makes sense
// for the synchronization being implemented, the clock will process a
// frame and emit signals for each phase that has been requested. (See the
// signals of the GdkFrameClock class for documentation of the phases.
// GDK_FRAME_CLOCK_PHASE_UPDATE and the gdk.FrameClock::update signal are most
// interesting for application writers, and are used to update the animations,
// using the frame time given by gdk.FrameClock.GetFrameTime().
//
// The frame time is reported in microseconds and generally in the same
// timescale as g_get_monotonic_time(), however, it is not the same as
// g_get_monotonic_time(). The frame time does not advance during the time a
// frame is being painted, and outside of a frame, an attempt is made so that
// all calls to gdk.FrameClock.GetFrameTime() that are called at a “similar”
// time get the same value. This means that if different animations are
// timed by looking at the difference in time between an initial value from
// gdk.FrameClock.GetFrameTime() and the value inside the gdk.FrameClock::update
// signal of the clock, they will stay exactly synchronized.
type FrameClock struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FrameClock)(nil)
)

// FrameClocker describes types inherited from class FrameClock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FrameClocker interface {
	coreglib.Objector
	baseFrameClock() *FrameClock
}

var _ FrameClocker = (*FrameClock)(nil)

func wrapFrameClock(obj *coreglib.Object) *FrameClock {
	return &FrameClock{
		Object: obj,
	}
}

func marshalFrameClock(p uintptr) (interface{}, error) {
	return wrapFrameClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (frameClock *FrameClock) baseFrameClock() *FrameClock {
	return frameClock
}

// BaseFrameClock returns the underlying base object.
func BaseFrameClock(obj FrameClocker) *FrameClock {
	return obj.baseFrameClock()
}

// ConnectAfterPaint: this signal ends processing of the frame.
//
// Applications should generally not handle this signal.
func (frameClock *FrameClock) ConnectAfterPaint(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "after-paint", false, unsafe.Pointer(C._gotk4_gdk4_FrameClock_ConnectAfterPaint), f)
}

// ConnectBeforePaint begins processing of the frame.
//
// Applications should generally not handle this signal.
func (frameClock *FrameClock) ConnectBeforePaint(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "before-paint", false, unsafe.Pointer(C._gotk4_gdk4_FrameClock_ConnectBeforePaint), f)
}

// ConnectFlushEvents: used to flush pending motion events that are being
// batched up and compressed together.
//
// Applications should not handle this signal.
func (frameClock *FrameClock) ConnectFlushEvents(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "flush-events", false, unsafe.Pointer(C._gotk4_gdk4_FrameClock_ConnectFlushEvents), f)
}

// ConnectLayout is emitted as the second step of toolkit and application
// processing of the frame.
//
// Any work to update sizes and positions of application elements should be
// performed. GTK normally handles this internally.
func (frameClock *FrameClock) ConnectLayout(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "layout", false, unsafe.Pointer(C._gotk4_gdk4_FrameClock_ConnectLayout), f)
}

// ConnectPaint is emitted as the third step of toolkit and application
// processing of the frame.
//
// The frame is repainted. GDK normally handles this internally and emits
// gdk.Surface::render signals which are turned into GtkWidget::snapshot
// (../gtk4/signal.Widget.snapshot.html) signals by GTK.
func (frameClock *FrameClock) ConnectPaint(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "paint", false, unsafe.Pointer(C._gotk4_gdk4_FrameClock_ConnectPaint), f)
}

// ConnectResumeEvents is emitted after processing of the frame is finished.
//
// This signal is handled internally by GTK to resume normal event processing.
// Applications should not handle this signal.
func (frameClock *FrameClock) ConnectResumeEvents(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "resume-events", false, unsafe.Pointer(C._gotk4_gdk4_FrameClock_ConnectResumeEvents), f)
}

// ConnectUpdate is emitted as the first step of toolkit and application
// processing of the frame.
//
// Animations should be updated using gdk.FrameClock.GetFrameTime().
// Applications can connect directly to this signal, or use
// gtk_widget_add_tick_callback() (../gtk4/method.Widget.add_tick_callback.html)
// as a more convenient interface.
func (frameClock *FrameClock) ConnectUpdate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(frameClock, "update", false, unsafe.Pointer(C._gotk4_gdk4_FrameClock_ConnectUpdate), f)
}

// BeginUpdating starts updates for an animation.
//
// Until a matching call to gdk.FrameClock.EndUpdating() is made,
// the frame clock will continually request a new frame with the
// GDK_FRAME_CLOCK_PHASE_UPDATE phase. This function may be called multiple
// times and frames will be requested until gdk_frame_clock_end_updating() is
// called the same number of times.
func (frameClock *FrameClock) BeginUpdating() {
	var _arg0 *C.GdkFrameClock // out

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	C.gdk_frame_clock_begin_updating(_arg0)
	runtime.KeepAlive(frameClock)
}

// EndUpdating stops updates for an animation.
//
// See the documentation for gdk.FrameClock.BeginUpdating().
func (frameClock *FrameClock) EndUpdating() {
	var _arg0 *C.GdkFrameClock // out

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	C.gdk_frame_clock_end_updating(_arg0)
	runtime.KeepAlive(frameClock)
}

// CurrentTimings gets the frame timings for the current frame.
//
// The function returns the following values:
//
//   - frameTimings (optional): GdkFrameTimings for the frame currently being
//     processed, or even no frame is being processed, for the previous frame.
//     Before any frames have been processed, returns NULL.
func (frameClock *FrameClock) CurrentTimings() *FrameTimings {
	var _arg0 *C.GdkFrameClock   // out
	var _cret *C.GdkFrameTimings // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	_cret = C.gdk_frame_clock_get_current_timings(_arg0)
	runtime.KeepAlive(frameClock)

	var _frameTimings *FrameTimings // out

	if _cret != nil {
		_frameTimings = (*FrameTimings)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gdk_frame_timings_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_frameTimings)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gdk_frame_timings_unref((*C.GdkFrameTimings)(intern.C))
			},
		)
	}

	return _frameTimings
}

// FPS calculates the current frames-per-second, based on the frame timings of
// frame_clock.
//
// The function returns the following values:
//
//   - gdouble: current fps, as a double.
func (frameClock *FrameClock) FPS() float64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.double         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	_cret = C.gdk_frame_clock_get_fps(_arg0)
	runtime.KeepAlive(frameClock)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// FrameCounter: GdkFrameClock maintains a 64-bit counter that increments for
// each frame drawn.
//
// The function returns the following values:
//
//   - gint64: inside frame processing, the value of the frame counter for the
//     current frame. Outside of frame processing, the frame counter for the
//     last frame.
func (frameClock *FrameClock) FrameCounter() int64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	_cret = C.gdk_frame_clock_get_frame_counter(_arg0)
	runtime.KeepAlive(frameClock)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// FrameTime gets the time that should currently be used for animations.
//
// Inside the processing of a frame, it’s the time used to compute the animation
// position of everything in a frame. Outside of a frame, it's the time of the
// conceptual “previous frame,” which may be either the actual previous frame
// time, or if that’s too old, an updated time.
//
// The function returns the following values:
//
//   - gint64: timestamp in microseconds, in the timescale of of
//     g_get_monotonic_time().
func (frameClock *FrameClock) FrameTime() int64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	_cret = C.gdk_frame_clock_get_frame_time(_arg0)
	runtime.KeepAlive(frameClock)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// HistoryStart returns the frame counter for the oldest frame available in
// history.
//
// GdkFrameClock internally keeps a history of GdkFrameTimings objects for
// recent frames that can be retrieved with gdk.FrameClock.GetTimings().
// The set of stored frames is the set from the counter values given by
// gdk.FrameClock.GetHistoryStart() and gdk.FrameClock.GetFrameCounter(),
// inclusive.
//
// The function returns the following values:
//
//   - gint64: frame counter value for the oldest frame that is available in the
//     internal frame history of the GdkFrameClock.
func (frameClock *FrameClock) HistoryStart() int64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	_cret = C.gdk_frame_clock_get_history_start(_arg0)
	runtime.KeepAlive(frameClock)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// RefreshInfo predicts a presentation time, based on history.
//
// Using the frame history stored in the frame clock, finds the last known
// presentation time and refresh interval, and assuming that presentation times
// are separated by the refresh interval, predicts a presentation time that
// is a multiple of the refresh interval after the last presentation time,
// and later than base_time.
//
// The function takes the following parameters:
//
//   - baseTime: base time for determining a presentaton time.
//
// The function returns the following values:
//
//   - refreshIntervalReturn (optional): location to store the determined
//     refresh interval, or NULL. A default refresh interval of 1/60th of a
//     second will be stored if no history is present.
//   - presentationTimeReturn: location to store the next candidate presentation
//     time after the given base time. 0 will be will be stored if no history is
//     present.
func (frameClock *FrameClock) RefreshInfo(baseTime int64) (refreshIntervalReturn, presentationTimeReturn int64) {
	var _arg0 *C.GdkFrameClock // out
	var _arg1 C.gint64         // out
	var _arg2 C.gint64         // in
	var _arg3 C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))
	_arg1 = C.gint64(baseTime)

	C.gdk_frame_clock_get_refresh_info(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(frameClock)
	runtime.KeepAlive(baseTime)

	var _refreshIntervalReturn int64  // out
	var _presentationTimeReturn int64 // out

	_refreshIntervalReturn = int64(_arg2)
	_presentationTimeReturn = int64(_arg3)

	return _refreshIntervalReturn, _presentationTimeReturn
}

// Timings retrieves a GdkFrameTimings object holding timing information for the
// current frame or a recent frame.
//
// The GdkFrameTimings object may not yet be complete: see
// gdk.FrameTimings.GetComplete() and gdk.FrameClock.GetHistoryStart().
//
// The function takes the following parameters:
//
//   - frameCounter: frame counter value identifying the frame to be received.
//
// The function returns the following values:
//
//   - frameTimings (optional): GdkFrameTimings object for the specified frame,
//     or NULL if it is not available.
func (frameClock *FrameClock) Timings(frameCounter int64) *FrameTimings {
	var _arg0 *C.GdkFrameClock   // out
	var _arg1 C.gint64           // out
	var _cret *C.GdkFrameTimings // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))
	_arg1 = C.gint64(frameCounter)

	_cret = C.gdk_frame_clock_get_timings(_arg0, _arg1)
	runtime.KeepAlive(frameClock)
	runtime.KeepAlive(frameCounter)

	var _frameTimings *FrameTimings // out

	if _cret != nil {
		_frameTimings = (*FrameTimings)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gdk_frame_timings_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_frameTimings)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gdk_frame_timings_unref((*C.GdkFrameTimings)(intern.C))
			},
		)
	}

	return _frameTimings
}

// RequestPhase asks the frame clock to run a particular phase.
//
// The signal corresponding the requested phase will be emitted the next time
// the frame clock processes. Multiple calls to gdk_frame_clock_request_phase()
// will be combined together and only one frame processed. If you are
// displaying animated content and want to continually request the
// GDK_FRAME_CLOCK_PHASE_UPDATE phase for a period of time, you should use
// gdk.FrameClock.BeginUpdating() instead, since this allows GTK to adjust
// system parameters to get maximally smooth animations.
//
// The function takes the following parameters:
//
//   - phase that is requested.
func (frameClock *FrameClock) RequestPhase(phase FrameClockPhase) {
	var _arg0 *C.GdkFrameClock     // out
	var _arg1 C.GdkFrameClockPhase // out

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))
	_arg1 = C.GdkFrameClockPhase(phase)

	C.gdk_frame_clock_request_phase(_arg0, _arg1)
	runtime.KeepAlive(frameClock)
	runtime.KeepAlive(phase)
}

// GLContext: GdkGLContext is an object representing a platform-specific OpenGL
// draw context.
//
// GdkGLContexts are created for a surface using gdk.Surface.CreateGLContext(),
// and the context will match the characteristics of the surface.
//
// A GdkGLContext is not tied to any particular normal framebuffer. For
// instance, it cannot draw to the surface back buffer. The GDK repaint system
// is in full control of the painting to that. Instead, you can create render
// buffers or textures and use cairo_draw_from_gl in the draw function of your
// widget to draw them. Then GDK will handle the integration of your rendering
// with that of other widgets.
//
// Support for GdkGLContext is platform-specific and context creation can fail,
// returning NULL context.
//
// A GdkGLContext has to be made "current" in order to start using it, otherwise
// any OpenGL call will be ignored.
//
// # Creating a new OpenGL context
//
// In order to create a new GdkGLContext instance you need a GdkSurface,
// which you typically get during the realize call of a widget.
//
// A GdkGLContext is not realized until either gdk.GLContext.MakeCurrent()
// or gdk.GLContext.Realize() is called. It is possible to specify details
// of the GL context like the OpenGL version to be used, or whether the
// GL context should have extra state validation enabled after calling
// gdk.Surface.CreateGLContext() by calling gdk.GLContext.Realize().
// If the realization fails you have the option to change the settings of the
// GdkGLContext and try again.
//
// # Using a GdkGLContext
//
// You will need to make the GdkGLContext the current context before issuing
// OpenGL calls; the system sends OpenGL commands to whichever context is
// current. It is possible to have multiple contexts, so you always need to
// ensure that the one which you want to draw with is the current one before
// issuing commands:
//
//	gdk_gl_context_make_current (context);
//
// You can now perform your drawing using OpenGL commands.
//
// You can check which GdkGLContext is the current one by using
// gdk.GLContext().GetCurrent; you can also unset any GdkGLContext that is
// currently set by calling gdk.GLContext().ClearCurrent.
type GLContext struct {
	_ [0]func() // equal guard
	DrawContext
}

var (
	_ DrawContexter = (*GLContext)(nil)
)

// GLContexter describes types inherited from class GLContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLContexter interface {
	coreglib.Objector
	baseGLContext() *GLContext
}

var _ GLContexter = (*GLContext)(nil)

func wrapGLContext(obj *coreglib.Object) *GLContext {
	return &GLContext{
		DrawContext: DrawContext{
			Object: obj,
		},
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	return wrapGLContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *GLContext) baseGLContext() *GLContext {
	return self
}

// BaseGLContext returns the underlying base object.
func BaseGLContext(obj GLContexter) *GLContext {
	return obj.baseGLContext()
}

// AllowedApis gets the allowed APIs set via gdk_gl_context_set_allowed_apis().
//
// The function returns the following values:
//
//   - glapI: allowed APIs.
func (self *GLContext) AllowedApis() GLAPI {
	var _arg0 *C.GdkGLContext // out
	var _cret C.GdkGLAPI      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_context_get_allowed_apis(_arg0)
	runtime.KeepAlive(self)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// Api gets the API currently in use.
//
// If the renderer has not been realized yet, 0 is returned.
//
// The function returns the following values:
//
//   - glapI: currently used API.
func (self *GLContext) Api() GLAPI {
	var _arg0 *C.GdkGLContext // out
	var _cret C.GdkGLAPI      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_context_get_api(_arg0)
	runtime.KeepAlive(self)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// DebugEnabled retrieves whether the context is doing extra validations and
// runtime checking.
//
// See gdk.GLContext.SetDebugEnabled().
//
// The function returns the following values:
//
//   - ok: TRUE if debugging is enabled.
func (context *GLContext) DebugEnabled() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_gl_context_get_debug_enabled(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Display retrieves the display the context is created for.
//
// The function returns the following values:
//
//   - display (optional): GdkDisplay.
func (context *GLContext) Display() *Display {
	var _arg0 *C.GdkGLContext // out
	var _cret *C.GdkDisplay   // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_gl_context_get_display(_arg0)
	runtime.KeepAlive(context)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// ForwardCompatible retrieves whether the context is forward-compatible.
//
// See gdk.GLContext.SetForwardCompatible().
//
// The function returns the following values:
//
//   - ok: TRUE if the context should be forward-compatible.
func (context *GLContext) ForwardCompatible() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_gl_context_get_forward_compatible(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequiredVersion retrieves required OpenGL version set as a requirement
// for the context realization. It will not change even if a greater
// OpenGL version is supported and used after the context is realized. See
// gdk.GLContext.GetVersion() for the real version in use.
//
// See gdk.GLContext.SetRequiredVersion().
//
// The function returns the following values:
//
//   - major (optional): return location for the major version to request.
//   - minor (optional): return location for the minor version to request.
func (context *GLContext) RequiredVersion() (major, minor int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // in
	var _arg2 C.int           // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gdk_gl_context_get_required_version(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

// SharedContext: used to retrieves the GdkGLContext that this context share
// data with.
//
// As many contexts can share data now and no single shared context exists
// anymore, this function has been deprecated and now always returns NULL.
//
// Deprecated: Use gdk.GLContext.IsShared() to check if contexts can be shared.
//
// The function returns the following values:
//
//   - glContext (optional): NULL.
func (context *GLContext) SharedContext() GLContexter {
	var _arg0 *C.GdkGLContext // out
	var _cret *C.GdkGLContext // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_gl_context_get_shared_context(_arg0)
	runtime.KeepAlive(context)

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// Surface retrieves the surface used by the context.
//
// The function returns the following values:
//
//   - surface (optional): GdkSurface.
func (context *GLContext) Surface() Surfacer {
	var _arg0 *C.GdkGLContext // out
	var _cret *C.GdkSurface   // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_gl_context_get_surface(_arg0)
	runtime.KeepAlive(context)

	var _surface Surfacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Surfacer)
				return ok
			})
			rv, ok := casted.(Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _surface
}

// UseES checks whether the context is using an OpenGL or OpenGL ES profile.
//
// The function returns the following values:
//
//   - ok: TRUE if the GdkGLContext is using an OpenGL ES profile; FALSE if
//     other profile is in use of if the context has not yet been realized.
func (context *GLContext) UseES() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_gl_context_get_use_es(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Version retrieves the OpenGL version of the context.
//
// The context must be realized prior to calling this function.
//
// The function returns the following values:
//
//   - major: return location for the major version.
//   - minor: return location for the minor version.
func (context *GLContext) Version() (major, minor int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // in
	var _arg2 C.int           // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gdk_gl_context_get_version(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

// IsLegacy: whether the GdkGLContext is in legacy mode or not.
//
// The GdkGLContext must be realized before calling this function.
//
// When realizing a GL context, GDK will try to use the OpenGL 3.2 core profile;
// this profile removes all the OpenGL API that was deprecated prior to the 3.2
// version of the specification. If the realization is successful, this function
// will return FALSE.
//
// If the underlying OpenGL implementation does not support core profiles,
// GDK will fall back to a pre-3.2 compatibility profile, and this function will
// return TRUE.
//
// You can use the value returned by this function to decide which kind of
// OpenGL API to use, or whether to do extension discovery, or what kind of
// shader programs to load.
//
// The function returns the following values:
//
//   - ok: TRUE if the GL context is in legacy mode.
func (context *GLContext) IsLegacy() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_gl_context_is_legacy(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsShared checks if the two GL contexts can share resources.
//
// When they can, the texture IDs from other can be used in self. This is
// particularly useful when passing GdkGLTexture objects between different
// contexts.
//
// Contexts created for the same display with the same properties will always
// be compatible, even if they are created for different surfaces. For other
// contexts it depends on the GL backend.
//
// Both contexts must be realized for this check to succeed. If either one is
// not, this function will return FALSE.
//
// The function takes the following parameters:
//
//   - other: GdkGLContext that should be compatible with self.
//
// The function returns the following values:
//
//   - ok: TRUE if the two GL contexts are compatible.
func (self *GLContext) IsShared(other GLContexter) bool {
	var _arg0 *C.GdkGLContext // out
	var _arg1 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(other).Native()))

	_cret = C.gdk_gl_context_is_shared(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(other)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MakeCurrent makes the context the current one.
func (context *GLContext) MakeCurrent() {
	var _arg0 *C.GdkGLContext // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gdk_gl_context_make_current(_arg0)
	runtime.KeepAlive(context)
}

// Realize realizes the given GdkGLContext.
//
// It is safe to call this function on a realized GdkGLContext.
func (context *GLContext) Realize() error {
	var _arg0 *C.GdkGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gdk_gl_context_realize(_arg0, &_cerr)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAllowedApis sets the allowed APIs. When gdk_gl_context_realize() is
// called, only the allowed APIs will be tried. If you set this to 0, realizing
// will always fail.
//
// If you set it on a realized context, the property will not have any effect.
// It is only relevant during gdk_gl_context_realize().
//
// By default, all APIs are allowed.
//
// The function takes the following parameters:
//
//   - apis: allowed APIs.
func (self *GLContext) SetAllowedApis(apis GLAPI) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.GdkGLAPI      // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GdkGLAPI(apis)

	C.gdk_gl_context_set_allowed_apis(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(apis)
}

// SetDebugEnabled sets whether the GdkGLContext should perform extra
// validations and runtime checking.
//
// This is useful during development, but has additional overhead.
//
// The GdkGLContext must not be realized or made current prior to calling this
// function.
//
// The function takes the following parameters:
//
//   - enabled: whether to enable debugging in the context.
func (context *GLContext) SetDebugEnabled(enabled bool) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gdk_gl_context_set_debug_enabled(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(enabled)
}

// SetForwardCompatible sets whether the GdkGLContext should be
// forward-compatible.
//
// Forward-compatible contexts must not support OpenGL functionality that has
// been marked as deprecated in the requested version; non-forward compatible
// contexts, on the other hand, must support both deprecated and non deprecated
// functionality.
//
// The GdkGLContext must not be realized or made current prior to calling this
// function.
//
// The function takes the following parameters:
//
//   - compatible: whether the context should be forward-compatible.
func (context *GLContext) SetForwardCompatible(compatible bool) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if compatible {
		_arg1 = C.TRUE
	}

	C.gdk_gl_context_set_forward_compatible(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(compatible)
}

// SetRequiredVersion sets the major and minor version of OpenGL to request.
//
// Setting major and minor to zero will use the default values.
//
// Setting major and minor lower than the minimum versions required by GTK will
// result in the context choosing the minimum version.
//
// The context must not be realized or made current prior to calling this
// function.
//
// The function takes the following parameters:
//
//   - major version to request.
//   - minor version to request.
func (context *GLContext) SetRequiredVersion(major, minor int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(major)
	_arg2 = C.int(minor)

	C.gdk_gl_context_set_required_version(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(major)
	runtime.KeepAlive(minor)
}

// SetUseES requests that GDK create an OpenGL ES context instead of an OpenGL
// one.
//
// Not all platforms support OpenGL ES.
//
// The context must not have been realized.
//
// By default, GDK will attempt to automatically detect whether the underlying
// GL implementation is OpenGL or OpenGL ES once the context is realized.
//
// You should check the return value of gdk.GLContext.GetUseES() after calling
// gdk.GLContext.Realize() to decide whether to use the OpenGL or OpenGL ES API,
// extensions, or shaders.
//
// The function takes the following parameters:
//
//   - useEs: whether the context should use OpenGL ES instead of OpenGL,
//     or -1 to allow auto-detection.
func (context *GLContext) SetUseES(useEs int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(useEs)

	C.gdk_gl_context_set_use_es(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(useEs)
}

// GLContextClearCurrent clears the current GdkGLContext.
//
// Any OpenGL call after this function returns will be ignored until
// gdk.GLContext.MakeCurrent() is called.
func GLContextClearCurrent() {
	C.gdk_gl_context_clear_current()
}

// GLContextGetCurrent retrieves the current GdkGLContext.
//
// The function returns the following values:
//
//   - glContext (optional): current GdkGLContext.
func GLContextGetCurrent() GLContexter {
	var _cret *C.GdkGLContext // in

	_cret = C.gdk_gl_context_get_current()

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// GLTexture: gdkTexture representing a GL texture object.
type GLTexture struct {
	_ [0]func() // equal guard
	Texture
}

var (
	_ Texturer = (*GLTexture)(nil)
)

func wrapGLTexture(obj *coreglib.Object) *GLTexture {
	return &GLTexture{
		Texture: Texture{
			Object: obj,
			Paintable: Paintable{
				Object: obj,
			},
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		},
	}
}

func marshalGLTexture(p uintptr) (interface{}, error) {
	return wrapGLTexture(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Release releases the GL resources held by a GdkGLTexture.
//
// The texture contents are still available via the gdk.Texture.Download()
// function, after this function has been called.
func (self *GLTexture) Release() {
	var _arg0 *C.GdkGLTexture // out

	_arg0 = (*C.GdkGLTexture)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gdk_gl_texture_release(_arg0)
	runtime.KeepAlive(self)
}

// GLTextureBuilder: GdkGLTextureBuilder is a builder used to construct
// gdk.Texture objects from GL textures.
//
// The operation is quite simple: Create a texture builder,
// set all the necessary properties - keep in mind that the
// properties gdk.GLTextureBuilder:context, gdk.GLTextureBuilder:id,
// gdk.GLTextureBuilder:width, and gdk.GLTextureBuilder:height are mandatory -
// and then call gdk.GLTextureBuilder.Build() to create the new texture.
//
// GdkGLTextureBuilder can be used for quick one-shot construction of textures
// as well as kept around and reused to construct multiple textures.
type GLTextureBuilder struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*GLTextureBuilder)(nil)
)

func wrapGLTextureBuilder(obj *coreglib.Object) *GLTextureBuilder {
	return &GLTextureBuilder{
		Object: obj,
	}
}

func marshalGLTextureBuilder(p uintptr) (interface{}, error) {
	return wrapGLTextureBuilder(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGLTextureBuilder creates a new texture builder.
//
// The function returns the following values:
//
//   - glTextureBuilder: new GdkTextureBuilder.
func NewGLTextureBuilder() *GLTextureBuilder {
	var _cret *C.GdkGLTextureBuilder // in

	_cret = C.gdk_gl_texture_builder_new()

	var _glTextureBuilder *GLTextureBuilder // out

	_glTextureBuilder = wrapGLTextureBuilder(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glTextureBuilder
}

// Context gets the context previously set via
// gdk_gl_texture_builder_set_context() or NULL if none was set.
//
// The function returns the following values:
//
//   - glContext (optional): context.
func (self *GLTextureBuilder) Context() GLContexter {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret *C.GdkGLContext        // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_context(_arg0)
	runtime.KeepAlive(self)

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// Format gets the format previously set via
// gdk_gl_texture_builder_set_format().
//
// The function returns the following values:
//
//   - memoryFormat: format.
func (self *GLTextureBuilder) Format() MemoryFormat {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret C.GdkMemoryFormat      // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_format(_arg0)
	runtime.KeepAlive(self)

	var _memoryFormat MemoryFormat // out

	_memoryFormat = MemoryFormat(_cret)

	return _memoryFormat
}

// HasMipmap gets whether the texture has a mipmap.
//
// The function returns the following values:
//
//   - ok: whether the texture has a mipmap.
func (self *GLTextureBuilder) HasMipmap() bool {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_has_mipmap(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Height gets the height previously set via gdk_gl_texture_builder_set_height()
// or 0 if the height wasn't set.
//
// The function returns the following values:
//
//   - gint: height.
func (self *GLTextureBuilder) Height() int {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret C.int                  // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_height(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ID gets the texture id previously set via gdk_gl_texture_builder_set_id() or
// 0 if the id wasn't set.
//
// The function returns the following values:
//
//   - guint: id.
func (self *GLTextureBuilder) ID() uint {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret C.guint                // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_id(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Sync gets the GLsync previously set via gdk_gl_texture_builder_set_sync().
//
// The function returns the following values:
//
//   - gpointer (optional): GLSync.
func (self *GLTextureBuilder) Sync() unsafe.Pointer {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret C.gpointer             // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_sync(_arg0)
	runtime.KeepAlive(self)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// UpdateRegion gets the region previously set via
// gdk_gl_texture_builder_set_update_region() or NULL if none was set.
//
// The function returns the following values:
//
//   - region (optional): region.
func (self *GLTextureBuilder) UpdateRegion() *cairo.Region {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret *C.cairo_region_t      // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_update_region(_arg0)
	runtime.KeepAlive(self)

	var _region *cairo.Region // out

	if _cret != nil {
		{
			_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
			_region = (*cairo.Region)(unsafe.Pointer(_pp))
		}
		C.cairo_region_reference(_cret)
		runtime.SetFinalizer(_region, func(v *cairo.Region) {
			C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
		})
	}

	return _region
}

// UpdateTexture gets the texture previously set via
// gdk_gl_texture_builder_set_update_texture() or NULL if none was set.
//
// The function returns the following values:
//
//   - texture (optional): texture.
func (self *GLTextureBuilder) UpdateTexture() Texturer {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret *C.GdkTexture          // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_update_texture(_arg0)
	runtime.KeepAlive(self)

	var _texture Texturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Texturer)
				return ok
			})
			rv, ok := casted.(Texturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
			}
			_texture = rv
		}
	}

	return _texture
}

// Width gets the width previously set via gdk_gl_texture_builder_set_width() or
// 0 if the width wasn't set.
//
// The function returns the following values:
//
//   - gint: width.
func (self *GLTextureBuilder) Width() int {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _cret C.int                  // in

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_gl_texture_builder_get_width(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SetContext sets the context to be used for the texture. This is the context
// that owns the texture.
//
// The context must be set before calling gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - context (optional) the texture beongs to or NULL to unset.
func (self *GLTextureBuilder) SetContext(context GLContexter) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 *C.GdkGLContext        // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if context != nil {
		_arg1 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C.gdk_gl_texture_builder_set_context(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(context)
}

// SetFormat sets the format of the texture. The default is
// GDK_MEMORY_R8G8B8A8_PREMULTIPLIED.
//
// The format is the preferred format the texture data should be
// downloaded to. The format must be supported by the GL version of
// gdk.GLTextureBuilder:context.
//
// GDK's texture download code assumes that the format corresponds to the
// storage parameters of the GL texture in an obvious way. For example,
// a format of GDK_MEMORY_R16G16B16A16_PREMULTIPLIED is expected to be stored
// as GL_RGBA16 texture, and GDK_MEMORY_G8A8 is expected to be stored as GL_RG8
// texture.
//
// Setting the right format is particularly useful when using high bit
// depth textures to preserve the bit depth, to set the correct value for
// unpremultiplied textures and to make sure opaque textures are treated as
// such.
//
// Non-RGBA textures need to have swizzling parameters set up properly to be
// usable in GSK's shaders.
//
// The function takes the following parameters:
//
//   - format texture's format.
func (self *GLTextureBuilder) SetFormat(format MemoryFormat) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 C.GdkMemoryFormat      // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GdkMemoryFormat(format)

	C.gdk_gl_texture_builder_set_format(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(format)
}

// SetHasMipmap sets whether the texture has a mipmap. This allows the renderer
// and other users of the generated texture to use a higher quality downscaling.
//
// Typically, the glGenerateMipmap function is used to generate a mimap.
//
// The function takes the following parameters:
//
//   - hasMipmap: whether the texture has a mipmap.
func (self *GLTextureBuilder) SetHasMipmap(hasMipmap bool) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if hasMipmap {
		_arg1 = C.TRUE
	}

	C.gdk_gl_texture_builder_set_has_mipmap(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(hasMipmap)
}

// SetHeight sets the height of the texture.
//
// The height must be set before calling gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - height texture's height or 0 to unset.
func (self *GLTextureBuilder) SetHeight(height int) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(height)

	C.gdk_gl_texture_builder_set_height(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(height)
}

// SetID sets the texture id of the texture. The texture id must remain
// unmodified until the texture was finalized. See gdk.GLTextureBuilder.Build()
// for a longer discussion.
//
// The id must be set before calling gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - id: texture id to be used for creating the texture.
func (self *GLTextureBuilder) SetID(id uint) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 C.guint                // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(id)

	C.gdk_gl_texture_builder_set_id(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(id)
}

// SetSync sets the GLSync object to use for the texture.
//
// GTK will wait on this object before using the created GdkTexture.
//
// The destroy function that is passed to gdk.GLTextureBuilder.Build() is
// responsible for freeing the sync object when it is no longer needed.
// The texture builder does not destroy it and it is the callers responsibility
// to make sure it doesn't leak.
//
// The function takes the following parameters:
//
//   - sync (optional): GLSync object.
func (self *GLTextureBuilder) SetSync(sync unsafe.Pointer) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 C.gpointer             // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(sync))

	C.gdk_gl_texture_builder_set_sync(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sync)
}

// SetUpdateRegion sets the region to be updated by this texture. Together with
// gdk.GLTextureBuilder:update-texture this describes an update of a previous
// texture.
//
// When rendering animations of large textures, it is possible that consecutive
// textures are only updating contents in parts of the texture. It is then
// possible to describe this update via these two properties, so that GTK can
// avoid rerendering parts that did not change.
//
// An example would be a screen recording where only the mouse pointer moves.
//
// The function takes the following parameters:
//
//   - region (optional) to update.
func (self *GLTextureBuilder) SetUpdateRegion(region *cairo.Region) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 *C.cairo_region_t      // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if region != nil {
		_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gdk_gl_texture_builder_set_update_region(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(region)
}

// SetUpdateTexture sets the texture to be updated by this texture. See
// gdk.GLTextureBuilder.SetUpdateRegion() for an explanation.
//
// The function takes the following parameters:
//
//   - texture (optional) to update.
func (self *GLTextureBuilder) SetUpdateTexture(texture Texturer) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 *C.GdkTexture          // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if texture != nil {
		_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	}

	C.gdk_gl_texture_builder_set_update_texture(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(texture)
}

// SetWidth sets the width of the texture.
//
// The width must be set before calling gdk.GLTextureBuilder.Build().
//
// The function takes the following parameters:
//
//   - width texture's width or 0 to unset.
func (self *GLTextureBuilder) SetWidth(width int) {
	var _arg0 *C.GdkGLTextureBuilder // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GdkGLTextureBuilder)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(width)

	C.gdk_gl_texture_builder_set_width(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(width)
}

// GrabBrokenEvent: event related to a broken windowing system grab.
type GrabBrokenEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*GrabBrokenEvent)(nil)
)

func wrapGrabBrokenEvent(obj *coreglib.Object) *GrabBrokenEvent {
	return &GrabBrokenEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalGrabBrokenEvent(p uintptr) (interface{}, error) {
	return wrapGrabBrokenEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GrabSurface extracts the grab surface from a grab broken event.
//
// The function returns the following values:
//
//   - surface: grab surface of event.
func (event *GrabBrokenEvent) GrabSurface() Surfacer {
	var _arg0 *C.GdkEvent   // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_grab_broken_event_get_grab_surface(_arg0)
	runtime.KeepAlive(event)

	var _surface Surfacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Surfacer)
			return ok
		})
		rv, ok := casted.(Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	return _surface
}

// Implicit checks whether the grab broken event is for an implicit grab.
//
// The function returns the following values:
//
//   - ok: TRUE if the an implicit grab was broken.
func (event *GrabBrokenEvent) Implicit() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_grab_broken_event_get_implicit(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyEvent: event related to a key-based device.
type KeyEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*KeyEvent)(nil)
)

func wrapKeyEvent(obj *coreglib.Object) *KeyEvent {
	return &KeyEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalKeyEvent(p uintptr) (interface{}, error) {
	return wrapKeyEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConsumedModifiers extracts the consumed modifiers from a key event.
//
// The function returns the following values:
//
//   - modifierType: consumed modifiers or event.
func (event *KeyEvent) ConsumedModifiers() ModifierType {
	var _arg0 *C.GdkEvent       // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_key_event_get_consumed_modifiers(_arg0)
	runtime.KeepAlive(event)

	var _modifierType ModifierType // out

	_modifierType = ModifierType(_cret)

	return _modifierType
}

// Keycode extracts the keycode from a key event.
//
// The function returns the following values:
//
//   - guint: keycode of event.
func (event *KeyEvent) Keycode() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_key_event_get_keycode(_arg0)
	runtime.KeepAlive(event)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Keyval extracts the keyval from a key event.
//
// The function returns the following values:
//
//   - guint: keyval of event.
func (event *KeyEvent) Keyval() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_key_event_get_keyval(_arg0)
	runtime.KeepAlive(event)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Layout extracts the layout from a key event.
//
// The function returns the following values:
//
//   - guint: layout of event.
func (event *KeyEvent) Layout() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_key_event_get_layout(_arg0)
	runtime.KeepAlive(event)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Level extracts the shift level from a key event.
//
// The function returns the following values:
//
//   - guint: shift level of event.
func (event *KeyEvent) Level() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_key_event_get_level(_arg0)
	runtime.KeepAlive(event)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Match gets a keyval and modifier combination that will match the event.
//
// See gdk.KeyEvent.Matches().
//
// The function returns the following values:
//
//   - keyval: return location for a keyval.
//   - modifiers: return location for modifiers.
//   - ok: TRUE on success.
func (event *KeyEvent) Match() (uint, ModifierType, bool) {
	var _arg0 *C.GdkEvent       // out
	var _arg1 C.guint           // in
	var _arg2 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_key_event_get_match(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _keyval uint            // out
	var _modifiers ModifierType // out
	var _ok bool                // out

	_keyval = uint(_arg1)
	_modifiers = ModifierType(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _keyval, _modifiers, _ok
}

// IsModifier extracts whether the key event is for a modifier key.
//
// The function returns the following values:
//
//   - ok: TRUE if the event is for a modifier key.
func (event *KeyEvent) IsModifier() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_key_event_is_modifier(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches a key event against a keyval and modifiers.
//
// This is typically used to trigger keyboard shortcuts such as Ctrl-C.
//
// Partial matches are possible where the combination matches if the currently
// active group is ignored.
//
// Note that we ignore Caps Lock for matching.
//
// The function takes the following parameters:
//
//   - keyval to match.
//   - modifiers to match.
//
// The function returns the following values:
//
//   - keyMatch: GdkKeyMatch value describing whether event matches.
func (event *KeyEvent) Matches(keyval uint, modifiers ModifierType) KeyMatch {
	var _arg0 *C.GdkEvent       // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.GdkKeyMatch     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	_arg1 = C.guint(keyval)
	_arg2 = C.GdkModifierType(modifiers)

	_cret = C.gdk_key_event_matches(_arg0, _arg1, _arg2)
	runtime.KeepAlive(event)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(modifiers)

	var _keyMatch KeyMatch // out

	_keyMatch = KeyMatch(_cret)

	return _keyMatch
}

// MemoryTexture: GdkTexture representing image data in memory.
type MemoryTexture struct {
	_ [0]func() // equal guard
	Texture
}

var (
	_ Texturer = (*MemoryTexture)(nil)
)

func wrapMemoryTexture(obj *coreglib.Object) *MemoryTexture {
	return &MemoryTexture{
		Texture: Texture{
			Object: obj,
			Paintable: Paintable{
				Object: obj,
			},
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		},
	}
}

func marshalMemoryTexture(p uintptr) (interface{}, error) {
	return wrapMemoryTexture(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMemoryTexture creates a new texture for a blob of image data.
//
// The GBytes must contain stride × height pixels in the given format.
//
// The function takes the following parameters:
//
//   - width of the texture.
//   - height of the texture.
//   - format of the data.
//   - bytes: GBytes containing the pixel data.
//   - stride for the data.
//
// The function returns the following values:
//
//   - memoryTexture: newly-created GdkTexture.
func NewMemoryTexture(width, height int, format MemoryFormat, bytes *glib.Bytes, stride uint) *MemoryTexture {
	var _arg1 C.int             // out
	var _arg2 C.int             // out
	var _arg3 C.GdkMemoryFormat // out
	var _arg4 *C.GBytes         // out
	var _arg5 C.gsize           // out
	var _cret *C.GdkTexture     // in

	_arg1 = C.int(width)
	_arg2 = C.int(height)
	_arg3 = C.GdkMemoryFormat(format)
	_arg4 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	_arg5 = C.gsize(stride)

	_cret = C.gdk_memory_texture_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(format)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(stride)

	var _memoryTexture *MemoryTexture // out

	_memoryTexture = wrapMemoryTexture(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _memoryTexture
}

// Monitor: GdkMonitor objects represent the individual outputs that are
// associated with a GdkDisplay.
//
// GdkDisplay keeps a GListModel to enumerate and monitor monitors with
// gdk.Display.GetMonitors(). You can use gdk.Display.GetMonitorAtSurface() to
// find a particular monitor.
type Monitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Monitor)(nil)
)

func wrapMonitor(obj *coreglib.Object) *Monitor {
	return &Monitor{
		Object: obj,
	}
}

func marshalMonitor(p uintptr) (interface{}, error) {
	return wrapMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectInvalidate is emitted when the output represented by monitor gets
// disconnected.
func (monitor *Monitor) ConnectInvalidate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(monitor, "invalidate", false, unsafe.Pointer(C._gotk4_gdk4_Monitor_ConnectInvalidate), f)
}

// Connector gets the name of the monitor's connector, if available.
//
// These are strings such as "eDP-1", or "HDMI-2". They depend on software and
// hardware configuration, and should not be relied on as stable identifiers of
// a specific monitor.
//
// The function returns the following values:
//
//   - utf8 (optional): name of the connector.
func (monitor *Monitor) Connector() string {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_connector(_arg0)
	runtime.KeepAlive(monitor)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Description gets a string describing the monitor, if available.
//
// This can be used to identify a monitor in the UI.
//
// The function returns the following values:
//
//   - utf8 (optional): monitor description.
func (monitor *Monitor) Description() string {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_description(_arg0)
	runtime.KeepAlive(monitor)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Display gets the display that this monitor belongs to.
//
// The function returns the following values:
//
//   - display: display.
func (monitor *Monitor) Display() *Display {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_display(_arg0)
	runtime.KeepAlive(monitor)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// Geometry retrieves the size and position of the monitor within the display
// coordinate space.
//
// The returned geometry is in ”application pixels”, not in ”device pixels” (see
// gdk.Monitor.GetScale()).
//
// The function returns the following values:
//
//   - geometry: GdkRectangle to be filled with the monitor geometry.
func (monitor *Monitor) Geometry() *Rectangle {
	var _arg0 *C.GdkMonitor  // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	C.gdk_monitor_get_geometry(_arg0, &_arg1)
	runtime.KeepAlive(monitor)

	var _geometry *Rectangle // out

	_geometry = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _geometry
}

// HeightMm gets the height in millimeters of the monitor.
//
// The function returns the following values:
//
//   - gint: physical height of the monitor.
func (monitor *Monitor) HeightMm() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_height_mm(_arg0)
	runtime.KeepAlive(monitor)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Manufacturer gets the name or PNP ID of the monitor's manufacturer.
//
// Note that this value might also vary depending on actual display backend.
//
// The PNP ID registry is located at https://uefi.org/pnp_id_list
// (https://uefi.org/pnp_id_list).
//
// The function returns the following values:
//
//   - utf8 (optional): name of the manufacturer.
func (monitor *Monitor) Manufacturer() string {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_manufacturer(_arg0)
	runtime.KeepAlive(monitor)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Model gets the string identifying the monitor model, if available.
//
// The function returns the following values:
//
//   - utf8 (optional): monitor model.
func (monitor *Monitor) Model() string {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_model(_arg0)
	runtime.KeepAlive(monitor)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// RefreshRate gets the refresh rate of the monitor, if available.
//
// The value is in milli-Hertz, so a refresh rate of 60Hz is returned as 60000.
//
// The function returns the following values:
//
//   - gint: refresh rate in milli-Hertz, or 0.
func (monitor *Monitor) RefreshRate() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_refresh_rate(_arg0)
	runtime.KeepAlive(monitor)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Scale gets the internal scale factor that maps from monitor coordinates to
// device pixels.
//
// This can be used if you want to create pixel based data for a particular
// monitor, but most of the time you’re drawing to a surface where it is better
// to use gdk.Surface.GetScale() instead.
//
// The function returns the following values:
//
//   - gdouble: scale.
func (monitor *Monitor) Scale() float64 {
	var _arg0 *C.GdkMonitor // out
	var _cret C.double      // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_scale(_arg0)
	runtime.KeepAlive(monitor)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ScaleFactor gets the internal scale factor that maps from monitor coordinates
// to device pixels.
//
// On traditional systems this is 1, but on very high density outputs it can be
// a higher value (often 2).
//
// This can be used if you want to create pixel based data for a particular
// monitor, but most of the time you’re drawing to a surface where it is better
// to use gdk.Surface.GetScaleFactor() instead.
//
// The function returns the following values:
//
//   - gint: scale factor.
func (monitor *Monitor) ScaleFactor() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_scale_factor(_arg0)
	runtime.KeepAlive(monitor)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SubpixelLayout gets information about the layout of red, green and blue
// primaries for pixels.
//
// The function returns the following values:
//
//   - subpixelLayout: subpixel layout.
func (monitor *Monitor) SubpixelLayout() SubpixelLayout {
	var _arg0 *C.GdkMonitor       // out
	var _cret C.GdkSubpixelLayout // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_subpixel_layout(_arg0)
	runtime.KeepAlive(monitor)

	var _subpixelLayout SubpixelLayout // out

	_subpixelLayout = SubpixelLayout(_cret)

	return _subpixelLayout
}

// WidthMm gets the width in millimeters of the monitor.
//
// The function returns the following values:
//
//   - gint: physical width of the monitor.
func (monitor *Monitor) WidthMm() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_get_width_mm(_arg0)
	runtime.KeepAlive(monitor)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsValid returns TRUE if the monitor object corresponds to a physical monitor.
//
// The monitor becomes invalid when the physical monitor is unplugged or
// removed.
//
// The function returns the following values:
//
//   - ok: TRUE if the object corresponds to a physical monitor.
func (monitor *Monitor) IsValid() bool {
	var _arg0 *C.GdkMonitor // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gdk_monitor_is_valid(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MotionEvent: event related to a pointer or touch device motion.
type MotionEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*MotionEvent)(nil)
)

func wrapMotionEvent(obj *coreglib.Object) *MotionEvent {
	return &MotionEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalMotionEvent(p uintptr) (interface{}, error) {
	return wrapMotionEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// PadEvent: event related to a pad-based device.
type PadEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*PadEvent)(nil)
)

func wrapPadEvent(obj *coreglib.Object) *PadEvent {
	return &PadEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalPadEvent(p uintptr) (interface{}, error) {
	return wrapPadEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AxisValue extracts the information from a pad strip or ring event.
//
// The function returns the following values:
//
//   - index: return location for the axis index.
//   - value: return location for the axis value.
func (event *PadEvent) AxisValue() (uint, float64) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.guint     // in
	var _arg2 C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	C.gdk_pad_event_get_axis_value(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _index uint    // out
	var _value float64 // out

	_index = uint(_arg1)
	_value = float64(_arg2)

	return _index, _value
}

// Button extracts information about the pressed button from a pad event.
//
// The function returns the following values:
//
//   - guint: button of event.
func (event *PadEvent) Button() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_pad_event_get_button(_arg0)
	runtime.KeepAlive(event)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GroupMode extracts group and mode information from a pad event.
//
// The function returns the following values:
//
//   - group: return location for the group.
//   - mode: return location for the mode.
func (event *PadEvent) GroupMode() (group, mode uint) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.guint     // in
	var _arg2 C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	C.gdk_pad_event_get_group_mode(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _group uint // out
	var _mode uint  // out

	_group = uint(_arg1)
	_mode = uint(_arg2)

	return _group, _mode
}

// ProximityEvent: event related to the proximity of a tool to a device.
type ProximityEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*ProximityEvent)(nil)
)

func wrapProximityEvent(obj *coreglib.Object) *ProximityEvent {
	return &ProximityEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalProximityEvent(p uintptr) (interface{}, error) {
	return wrapProximityEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ScrollEvent: event related to a scrolling motion.
type ScrollEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*ScrollEvent)(nil)
)

func wrapScrollEvent(obj *coreglib.Object) *ScrollEvent {
	return &ScrollEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalScrollEvent(p uintptr) (interface{}, error) {
	return wrapScrollEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Deltas extracts the scroll deltas of a scroll event.
//
// The deltas will be zero unless the scroll direction is GDK_SCROLL_SMOOTH.
//
// For the representation unit of these deltas, see gdk.ScrollEvent.GetUnit().
//
// The function returns the following values:
//
//   - deltaX: return location for x scroll delta.
//   - deltaY: return location for y scroll delta.
func (event *ScrollEvent) Deltas() (deltaX, deltaY float64) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.double    // in
	var _arg2 C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	C.gdk_scroll_event_get_deltas(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _deltaX float64 // out
	var _deltaY float64 // out

	_deltaX = float64(_arg1)
	_deltaY = float64(_arg2)

	return _deltaX, _deltaY
}

// Direction extracts the direction of a scroll event.
//
// The function returns the following values:
//
//   - scrollDirection: scroll direction of event.
func (event *ScrollEvent) Direction() ScrollDirection {
	var _arg0 *C.GdkEvent          // out
	var _cret C.GdkScrollDirection // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_scroll_event_get_direction(_arg0)
	runtime.KeepAlive(event)

	var _scrollDirection ScrollDirection // out

	_scrollDirection = ScrollDirection(_cret)

	return _scrollDirection
}

// Unit extracts the scroll delta unit of a scroll event.
//
// The unit will always be GDK_SCROLL_UNIT_WHEEL if the scroll direction is not
// GDK_SCROLL_SMOOTH.
//
// The function returns the following values:
//
//   - scrollUnit: scroll unit.
func (event *ScrollEvent) Unit() ScrollUnit {
	var _arg0 *C.GdkEvent     // out
	var _cret C.GdkScrollUnit // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_scroll_event_get_unit(_arg0)
	runtime.KeepAlive(event)

	var _scrollUnit ScrollUnit // out

	_scrollUnit = ScrollUnit(_cret)

	return _scrollUnit
}

// IsStop: check whether a scroll event is a stop scroll event.
//
// Scroll sequences with smooth scroll information may provide a stop scroll
// event once the interaction with the device finishes, e.g. by lifting a
// finger. This stop scroll event is the signal that a widget may trigger
// kinetic scrolling based on the current velocity.
//
// Stop scroll events always have a delta of 0/0.
//
// The function returns the following values:
//
//   - ok: TRUE if the event is a scroll stop event.
func (event *ScrollEvent) IsStop() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_scroll_event_is_stop(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Seat: GdkSeat object represents a collection of input devices that belong to
// a user.
type Seat struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Seat)(nil)
)

// Seater describes types inherited from class Seat.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Seater interface {
	coreglib.Objector
	baseSeat() *Seat
}

var _ Seater = (*Seat)(nil)

func wrapSeat(obj *coreglib.Object) *Seat {
	return &Seat{
		Object: obj,
	}
}

func marshalSeat(p uintptr) (interface{}, error) {
	return wrapSeat(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (seat *Seat) baseSeat() *Seat {
	return seat
}

// BaseSeat returns the underlying base object.
func BaseSeat(obj Seater) *Seat {
	return obj.baseSeat()
}

// ConnectDeviceAdded is emitted when a new input device is related to this
// seat.
func (seat *Seat) ConnectDeviceAdded(f func(device Devicer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(seat, "device-added", false, unsafe.Pointer(C._gotk4_gdk4_Seat_ConnectDeviceAdded), f)
}

// ConnectDeviceRemoved is emitted when an input device is removed (e.g.
// unplugged).
func (seat *Seat) ConnectDeviceRemoved(f func(device Devicer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(seat, "device-removed", false, unsafe.Pointer(C._gotk4_gdk4_Seat_ConnectDeviceRemoved), f)
}

// ConnectToolAdded is emitted whenever a new tool is made known to the seat.
//
// The tool may later be assigned to a device (i.e. on proximity with a tablet).
// The device will emit the gdk.Device::tool-changed signal accordingly.
//
// A same tool may be used by several devices.
func (seat *Seat) ConnectToolAdded(f func(tool *DeviceTool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(seat, "tool-added", false, unsafe.Pointer(C._gotk4_gdk4_Seat_ConnectToolAdded), f)
}

// ConnectToolRemoved is emitted whenever a tool is no longer known to this
// seat.
func (seat *Seat) ConnectToolRemoved(f func(tool *DeviceTool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(seat, "tool-removed", false, unsafe.Pointer(C._gotk4_gdk4_Seat_ConnectToolRemoved), f)
}

// Capabilities returns the capabilities this GdkSeat currently has.
//
// The function returns the following values:
//
//   - seatCapabilities: seat capabilities.
func (seat *Seat) Capabilities() SeatCapabilities {
	var _arg0 *C.GdkSeat            // out
	var _cret C.GdkSeatCapabilities // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(coreglib.InternObject(seat).Native()))

	_cret = C.gdk_seat_get_capabilities(_arg0)
	runtime.KeepAlive(seat)

	var _seatCapabilities SeatCapabilities // out

	_seatCapabilities = SeatCapabilities(_cret)

	return _seatCapabilities
}

// Devices returns the devices that match the given capabilities.
//
// The function takes the following parameters:
//
//   - capabilities to get devices for.
//
// The function returns the following values:
//
//   - list: list of GdkDevices. The list must be freed with g_list_free(),
//     the elements are owned by GTK and must not be freed.
func (seat *Seat) Devices(capabilities SeatCapabilities) []Devicer {
	var _arg0 *C.GdkSeat            // out
	var _arg1 C.GdkSeatCapabilities // out
	var _cret *C.GList              // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(coreglib.InternObject(seat).Native()))
	_arg1 = C.GdkSeatCapabilities(capabilities)

	_cret = C.gdk_seat_get_devices(_arg0, _arg1)
	runtime.KeepAlive(seat)
	runtime.KeepAlive(capabilities)

	var _list []Devicer // out

	_list = make([]Devicer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GdkDevice)(v)
		var dst Devicer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gdk.Devicer is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// Display returns the GdkDisplay this seat belongs to.
//
// The function returns the following values:
//
//   - display: GdkDisplay. This object is owned by GTK and must not be freed.
func (seat *Seat) Display() *Display {
	var _arg0 *C.GdkSeat    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(coreglib.InternObject(seat).Native()))

	_cret = C.gdk_seat_get_display(_arg0)
	runtime.KeepAlive(seat)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// Keyboard returns the device that routes keyboard events.
//
// The function returns the following values:
//
//   - device (optional): GdkDevice with keyboard capabilities. This object is
//     owned by GTK and must not be freed.
func (seat *Seat) Keyboard() Devicer {
	var _arg0 *C.GdkSeat   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(coreglib.InternObject(seat).Native()))

	_cret = C.gdk_seat_get_keyboard(_arg0)
	runtime.KeepAlive(seat)

	var _device Devicer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// Pointer returns the device that routes pointer events.
//
// The function returns the following values:
//
//   - device (optional): GdkDevice with pointer capabilities. This object is
//     owned by GTK and must not be freed.
func (seat *Seat) Pointer() Devicer {
	var _arg0 *C.GdkSeat   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(coreglib.InternObject(seat).Native()))

	_cret = C.gdk_seat_get_pointer(_arg0)
	runtime.KeepAlive(seat)

	var _device Devicer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// Tools returns all GdkDeviceTools that are known to the application.
//
// The function returns the following values:
//
//   - list: A list of tools. Free with g_list_free().
func (seat *Seat) Tools() []*DeviceTool {
	var _arg0 *C.GdkSeat // out
	var _cret *C.GList   // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(coreglib.InternObject(seat).Native()))

	_cret = C.gdk_seat_get_tools(_arg0)
	runtime.KeepAlive(seat)

	var _list []*DeviceTool // out

	_list = make([]*DeviceTool, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GdkDeviceTool)(v)
		var dst *DeviceTool // out
		dst = wrapDeviceTool(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Snapshot: base type for snapshot operations.
//
// The subclass of GdkSnapshot used by GTK is GtkSnapshot
// (../gtk4/class.Snapshot.html).
type Snapshot struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Snapshot)(nil)
)

// Snapshotter describes types inherited from class Snapshot.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Snapshotter interface {
	coreglib.Objector
	baseSnapshot() *Snapshot
}

var _ Snapshotter = (*Snapshot)(nil)

func wrapSnapshot(obj *coreglib.Object) *Snapshot {
	return &Snapshot{
		Object: obj,
	}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	return wrapSnapshot(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Snapshot) baseSnapshot() *Snapshot {
	return v
}

// BaseSnapshot returns the underlying base object.
func BaseSnapshot(obj Snapshotter) *Snapshot {
	return obj.baseSnapshot()
}

// Surface: GdkSurface is a rectangular region on the screen.
//
// It’s a low-level object, used to implement high-level objects such as
// GtkWindow (../gtk4/class.Window.html).
//
// The surfaces you see in practice are either gdk.Toplevel or gdk.Popup,
// and those interfaces provide much of the required API to interact with these
// surfaces. Other, more specialized surface types exist, but you will rarely
// interact with them directly.
type Surface struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Surface)(nil)
)

// Surfacer describes types inherited from class Surface.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Surfacer interface {
	coreglib.Objector
	baseSurface() *Surface
}

var _ Surfacer = (*Surface)(nil)

func wrapSurface(obj *coreglib.Object) *Surface {
	return &Surface{
		Object: obj,
	}
}

func marshalSurface(p uintptr) (interface{}, error) {
	return wrapSurface(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (surface *Surface) baseSurface() *Surface {
	return surface
}

// BaseSurface returns the underlying base object.
func BaseSurface(obj Surfacer) *Surface {
	return obj.baseSurface()
}

// ConnectEnterMonitor is emitted when surface starts being present on the
// monitor.
func (surface *Surface) ConnectEnterMonitor(f func(monitor *Monitor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(surface, "enter-monitor", false, unsafe.Pointer(C._gotk4_gdk4_Surface_ConnectEnterMonitor), f)
}

// ConnectEvent is emitted when GDK receives an input event for surface.
func (surface *Surface) ConnectEvent(f func(event Eventer) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(surface, "event", false, unsafe.Pointer(C._gotk4_gdk4_Surface_ConnectEvent), f)
}

// ConnectLayout is emitted when the size of surface is changed, or when
// relayout should be performed.
//
// Surface size is reported in ”application pixels”, not ”device pixels” (see
// gdk_surface_get_scale_factor()).
func (surface *Surface) ConnectLayout(f func(width, height int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(surface, "layout", false, unsafe.Pointer(C._gotk4_gdk4_Surface_ConnectLayout), f)
}

// ConnectLeaveMonitor is emitted when surface stops being present on the
// monitor.
func (surface *Surface) ConnectLeaveMonitor(f func(monitor *Monitor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(surface, "leave-monitor", false, unsafe.Pointer(C._gotk4_gdk4_Surface_ConnectLeaveMonitor), f)
}

// ConnectRender is emitted when part of the surface needs to be redrawn.
func (surface *Surface) ConnectRender(f func(region *cairo.Region) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(surface, "render", false, unsafe.Pointer(C._gotk4_gdk4_Surface_ConnectRender), f)
}

// NewSurfacePopup: create a new popup surface.
//
// The surface will be attached to parent and can be positioned relative to it
// using gdk.Popup.Present().
//
// The function takes the following parameters:
//
//   - parent surface to attach the surface to.
//   - autohide: whether to hide the surface on outside clicks.
//
// The function returns the following values:
//
//   - surface: new GdkSurface.
func NewSurfacePopup(parent Surfacer, autohide bool) *Surface {
	var _arg1 *C.GdkSurface // out
	var _arg2 C.gboolean    // out
	var _cret *C.GdkSurface // in

	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	if autohide {
		_arg2 = C.TRUE
	}

	_cret = C.gdk_surface_new_popup(_arg1, _arg2)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(autohide)

	var _surface *Surface // out

	_surface = wrapSurface(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _surface
}

// NewSurfaceToplevel creates a new toplevel surface.
//
// The function takes the following parameters:
//
//   - display to create the surface on.
//
// The function returns the following values:
//
//   - surface: new GdkSurface.
func NewSurfaceToplevel(display *Display) *Surface {
	var _arg1 *C.GdkDisplay // out
	var _cret *C.GdkSurface // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_surface_new_toplevel(_arg1)
	runtime.KeepAlive(display)

	var _surface *Surface // out

	_surface = wrapSurface(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _surface
}

// Beep emits a short beep associated to surface.
//
// If the display of surface does not support per-surface beeps, emits a short
// beep on the display just as gdk.Display.Beep().
func (surface *Surface) Beep() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gdk_surface_beep(_arg0)
	runtime.KeepAlive(surface)
}

// CreateCairoContext creates a new GdkCairoContext for rendering on surface.
//
// The function returns the following values:
//
//   - cairoContext: newly created GdkCairoContext.
func (surface *Surface) CreateCairoContext() CairoContexter {
	var _arg0 *C.GdkSurface      // out
	var _cret *C.GdkCairoContext // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_create_cairo_context(_arg0)
	runtime.KeepAlive(surface)

	var _cairoContext CairoContexter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.CairoContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CairoContexter)
			return ok
		})
		rv, ok := casted.(CairoContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.CairoContexter")
		}
		_cairoContext = rv
	}

	return _cairoContext
}

// CreateGLContext creates a new GdkGLContext for the GdkSurface.
//
// The context is disconnected from any particular surface or surface. If the
// creation of the GdkGLContext failed, error will be set. Before using the
// returned GdkGLContext, you will need to call gdk.GLContext.MakeCurrent() or
// gdk.GLContext.Realize().
//
// The function returns the following values:
//
//   - glContext: newly created GdkGLContext.
func (surface *Surface) CreateGLContext() (GLContexter, error) {
	var _arg0 *C.GdkSurface   // out
	var _cret *C.GdkGLContext // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_create_gl_context(_arg0, &_cerr)
	runtime.KeepAlive(surface)

	var _glContext GLContexter // out
	var _goerr error           // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_glContext = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _glContext, _goerr
}

// CreateSimilarSurface: create a new Cairo surface that is as compatible as
// possible with the given surface.
//
// For example the new surface will have the same fallback resolution and font
// options as surface. Generally, the new surface will also use the same backend
// as surface, unless that is not possible for some reason. The type of the
// returned surface may be examined with cairo_surface_get_type().
//
// Initially the surface contents are all 0 (transparent if contents have
// transparency, black otherwise.)
//
// This function always returns a valid pointer, but it will return a pointer
// to a “nil” surface if other is already in an error state or any other error
// occurs.
//
// Deprecated: Create a suitable cairo image surface yourself.
//
// The function takes the following parameters:
//
//   - content for the new surface.
//   - width of the new surface.
//   - height of the new surface.
//
// The function returns the following values:
//
//   - ret: pointer to the newly allocated surface. The caller owns the surface
//     and should call cairo_surface_destroy() when done with it.
func (surface *Surface) CreateSimilarSurface(content cairo.Content, width, height int) *cairo.Surface {
	var _arg0 *C.GdkSurface      // out
	var _arg1 C.cairo_content_t  // out
	var _arg2 C.int              // out
	var _arg3 C.int              // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg1 = C.cairo_content_t(content)
	_arg2 = C.int(width)
	_arg3 = C.int(height)

	_cret = C.gdk_surface_create_similar_surface(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(content)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _ret *cairo.Surface // out

	_ret = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_ret, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _ret
}

// CreateVulkanContext sets an error and returns NULL.
//
// Deprecated: GTK does not expose any Vulkan internals. This function is a
// leftover that was accidentally exposed.
//
// The function returns the following values:
//
//   - vulkanContext: NULL.
func (surface *Surface) CreateVulkanContext() (VulkanContexter, error) {
	var _arg0 *C.GdkSurface       // out
	var _cret *C.GdkVulkanContext // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_create_vulkan_context(_arg0, &_cerr)
	runtime.KeepAlive(surface)

	var _vulkanContext VulkanContexter // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.VulkanContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(VulkanContexter)
			return ok
		})
		rv, ok := casted.(VulkanContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.VulkanContexter")
		}
		_vulkanContext = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _vulkanContext, _goerr
}

// Destroy destroys the window system resources associated with surface and
// decrements surface's reference count.
//
// The window system resources for all children of surface are also destroyed,
// but the children’s reference counts are not decremented.
//
// Note that a surface will not be destroyed automatically when its reference
// count reaches zero. You must call this function yourself before that happens.
func (surface *Surface) Destroy() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gdk_surface_destroy(_arg0)
	runtime.KeepAlive(surface)
}

// Cursor retrieves a GdkCursor pointer for the cursor currently set on the
// GdkSurface.
//
// If the return value is NULL then there is no custom cursor set on the
// surface, and it is using the cursor for its parent surface.
//
// Use gdk.Surface.SetCursor() to unset the cursor of the surface.
//
// The function returns the following values:
//
//   - cursor (optional): GdkCursor.
func (surface *Surface) Cursor() *Cursor {
	var _arg0 *C.GdkSurface // out
	var _cret *C.GdkCursor  // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_cursor(_arg0)
	runtime.KeepAlive(surface)

	var _cursor *Cursor // out

	if _cret != nil {
		_cursor = wrapCursor(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _cursor
}

// DeviceCursor retrieves a GdkCursor pointer for the device currently set on
// the specified GdkSurface.
//
// If the return value is NULL then there is no custom cursor set on the
// specified surface, and it is using the cursor for its parent surface.
//
// Use gdk.Surface.SetCursor() to unset the cursor of the surface.
//
// The function takes the following parameters:
//
//   - device: pointer GdkDevice.
//
// The function returns the following values:
//
//   - cursor (optional): GdkCursor.
func (surface *Surface) DeviceCursor(device Devicer) *Cursor {
	var _arg0 *C.GdkSurface // out
	var _arg1 *C.GdkDevice  // out
	var _cret *C.GdkCursor  // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_surface_get_device_cursor(_arg0, _arg1)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(device)

	var _cursor *Cursor // out

	if _cret != nil {
		_cursor = wrapCursor(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _cursor
}

// DevicePosition obtains the current device position and modifier state.
//
// The position is given in coordinates relative to the upper left corner of
// surface.
//
// The function takes the following parameters:
//
//   - device: pointer GdkDevice to query to.
//
// The function returns the following values:
//
//   - x (optional): return location for the X coordinate of device.
//   - y (optional): return location for the Y coordinate of device.
//   - mask (optional): return location for the modifier mask.
//   - ok: TRUE if the device is over the surface.
func (surface *Surface) DevicePosition(device Devicer) (x, y float64, mask ModifierType, ok bool) {
	var _arg0 *C.GdkSurface     // out
	var _arg1 *C.GdkDevice      // out
	var _arg2 C.double          // in
	var _arg3 C.double          // in
	var _arg4 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_surface_get_device_position(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(device)

	var _x float64         // out
	var _y float64         // out
	var _mask ModifierType // out
	var _ok bool           // out

	_x = float64(_arg2)
	_y = float64(_arg3)
	_mask = ModifierType(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _mask, _ok
}

// Display gets the GdkDisplay associated with a GdkSurface.
//
// The function returns the following values:
//
//   - display: GdkDisplay associated with surface.
func (surface *Surface) Display() *Display {
	var _arg0 *C.GdkSurface // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_display(_arg0)
	runtime.KeepAlive(surface)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// FrameClock gets the frame clock for the surface.
//
// The frame clock for a surface never changes unless the surface is reparented
// to a new toplevel surface.
//
// The function returns the following values:
//
//   - frameClock: frame clock.
func (surface *Surface) FrameClock() FrameClocker {
	var _arg0 *C.GdkSurface    // out
	var _cret *C.GdkFrameClock // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_frame_clock(_arg0)
	runtime.KeepAlive(surface)

	var _frameClock FrameClocker // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.FrameClocker is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FrameClocker)
			return ok
		})
		rv, ok := casted.(FrameClocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
		}
		_frameClock = rv
	}

	return _frameClock
}

// Height returns the height of the given surface.
//
// Surface size is reported in ”application pixels”, not ”device pixels” (see
// gdk.Surface.GetScaleFactor()).
//
// The function returns the following values:
//
//   - gint: height of surface.
func (surface *Surface) Height() int {
	var _arg0 *C.GdkSurface // out
	var _cret C.int         // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_height(_arg0)
	runtime.KeepAlive(surface)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Mapped checks whether the surface has been mapped.
//
// A surface is mapped with gdk.Toplevel.Present() or gdk.Popup.Present().
//
// The function returns the following values:
//
//   - ok: TRUE if the surface is mapped.
func (surface *Surface) Mapped() bool {
	var _arg0 *C.GdkSurface // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_mapped(_arg0)
	runtime.KeepAlive(surface)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Scale returns the internal scale that maps from surface coordinates to the
// actual device pixels.
//
// When the scale is bigger than 1, the windowing system prefers to get buffers
// with a resolution that is bigger than the surface size (e.g. to show the
// surface on a high-resolution display, or in a magnifier).
//
// Compare with gdk.Surface.GetScaleFactor(), which returns the next larger
// integer.
//
// The scale may change during the lifetime of the surface.
//
// The function returns the following values:
//
//   - gdouble: scale.
func (surface *Surface) Scale() float64 {
	var _arg0 *C.GdkSurface // out
	var _cret C.double      // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_scale(_arg0)
	runtime.KeepAlive(surface)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ScaleFactor returns the internal scale factor that maps from surface
// coordinates to the actual device pixels.
//
// On traditional systems this is 1, but on very high density outputs this
// can be a higher value (often 2). A higher value means that drawing is
// automatically scaled up to a higher resolution, so any code doing drawing
// will automatically look nicer. However, if you are supplying pixel-based data
// the scale value can be used to determine whether to use a pixel resource with
// higher resolution data.
//
// The scale factor may change during the lifetime of the surface.
//
// The function returns the following values:
//
//   - gint: scale factor.
func (surface *Surface) ScaleFactor() int {
	var _arg0 *C.GdkSurface // out
	var _cret C.int         // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_scale_factor(_arg0)
	runtime.KeepAlive(surface)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Width returns the width of the given surface.
//
// Surface size is reported in ”application pixels”, not ”device pixels” (see
// gdk.Surface.GetScaleFactor()).
//
// The function returns the following values:
//
//   - gint: width of surface.
func (surface *Surface) Width() int {
	var _arg0 *C.GdkSurface // out
	var _cret C.int         // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_get_width(_arg0)
	runtime.KeepAlive(surface)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Hide the surface.
//
// For toplevel surfaces, withdraws them, so they will no longer be known
// to the window manager; for all surfaces, unmaps them, so they won’t be
// displayed. Normally done automatically as part of gtk_widget_hide()
// (../gtk4/method.Widget.hide.html).
func (surface *Surface) Hide() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gdk_surface_hide(_arg0)
	runtime.KeepAlive(surface)
}

// IsDestroyed: check to see if a surface is destroyed.
//
// The function returns the following values:
//
//   - ok: TRUE if the surface is destroyed.
func (surface *Surface) IsDestroyed() bool {
	var _arg0 *C.GdkSurface // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gdk_surface_is_destroyed(_arg0)
	runtime.KeepAlive(surface)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueueRender forces a gdk.Surface::render signal emission for surface to be
// scheduled.
//
// This function is useful for implementations that track invalid regions on
// their own.
func (surface *Surface) QueueRender() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gdk_surface_queue_render(_arg0)
	runtime.KeepAlive(surface)
}

// RequestLayout: request a layout phase from the surface's frame clock.
//
// See gdk.FrameClock.RequestPhase().
func (surface *Surface) RequestLayout() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gdk_surface_request_layout(_arg0)
	runtime.KeepAlive(surface)
}

// SetCursor sets the default mouse pointer for a GdkSurface.
//
// Passing NULL for the cursor argument means that surface will use the cursor
// of its parent surface. Most surfaces should use this default. Note that
// cursor must be for the same display as surface.
//
// Use gdk.Cursor.NewFromName or gdk.Cursor.NewFromTexture to create the cursor.
// To make the cursor invisible, use GDK_BLANK_CURSOR.
//
// The function takes the following parameters:
//
//   - cursor (optional): GdkCursor.
func (surface *Surface) SetCursor(cursor *Cursor) {
	var _arg0 *C.GdkSurface // out
	var _arg1 *C.GdkCursor  // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	if cursor != nil {
		_arg1 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))
	}

	C.gdk_surface_set_cursor(_arg0, _arg1)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(cursor)
}

// SetDeviceCursor sets a specific GdkCursor for a given device when it gets
// inside surface.
//
// Passing NULL for the cursor argument means that surface will use the cursor
// of its parent surface. Most surfaces should use this default.
//
// Use gdk.Cursor.NewFromName or gdk.Cursor.NewFromTexture to create the cursor.
// To make the cursor invisible, use GDK_BLANK_CURSOR.
//
// The function takes the following parameters:
//
//   - device: pointer GdkDevice.
//   - cursor: GdkCursor.
func (surface *Surface) SetDeviceCursor(device Devicer, cursor *Cursor) {
	var _arg0 *C.GdkSurface // out
	var _arg1 *C.GdkDevice  // out
	var _arg2 *C.GdkCursor  // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))

	C.gdk_surface_set_device_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(device)
	runtime.KeepAlive(cursor)
}

// SetInputRegion: apply the region to the surface for the purpose of event
// handling.
//
// Mouse events which happen while the pointer position corresponds to an unset
// bit in the mask will be passed on the surface below surface.
//
// An input region is typically used with RGBA surfaces. The alpha channel
// of the surface defines which pixels are invisible and allows for nicely
// antialiased borders, and the input region controls where the surface is
// “clickable”.
//
// Use gdk.Display.SupportsInputShapes() to find out if a particular backend
// supports input regions.
//
// The function takes the following parameters:
//
//   - region of surface to be reactive.
func (surface *Surface) SetInputRegion(region *cairo.Region) {
	var _arg0 *C.GdkSurface     // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_surface_set_input_region(_arg0, _arg1)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(region)
}

// SetOpaqueRegion marks a region of the GdkSurface as opaque.
//
// For optimisation purposes, compositing window managers may like to not draw
// obscured regions of surfaces, or turn off blending during for these regions.
// With RGB windows with no transparency, this is just the shape of the window,
// but with ARGB32 windows, the compositor does not know what regions of the
// window are transparent or not.
//
// This function only works for toplevel surfaces.
//
// GTK will update this property automatically if the surface background is
// opaque, as we know where the opaque regions are. If your surface background
// is not opaque, please update this property in your GtkWidgetClass.css_changed
// (../gtk4/vfunc.Widget.css_changed.html) handler.
//
// The function takes the following parameters:
//
//   - region (optional): region, or NULL to make the entire surface opaque.
func (surface *Surface) SetOpaqueRegion(region *cairo.Region) {
	var _arg0 *C.GdkSurface     // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	if region != nil {
		_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gdk_surface_set_opaque_region(_arg0, _arg1)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(region)
}

// Texture: GdkTexture is the basic element used to refer to pixel data.
//
// It is primarily meant for pixel data that will not change over multiple
// frames, and will be used for a long time.
//
// There are various ways to create GdkTexture objects from a gdkpixbuf.Pixbuf,
// or from bytes stored in memory, a file, or a gio.Resource.
//
// The ownership of the pixel data is transferred to the GdkTexture instance;
// you can only make a copy of it, via gdk.Texture.Download().
//
// GdkTexture is an immutable object: That means you cannot change anything
// about it other than increasing the reference count via gobject.Object.Ref(),
// and consequently, it is a thread-safe object.
type Texture struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Paintable
	gio.LoadableIcon
}

var (
	_ coreglib.Objector = (*Texture)(nil)
)

// Texturer describes types inherited from class Texture.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Texturer interface {
	coreglib.Objector
	baseTexture() *Texture
}

var _ Texturer = (*Texture)(nil)

func wrapTexture(obj *coreglib.Object) *Texture {
	return &Texture{
		Object: obj,
		Paintable: Paintable{
			Object: obj,
		},
		LoadableIcon: gio.LoadableIcon{
			Icon: gio.Icon{
				Object: obj,
			},
		},
	}
}

func marshalTexture(p uintptr) (interface{}, error) {
	return wrapTexture(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *Texture) baseTexture() *Texture {
	return self
}

// BaseTexture returns the underlying base object.
func BaseTexture(obj Texturer) *Texture {
	return obj.baseTexture()
}

// NewTextureForPixbuf creates a new texture object representing the GdkPixbuf.
//
// This function is threadsafe, so that you can e.g. use GTask and
// gio.Task.RunInThread() to avoid blocking the main thread while loading a big
// image.
//
// The function takes the following parameters:
//
//   - pixbuf: GdkPixbuf.
//
// The function returns the following values:
//
//   - texture: new GdkTexture.
func NewTextureForPixbuf(pixbuf *gdkpixbuf.Pixbuf) *Texture {
	var _arg1 *C.GdkPixbuf  // out
	var _cret *C.GdkTexture // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	_cret = C.gdk_texture_new_for_pixbuf(_arg1)
	runtime.KeepAlive(pixbuf)

	var _texture *Texture // out

	_texture = wrapTexture(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _texture
}

// NewTextureFromBytes creates a new texture by loading an image from memory,
//
// The file format is detected automatically. The supported formats are PNG,
// JPEG and TIFF, though more formats might be available.
//
// If NULL is returned, then error will be set.
//
// This function is threadsafe, so that you can e.g. use GTask and
// gio.Task.RunInThread() to avoid blocking the main thread while loading a big
// image.
//
// The function takes the following parameters:
//
//   - bytes: GBytes containing the data to load.
//
// The function returns the following values:
//
//   - texture: newly-created GdkTexture.
func NewTextureFromBytes(bytes *glib.Bytes) (*Texture, error) {
	var _arg1 *C.GBytes     // out
	var _cret *C.GdkTexture // in
	var _cerr *C.GError     // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.gdk_texture_new_from_bytes(_arg1, &_cerr)
	runtime.KeepAlive(bytes)

	var _texture *Texture // out
	var _goerr error      // out

	_texture = wrapTexture(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _texture, _goerr
}

// NewTextureFromFile creates a new texture by loading an image from a file.
//
// The file format is detected automatically. The supported formats are PNG,
// JPEG and TIFF, though more formats might be available.
//
// If NULL is returned, then error will be set.
//
// This function is threadsafe, so that you can e.g. use GTask and
// gio.Task.RunInThread() to avoid blocking the main thread while loading a big
// image.
//
// The function takes the following parameters:
//
//   - file: GFile to load.
//
// The function returns the following values:
//
//   - texture: newly-created GdkTexture.
func NewTextureFromFile(file gio.Filer) (*Texture, error) {
	var _arg1 *C.GFile      // out
	var _cret *C.GdkTexture // in
	var _cerr *C.GError     // in

	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.gdk_texture_new_from_file(_arg1, &_cerr)
	runtime.KeepAlive(file)

	var _texture *Texture // out
	var _goerr error      // out

	_texture = wrapTexture(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _texture, _goerr
}

// NewTextureFromFilename creates a new texture by loading an image from a file.
//
// The file format is detected automatically. The supported formats are PNG,
// JPEG and TIFF, though more formats might be available.
//
// If NULL is returned, then error will be set.
//
// This function is threadsafe, so that you can e.g. use GTask and
// gio.Task.RunInThread() to avoid blocking the main thread while loading a big
// image.
//
// The function takes the following parameters:
//
//   - path: filename to load.
//
// The function returns the following values:
//
//   - texture: newly-created GdkTexture.
func NewTextureFromFilename(path string) (*Texture, error) {
	var _arg1 *C.char       // out
	var _cret *C.GdkTexture // in
	var _cerr *C.GError     // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_texture_new_from_filename(_arg1, &_cerr)
	runtime.KeepAlive(path)

	var _texture *Texture // out
	var _goerr error      // out

	_texture = wrapTexture(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _texture, _goerr
}

// NewTextureFromResource creates a new texture by loading an image from a
// resource.
//
// The file format is detected automatically. The supported formats are PNG and
// JPEG, though more formats might be available.
//
// It is a fatal error if resource_path does not specify a valid image resource
// and the program will abort if that happens. If you are unsure about the
// validity of a resource, use gdk.Texture.NewFromFile to load it.
//
// This function is threadsafe, so that you can e.g. use GTask and
// gio.Task.RunInThread() to avoid blocking the main thread while loading a big
// image.
//
// The function takes the following parameters:
//
//   - resourcePath: path of the resource file.
//
// The function returns the following values:
//
//   - texture: newly-created GdkTexture.
func NewTextureFromResource(resourcePath string) *Texture {
	var _arg1 *C.char       // out
	var _cret *C.GdkTexture // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_texture_new_from_resource(_arg1)
	runtime.KeepAlive(resourcePath)

	var _texture *Texture // out

	_texture = wrapTexture(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _texture
}

// Format gets the memory format most closely associated with the data of the
// texture.
//
// Note that it may not be an exact match for texture data stored on the GPU or
// with compression.
//
// The format can give an indication about the bit depth and opacity of the
// texture and is useful to determine the best format for downloading the
// texture.
//
// The function returns the following values:
//
//   - memoryFormat: preferred format for the texture's data.
func (self *Texture) Format() MemoryFormat {
	var _arg0 *C.GdkTexture     // out
	var _cret C.GdkMemoryFormat // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gdk_texture_get_format(_arg0)
	runtime.KeepAlive(self)

	var _memoryFormat MemoryFormat // out

	_memoryFormat = MemoryFormat(_cret)

	return _memoryFormat
}

// Height returns the height of the texture, in pixels.
//
// The function returns the following values:
//
//   - gint: height of the GdkTexture.
func (texture *Texture) Height() int {
	var _arg0 *C.GdkTexture // out
	var _cret C.int         // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	_cret = C.gdk_texture_get_height(_arg0)
	runtime.KeepAlive(texture)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Width returns the width of texture, in pixels.
//
// The function returns the following values:
//
//   - gint: width of the GdkTexture.
func (texture *Texture) Width() int {
	var _arg0 *C.GdkTexture // out
	var _cret C.int         // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	_cret = C.gdk_texture_get_width(_arg0)
	runtime.KeepAlive(texture)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SaveToPNG: store the given texture to the filename as a PNG file.
//
// This is a utility function intended for debugging and testing.
// If you want more control over formats, proper error handling or
// want to store to a gio.File or other location, you might want to use
// gdk.Texture.SaveToPNGBytes() or look into the gdk-pixbuf library.
//
// The function takes the following parameters:
//
//   - filename to store to.
//
// The function returns the following values:
//
//   - ok: TRUE if saving succeeded, FALSE on failure.
func (texture *Texture) SaveToPNG(filename string) bool {
	var _arg0 *C.GdkTexture // out
	var _arg1 *C.char       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_texture_save_to_png(_arg0, _arg1)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(filename)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SaveToPNGBytes: store the given texture in memory as a PNG file.
//
// Use gdk.Texture.NewFromBytes to read it back.
//
// If you want to serialize a texture, this is a convenient and portable way to
// do that.
//
// If you need more control over the generated image, such as attaching
// metadata, you should look into an image handling library such as the
// gdk-pixbuf library.
//
// If you are dealing with high dynamic range float data, you might also want to
// consider gdk.Texture.SaveToTIFFBytes() instead.
//
// The function returns the following values:
//
//   - bytes: newly allocated GBytes containing PNG data.
func (texture *Texture) SaveToPNGBytes() *glib.Bytes {
	var _arg0 *C.GdkTexture // out
	var _cret *C.GBytes     // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	_cret = C.gdk_texture_save_to_png_bytes(_arg0)
	runtime.KeepAlive(texture)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// SaveToTIFF: store the given texture to the filename as a TIFF file.
//
// GTK will attempt to store data without loss.
//
// The function takes the following parameters:
//
//   - filename to store to.
//
// The function returns the following values:
//
//   - ok: TRUE if saving succeeded, FALSE on failure.
func (texture *Texture) SaveToTIFF(filename string) bool {
	var _arg0 *C.GdkTexture // out
	var _arg1 *C.char       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_texture_save_to_tiff(_arg0, _arg1)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(filename)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SaveToTIFFBytes: store the given texture in memory as a TIFF file.
//
// Use gdk.Texture.NewFromBytes to read it back.
//
// This function is intended to store a representation of the texture's data
// that is as accurate as possible. This is particularly relevant when working
// with high dynamic range images and floating-point texture data.
//
// If that is not your concern and you are interested in a smaller size and a
// more portable format, you might want to use gdk.Texture.SaveToPNGBytes().
//
// The function returns the following values:
//
//   - bytes: newly allocated GBytes containing TIFF data.
func (texture *Texture) SaveToTIFFBytes() *glib.Bytes {
	var _arg0 *C.GdkTexture // out
	var _cret *C.GBytes     // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	_cret = C.gdk_texture_save_to_tiff_bytes(_arg0)
	runtime.KeepAlive(texture)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// TouchEvent: event related to a touch-based device.
type TouchEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*TouchEvent)(nil)
)

func wrapTouchEvent(obj *coreglib.Object) *TouchEvent {
	return &TouchEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalTouchEvent(p uintptr) (interface{}, error) {
	return wrapTouchEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// EmulatingPointer extracts whether a touch event is emulating a pointer event.
//
// The function returns the following values:
//
//   - ok: TRUE if event is emulating.
func (event *TouchEvent) EmulatingPointer() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_touch_event_get_emulating_pointer(_arg0)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TouchpadEvent: event related to a gesture on a touchpad device.
//
// Unlike touchscreens, where the windowing system sends basic sequences of
// begin, update, end events, and leaves gesture recognition to the clients,
// touchpad gestures are typically processed by the system, resulting in these
// events.
type TouchpadEvent struct {
	_ [0]func() // equal guard
	Event
}

var (
	_ Eventer = (*TouchpadEvent)(nil)
)

func wrapTouchpadEvent(obj *coreglib.Object) *TouchpadEvent {
	return &TouchpadEvent{
		Event: Event{
			Object: obj,
		},
	}
}

func marshalTouchpadEvent(p uintptr) (interface{}, error) {
	return wrapTouchpadEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Deltas extracts delta information from a touchpad event.
//
// The function returns the following values:
//
//   - dx: return location for x.
//   - dy: return location for y.
func (event *TouchpadEvent) Deltas() (dx, dy float64) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.double    // in
	var _arg2 C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	C.gdk_touchpad_event_get_deltas(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _dx float64 // out
	var _dy float64 // out

	_dx = float64(_arg1)
	_dy = float64(_arg2)

	return _dx, _dy
}

// GesturePhase extracts the touchpad gesture phase from a touchpad event.
//
// The function returns the following values:
//
//   - touchpadGesturePhase: gesture phase of event.
func (event *TouchpadEvent) GesturePhase() TouchpadGesturePhase {
	var _arg0 *C.GdkEvent               // out
	var _cret C.GdkTouchpadGesturePhase // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_touchpad_event_get_gesture_phase(_arg0)
	runtime.KeepAlive(event)

	var _touchpadGesturePhase TouchpadGesturePhase // out

	_touchpadGesturePhase = TouchpadGesturePhase(_cret)

	return _touchpadGesturePhase
}

// NFingers extracts the number of fingers from a touchpad event.
//
// The function returns the following values:
//
//   - guint: number of fingers for event.
func (event *TouchpadEvent) NFingers() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_touchpad_event_get_n_fingers(_arg0)
	runtime.KeepAlive(event)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PinchAngleDelta extracts the angle delta from a touchpad pinch event.
//
// The function returns the following values:
//
//   - gdouble: angle delta of event.
func (event *TouchpadEvent) PinchAngleDelta() float64 {
	var _arg0 *C.GdkEvent // out
	var _cret C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_touchpad_event_get_pinch_angle_delta(_arg0)
	runtime.KeepAlive(event)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PinchScale extracts the scale from a touchpad pinch event.
//
// The function returns the following values:
//
//   - gdouble: scale of event.
func (event *TouchpadEvent) PinchScale() float64 {
	var _arg0 *C.GdkEvent // out
	var _cret C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gdk_touchpad_event_get_pinch_scale(_arg0)
	runtime.KeepAlive(event)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// VulkanContext: GdkVulkanContext is an object representing the
// platform-specific Vulkan draw context.
//
// GdkVulkanContexts are created for a surface using
// gdk.Surface.CreateVulkanContext(), and the context will match the
// characteristics of the surface.
//
// Support for GdkVulkanContext is platform-specific and context creation can
// fail, returning NULL context.
type VulkanContext struct {
	_ [0]func() // equal guard
	DrawContext

	*coreglib.Object
	gio.Initable
}

var (
	_ DrawContexter     = (*VulkanContext)(nil)
	_ coreglib.Objector = (*VulkanContext)(nil)
)

// VulkanContexter describes types inherited from class VulkanContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type VulkanContexter interface {
	coreglib.Objector
	baseVulkanContext() *VulkanContext
}

var _ VulkanContexter = (*VulkanContext)(nil)

func wrapVulkanContext(obj *coreglib.Object) *VulkanContext {
	return &VulkanContext{
		DrawContext: DrawContext{
			Object: obj,
		},
		Object: obj,
		Initable: gio.Initable{
			Object: obj,
		},
	}
}

func marshalVulkanContext(p uintptr) (interface{}, error) {
	return wrapVulkanContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *VulkanContext) baseVulkanContext() *VulkanContext {
	return v
}

// BaseVulkanContext returns the underlying base object.
func BaseVulkanContext(obj VulkanContexter) *VulkanContext {
	return obj.baseVulkanContext()
}

// ConnectImagesUpdated is emitted when the images managed by this context have
// changed.
//
// Usually this means that the swapchain had to be recreated, for example in
// response to a change of the surface size.
func (v *VulkanContext) ConnectImagesUpdated(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "images-updated", false, unsafe.Pointer(C._gotk4_gdk4_VulkanContext_ConnectImagesUpdated), f)
}

// ContentFormats: GdkContentFormats structure is used to advertise and
// negotiate the format of content.
//
// You will encounter GdkContentFormats when interacting with objects
// controlling operations that pass data between different widgets, window or
// application, like gdk.Drag, gdk.Drop, gdk.Clipboard or gdk.ContentProvider.
//
// GDK supports content in 2 forms: GType and mime type. Using GTypes is
// meant only for in-process content transfers. Mime types are meant to be
// used for data passing both in-process and out-of-process. The details
// of how data is passed is described in the documentation of the actual
// implementations. To transform between the two forms, gdk.ContentSerializer
// and gdk.ContentDeserializer are used.
//
// A GdkContentFormats describes a set of possible formats content can be
// exchanged in. It is assumed that this set is ordered. GTypes are more
// important than mime types. Order between different GTypes or mime types is
// the order they were added in, most important first. Functions that care
// about order, such as gdk.ContentFormats.Union(), will describe in their
// documentation how they interpret that order, though in general the order of
// the first argument is considered the primary order of the result, followed by
// the order of further arguments.
//
// For debugging purposes, the function gdk.ContentFormats.ToString() exists.
// It will print a comma-separated list of formats from most important to least
// important.
//
// GdkContentFormats is an immutable struct. After creation, you cannot change
// the types it represents. Instead, new GdkContentFormats have to be created.
// The gdk.ContentFormatsBuilder structure is meant to help in this endeavor.
//
// An instance of this type is always passed by reference.
type ContentFormats struct {
	*contentFormats
}

// contentFormats is the struct that's finalized.
type contentFormats struct {
	native *C.GdkContentFormats
}

func marshalContentFormats(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ContentFormats{&contentFormats{(*C.GdkContentFormats)(b)}}, nil
}

// NewContentFormats constructs a struct ContentFormats.
func NewContentFormats(mimeTypes []string) *ContentFormats {
	var _arg1 **C.char // out
	var _arg2 C.guint
	var _cret *C.GdkContentFormats // in

	_arg2 = (C.guint)(len(mimeTypes))
	_arg1 = (**C.char)(C.calloc(C.size_t(len(mimeTypes)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.char)(_arg1), len(mimeTypes))
		for i := range mimeTypes {
			out[i] = (*C.char)(unsafe.Pointer(C.CString(mimeTypes[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gdk_content_formats_new(_arg1, _arg2)
	runtime.KeepAlive(mimeTypes)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// NewContentFormatsForGType constructs a struct ContentFormats.
func NewContentFormatsForGType(typ coreglib.Type) *ContentFormats {
	var _arg1 C.GType              // out
	var _cret *C.GdkContentFormats // in

	_arg1 = C.GType(typ)

	_cret = C.gdk_content_formats_new_for_gtype(_arg1)
	runtime.KeepAlive(typ)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// ContainGType checks if a given GType is part of the given formats.
//
// The function takes the following parameters:
//
//   - typ: GType to search for.
//
// The function returns the following values:
//
//   - ok: TRUE if the GType was found.
func (formats *ContentFormats) ContainGType(typ coreglib.Type) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 C.GType              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg1 = C.GType(typ)

	_cret = C.gdk_content_formats_contain_gtype(_arg0, _arg1)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainMIMEType checks if a given mime type is part of the given formats.
//
// The function takes the following parameters:
//
//   - mimeType: mime type to search for.
//
// The function returns the following values:
//
//   - ok: TRUE if the mime_type was found.
func (formats *ContentFormats) ContainMIMEType(mimeType string) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.char              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_content_formats_contain_mime_type(_arg0, _arg1)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(mimeType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GTypes gets the GTypes included in formats.
//
// Note that formats may not contain any GTypes, in particular when they are
// empty. In that case NULL will be returned.
//
// The function returns the following values:
//
//   - gTypes (optional): G_TYPE_INVALID-terminated array of types included in
//     formats.
func (formats *ContentFormats) GTypes() []coreglib.Type {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GType             // in
	var _arg1 C.gsize              // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_content_formats_get_gtypes(_arg0, &_arg1)
	runtime.KeepAlive(formats)

	var _gTypes []coreglib.Type // out

	if _cret != nil {
		{
			src := unsafe.Slice((*C.GType)(_cret), _arg1)
			_gTypes = make([]coreglib.Type, _arg1)
			for i := 0; i < int(_arg1); i++ {
				_gTypes[i] = coreglib.Type(src[i])
			}
		}
	}

	return _gTypes
}

// MIMETypes gets the mime types included in formats.
//
// Note that formats may not contain any mime types, in particular when they are
// empty. In that case NULL will be returned.
//
// The function returns the following values:
//
//   - utf8s (optional): NULL-terminated array of interned strings of mime types
//     included in formats.
func (formats *ContentFormats) MIMETypes() []string {
	var _arg0 *C.GdkContentFormats // out
	var _cret **C.char             // in
	var _arg1 C.gsize              // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_content_formats_get_mime_types(_arg0, &_arg1)
	runtime.KeepAlive(formats)

	var _utf8s []string // out

	if _cret != nil {
		{
			src := unsafe.Slice((**C.char)(_cret), _arg1)
			_utf8s = make([]string, _arg1)
			for i := 0; i < int(_arg1); i++ {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// Match checks if first and second have any matching formats.
//
// The function takes the following parameters:
//
//   - second: GdkContentFormats to intersect with.
//
// The function returns the following values:
//
//   - ok: TRUE if a matching format was found.
func (first *ContentFormats) Match(second *ContentFormats) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(first)))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(second)))

	_cret = C.gdk_content_formats_match(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchGType finds the first GType from first that is also contained in second.
//
// If no matching GType is found, G_TYPE_INVALID is returned.
//
// The function takes the following parameters:
//
//   - second: GdkContentFormats to intersect with.
//
// The function returns the following values:
//
//   - gType: first common GType or G_TYPE_INVALID if none.
func (first *ContentFormats) MatchGType(second *ContentFormats) coreglib.Type {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret C.GType              // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(first)))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(second)))

	_cret = C.gdk_content_formats_match_gtype(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// MatchMIMEType finds the first mime type from first that is also contained in
// second.
//
// If no matching mime type is found, NULL is returned.
//
// The function takes the following parameters:
//
//   - second: GdkContentFormats to intersect with.
//
// The function returns the following values:
//
//   - utf8 (optional): first common mime type or NULL if none.
func (first *ContentFormats) MatchMIMEType(second *ContentFormats) string {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret *C.char              // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(first)))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(second)))

	_cret = C.gdk_content_formats_match_mime_type(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// String prints the given formats into a human-readable string.
//
// The resulting string can be parsed with gdk.ContentFormats().Parse.
//
// This is a small wrapper around gdk.ContentFormats.Print() to help when
// debugging.
//
// The function returns the following values:
//
//   - utf8: new string.
func (formats *ContentFormats) String() string {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.char              // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_content_formats_to_string(_arg0)
	runtime.KeepAlive(formats)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Union: append all missing types from second to first, in the order they had
// in second.
//
// The function takes the following parameters:
//
//   - second: GdkContentFormats to merge from.
//
// The function returns the following values:
//
//   - contentFormats: new GdkContentFormats.
func (first *ContentFormats) Union(second *ContentFormats) *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(first)))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(second)))

	_cret = C.gdk_content_formats_union(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// UnionDeserializeGTypes: add GTypes for mime types in formats for which
// deserializers are registered.
//
// The function returns the following values:
//
//   - contentFormats: new GdkContentFormats.
func (formats *ContentFormats) UnionDeserializeGTypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_content_formats_union_deserialize_gtypes(_arg0)
	runtime.KeepAlive(formats)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// UnionDeserializeMIMETypes: add mime types for GTypes in formats for which
// deserializers are registered.
//
// The function returns the following values:
//
//   - contentFormats: new GdkContentFormats.
func (formats *ContentFormats) UnionDeserializeMIMETypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_content_formats_union_deserialize_mime_types(_arg0)
	runtime.KeepAlive(formats)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// UnionSerializeGTypes: add GTypes for the mime types in formats for which
// serializers are registered.
//
// The function returns the following values:
//
//   - contentFormats: new GdkContentFormats.
func (formats *ContentFormats) UnionSerializeGTypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_content_formats_union_serialize_gtypes(_arg0)
	runtime.KeepAlive(formats)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// UnionSerializeMIMETypes: add mime types for GTypes in formats for which
// serializers are registered.
//
// The function returns the following values:
//
//   - contentFormats: new GdkContentFormats.
func (formats *ContentFormats) UnionSerializeMIMETypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_content_formats_union_serialize_mime_types(_arg0)
	runtime.KeepAlive(formats)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// ContentFormatsParse parses the given string into GdkContentFormats and
// returns the formats.
//
// Strings printed via gdk.ContentFormats.ToString() can be read in again
// successfully using this function.
//
// If string does not describe valid content formats, NULL is returned.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//
// The function returns the following values:
//
//   - contentFormats (optional): content formats if string is valid.
func ContentFormatsParse(str string) *ContentFormats {
	var _arg1 *C.char              // out
	var _cret *C.GdkContentFormats // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_content_formats_parse(_arg1)
	runtime.KeepAlive(str)

	var _contentFormats *ContentFormats // out

	if _cret != nil {
		_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_contentFormats)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
			},
		)
	}

	return _contentFormats
}

// ContentFormatsBuilder: GdkContentFormatsBuilder is an auxiliary struct used
// to create new GdkContentFormats, and should not be kept around.
//
// An instance of this type is always passed by reference.
type ContentFormatsBuilder struct {
	*contentFormatsBuilder
}

// contentFormatsBuilder is the struct that's finalized.
type contentFormatsBuilder struct {
	native *C.GdkContentFormatsBuilder
}

func marshalContentFormatsBuilder(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ContentFormatsBuilder{&contentFormatsBuilder{(*C.GdkContentFormatsBuilder)(b)}}, nil
}

// NewContentFormatsBuilder constructs a struct ContentFormatsBuilder.
func NewContentFormatsBuilder() *ContentFormatsBuilder {
	var _cret *C.GdkContentFormatsBuilder // in

	_cret = C.gdk_content_formats_builder_new()

	var _contentFormatsBuilder *ContentFormatsBuilder // out

	_contentFormatsBuilder = (*ContentFormatsBuilder)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormatsBuilder)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_builder_unref((*C.GdkContentFormatsBuilder)(intern.C))
		},
	)

	return _contentFormatsBuilder
}

// AddFormats appends all formats from formats to builder, skipping those that
// already exist.
//
// The function takes the following parameters:
//
//   - formats to add.
func (builder *ContentFormatsBuilder) AddFormats(formats *ContentFormats) {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _arg1 *C.GdkContentFormats        // out

	_arg0 = (*C.GdkContentFormatsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	C.gdk_content_formats_builder_add_formats(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(formats)
}

// AddGType appends type to builder if it has not already been added.
//
// The function takes the following parameters:
//
//   - typ: GType.
func (builder *ContentFormatsBuilder) AddGType(typ coreglib.Type) {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _arg1 C.GType                     // out

	_arg0 = (*C.GdkContentFormatsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = C.GType(typ)

	C.gdk_content_formats_builder_add_gtype(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typ)
}

// AddMIMEType appends mime_type to builder if it has not already been added.
//
// The function takes the following parameters:
//
//   - mimeType: mime type.
func (builder *ContentFormatsBuilder) AddMIMEType(mimeType string) {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _arg1 *C.char                     // out

	_arg0 = (*C.GdkContentFormatsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_content_formats_builder_add_mime_type(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(mimeType)
}

// ToFormats creates a new GdkContentFormats from the given builder.
//
// The given GdkContentFormatsBuilder is reset once this function returns;
// you cannot call this function multiple times on the same builder instance.
//
// This function is intended primarily for bindings. C code should use
// gdk.ContentFormatsBuilder.FreeToFormats().
//
// The function returns the following values:
//
//   - contentFormats: newly created GdkContentFormats with all the formats
//     added to builder.
func (builder *ContentFormatsBuilder) ToFormats() *ContentFormats {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _cret *C.GdkContentFormats        // in

	_arg0 = (*C.GdkContentFormatsBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	_cret = C.gdk_content_formats_builder_to_formats(_arg0)
	runtime.KeepAlive(builder)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_contentFormats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
		},
	)

	return _contentFormats
}

// ContentProviderClass class structure for GdkContentProvider.
//
// An instance of this type is always passed by reference.
type ContentProviderClass struct {
	*contentProviderClass
}

// contentProviderClass is the struct that's finalized.
type contentProviderClass struct {
	native *C.GdkContentProviderClass
}

// DmabufFormats: GdkDmabufFormats struct provides information about supported
// DMA buffer formats.
//
// You can query whether a given format is supported with
// gdk.DmabufFormats.Contains() and you can iterate over the list
// of all supported formats with gdk.DmabufFormats.GetNFormats() and
// gdk.DmabufFormats.GetFormat().
//
// The list of supported formats is sorted by preference, with the best formats
// coming first.
//
// The list may contains (format, modifier) pairs where the modifier is
// DMA_FORMAT_MOD_INVALID, indicating that **_implicit modifiers_** may be used
// with this format.
//
// See gdk.DmabufTextureBuilder for more information about DMA buffers.
//
// Note that DMA buffers only exist on Linux.
//
// An instance of this type is always passed by reference.
type DmabufFormats struct {
	*dmabufFormats
}

// dmabufFormats is the struct that's finalized.
type dmabufFormats struct {
	native *C.GdkDmabufFormats
}

func marshalDmabufFormats(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DmabufFormats{&dmabufFormats{(*C.GdkDmabufFormats)(b)}}, nil
}

// Contains returns whether a given format is contained in formats.
//
// The function takes the following parameters:
//
//   - fourcc: format code.
//   - modifier: format modifier.
//
// The function returns the following values:
//
//   - ok: TRUE if the format specified by the arguments is part of formats.
func (formats *DmabufFormats) Contains(fourcc uint32, modifier uint64) bool {
	var _arg0 *C.GdkDmabufFormats // out
	var _arg1 C.guint32           // out
	var _arg2 C.guint64           // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GdkDmabufFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg1 = C.guint32(fourcc)
	_arg2 = C.guint64(modifier)

	_cret = C.gdk_dmabuf_formats_contains(_arg0, _arg1, _arg2)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(fourcc)
	runtime.KeepAlive(modifier)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal returns whether formats1 and formats2 contain the same dmabuf formats,
// in the same order.
//
// The function takes the following parameters:
//
//   - formats2 (optional): another GdkDmabufFormats.
//
// The function returns the following values:
//
//   - ok: TRUE if formats1 and formats2 are equal.
func (formats1 *DmabufFormats) Equal(formats2 *DmabufFormats) bool {
	var _arg0 *C.GdkDmabufFormats // out
	var _arg1 *C.GdkDmabufFormats // out
	var _cret C.gboolean          // in

	if formats1 != nil {
		_arg0 = (*C.GdkDmabufFormats)(gextras.StructNative(unsafe.Pointer(formats1)))
	}
	if formats2 != nil {
		_arg1 = (*C.GdkDmabufFormats)(gextras.StructNative(unsafe.Pointer(formats2)))
	}

	_cret = C.gdk_dmabuf_formats_equal(_arg0, _arg1)
	runtime.KeepAlive(formats1)
	runtime.KeepAlive(formats2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Format gets the fourcc code and modifier for a format that is contained in
// formats.
//
// The function takes the following parameters:
//
//   - idx: index of the format to return.
//
// The function returns the following values:
//
//   - fourcc: return location for the format code.
//   - modifier: return location for the format modifier.
func (formats *DmabufFormats) Format(idx uint) (uint32, uint64) {
	var _arg0 *C.GdkDmabufFormats // out
	var _arg1 C.gsize             // out
	var _arg2 C.guint32           // in
	var _arg3 C.guint64           // in

	_arg0 = (*C.GdkDmabufFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg1 = C.gsize(idx)

	C.gdk_dmabuf_formats_get_format(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(idx)

	var _fourcc uint32   // out
	var _modifier uint64 // out

	_fourcc = uint32(_arg2)
	_modifier = uint64(_arg3)

	return _fourcc, _modifier
}

// NFormats returns the number of formats that the formats object contains.
//
// Note that DMA buffers are a Linux concept, so on other platforms,
// gdk.DmabufFormats.GetNFormats() will always return zero.
//
// The function returns the following values:
//
//   - gsize: number of formats.
func (formats *DmabufFormats) NFormats() uint {
	var _arg0 *C.GdkDmabufFormats // out
	var _cret C.gsize             // in

	_arg0 = (*C.GdkDmabufFormats)(gextras.StructNative(unsafe.Pointer(formats)))

	_cret = C.gdk_dmabuf_formats_get_n_formats(_arg0)
	runtime.KeepAlive(formats)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// EventSequence: GdkEventSequence is an opaque type representing a sequence of
// related touch events.
//
// An instance of this type is always passed by reference.
type EventSequence struct {
	*eventSequence
}

// eventSequence is the struct that's finalized.
type eventSequence struct {
	native *C.GdkEventSequence
}

func marshalEventSequence(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &EventSequence{&eventSequence{(*C.GdkEventSequence)(b)}}, nil
}

// FileList: opaque type representing a list of files.
//
// An instance of this type is always passed by reference.
type FileList struct {
	*fileList
}

// fileList is the struct that's finalized.
type fileList struct {
	native *C.GdkFileList
}

func marshalFileList(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FileList{&fileList{(*C.GdkFileList)(b)}}, nil
}

// NewFileListFromArray constructs a struct FileList.
func NewFileListFromArray(files []gio.Filer) *FileList {
	var _arg1 **C.GFile // out
	var _arg2 C.gsize
	var _cret *C.GdkFileList // in

	_arg2 = (C.gsize)(len(files))
	_arg1 = (**C.GFile)(C.calloc(C.size_t(len(files)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GFile)(_arg1), len(files))
		for i := range files {
			out[i] = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(files[i]).Native()))
		}
	}

	_cret = C.gdk_file_list_new_from_array(_arg1, _arg2)
	runtime.KeepAlive(files)

	var _fileList *FileList // out

	_fileList = (*FileList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _fileList
}

// NewFileListFromList constructs a struct FileList.
func NewFileListFromList(files []gio.Filer) *FileList {
	var _arg1 *C.GSList      // out
	var _cret *C.GdkFileList // in

	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_slist_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_slist_free(_arg1)

	_cret = C.gdk_file_list_new_from_list(_arg1)
	runtime.KeepAlive(files)

	var _fileList *FileList // out

	_fileList = (*FileList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _fileList
}

// Files retrieves the list of files inside a GdkFileList.
//
// This function is meant for language bindings.
//
// The function returns the following values:
//
//   - sList files inside the list.
func (fileList *FileList) Files() []*gio.File {
	var _arg0 *C.GdkFileList // out
	var _cret *C.GSList      // in

	_arg0 = (*C.GdkFileList)(gextras.StructNative(unsafe.Pointer(fileList)))

	_cret = C.gdk_file_list_get_files(_arg0)
	runtime.KeepAlive(fileList)

	var _sList []*gio.File // out

	_sList = make([]*gio.File, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GFile)(v)
		var dst *gio.File // out
		{
			obj := coreglib.Take(unsafe.Pointer(src))
			dst = &gio.File{
				Object: obj,
			}
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// FrameTimings: GdkFrameTimings object holds timing information for a single
// frame of the application’s displays.
//
// To retrieve GdkFrameTimings objects, use gdk.FrameClock.GetTimings() or
// gdk.FrameClock.GetCurrentTimings(). The information in GdkFrameTimings is
// useful for precise synchronization of video with the event or audio streams,
// and for measuring quality metrics for the application’s display, such as
// latency and jitter.
//
// An instance of this type is always passed by reference.
type FrameTimings struct {
	*frameTimings
}

// frameTimings is the struct that's finalized.
type frameTimings struct {
	native *C.GdkFrameTimings
}

func marshalFrameTimings(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FrameTimings{&frameTimings{(*C.GdkFrameTimings)(b)}}, nil
}

// Complete returns whether timings are complete.
//
// The timing information in a GdkFrameTimings is filled in incrementally as the
// frame as drawn and passed off to the window system for processing and display
// to the user. The accessor functions for GdkFrameTimings can return 0 to
// indicate an unavailable value for two reasons: either because the information
// is not yet available, or because it isn't available at all.
//
// Once this function returns TRUE for a frame, you can be certain that no
// further values will become available and be stored in the GdkFrameTimings.
//
// The function returns the following values:
//
//   - ok: TRUE if all information that will be available for the frame has been
//     filled in.
func (timings *FrameTimings) Complete() bool {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GdkFrameTimings)(gextras.StructNative(unsafe.Pointer(timings)))

	_cret = C.gdk_frame_timings_get_complete(_arg0)
	runtime.KeepAlive(timings)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FrameCounter gets the frame counter value of the GdkFrameClock when this
// frame was drawn.
//
// The function returns the following values:
//
//   - gint64: frame counter value for this frame.
func (timings *FrameTimings) FrameCounter() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(gextras.StructNative(unsafe.Pointer(timings)))

	_cret = C.gdk_frame_timings_get_frame_counter(_arg0)
	runtime.KeepAlive(timings)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// FrameTime returns the frame time for the frame.
//
// This is the time value that is typically used to time animations for the
// frame. See gdk.FrameClock.GetFrameTime().
//
// The function returns the following values:
//
//   - gint64: frame time for the frame, in the timescale of
//     g_get_monotonic_time().
func (timings *FrameTimings) FrameTime() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(gextras.StructNative(unsafe.Pointer(timings)))

	_cret = C.gdk_frame_timings_get_frame_time(_arg0)
	runtime.KeepAlive(timings)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// PredictedPresentationTime gets the predicted time at which this frame will be
// displayed.
//
// Although no predicted time may be available, if one is available,
// it will be available while the frame is being generated, in contrast to
// gdk.FrameTimings.GetPresentationTime(), which is only available after the
// frame has been presented.
//
// In general, if you are simply animating, you should use
// gdk.FrameClock.GetFrameTime() rather than this function, but this function is
// useful for applications that want exact control over latency. For example,
// a movie player may want this information for Audio/Video synchronization.
//
// The function returns the following values:
//
//   - gint64: predicted time at which the frame will be presented, in the
//     timescale of g_get_monotonic_time(), or 0 if no predicted presentation
//     time is available.
func (timings *FrameTimings) PredictedPresentationTime() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(gextras.StructNative(unsafe.Pointer(timings)))

	_cret = C.gdk_frame_timings_get_predicted_presentation_time(_arg0)
	runtime.KeepAlive(timings)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// PresentationTime reurns the presentation time.
//
// This is the time at which the frame became visible to the user.
//
// The function returns the following values:
//
//   - gint64: time the frame was displayed to the user, in the timescale of
//     g_get_monotonic_time(), or 0 if no presentation time is available.
//     See gdk.FrameTimings.GetComplete().
func (timings *FrameTimings) PresentationTime() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(gextras.StructNative(unsafe.Pointer(timings)))

	_cret = C.gdk_frame_timings_get_presentation_time(_arg0)
	runtime.KeepAlive(timings)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// RefreshInterval gets the natural interval between presentation times for the
// display that this frame was displayed on.
//
// Frame presentation usually happens during the “vertical blanking interval”.
//
// The function returns the following values:
//
//   - gint64: refresh interval of the display, in microseconds, or 0 if the
//     refresh interval is not available. See gdk.FrameTimings.GetComplete().
func (timings *FrameTimings) RefreshInterval() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(gextras.StructNative(unsafe.Pointer(timings)))

	_cret = C.gdk_frame_timings_get_refresh_interval(_arg0)
	runtime.KeepAlive(timings)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// KeymapKey: GdkKeymapKey is a hardware key that can be mapped to a keyval.
//
// An instance of this type is always passed by reference.
type KeymapKey struct {
	*keymapKey
}

// keymapKey is the struct that's finalized.
type keymapKey struct {
	native *C.GdkKeymapKey
}

// NewKeymapKey creates a new KeymapKey instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewKeymapKey(keycode uint, group, level int) KeymapKey {
	var f0 C.guint // out
	f0 = C.guint(keycode)
	var f1 C.int // out
	f1 = C.int(group)
	var f2 C.int // out
	f2 = C.int(level)

	v := C.GdkKeymapKey{
		keycode: f0,
		group:   f1,
		level:   f2,
	}

	return *(*KeymapKey)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Keycode: hardware keycode. This is an identifying number for a physical key.
func (k *KeymapKey) Keycode() uint {
	valptr := &k.native.keycode
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Group indicates movement in a horizontal direction. Usually groups are
// used for two different languages. In group 0, a key might have two English
// characters, and in group 1 it might have two Hebrew characters. The Hebrew
// characters will be printed on the key next to the English characters.
func (k *KeymapKey) Group() int {
	valptr := &k.native.group
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Level indicates which symbol on the key will be used, in a vertical
// direction. So on a standard US keyboard, the key with the number “1” on it
// also has the exclamation point ("!") character on it. The level indicates
// whether to use the “1” or the “!” symbol. The letter keys are considered
// to have a lowercase letter at level 0, and an uppercase letter at level 1,
// though only the uppercase letter is printed.
func (k *KeymapKey) Level() int {
	valptr := &k.native.level
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Keycode: hardware keycode. This is an identifying number for a physical key.
func (k *KeymapKey) SetKeycode(keycode uint) {
	valptr := &k.native.keycode
	*valptr = C.guint(keycode)
}

// Group indicates movement in a horizontal direction. Usually groups are
// used for two different languages. In group 0, a key might have two English
// characters, and in group 1 it might have two Hebrew characters. The Hebrew
// characters will be printed on the key next to the English characters.
func (k *KeymapKey) SetGroup(group int) {
	valptr := &k.native.group
	*valptr = C.int(group)
}

// Level indicates which symbol on the key will be used, in a vertical
// direction. So on a standard US keyboard, the key with the number “1” on it
// also has the exclamation point ("!") character on it. The level indicates
// whether to use the “1” or the “!” symbol. The letter keys are considered
// to have a lowercase letter at level 0, and an uppercase letter at level 1,
// though only the uppercase letter is printed.
func (k *KeymapKey) SetLevel(level int) {
	valptr := &k.native.level
	*valptr = C.int(level)
}

// PaintableInterface: list of functions that can be implemented for the
// GdkPaintable interface.
//
// Note that apart from the gdk.Paintable.Snapshot() function, no virtual
// function of this interface is mandatory to implement, though it is a good
// idea to implement gdk.Paintable.GetCurrentImage() for non-static paintables
// and gdk.Paintable.GetFlags() if the image is not dynamic as the default
// implementation returns no flags and that will make the implementation likely
// quite slow.
//
// An instance of this type is always passed by reference.
type PaintableInterface struct {
	*paintableInterface
}

// paintableInterface is the struct that's finalized.
type paintableInterface struct {
	native *C.GdkPaintableInterface
}

// PopupLayout: GdkPopupLayout struct contains information that is necessary
// position a gdk.Popup relative to its parent.
//
// The positioning requires a negotiation with the windowing system, since it
// depends on external constraints, such as the position of the parent surface,
// and the screen dimensions.
//
// The basic ingredients are a rectangle on the parent surface, and the anchor
// on both that rectangle and the popup. The anchors specify a side or corner to
// place next to each other.
//
// !Popup anchors (popup-anchors.png)
//
// For cases where placing the anchors next to each other would make the popup
// extend offscreen, the layout includes some hints for how to resolve this
// problem. The hints may suggest to flip the anchor position to the other side,
// or to 'slide' the popup along a side, or to resize it.
//
// !Flipping popups (popup-flip.png)
//
// !Sliding popups (popup-slide.png)
//
// These hints may be combined.
//
// Ultimatively, it is up to the windowing system to determine the position
// and size of the popup. You can learn about the result by calling
// gdk.Popup.GetPositionX(), gdk.Popup.GetPositionY(), gdk.Popup.GetRectAnchor()
// and gdk.Popup.GetSurfaceAnchor() after the popup has been presented.
// This can be used to adjust the rendering. For example, GtkPopover
// (../gtk4/class.Popover.html) changes its arrow position accordingly. But you
// have to be careful avoid changing the size of the popover, or it has to be
// presented again.
//
// An instance of this type is always passed by reference.
type PopupLayout struct {
	*popupLayout
}

// popupLayout is the struct that's finalized.
type popupLayout struct {
	native *C.GdkPopupLayout
}

func marshalPopupLayout(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &PopupLayout{&popupLayout{(*C.GdkPopupLayout)(b)}}, nil
}

// NewPopupLayout constructs a struct PopupLayout.
func NewPopupLayout(anchorRect *Rectangle, rectAnchor Gravity, surfaceAnchor Gravity) *PopupLayout {
	var _arg1 *C.GdkRectangle   // out
	var _arg2 C.GdkGravity      // out
	var _arg3 C.GdkGravity      // out
	var _cret *C.GdkPopupLayout // in

	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(anchorRect)))
	_arg2 = C.GdkGravity(rectAnchor)
	_arg3 = C.GdkGravity(surfaceAnchor)

	_cret = C.gdk_popup_layout_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(anchorRect)
	runtime.KeepAlive(rectAnchor)
	runtime.KeepAlive(surfaceAnchor)

	var _popupLayout *PopupLayout // out

	_popupLayout = (*PopupLayout)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_popupLayout)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_popup_layout_unref((*C.GdkPopupLayout)(intern.C))
		},
	)

	return _popupLayout
}

// Copy makes a copy of layout.
//
// The function returns the following values:
//
//   - popupLayout: copy of layout.
func (layout *PopupLayout) Copy() *PopupLayout {
	var _arg0 *C.GdkPopupLayout // out
	var _cret *C.GdkPopupLayout // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_popup_layout_copy(_arg0)
	runtime.KeepAlive(layout)

	var _popupLayout *PopupLayout // out

	_popupLayout = (*PopupLayout)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_popupLayout)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_popup_layout_unref((*C.GdkPopupLayout)(intern.C))
		},
	)

	return _popupLayout
}

// Equal: check whether layout and other has identical layout properties.
//
// The function takes the following parameters:
//
//   - other GdkPopupLayout.
//
// The function returns the following values:
//
//   - ok: TRUE if layout and other have identical layout properties, otherwise
//     FALSE.
func (layout *PopupLayout) Equal(other *PopupLayout) bool {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 *C.GdkPopupLayout // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(other)))

	_cret = C.gdk_popup_layout_equal(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(other)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AnchorHints: get the GdkAnchorHints.
//
// The function returns the following values:
//
//   - anchorHints: GdkAnchorHints.
func (layout *PopupLayout) AnchorHints() AnchorHints {
	var _arg0 *C.GdkPopupLayout // out
	var _cret C.GdkAnchorHints  // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_popup_layout_get_anchor_hints(_arg0)
	runtime.KeepAlive(layout)

	var _anchorHints AnchorHints // out

	_anchorHints = AnchorHints(_cret)

	return _anchorHints
}

// AnchorRect: get the anchor rectangle.
//
// The function returns the following values:
//
//   - rectangle: anchor rectangle.
func (layout *PopupLayout) AnchorRect() *Rectangle {
	var _arg0 *C.GdkPopupLayout // out
	var _cret *C.GdkRectangle   // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_popup_layout_get_anchor_rect(_arg0)
	runtime.KeepAlive(layout)

	var _rectangle *Rectangle // out

	_rectangle = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rectangle
}

// Offset retrieves the offset for the anchor rectangle.
//
// The function returns the following values:
//
//   - dx: return location for the delta X coordinate.
//   - dy: return location for the delta Y coordinate.
func (layout *PopupLayout) Offset() (dx int, dy int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // in
	var _arg2 C.int             // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	C.gdk_popup_layout_get_offset(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _dx int // out
	var _dy int // out

	_dx = int(_arg1)
	_dy = int(_arg2)

	return _dx, _dy
}

// RectAnchor returns the anchor position on the anchor rectangle.
//
// The function returns the following values:
//
//   - gravity: anchor on the anchor rectangle.
func (layout *PopupLayout) RectAnchor() Gravity {
	var _arg0 *C.GdkPopupLayout // out
	var _cret C.GdkGravity      // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_popup_layout_get_rect_anchor(_arg0)
	runtime.KeepAlive(layout)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// ShadowWidth obtains the shadow widths of this layout.
//
// The function returns the following values:
//
//   - left: return location for the left shadow width.
//   - right: return location for the right shadow width.
//   - top: return location for the top shadow width.
//   - bottom: return location for the bottom shadow width.
func (layout *PopupLayout) ShadowWidth() (left int, right int, top int, bottom int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // in
	var _arg2 C.int             // in
	var _arg3 C.int             // in
	var _arg4 C.int             // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	C.gdk_popup_layout_get_shadow_width(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(layout)

	var _left int   // out
	var _right int  // out
	var _top int    // out
	var _bottom int // out

	_left = int(_arg1)
	_right = int(_arg2)
	_top = int(_arg3)
	_bottom = int(_arg4)

	return _left, _right, _top, _bottom
}

// SurfaceAnchor returns the anchor position on the popup surface.
//
// The function returns the following values:
//
//   - gravity: anchor on the popup surface.
func (layout *PopupLayout) SurfaceAnchor() Gravity {
	var _arg0 *C.GdkPopupLayout // out
	var _cret C.GdkGravity      // in

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_popup_layout_get_surface_anchor(_arg0)
	runtime.KeepAlive(layout)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// SetAnchorHints: set new anchor hints.
//
// The set anchor_hints determines how surface will be moved if the anchor
// points cause it to move off-screen. For example, GDK_ANCHOR_FLIP_X will
// replace GDK_GRAVITY_NORTH_WEST with GDK_GRAVITY_NORTH_EAST and vice versa if
// surface extends beyond the left or right edges of the monitor.
//
// The function takes the following parameters:
//
//   - anchorHints: new GdkAnchorHints.
func (layout *PopupLayout) SetAnchorHints(anchorHints AnchorHints) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.GdkAnchorHints  // out

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = C.GdkAnchorHints(anchorHints)

	C.gdk_popup_layout_set_anchor_hints(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(anchorHints)
}

// SetAnchorRect: set the anchor rectangle.
//
// The function takes the following parameters:
//
//   - anchorRect: new anchor rectangle.
func (layout *PopupLayout) SetAnchorRect(anchorRect *Rectangle) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 *C.GdkRectangle   // out

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(anchorRect)))

	C.gdk_popup_layout_set_anchor_rect(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(anchorRect)
}

// SetOffset: offset the position of the anchor rectangle with the given delta.
//
// The function takes the following parameters:
//
//   - dx: x delta to offset the anchor rectangle with.
//   - dy: y delta to offset the anchor rectangle with.
func (layout *PopupLayout) SetOffset(dx int, dy int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = C.int(dx)
	_arg2 = C.int(dy)

	C.gdk_popup_layout_set_offset(_arg0, _arg1, _arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
}

// SetRectAnchor: set the anchor on the anchor rectangle.
//
// The function takes the following parameters:
//
//   - anchor: new rect anchor.
func (layout *PopupLayout) SetRectAnchor(anchor Gravity) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.GdkGravity      // out

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = C.GdkGravity(anchor)

	C.gdk_popup_layout_set_rect_anchor(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(anchor)
}

// SetShadowWidth sets the shadow width of the popup.
//
// The shadow width corresponds to the part of the computed surface size that
// would consist of the shadow margin surrounding the window, would there be
// any.
//
// The function takes the following parameters:
//
//   - left: width of the left part of the shadow.
//   - right: width of the right part of the shadow.
//   - top: height of the top part of the shadow.
//   - bottom: height of the bottom part of the shadow.
func (layout *PopupLayout) SetShadowWidth(left int, right int, top int, bottom int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = C.int(left)
	_arg2 = C.int(right)
	_arg3 = C.int(top)
	_arg4 = C.int(bottom)

	C.gdk_popup_layout_set_shadow_width(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(left)
	runtime.KeepAlive(right)
	runtime.KeepAlive(top)
	runtime.KeepAlive(bottom)
}

// SetSurfaceAnchor: set the anchor on the popup surface.
//
// The function takes the following parameters:
//
//   - anchor: new popup surface anchor.
func (layout *PopupLayout) SetSurfaceAnchor(anchor Gravity) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.GdkGravity      // out

	_arg0 = (*C.GdkPopupLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = C.GdkGravity(anchor)

	C.gdk_popup_layout_set_surface_anchor(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(anchor)
}

// RGBA: GdkRGBA is used to represent a color, in a way that is compatible with
// cairo’s notion of color.
//
// GdkRGBA is a convenient way to pass colors around. It’s based on cairo’s way
// to deal with colors and mirrors its behavior. All values are in the range
// from 0.0 to 1.0 inclusive. So the color (0.0, 0.0, 0.0, 0.0) represents
// transparent black and (1.0, 1.0, 1.0, 1.0) is opaque white. Other values will
// be clamped to this range when drawing.
//
// An instance of this type is always passed by reference.
type RGBA struct {
	*rgbA
}

// rgbA is the struct that's finalized.
type rgbA struct {
	native *C.GdkRGBA
}

func marshalRGBA(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &RGBA{&rgbA{(*C.GdkRGBA)(b)}}, nil
}

// NewRGBA creates a new RGBA instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewRGBA(red, green, blue, alpha float32) RGBA {
	var f0 C.float // out
	f0 = C.float(red)
	var f1 C.float // out
	f1 = C.float(green)
	var f2 C.float // out
	f2 = C.float(blue)
	var f3 C.float // out
	f3 = C.float(alpha)

	v := C.GdkRGBA{
		red:   f0,
		green: f1,
		blue:  f2,
		alpha: f3,
	}

	return *(*RGBA)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Red: intensity of the red channel from 0.0 to 1.0 inclusive.
func (r *RGBA) Red() float32 {
	valptr := &r.native.red
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Green: intensity of the green channel from 0.0 to 1.0 inclusive.
func (r *RGBA) Green() float32 {
	valptr := &r.native.green
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Blue: intensity of the blue channel from 0.0 to 1.0 inclusive.
func (r *RGBA) Blue() float32 {
	valptr := &r.native.blue
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Alpha: opacity of the color from 0.0 for completely translucent to 1.0 for
// opaque.
func (r *RGBA) Alpha() float32 {
	valptr := &r.native.alpha
	var _v float32 // out
	_v = float32(*valptr)
	return _v
}

// Red: intensity of the red channel from 0.0 to 1.0 inclusive.
func (r *RGBA) SetRed(red float32) {
	valptr := &r.native.red
	*valptr = C.float(red)
}

// Green: intensity of the green channel from 0.0 to 1.0 inclusive.
func (r *RGBA) SetGreen(green float32) {
	valptr := &r.native.green
	*valptr = C.float(green)
}

// Blue: intensity of the blue channel from 0.0 to 1.0 inclusive.
func (r *RGBA) SetBlue(blue float32) {
	valptr := &r.native.blue
	*valptr = C.float(blue)
}

// Alpha: opacity of the color from 0.0 for completely translucent to 1.0 for
// opaque.
func (r *RGBA) SetAlpha(alpha float32) {
	valptr := &r.native.alpha
	*valptr = C.float(alpha)
}

// Copy makes a copy of a GdkRGBA.
//
// The result must be freed through gdk.RGBA.Free().
//
// The function returns the following values:
//
//   - rgbA: newly allocated GdkRGBA, with the same contents as rgba.
func (rgba *RGBA) Copy() *RGBA {
	var _arg0 *C.GdkRGBA // out
	var _cret *C.GdkRGBA // in

	_arg0 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	_cret = C.gdk_rgba_copy(_arg0)
	runtime.KeepAlive(rgba)

	var _rgbA *RGBA // out

	_rgbA = (*RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_rgbA)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_rgba_free((*C.GdkRGBA)(intern.C))
		},
	)

	return _rgbA
}

// Equal compares two GdkRGBA colors.
//
// The function takes the following parameters:
//
//   - p2: another GdkRGBA.
//
// The function returns the following values:
//
//   - ok: TRUE if the two colors compare equal.
func (p1 *RGBA) Equal(p2 *RGBA) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(p1)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(p2)))

	_cret = C.gdk_rgba_equal(_arg0, _arg1)
	runtime.KeepAlive(p1)
	runtime.KeepAlive(p2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash: hash function suitable for using for a hash table that stores GdkRGBAs.
//
// The function returns the following values:
//
//   - guint: hash value for p.
func (p *RGBA) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(p)))

	_cret = C.gdk_rgba_hash(_arg0)
	runtime.KeepAlive(p)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsClear checks if an rgba value is transparent.
//
// That is, drawing with the value would not produce any change.
//
// The function returns the following values:
//
//   - ok: TRUE if the rgba is clear.
func (rgba *RGBA) IsClear() bool {
	var _arg0 *C.GdkRGBA // out
	var _cret C.gboolean // in

	_arg0 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	_cret = C.gdk_rgba_is_clear(_arg0)
	runtime.KeepAlive(rgba)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsOpaque checks if an rgba value is opaque.
//
// That is, drawing with the value will not retain any results from previous
// contents.
//
// The function returns the following values:
//
//   - ok: TRUE if the rgba is opaque.
func (rgba *RGBA) IsOpaque() bool {
	var _arg0 *C.GdkRGBA // out
	var _cret C.gboolean // in

	_arg0 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	_cret = C.gdk_rgba_is_opaque(_arg0)
	runtime.KeepAlive(rgba)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Parse parses a textual representation of a color.
//
// The string can be either one of:
//
// - A standard name (Taken from the CSS specification).
//
// - A hexadecimal value in the form “\#rgb”, “\#rrggbb”, “\#rrrgggbbb” or
// ”\#rrrrggggbbbb”
//
// - A hexadecimal value in the form “\#rgba”, “\#rrggbbaa”, or
// ”\#rrrrggggbbbbaaaa”
//
// - A RGB color in the form “rgb(r,g,b)” (In this case the color will have full
// opacity)
//
// - A RGBA color in the form “rgba(r,g,b,a)”
//
// - A HSL color in the form "hsl(hue, saturation, lightness)"
//
// - A HSLA color in the form "hsla(hue, saturation, lightness, alpha)"
//
// Where “r”, “g”, “b” and “a” are respectively the red, green, blue and alpha
// color values. In the last two cases, “r”, “g”, and “b” are either integers in
// the range 0 to 255 or percentage values in the range 0% to 100%, and a is a
// floating point value in the range 0 to 1.
//
// The function takes the following parameters:
//
//   - spec: string specifying the color.
//
// The function returns the following values:
//
//   - ok: TRUE if the parsing succeeded.
func (rgba *RGBA) Parse(spec string) bool {
	var _arg0 *C.GdkRGBA // out
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(spec)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_rgba_parse(_arg0, _arg1)
	runtime.KeepAlive(rgba)
	runtime.KeepAlive(spec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String returns a textual specification of rgba in the form rgb(r,g,b) or
// rgba(r,g,b,a), where “r”, “g”, “b” and “a” represent the red, green, blue and
// alpha values respectively. “r”, “g”, and “b” are represented as integers in
// the range 0 to 255, and “a” is represented as a floating point value in the
// range 0 to 1.
//
// These string forms are string forms that are supported by the CSS3 colors
// module, and can be parsed by gdk.RGBA.Parse().
//
// Note that this string representation may lose some precision, since “r”,
// “g” and “b” are represented as 8-bit integers. If this is a concern,
// you should use a different representation.
//
// The function returns the following values:
//
//   - utf8: newly allocated text string.
func (rgba *RGBA) String() string {
	var _arg0 *C.GdkRGBA // out
	var _cret *C.char    // in

	_arg0 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	_cret = C.gdk_rgba_to_string(_arg0)
	runtime.KeepAlive(rgba)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Rectangle: GdkRectangle data type for representing rectangles.
//
// GdkRectangle is identical to cairo_rectangle_t. Together with Cairo’s
// cairo_region_t data type, these are the central types for representing sets
// of pixels.
//
// The intersection of two rectangles can be computed with
// gdk.Rectangle.Intersect(); to find the union of two rectangles use
// gdk.Rectangle.Union().
//
// The cairo_region_t type provided by Cairo is usually used for managing
// non-rectangular clipping of graphical operations.
//
// The Graphene library has a number of other data types for regions and volumes
// in 2D and 3D.
//
// An instance of this type is always passed by reference.
type Rectangle struct {
	*rectangle
}

// rectangle is the struct that's finalized.
type rectangle struct {
	native *C.GdkRectangle
}

func marshalRectangle(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Rectangle{&rectangle{(*C.GdkRectangle)(b)}}, nil
}

// NewRectangle creates a new Rectangle instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewRectangle(x, y, width, height int) Rectangle {
	var f0 C.int // out
	f0 = C.int(x)
	var f1 C.int // out
	f1 = C.int(y)
	var f2 C.int // out
	f2 = C.int(width)
	var f3 C.int // out
	f3 = C.int(height)

	v := C.GdkRectangle{
		x:      f0,
		y:      f1,
		width:  f2,
		height: f3,
	}

	return *(*Rectangle)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// X: x coordinate of the top left corner.
func (r *Rectangle) X() int {
	valptr := &r.native.x
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Y: y coordinate of the top left corner.
func (r *Rectangle) Y() int {
	valptr := &r.native.y
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width: width of the rectangle.
func (r *Rectangle) Width() int {
	valptr := &r.native.width
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height: height of the rectangle.
func (r *Rectangle) Height() int {
	valptr := &r.native.height
	var _v int // out
	_v = int(*valptr)
	return _v
}

// X: x coordinate of the top left corner.
func (r *Rectangle) SetX(x int) {
	valptr := &r.native.x
	*valptr = C.int(x)
}

// Y: y coordinate of the top left corner.
func (r *Rectangle) SetY(y int) {
	valptr := &r.native.y
	*valptr = C.int(y)
}

// Width: width of the rectangle.
func (r *Rectangle) SetWidth(width int) {
	valptr := &r.native.width
	*valptr = C.int(width)
}

// Height: height of the rectangle.
func (r *Rectangle) SetHeight(height int) {
	valptr := &r.native.height
	*valptr = C.int(height)
}

// ContainsPoint returns TRUE if rect contains the point described by x and y.
//
// The function takes the following parameters:
//
//   - x: x coordinate.
//   - y: y coordinate.
//
// The function returns the following values:
//
//   - ok: TRUE if rect contains the point.
func (rect *Rectangle) ContainsPoint(x int, y int) bool {
	var _arg0 *C.GdkRectangle // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(rect)))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gdk_rectangle_contains_point(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rect)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal checks if the two given rectangles are equal.
//
// The function takes the following parameters:
//
//   - rect2: GdkRectangle.
//
// The function returns the following values:
//
//   - ok: TRUE if the rectangles are equal.
func (rect1 *Rectangle) Equal(rect2 *Rectangle) bool {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(rect1)))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(rect2)))

	_cret = C.gdk_rectangle_equal(_arg0, _arg1)
	runtime.KeepAlive(rect1)
	runtime.KeepAlive(rect2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Intersect calculates the intersection of two rectangles.
//
// It is allowed for dest to be the same as either src1 or src2. If the
// rectangles do not intersect, dest’s width and height is set to 0 and its
// x and y values are undefined. If you are only interested in whether the
// rectangles intersect, but not in the intersecting area itself, pass NULL for
// dest.
//
// The function takes the following parameters:
//
//   - src2: GdkRectangle.
//
// The function returns the following values:
//
//   - dest (optional): return location for the intersection of src1 and src2.
//   - ok: TRUE if the rectangles intersect.
func (src1 *Rectangle) Intersect(src2 *Rectangle) (*Rectangle, bool) {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out
	var _arg2 C.GdkRectangle  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(src1)))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(src2)))

	_cret = C.gdk_rectangle_intersect(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(src1)
	runtime.KeepAlive(src2)

	var _dest *Rectangle // out
	var _ok bool         // out

	_dest = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// Union calculates the union of two rectangles.
//
// The union of rectangles src1 and src2 is the smallest rectangle which
// includes both src1 and src2 within it. It is allowed for dest to be the same
// as either src1 or src2.
//
// Note that this function does not ignore 'empty' rectangles (ie. with zero
// width or height).
//
// The function takes the following parameters:
//
//   - src2: GdkRectangle.
//
// The function returns the following values:
//
//   - dest: return location for the union of src1 and src2.
func (src1 *Rectangle) Union(src2 *Rectangle) *Rectangle {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out
	var _arg2 C.GdkRectangle  // in

	_arg0 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(src1)))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(src2)))

	C.gdk_rectangle_union(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(src1)
	runtime.KeepAlive(src2)

	var _dest *Rectangle // out

	_dest = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _dest
}

// TextureDownloader: GdkTextureDownloader is used to download the contents of a
// gdk.Texture.
//
// It is intended to be created as a short-term object for a single download,
// but can be used for multiple downloads of different textures or with
// different settings.
//
// GdkTextureDownloader can be used to convert data between different formats.
// Create a GdkTexture for the existing format and then download it in a
// different format.
//
// An instance of this type is always passed by reference.
type TextureDownloader struct {
	*textureDownloader
}

// textureDownloader is the struct that's finalized.
type textureDownloader struct {
	native *C.GdkTextureDownloader
}

func marshalTextureDownloader(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TextureDownloader{&textureDownloader{(*C.GdkTextureDownloader)(b)}}, nil
}

// NewTextureDownloader constructs a struct TextureDownloader.
func NewTextureDownloader(texture Texturer) *TextureDownloader {
	var _arg1 *C.GdkTexture           // out
	var _cret *C.GdkTextureDownloader // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	_cret = C.gdk_texture_downloader_new(_arg1)
	runtime.KeepAlive(texture)

	var _textureDownloader *TextureDownloader // out

	_textureDownloader = (*TextureDownloader)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_textureDownloader)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_texture_downloader_free((*C.GdkTextureDownloader)(intern.C))
		},
	)

	return _textureDownloader
}

// Copy creates a copy of the downloader.
//
// This function is meant for language bindings.
//
// The function returns the following values:
//
//   - textureDownloader: copy of the downloader.
func (self *TextureDownloader) Copy() *TextureDownloader {
	var _arg0 *C.GdkTextureDownloader // out
	var _cret *C.GdkTextureDownloader // in

	_arg0 = (*C.GdkTextureDownloader)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gdk_texture_downloader_copy(_arg0)
	runtime.KeepAlive(self)

	var _textureDownloader *TextureDownloader // out

	_textureDownloader = (*TextureDownloader)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_textureDownloader)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_texture_downloader_free((*C.GdkTextureDownloader)(intern.C))
		},
	)

	return _textureDownloader
}

// DownloadBytes downloads the given texture pixels into a GBytes. The rowstride
// will be stored in the stride value.
//
// This function will abort if it tries to download a large texture and fails
// to allocate memory. If you think that may happen, you should handle memory
// allocation yourself and use gdk.TextureDownloader.DownloadInto() once
// allocation succeeded.
//
// The function returns the following values:
//
//   - outStride: stride of the resulting data in bytes.
//   - bytes: downloaded pixels.
func (self *TextureDownloader) DownloadBytes() (uint, *glib.Bytes) {
	var _arg0 *C.GdkTextureDownloader // out
	var _arg1 C.gsize                 // in
	var _cret *C.GBytes               // in

	_arg0 = (*C.GdkTextureDownloader)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gdk_texture_downloader_download_bytes(_arg0, &_arg1)
	runtime.KeepAlive(self)

	var _outStride uint    // out
	var _bytes *glib.Bytes // out

	_outStride = uint(_arg1)
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _outStride, _bytes
}

// Format gets the format that the data will be downloaded in.
//
// The function returns the following values:
//
//   - memoryFormat: format of the download.
func (self *TextureDownloader) Format() MemoryFormat {
	var _arg0 *C.GdkTextureDownloader // out
	var _cret C.GdkMemoryFormat       // in

	_arg0 = (*C.GdkTextureDownloader)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gdk_texture_downloader_get_format(_arg0)
	runtime.KeepAlive(self)

	var _memoryFormat MemoryFormat // out

	_memoryFormat = MemoryFormat(_cret)

	return _memoryFormat
}

// Texture gets the texture that the downloader will download.
//
// The function returns the following values:
//
//   - texture to download.
func (self *TextureDownloader) Texture() Texturer {
	var _arg0 *C.GdkTextureDownloader // out
	var _cret *C.GdkTexture           // in

	_arg0 = (*C.GdkTextureDownloader)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gdk_texture_downloader_get_texture(_arg0)
	runtime.KeepAlive(self)

	var _texture Texturer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Texturer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Texturer)
			return ok
		})
		rv, ok := casted.(Texturer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
		}
		_texture = rv
	}

	return _texture
}

// SetFormat sets the format the downloader will download.
//
// By default, GDK_MEMORY_DEFAULT is set.
//
// The function takes the following parameters:
//
//   - format to use.
func (self *TextureDownloader) SetFormat(format MemoryFormat) {
	var _arg0 *C.GdkTextureDownloader // out
	var _arg1 C.GdkMemoryFormat       // out

	_arg0 = (*C.GdkTextureDownloader)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.GdkMemoryFormat(format)

	C.gdk_texture_downloader_set_format(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(format)
}

// SetTexture changes the texture the downloader will download.
//
// The function takes the following parameters:
//
//   - texture: new texture to download.
func (self *TextureDownloader) SetTexture(texture Texturer) {
	var _arg0 *C.GdkTextureDownloader // out
	var _arg1 *C.GdkTexture           // out

	_arg0 = (*C.GdkTextureDownloader)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	C.gdk_texture_downloader_set_texture(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(texture)
}

// TimeCoord: GdkTimeCoord stores a single event in a motion history.
//
// To check whether an axis is present, check whether the corresponding flag
// from the gdk.AxisFlags enumeration is set in the flags To access individual
// axis values, use the values of the values of the gdk.AxisUse enumerations as
// indices.
//
// An instance of this type is always passed by reference.
type TimeCoord struct {
	*timeCoord
}

// timeCoord is the struct that's finalized.
type timeCoord struct {
	native *C.GdkTimeCoord
}

// Time: timestamp for this event.
func (t *TimeCoord) Time() uint32 {
	valptr := &t.native.time
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// Flags indicating what axes are present, see gdk.AxisFlags.
func (t *TimeCoord) Flags() AxisFlags {
	valptr := &t.native.flags
	var _v AxisFlags // out
	_v = AxisFlags(*valptr)
	return _v
}

// Axes axis values, indexed by gdk.AxisUse.
func (t *TimeCoord) Axes() [12]float64 {
	valptr := &t.native.axes
	var _v [12]float64 // out
	_v = *(*[12]float64)(unsafe.Pointer(&*valptr))
	return _v
}

// Time: timestamp for this event.
func (t *TimeCoord) SetTime(time uint32) {
	valptr := &t.native.time
	*valptr = C.guint32(time)
}

// ToplevelLayout: GdkToplevelLayout struct contains information that is
// necessary to present a sovereign window on screen.
//
// The GdkToplevelLayout struct is necessary for using gdk.Toplevel.Present().
//
// Toplevel surfaces are sovereign windows that can be presented to the user in
// various states (maximized, on all workspaces, etc).
//
// An instance of this type is always passed by reference.
type ToplevelLayout struct {
	*toplevelLayout
}

// toplevelLayout is the struct that's finalized.
type toplevelLayout struct {
	native *C.GdkToplevelLayout
}

func marshalToplevelLayout(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ToplevelLayout{&toplevelLayout{(*C.GdkToplevelLayout)(b)}}, nil
}

// NewToplevelLayout constructs a struct ToplevelLayout.
func NewToplevelLayout() *ToplevelLayout {
	var _cret *C.GdkToplevelLayout // in

	_cret = C.gdk_toplevel_layout_new()

	var _toplevelLayout *ToplevelLayout // out

	_toplevelLayout = (*ToplevelLayout)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_toplevelLayout)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_toplevel_layout_unref((*C.GdkToplevelLayout)(intern.C))
		},
	)

	return _toplevelLayout
}

// Copy: create a new GdkToplevelLayout and copy the contents of layout into it.
//
// The function returns the following values:
//
//   - toplevelLayout: copy of layout.
func (layout *ToplevelLayout) Copy() *ToplevelLayout {
	var _arg0 *C.GdkToplevelLayout // out
	var _cret *C.GdkToplevelLayout // in

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_toplevel_layout_copy(_arg0)
	runtime.KeepAlive(layout)

	var _toplevelLayout *ToplevelLayout // out

	_toplevelLayout = (*ToplevelLayout)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_toplevelLayout)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gdk_toplevel_layout_unref((*C.GdkToplevelLayout)(intern.C))
		},
	)

	return _toplevelLayout
}

// Equal: check whether layout and other has identical layout properties.
//
// The function takes the following parameters:
//
//   - other GdkToplevelLayout.
//
// The function returns the following values:
//
//   - ok: TRUE if layout and other have identical layout properties, otherwise
//     FALSE.
func (layout *ToplevelLayout) Equal(other *ToplevelLayout) bool {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 *C.GdkToplevelLayout // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	_arg1 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(other)))

	_cret = C.gdk_toplevel_layout_equal(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(other)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Fullscreen: if the layout specifies whether to the toplevel should go
// fullscreen, the value pointed to by fullscreen is set to TRUE if it should go
// fullscreen, or FALSE, if it should go unfullscreen.
//
// The function returns the following values:
//
//   - fullscreen: location to store whether the toplevel should be fullscreen.
//   - ok: whether the layout specifies the fullscreen state for the toplevel.
func (layout *ToplevelLayout) Fullscreen() (fullscreen bool, ok bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_toplevel_layout_get_fullscreen(_arg0, &_arg1)
	runtime.KeepAlive(layout)

	var _fullscreen bool // out
	var _ok bool         // out

	if _arg1 != 0 {
		_fullscreen = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _fullscreen, _ok
}

// FullscreenMonitor returns the monitor that the layout is fullscreening the
// surface on.
//
// The function returns the following values:
//
//   - monitor (optional) on which layout fullscreens.
func (layout *ToplevelLayout) FullscreenMonitor() *Monitor {
	var _arg0 *C.GdkToplevelLayout // out
	var _cret *C.GdkMonitor        // in

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_toplevel_layout_get_fullscreen_monitor(_arg0)
	runtime.KeepAlive(layout)

	var _monitor *Monitor // out

	if _cret != nil {
		_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _monitor
}

// Maximized: if the layout specifies whether to the toplevel should go
// maximized, the value pointed to by maximized is set to TRUE if it should go
// fullscreen, or FALSE, if it should go unmaximized.
//
// The function returns the following values:
//
//   - maximized: set to TRUE if the toplevel should be maximized.
//   - ok: whether the layout specifies the maximized state for the toplevel.
func (layout *ToplevelLayout) Maximized() (maximized bool, ok bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_toplevel_layout_get_maximized(_arg0, &_arg1)
	runtime.KeepAlive(layout)

	var _maximized bool // out
	var _ok bool        // out

	if _arg1 != 0 {
		_maximized = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _maximized, _ok
}

// Resizable returns whether the layout should allow the user to resize the
// surface.
//
// The function returns the following values:
//
//   - ok: TRUE if the layout is resizable.
func (layout *ToplevelLayout) Resizable() bool {
	var _arg0 *C.GdkToplevelLayout // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))

	_cret = C.gdk_toplevel_layout_get_resizable(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFullscreen sets whether the layout should cause the surface to be
// fullscreen when presented.
//
// The function takes the following parameters:
//
//   - fullscreen: TRUE to fullscreen the surface.
//   - monitor (optional) to fullscreen on.
func (layout *ToplevelLayout) SetFullscreen(fullscreen bool, monitor *Monitor) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // out
	var _arg2 *C.GdkMonitor        // out

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	if fullscreen {
		_arg1 = C.TRUE
	}
	if monitor != nil {
		_arg2 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	}

	C.gdk_toplevel_layout_set_fullscreen(_arg0, _arg1, _arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(fullscreen)
	runtime.KeepAlive(monitor)
}

// SetMaximized sets whether the layout should cause the surface to be maximized
// when presented.
//
// The function takes the following parameters:
//
//   - maximized: TRUE to maximize.
func (layout *ToplevelLayout) SetMaximized(maximized bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	if maximized {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_layout_set_maximized(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(maximized)
}

// SetResizable sets whether the layout should allow the user to resize the
// surface after it has been presented.
//
// The function takes the following parameters:
//
//   - resizable: TRUE to allow resizing.
func (layout *ToplevelLayout) SetResizable(resizable bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GdkToplevelLayout)(gextras.StructNative(unsafe.Pointer(layout)))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_layout_set_resizable(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(resizable)
}
