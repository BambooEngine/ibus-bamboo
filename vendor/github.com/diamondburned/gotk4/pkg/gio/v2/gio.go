// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gio-2.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gio2_Volume_ConnectRemoved(gpointer, guintptr);
// extern void _gotk4_gio2_Volume_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeChanged(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeAdded(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountRemoved(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountChanged(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountAdded(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveStopButton(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveConnected(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveChanged(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_removed(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_changed(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_added(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_removed(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_pre_unmount(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_changed(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_added(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_stop_button(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_eject_button(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_disconnected(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_connected(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_changed(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VfsClass_local_file_removed(GVfs*, char*);
// extern void _gotk4_gio2_VfsClass_local_file_moved(GVfs*, char*, char*);
// extern void _gotk4_gio2_VfsClass_add_writable_namespaces(GVfs*, GFileAttributeInfoList*);
// extern void _gotk4_gio2_SocketListener_ConnectEvent(gpointer, GSocketListenerEvent, GSocket*, guintptr);
// extern void _gotk4_gio2_SocketListenerClass_event(GSocketListener*, GSocketListenerEvent, GSocket*);
// extern void _gotk4_gio2_SocketListenerClass_changed(GSocketListener*);
// extern void _gotk4_gio2_SocketControlMessageClass_serialize(GSocketControlMessage*, gpointer);
// extern void _gotk4_gio2_SocketClient_ConnectEvent(gpointer, GSocketClientEvent, GSocketConnectable*, GIOStream*, guintptr);
// extern void _gotk4_gio2_SocketClientClass_event(GSocketClient*, GSocketClientEvent, GSocketConnectable*, GIOStream*);
// extern void _gotk4_gio2_SimpleAction_ConnectChangeState(gpointer, GVariant*, guintptr);
// extern void _gotk4_gio2_SimpleAction_ConnectActivate(gpointer, GVariant*, guintptr);
// extern void _gotk4_gio2_Settings_ConnectWritableChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_Settings_ConnectChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_SettingsClass_writable_changed(GSettings*, gchar*);
// extern void _gotk4_gio2_SettingsClass_changed(GSettings*, gchar*);
// extern void _gotk4_gio2_Resolver_ConnectReload(gpointer, guintptr);
// extern void _gotk4_gio2_ResolverClass_reload(GResolver*);
// extern void _gotk4_gio2_NetworkMonitor_ConnectNetworkChanged(gpointer, gboolean, guintptr);
// extern void _gotk4_gio2_Mount_ConnectUnmounted(gpointer, guintptr);
// extern void _gotk4_gio2_Mount_ConnectPreUnmount(gpointer, guintptr);
// extern void _gotk4_gio2_Mount_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gio2_MountOperation_ConnectShowUnmountProgress(gpointer, gchar*, gint64, gint64, guintptr);
// extern void _gotk4_gio2_MountOperation_ConnectReply(gpointer, GMountOperationResult, guintptr);
// extern void _gotk4_gio2_MountOperation_ConnectAskQuestion(gpointer, gchar*, gchar**, guintptr);
// extern void _gotk4_gio2_MountOperation_ConnectAskPassword(gpointer, gchar*, gchar*, gchar*, GAskPasswordFlags, guintptr);
// extern void _gotk4_gio2_MountOperation_ConnectAborted(gpointer, guintptr);
// extern void _gotk4_gio2_MountOperationClass_show_unmount_progress(GMountOperation*, gchar*, gint64, gint64);
// extern void _gotk4_gio2_MountOperationClass_reply(GMountOperation*, GMountOperationResult);
// extern void _gotk4_gio2_MountOperationClass_ask_question(GMountOperation*, char*, char**);
// extern void _gotk4_gio2_MountOperationClass_ask_password(GMountOperation*, char*, char*, char*, GAskPasswordFlags);
// extern void _gotk4_gio2_MountOperationClass_aborted(GMountOperation*);
// extern void _gotk4_gio2_MenuModel_ConnectItemsChanged(gpointer, gint, gint, gint, guintptr);
// extern void _gotk4_gio2_MenuModelClass_get_item_links(GMenuModel*, gint, GHashTable**);
// extern void _gotk4_gio2_MenuModelClass_get_item_attributes(GMenuModel*, gint, GHashTable**);
// extern void _gotk4_gio2_MemoryMonitor_ConnectLowMemoryWarning(gpointer, GMemoryMonitorWarningLevel, guintptr);
// extern void _gotk4_gio2_ListModel_ConnectItemsChanged(gpointer, guint, guint, guint, guintptr);
// extern void _gotk4_gio2_FilenameCompleter_ConnectGotCompletionData(gpointer, guintptr);
// extern void _gotk4_gio2_FilenameCompleterClass_got_completion_data(GFilenameCompleter*);
// extern void _gotk4_gio2_FileMonitor_ConnectChanged(gpointer, GFile*, GFile*, GFileMonitorEvent, guintptr);
// extern void _gotk4_gio2_FileMonitorClass_changed(GFileMonitor*, GFile*, GFile*, GFileMonitorEvent);
// extern void _gotk4_gio2_Drive_ConnectStopButton(gpointer, guintptr);
// extern void _gotk4_gio2_Drive_ConnectEjectButton(gpointer, guintptr);
// extern void _gotk4_gio2_Drive_ConnectDisconnected(gpointer, guintptr);
// extern void _gotk4_gio2_Drive_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gio2_DBusSignalCallback(GDBusConnection*, gchar*, gchar*, gchar*, gchar*, GVariant*, gpointer);
// extern void _gotk4_gio2_DBusProxy_ConnectGSignal(gpointer, gchar*, gchar*, GVariant*, guintptr);
// extern void _gotk4_gio2_DBusProxy_ConnectGPropertiesChanged(gpointer, GVariant*, gchar**, guintptr);
// extern void _gotk4_gio2_DBusProxyClass_g_signal(GDBusProxy*, gchar*, gchar*, GVariant*);
// extern void _gotk4_gio2_DBusObject_ConnectInterfaceRemoved(gpointer, GDBusInterface*, guintptr);
// extern void _gotk4_gio2_DBusObject_ConnectInterfaceAdded(gpointer, GDBusInterface*, guintptr);
// extern void _gotk4_gio2_DBusObjectManager_ConnectObjectRemoved(gpointer, GDBusObject*, guintptr);
// extern void _gotk4_gio2_DBusObjectManager_ConnectObjectAdded(gpointer, GDBusObject*, guintptr);
// extern void _gotk4_gio2_DBusObjectManager_ConnectInterfaceRemoved(gpointer, GDBusObject*, GDBusInterface*, guintptr);
// extern void _gotk4_gio2_DBusObjectManager_ConnectInterfaceAdded(gpointer, GDBusObject*, GDBusInterface*, guintptr);
// extern void _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxySignal(gpointer, GDBusObjectProxy*, GDBusProxy*, gchar*, gchar*, GVariant*, guintptr);
// extern void _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxyPropertiesChanged(gpointer, GDBusObjectProxy*, GDBusProxy*, GVariant*, gchar**, guintptr);
// extern void _gotk4_gio2_DBusObjectManagerClientClass_interface_proxy_signal(GDBusObjectManagerClient*, GDBusObjectProxy*, GDBusProxy*, gchar*, gchar*, GVariant*);
// extern void _gotk4_gio2_DBusInterfaceSkeletonClass_flush(GDBusInterfaceSkeleton*);
// extern void _gotk4_gio2_DBusConnection_ConnectClosed(gpointer, gboolean, GError*, guintptr);
// extern void _gotk4_gio2_Cancellable_ConnectCancelled(gpointer, guintptr);
// extern void _gotk4_gio2_CancellableClass_cancelled(GCancellable*);
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void _gotk4_gio2_Application_ConnectStartup(gpointer, guintptr);
// extern void _gotk4_gio2_Application_ConnectShutdown(gpointer, guintptr);
// extern void _gotk4_gio2_Application_ConnectOpen(gpointer, GFile**, gint, gchar*, guintptr);
// extern void _gotk4_gio2_Application_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gio2_ApplicationCommandLineClass_printerr_literal(GApplicationCommandLine*, gchar*);
// extern void _gotk4_gio2_ApplicationCommandLineClass_print_literal(GApplicationCommandLine*, gchar*);
// extern void _gotk4_gio2_ApplicationCommandLineClass_done(GApplicationCommandLine*);
// extern void _gotk4_gio2_ApplicationClass_startup(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_shutdown(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_run_mainloop(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_quit_mainloop(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_open(GApplication*, GFile**, gint, gchar*);
// extern void _gotk4_gio2_ApplicationClass_dbus_unregister(GApplication*, GDBusConnection*, gchar*);
// extern void _gotk4_gio2_ApplicationClass_before_emit(GApplication*, GVariant*);
// extern void _gotk4_gio2_ApplicationClass_after_emit(GApplication*, GVariant*);
// extern void _gotk4_gio2_ApplicationClass_add_platform_data(GApplication*, GVariantBuilder*);
// extern void _gotk4_gio2_ApplicationClass_activate(GApplication*);
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunched(gpointer, GAppInfo*, GVariant*, guintptr);
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunchStarted(gpointer, GAppInfo*, GVariant*, guintptr);
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_AppLaunchContextClass_launched(GAppLaunchContext*, GAppInfo*, GVariant*);
// extern void _gotk4_gio2_AppLaunchContextClass_launch_started(GAppLaunchContext*, GAppInfo*, GVariant*);
// extern void _gotk4_gio2_AppLaunchContextClass_launch_failed(GAppLaunchContext*, char*);
// extern void _gotk4_gio2_AppInfoMonitor_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gio2_ActionGroup_ConnectActionStateChanged(gpointer, gchar*, GVariant*, guintptr);
// extern void _gotk4_gio2_ActionGroup_ConnectActionRemoved(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_ActionGroup_ConnectActionEnabledChanged(gpointer, gchar*, gboolean, guintptr);
// extern void _gotk4_gio2_ActionGroup_ConnectActionAdded(gpointer, gchar*, guintptr);
// extern int _gotk4_gio2_SocketControlMessageClass_get_type(GSocketControlMessage*);
// extern int _gotk4_gio2_SocketControlMessageClass_get_level(GSocketControlMessage*);
// extern int _gotk4_gio2_ApplicationClass_command_line(GApplication*, GApplicationCommandLine*);
// extern guchar* _gotk4_gio2_TlsPasswordClass_get_value(GTlsPassword*, gsize*);
// extern gssize _gotk4_gio2_SocketAddressClass_get_native_size(GSocketAddress*);
// extern gssize _gotk4_gio2_OutputStreamClass_write_finish(GOutputStream*, GAsyncResult*, GError**);
// extern gssize _gotk4_gio2_OutputStreamClass_splice_finish(GOutputStream*, GAsyncResult*, GError**);
// extern gssize _gotk4_gio2_OutputStreamClass_splice(GOutputStream*, GInputStream*, GOutputStreamSpliceFlags, GCancellable*, GError**);
// extern gssize _gotk4_gio2_InputStreamClass_skip_finish(GInputStream*, GAsyncResult*, GError**);
// extern gssize _gotk4_gio2_InputStreamClass_skip(GInputStream*, gsize, GCancellable*, GError**);
// extern gssize _gotk4_gio2_InputStreamClass_read_finish(GInputStream*, GAsyncResult*, GError**);
// extern gssize _gotk4_gio2_BufferedInputStreamClass_fill_finish(GBufferedInputStream*, GAsyncResult*, GError**);
// extern gssize _gotk4_gio2_BufferedInputStreamClass_fill(GBufferedInputStream*, gssize, GCancellable*, GError**);
// extern gsize _gotk4_gio2_SocketControlMessageClass_get_size(GSocketControlMessage*);
// extern goffset _gotk4_gio2_FileOutputStreamClass_tell(GFileOutputStream*);
// extern goffset _gotk4_gio2_FileInputStreamClass_tell(GFileInputStream*);
// extern goffset _gotk4_gio2_FileIOStreamClass_tell(GFileIOStream*);
// extern gint _gotk4_glib2_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gint _gotk4_gio2_MenuModelClass_get_n_items(GMenuModel*);
// extern gint _gotk4_gio2_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gint _gotk4_gio2_Application_ConnectHandleLocalOptions(gpointer, GVariantDict*, guintptr);
// extern gint _gotk4_gio2_Application_ConnectCommandLine(gpointer, GApplicationCommandLine*, guintptr);
// extern gint _gotk4_gio2_ApplicationClass_handle_local_options(GApplication*, GVariantDict*);
// extern gchar** _gotk4_gio2_VfsClass_get_supported_uri_schemes(GVfs*);
// extern gchar* _gotk4_gio2_TlsPasswordClass_get_default_warning(GTlsPassword*);
// extern gchar* _gotk4_gio2_TlsDatabaseClass_create_certificate_handle(GTlsDatabase*, GTlsCertificate*);
// extern gchar* _gotk4_gio2_TlsConnectionClass_get_negotiated_protocol(GTlsConnection*);
// extern gchar* _gotk4_gio2_ResolverClass_lookup_by_address_finish(GResolver*, GAsyncResult*, GError**);
// extern gchar* _gotk4_gio2_ResolverClass_lookup_by_address(GResolver*, GInetAddress*, GCancellable*, GError**);
// extern gchar* _gotk4_gio2_InetAddressClass_to_string(GInetAddress*);
// extern gboolean _gotk4_glib2_EqualFuncFull(gconstpointer, gconstpointer, gpointer);
// extern gboolean _gotk4_gio2_VfsClass_local_file_set_attributes(GVfs*, char*, GFileInfo*, GFileQueryInfoFlags, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_VfsClass_is_active(GVfs*);
// extern gboolean _gotk4_gio2_TlsConnection_ConnectAcceptCertificate(gpointer, GTlsCertificate*, GTlsCertificateFlags, guintptr);
// extern gboolean _gotk4_gio2_TlsConnectionClass_handshake_finish(GTlsConnection*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_TlsConnectionClass_handshake(GTlsConnection*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_TlsConnectionClass_get_binding_data(GTlsConnection*, GTlsChannelBindingType, GByteArray*, GError**);
// extern gboolean _gotk4_gio2_TlsConnectionClass_accept_certificate(GTlsConnection*, GTlsCertificate*, GTlsCertificateFlags);
// extern gboolean _gotk4_gio2_ThreadedSocketService_ConnectRun(gpointer, GSocketConnection*, GObject*, guintptr);
// extern gboolean _gotk4_gio2_ThreadedSocketServiceClass_run(GThreadedSocketService*, GSocketConnection*, GObject*);
// extern gboolean _gotk4_gio2_SocketService_ConnectIncoming(gpointer, GSocketConnection*, GObject*, guintptr);
// extern gboolean _gotk4_gio2_SocketServiceClass_incoming(GSocketService*, GSocketConnection*, GObject*);
// extern gboolean _gotk4_gio2_SocketAddressClass_to_native(GSocketAddress*, gpointer, gsize, GError**);
// extern gboolean _gotk4_gio2_Settings_ConnectWritableChangeEvent(gpointer, guint, guintptr);
// extern gboolean _gotk4_gio2_Settings_ConnectChangeEvent(gpointer, gpointer, gint, guintptr);
// extern gboolean _gotk4_gio2_SettingsGetMapping(GVariant*, gpointer*, gpointer);
// extern gboolean _gotk4_gio2_SettingsClass_writable_change_event(GSettings*, GQuark);
// extern gboolean _gotk4_gio2_SettingsClass_change_event(GSettings*, GQuark*, gint);
// extern gboolean _gotk4_gio2_PermissionClass_release_finish(GPermission*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_PermissionClass_release(GPermission*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_PermissionClass_acquire_finish(GPermission*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_PermissionClass_acquire(GPermission*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_OutputStreamClass_writev_finish(GOutputStream*, GAsyncResult*, gsize*, GError**);
// extern gboolean _gotk4_gio2_OutputStreamClass_flush_finish(GOutputStream*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_OutputStreamClass_flush(GOutputStream*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_OutputStreamClass_close_fn(GOutputStream*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_OutputStreamClass_close_finish(GOutputStream*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_MenuModelClass_is_mutable(GMenuModel*);
// extern gboolean _gotk4_gio2_MenuLinkIterClass_get_next(GMenuLinkIter*, gchar**, GMenuModel**);
// extern gboolean _gotk4_gio2_MenuAttributeIterClass_get_next(GMenuAttributeIter*, gchar**, GVariant**);
// extern gboolean _gotk4_gio2_InputStreamClass_close_fn(GInputStream*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_InputStreamClass_close_finish(GInputStream*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_IOStreamClass_close_fn(GIOStream*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_IOStreamClass_close_finish(GIOStream*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_FileOutputStreamClass_truncate_fn(GFileOutputStream*, goffset, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_FileOutputStreamClass_seek(GFileOutputStream*, goffset, GSeekType, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_FileOutputStreamClass_can_truncate(GFileOutputStream*);
// extern gboolean _gotk4_gio2_FileOutputStreamClass_can_seek(GFileOutputStream*);
// extern gboolean _gotk4_gio2_FileMonitorClass_cancel(GFileMonitor*);
// extern gboolean _gotk4_gio2_FileInputStreamClass_seek(GFileInputStream*, goffset, GSeekType, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_FileInputStreamClass_can_seek(GFileInputStream*);
// extern gboolean _gotk4_gio2_FileIOStreamClass_truncate_fn(GFileIOStream*, goffset, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_FileIOStreamClass_seek(GFileIOStream*, goffset, GSeekType, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_FileIOStreamClass_can_truncate(GFileIOStream*);
// extern gboolean _gotk4_gio2_FileIOStreamClass_can_seek(GFileIOStream*);
// extern gboolean _gotk4_gio2_FileEnumeratorClass_close_fn(GFileEnumerator*, GCancellable*, GError**);
// extern gboolean _gotk4_gio2_FileEnumeratorClass_close_finish(GFileEnumerator*, GAsyncResult*, GError**);
// extern gboolean _gotk4_gio2_EqualFuncFull(gconstpointer, gconstpointer, gpointer);
// extern gboolean _gotk4_gio2_DtlsConnection_ConnectAcceptCertificate(gpointer, GTlsCertificate*, GTlsCertificateFlags, guintptr);
// extern gboolean _gotk4_gio2_DebugControllerDBus_ConnectAuthorize(gpointer, GDBusMethodInvocation*, guintptr);
// extern gboolean _gotk4_gio2_DebugControllerDBusClass_authorize(GDebugControllerDBus*, GDBusMethodInvocation*);
// extern gboolean _gotk4_gio2_DBusServer_ConnectNewConnection(gpointer, GDBusConnection*, guintptr);
// extern gboolean _gotk4_gio2_DBusObjectSkeleton_ConnectAuthorizeMethod(gpointer, GDBusInterfaceSkeleton*, GDBusMethodInvocation*, guintptr);
// extern gboolean _gotk4_gio2_DBusObjectSkeletonClass_authorize_method(GDBusObjectSkeleton*, GDBusInterfaceSkeleton*, GDBusMethodInvocation*);
// extern gboolean _gotk4_gio2_DBusInterfaceSkeleton_ConnectGAuthorizeMethod(gpointer, GDBusMethodInvocation*, guintptr);
// extern gboolean _gotk4_gio2_DBusInterfaceSkeletonClass_g_authorize_method(GDBusInterfaceSkeleton*, GDBusMethodInvocation*);
// extern gboolean _gotk4_gio2_DBusAuthObserver_ConnectAuthorizeAuthenticatedPeer(gpointer, GIOStream*, GCredentials*, guintptr);
// extern gboolean _gotk4_gio2_DBusAuthObserver_ConnectAllowMechanism(gpointer, gchar*, guintptr);
// extern gboolean _gotk4_gio2_Application_ConnectNameLost(gpointer, guintptr);
// extern gboolean _gotk4_gio2_ApplicationClass_name_lost(GApplication*);
// extern gboolean _gotk4_gio2_ApplicationClass_dbus_register(GApplication*, GDBusConnection*, gchar*, GError**);
// extern char* _gotk4_gio2_FileOutputStreamClass_get_etag(GFileOutputStream*);
// extern char* _gotk4_gio2_FileIOStreamClass_get_etag(GFileIOStream*);
// extern char* _gotk4_gio2_AppLaunchContextClass_get_startup_notify_id(GAppLaunchContext*, GAppInfo*, GList*);
// extern char* _gotk4_gio2_AppLaunchContextClass_get_display(GAppLaunchContext*, GAppInfo*, GList*);
// extern GVolume* _gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid(GVolumeMonitor*, char*);
// extern GVariant* _gotk4_gio2_MenuModelClass_get_item_attribute_value(GMenuModel*, gint, gchar*, GVariantType*);
// extern GVariant* _gotk4_gio2_DBusInterfaceSkeletonClass_get_properties(GDBusInterfaceSkeleton*);
// extern GTlsInteractionResult _gotk4_gio2_TlsInteractionClass_request_certificate_finish(GTlsInteraction*, GAsyncResult*, GError**);
// extern GTlsInteractionResult _gotk4_gio2_TlsInteractionClass_request_certificate(GTlsInteraction*, GTlsConnection*, GTlsCertificateRequestFlags, GCancellable*, GError**);
// extern GTlsInteractionResult _gotk4_gio2_TlsInteractionClass_ask_password_finish(GTlsInteraction*, GAsyncResult*, GError**);
// extern GTlsInteractionResult _gotk4_gio2_TlsInteractionClass_ask_password(GTlsInteraction*, GTlsPassword*, GCancellable*, GError**);
// extern GTlsCertificateFlags _gotk4_gio2_TlsDatabaseClass_verify_chain_finish(GTlsDatabase*, GAsyncResult*, GError**);
// extern GTlsCertificateFlags _gotk4_gio2_TlsDatabaseClass_verify_chain(GTlsDatabase*, GTlsCertificate*, gchar*, GSocketConnectable*, GTlsInteraction*, GTlsDatabaseVerifyFlags, GCancellable*, GError**);
// extern GTlsCertificateFlags _gotk4_gio2_TlsCertificateClass_verify(GTlsCertificate*, GSocketConnectable*, GTlsCertificate*);
// extern GTlsCertificate* _gotk4_gio2_TlsDatabaseClass_lookup_certificate_issuer_finish(GTlsDatabase*, GAsyncResult*, GError**);
// extern GTlsCertificate* _gotk4_gio2_TlsDatabaseClass_lookup_certificate_issuer(GTlsDatabase*, GTlsCertificate*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**);
// extern GTlsCertificate* _gotk4_gio2_TlsDatabaseClass_lookup_certificate_for_handle_finish(GTlsDatabase*, GAsyncResult*, GError**);
// extern GTlsCertificate* _gotk4_gio2_TlsDatabaseClass_lookup_certificate_for_handle(GTlsDatabase*, gchar*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**);
// extern GSocketFamily _gotk4_gio2_SocketAddressClass_get_family(GSocketAddress*);
// extern GSocketAddress* _gotk4_gio2_SocketAddressEnumeratorClass_next_finish(GSocketAddressEnumerator*, GAsyncResult*, GError**);
// extern GSocketAddress* _gotk4_gio2_SocketAddressEnumeratorClass_next(GSocketAddressEnumerator*, GCancellable*, GError**);
// extern GOutputStream* _gotk4_gio2_IOStreamClass_get_output_stream(GIOStream*);
// extern GMount* _gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid(GVolumeMonitor*, char*);
// extern GMenuModel* _gotk4_gio2_MenuModelClass_get_item_link(GMenuModel*, gint, gchar*);
// extern GMenuLinkIter* _gotk4_gio2_MenuModelClass_iterate_item_links(GMenuModel*, gint);
// extern GMenuAttributeIter* _gotk4_gio2_MenuModelClass_iterate_item_attributes(GMenuModel*, gint);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_volumes(GVolumeMonitor*);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_mounts(GVolumeMonitor*);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_connected_drives(GVolumeMonitor*);
// extern GList* _gotk4_gio2_TlsDatabaseClass_lookup_certificates_issued_by_finish(GTlsDatabase*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_TlsDatabaseClass_lookup_certificates_issued_by(GTlsDatabase*, GByteArray*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_service_finish(GResolver*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_records_finish(GResolver*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_records(GResolver*, gchar*, GResolverRecordType, GCancellable*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish(GResolver*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_with_flags(GResolver*, gchar*, GResolverNameLookupFlags, GCancellable*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_finish(GResolver*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name(GResolver*, gchar*, GCancellable*, GError**);
// extern GList* _gotk4_gio2_FileEnumeratorClass_next_files_finish(GFileEnumerator*, GAsyncResult*, GError**);
// extern GInputStream* _gotk4_gio2_IOStreamClass_get_input_stream(GIOStream*);
// extern GInputStream* _gotk4_gio2_ApplicationCommandLineClass_get_stdin(GApplicationCommandLine*);
// extern GFileInfo* _gotk4_gio2_FileOutputStreamClass_query_info_finish(GFileOutputStream*, GAsyncResult*, GError**);
// extern GFileInfo* _gotk4_gio2_FileOutputStreamClass_query_info(GFileOutputStream*, char*, GCancellable*, GError**);
// extern GFileInfo* _gotk4_gio2_FileInputStreamClass_query_info_finish(GFileInputStream*, GAsyncResult*, GError**);
// extern GFileInfo* _gotk4_gio2_FileInputStreamClass_query_info(GFileInputStream*, char*, GCancellable*, GError**);
// extern GFileInfo* _gotk4_gio2_FileIOStreamClass_query_info_finish(GFileIOStream*, GAsyncResult*, GError**);
// extern GFileInfo* _gotk4_gio2_FileIOStreamClass_query_info(GFileIOStream*, char*, GCancellable*, GError**);
// extern GFileInfo* _gotk4_gio2_FileEnumeratorClass_next_file(GFileEnumerator*, GCancellable*, GError**);
// extern GFile* _gotk4_gio2_VfsClass_parse_name(GVfs*, char*);
// extern GFile* _gotk4_gio2_VfsClass_get_file_for_uri(GVfs*, char*);
// extern GFile* _gotk4_gio2_VfsClass_get_file_for_path(GVfs*, char*);
// extern GFile* _gotk4_gio2_VFSFileLookupFunc(GVfs*, char*, gpointer);
// extern GDBusMessage* _gotk4_gio2_DBusMessageFilterFunction(GDBusConnection*, GDBusMessage*, gboolean, gpointer);
// extern GDBusInterfaceVTable* _gotk4_gio2_DBusInterfaceSkeletonClass_get_vtable(GDBusInterfaceSkeleton*);
// extern GDBusInterfaceInfo* _gotk4_gio2_DBusInterfaceSkeletonClass_get_info(GDBusInterfaceSkeleton*);
// GAction* _gotk4_gio2_ActionMap_virtual_lookup_action(void* fnptr, GActionMap* arg0, gchar* arg1) {
//   return ((GAction* (*)(GActionMap*, gchar*))(fnptr))(arg0, arg1);
// };
// GAppInfo* _gotk4_gio2_AppInfo_virtual_dup(void* fnptr, GAppInfo* arg0) {
//   return ((GAppInfo* (*)(GAppInfo*))(fnptr))(arg0);
// };
// GConverterResult _gotk4_gio2_Converter_virtual_convert(void* fnptr, GConverter* arg0, void* arg1, gsize arg2, void* arg3, gsize arg4, GConverterFlags arg5, gsize* arg6, gsize* arg7, GError** arg8) {
//   return ((GConverterResult (*)(GConverter*, void*, gsize, void*, gsize, GConverterFlags, gsize*, gsize*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
// };
// GDBusInterface* _gotk4_gio2_DBusObjectManager_virtual_get_interface(void* fnptr, GDBusObjectManager* arg0, gchar* arg1, gchar* arg2) {
//   return ((GDBusInterface* (*)(GDBusObjectManager*, gchar*, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// GDBusInterface* _gotk4_gio2_DBusObject_virtual_get_interface(void* fnptr, GDBusObject* arg0, gchar* arg1) {
//   return ((GDBusInterface* (*)(GDBusObject*, gchar*))(fnptr))(arg0, arg1);
// };
// GDBusInterfaceInfo* _gotk4_gio2_DBusInterfaceSkeleton_virtual_get_info(void* fnptr, GDBusInterfaceSkeleton* arg0) {
//   return ((GDBusInterfaceInfo* (*)(GDBusInterfaceSkeleton*))(fnptr))(arg0);
// };
// GDBusInterfaceInfo* _gotk4_gio2_DBusInterface_virtual_get_info(void* fnptr, GDBusInterface* arg0) {
//   return ((GDBusInterfaceInfo* (*)(GDBusInterface*))(fnptr))(arg0);
// };
// GDBusInterfaceVTable* _gotk4_gio2_DBusInterfaceSkeleton_virtual_get_vtable(void* fnptr, GDBusInterfaceSkeleton* arg0) {
//   return ((GDBusInterfaceVTable* (*)(GDBusInterfaceSkeleton*))(fnptr))(arg0);
// };
// GDBusObject* _gotk4_gio2_DBusInterface_virtual_dup_object(void* fnptr, GDBusInterface* arg0) {
//   return ((GDBusObject* (*)(GDBusInterface*))(fnptr))(arg0);
// };
// GDBusObject* _gotk4_gio2_DBusObjectManager_virtual_get_object(void* fnptr, GDBusObjectManager* arg0, gchar* arg1) {
//   return ((GDBusObject* (*)(GDBusObjectManager*, gchar*))(fnptr))(arg0, arg1);
// };
// GDrive* _gotk4_gio2_Mount_virtual_get_drive(void* fnptr, GMount* arg0) {
//   return ((GDrive* (*)(GMount*))(fnptr))(arg0);
// };
// GDrive* _gotk4_gio2_Volume_virtual_get_drive(void* fnptr, GVolume* arg0) {
//   return ((GDrive* (*)(GVolume*))(fnptr))(arg0);
// };
// GDriveStartStopType _gotk4_gio2_Drive_virtual_get_start_stop_type(void* fnptr, GDrive* arg0) {
//   return ((GDriveStartStopType (*)(GDrive*))(fnptr))(arg0);
// };
// GFile* _gotk4_gio2_File_virtual_dup(void* fnptr, GFile* arg0) {
//   return ((GFile* (*)(GFile*))(fnptr))(arg0);
// };
// GFile* _gotk4_gio2_File_virtual_get_child_for_display_name(void* fnptr, GFile* arg0, char* arg1, GError** arg2) {
//   return ((GFile* (*)(GFile*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFile* _gotk4_gio2_File_virtual_get_parent(void* fnptr, GFile* arg0) {
//   return ((GFile* (*)(GFile*))(fnptr))(arg0);
// };
// GFile* _gotk4_gio2_File_virtual_mount_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFile* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFile* _gotk4_gio2_File_virtual_resolve_relative_path(void* fnptr, GFile* arg0, char* arg1) {
//   return ((GFile* (*)(GFile*, char*))(fnptr))(arg0, arg1);
// };
// GFile* _gotk4_gio2_File_virtual_set_display_name(void* fnptr, GFile* arg0, char* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFile* (*)(GFile*, char*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFile* _gotk4_gio2_File_virtual_set_display_name_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFile* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFile* _gotk4_gio2_Mount_virtual_get_default_location(void* fnptr, GMount* arg0) {
//   return ((GFile* (*)(GMount*))(fnptr))(arg0);
// };
// GFile* _gotk4_gio2_Mount_virtual_get_root(void* fnptr, GMount* arg0) {
//   return ((GFile* (*)(GMount*))(fnptr))(arg0);
// };
// GFile* _gotk4_gio2_VFS_virtual_get_file_for_path(void* fnptr, GVfs* arg0, char* arg1) {
//   return ((GFile* (*)(GVfs*, char*))(fnptr))(arg0, arg1);
// };
// GFile* _gotk4_gio2_VFS_virtual_get_file_for_uri(void* fnptr, GVfs* arg0, char* arg1) {
//   return ((GFile* (*)(GVfs*, char*))(fnptr))(arg0, arg1);
// };
// GFile* _gotk4_gio2_VFS_virtual_parse_name(void* fnptr, GVfs* arg0, char* arg1) {
//   return ((GFile* (*)(GVfs*, char*))(fnptr))(arg0, arg1);
// };
// GFile* _gotk4_gio2_Volume_virtual_get_activation_root(void* fnptr, GVolume* arg0) {
//   return ((GFile* (*)(GVolume*))(fnptr))(arg0);
// };
// GFileAttributeInfoList* _gotk4_gio2_File_virtual_query_settable_attributes(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GFileAttributeInfoList* (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileAttributeInfoList* _gotk4_gio2_File_virtual_query_writable_namespaces(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GFileAttributeInfoList* (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileEnumerator* _gotk4_gio2_File_virtual_enumerate_children(void* fnptr, GFile* arg0, char* arg1, GFileQueryInfoFlags arg2, GCancellable* arg3, GError** arg4) {
//   return ((GFileEnumerator* (*)(GFile*, char*, GFileQueryInfoFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GFileEnumerator* _gotk4_gio2_File_virtual_enumerate_children_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileEnumerator* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_create_readwrite(void* fnptr, GFile* arg0, GFileCreateFlags arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileIOStream* (*)(GFile*, GFileCreateFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_create_readwrite_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_open_readwrite(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_open_readwrite_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_replace_readwrite(void* fnptr, GFile* arg0, char* arg1, gboolean arg2, GFileCreateFlags arg3, GCancellable* arg4, GError** arg5) {
//   return ((GFileIOStream* (*)(GFile*, char*, gboolean, GFileCreateFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_replace_readwrite_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInfo* _gotk4_gio2_FileEnumerator_virtual_next_file(void* fnptr, GFileEnumerator* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GFileInfo* (*)(GFileEnumerator*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInfo* _gotk4_gio2_FileIOStream_virtual_query_info(void* fnptr, GFileIOStream* arg0, char* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileInfo* (*)(GFileIOStream*, char*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileInfo* _gotk4_gio2_FileIOStream_virtual_query_info_finish(void* fnptr, GFileIOStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileInfo* (*)(GFileIOStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInfo* _gotk4_gio2_FileInputStream_virtual_query_info(void* fnptr, GFileInputStream* arg0, char* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileInfo* (*)(GFileInputStream*, char*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileInfo* _gotk4_gio2_FileInputStream_virtual_query_info_finish(void* fnptr, GFileInputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileInfo* (*)(GFileInputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInfo* _gotk4_gio2_FileOutputStream_virtual_query_info(void* fnptr, GFileOutputStream* arg0, char* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileInfo* (*)(GFileOutputStream*, char*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileInfo* _gotk4_gio2_FileOutputStream_virtual_query_info_finish(void* fnptr, GFileOutputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileInfo* (*)(GFileOutputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInfo* _gotk4_gio2_File_virtual_query_filesystem_info(void* fnptr, GFile* arg0, char* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileInfo* (*)(GFile*, char*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileInfo* _gotk4_gio2_File_virtual_query_filesystem_info_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileInfo* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInfo* _gotk4_gio2_File_virtual_query_info(void* fnptr, GFile* arg0, char* arg1, GFileQueryInfoFlags arg2, GCancellable* arg3, GError** arg4) {
//   return ((GFileInfo* (*)(GFile*, char*, GFileQueryInfoFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GFileInfo* _gotk4_gio2_File_virtual_query_info_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileInfo* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInputStream* _gotk4_gio2_File_virtual_read_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileInputStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileInputStream* _gotk4_gio2_File_virtual_read_fn(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GFileInputStream* (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileMonitor* _gotk4_gio2_File_virtual_monitor_dir(void* fnptr, GFile* arg0, GFileMonitorFlags arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileMonitor* (*)(GFile*, GFileMonitorFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileMonitor* _gotk4_gio2_File_virtual_monitor_file(void* fnptr, GFile* arg0, GFileMonitorFlags arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileMonitor* (*)(GFile*, GFileMonitorFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileOutputStream* _gotk4_gio2_File_virtual_append_to(void* fnptr, GFile* arg0, GFileCreateFlags arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileOutputStream* (*)(GFile*, GFileCreateFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileOutputStream* _gotk4_gio2_File_virtual_append_to_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileOutputStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileOutputStream* _gotk4_gio2_File_virtual_create(void* fnptr, GFile* arg0, GFileCreateFlags arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileOutputStream* (*)(GFile*, GFileCreateFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileOutputStream* _gotk4_gio2_File_virtual_create_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileOutputStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileOutputStream* _gotk4_gio2_File_virtual_replace(void* fnptr, GFile* arg0, char* arg1, gboolean arg2, GFileCreateFlags arg3, GCancellable* arg4, GError** arg5) {
//   return ((GFileOutputStream* (*)(GFile*, char*, gboolean, GFileCreateFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// GFileOutputStream* _gotk4_gio2_File_virtual_replace_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileOutputStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GIOCondition _gotk4_gio2_DatagramBased_virtual_condition_check(void* fnptr, GDatagramBased* arg0, GIOCondition arg1) {
//   return ((GIOCondition (*)(GDatagramBased*, GIOCondition))(fnptr))(arg0, arg1);
// };
// GIOStream* _gotk4_gio2_Proxy_virtual_connect(void* fnptr, GProxy* arg0, GIOStream* arg1, GProxyAddress* arg2, GCancellable* arg3, GError** arg4) {
//   return ((GIOStream* (*)(GProxy*, GIOStream*, GProxyAddress*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GIOStream* _gotk4_gio2_Proxy_virtual_connect_finish(void* fnptr, GProxy* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GIOStream* (*)(GProxy*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GIcon* _gotk4_gio2_AppInfo_virtual_get_icon(void* fnptr, GAppInfo* arg0) {
//   return ((GIcon* (*)(GAppInfo*))(fnptr))(arg0);
// };
// GIcon* _gotk4_gio2_Drive_virtual_get_icon(void* fnptr, GDrive* arg0) {
//   return ((GIcon* (*)(GDrive*))(fnptr))(arg0);
// };
// GIcon* _gotk4_gio2_Drive_virtual_get_symbolic_icon(void* fnptr, GDrive* arg0) {
//   return ((GIcon* (*)(GDrive*))(fnptr))(arg0);
// };
// GIcon* _gotk4_gio2_Mount_virtual_get_icon(void* fnptr, GMount* arg0) {
//   return ((GIcon* (*)(GMount*))(fnptr))(arg0);
// };
// GIcon* _gotk4_gio2_Mount_virtual_get_symbolic_icon(void* fnptr, GMount* arg0) {
//   return ((GIcon* (*)(GMount*))(fnptr))(arg0);
// };
// GIcon* _gotk4_gio2_Volume_virtual_get_icon(void* fnptr, GVolume* arg0) {
//   return ((GIcon* (*)(GVolume*))(fnptr))(arg0);
// };
// GIcon* _gotk4_gio2_Volume_virtual_get_symbolic_icon(void* fnptr, GVolume* arg0) {
//   return ((GIcon* (*)(GVolume*))(fnptr))(arg0);
// };
// GInputStream* _gotk4_gio2_ApplicationCommandLine_virtual_get_stdin(void* fnptr, GApplicationCommandLine* arg0) {
//   return ((GInputStream* (*)(GApplicationCommandLine*))(fnptr))(arg0);
// };
// GInputStream* _gotk4_gio2_IOStream_virtual_get_input_stream(void* fnptr, GIOStream* arg0) {
//   return ((GInputStream* (*)(GIOStream*))(fnptr))(arg0);
// };
// GInputStream* _gotk4_gio2_LoadableIcon_virtual_load(void* fnptr, GLoadableIcon* arg0, int arg1, char** arg2, GCancellable* arg3, GError** arg4) {
//   return ((GInputStream* (*)(GLoadableIcon*, int, char**, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GInputStream* _gotk4_gio2_LoadableIcon_virtual_load_finish(void* fnptr, GLoadableIcon* arg0, GAsyncResult* arg1, char** arg2, GError** arg3) {
//   return ((GInputStream* (*)(GLoadableIcon*, GAsyncResult*, char**, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GList* _gotk4_gio2_DBusObjectManager_virtual_get_objects(void* fnptr, GDBusObjectManager* arg0) {
//   return ((GList* (*)(GDBusObjectManager*))(fnptr))(arg0);
// };
// GList* _gotk4_gio2_DBusObject_virtual_get_interfaces(void* fnptr, GDBusObject* arg0) {
//   return ((GList* (*)(GDBusObject*))(fnptr))(arg0);
// };
// GList* _gotk4_gio2_Drive_virtual_get_volumes(void* fnptr, GDrive* arg0) {
//   return ((GList* (*)(GDrive*))(fnptr))(arg0);
// };
// GList* _gotk4_gio2_FileEnumerator_virtual_next_files_finish(void* fnptr, GFileEnumerator* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GFileEnumerator*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_by_name(void* fnptr, GResolver* arg0, gchar* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GList* (*)(GResolver*, gchar*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_by_name_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_by_name_with_flags(void* fnptr, GResolver* arg0, gchar* arg1, GResolverNameLookupFlags arg2, GCancellable* arg3, GError** arg4) {
//   return ((GList* (*)(GResolver*, gchar*, GResolverNameLookupFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_by_name_with_flags_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_records(void* fnptr, GResolver* arg0, gchar* arg1, GResolverRecordType arg2, GCancellable* arg3, GError** arg4) {
//   return ((GList* (*)(GResolver*, gchar*, GResolverRecordType, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_records_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_service_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GList* _gotk4_gio2_TLSDatabase_virtual_lookup_certificates_issued_by(void* fnptr, GTlsDatabase* arg0, GByteArray* arg1, GTlsInteraction* arg2, GTlsDatabaseLookupFlags arg3, GCancellable* arg4, GError** arg5) {
//   return ((GList* (*)(GTlsDatabase*, GByteArray*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// GList* _gotk4_gio2_TLSDatabase_virtual_lookup_certificates_issued_by_finish(void* fnptr, GTlsDatabase* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GList* _gotk4_gio2_VolumeMonitor_virtual_get_connected_drives(void* fnptr, GVolumeMonitor* arg0) {
//   return ((GList* (*)(GVolumeMonitor*))(fnptr))(arg0);
// };
// GList* _gotk4_gio2_VolumeMonitor_virtual_get_mounts(void* fnptr, GVolumeMonitor* arg0) {
//   return ((GList* (*)(GVolumeMonitor*))(fnptr))(arg0);
// };
// GList* _gotk4_gio2_VolumeMonitor_virtual_get_volumes(void* fnptr, GVolumeMonitor* arg0) {
//   return ((GList* (*)(GVolumeMonitor*))(fnptr))(arg0);
// };
// GMenuAttributeIter* _gotk4_gio2_MenuModel_virtual_iterate_item_attributes(void* fnptr, GMenuModel* arg0, gint arg1) {
//   return ((GMenuAttributeIter* (*)(GMenuModel*, gint))(fnptr))(arg0, arg1);
// };
// GMenuLinkIter* _gotk4_gio2_MenuModel_virtual_iterate_item_links(void* fnptr, GMenuModel* arg0, gint arg1) {
//   return ((GMenuLinkIter* (*)(GMenuModel*, gint))(fnptr))(arg0, arg1);
// };
// GMenuModel* _gotk4_gio2_MenuModel_virtual_get_item_link(void* fnptr, GMenuModel* arg0, gint arg1, gchar* arg2) {
//   return ((GMenuModel* (*)(GMenuModel*, gint, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// GMount* _gotk4_gio2_File_virtual_find_enclosing_mount(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GMount* (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GMount* _gotk4_gio2_File_virtual_find_enclosing_mount_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GMount* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GMount* _gotk4_gio2_VolumeMonitor_virtual_get_mount_for_uuid(void* fnptr, GVolumeMonitor* arg0, char* arg1) {
//   return ((GMount* (*)(GVolumeMonitor*, char*))(fnptr))(arg0, arg1);
// };
// GMount* _gotk4_gio2_Volume_virtual_get_mount(void* fnptr, GVolume* arg0) {
//   return ((GMount* (*)(GVolume*))(fnptr))(arg0);
// };
// GObject* _gotk4_gio2_AsyncResult_virtual_get_source_object(void* fnptr, GAsyncResult* arg0) {
//   return ((GObject* (*)(GAsyncResult*))(fnptr))(arg0);
// };
// GOutputStream* _gotk4_gio2_IOStream_virtual_get_output_stream(void* fnptr, GIOStream* arg0) {
//   return ((GOutputStream* (*)(GIOStream*))(fnptr))(arg0);
// };
// GPollableReturn _gotk4_gio2_PollableOutputStream_virtual_writev_nonblocking(void* fnptr, GPollableOutputStream* arg0, GOutputVector* arg1, gsize arg2, gsize* arg3, GError** arg4) {
//   return ((GPollableReturn (*)(GPollableOutputStream*, GOutputVector*, gsize, gsize*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GSocketAddress* _gotk4_gio2_SocketAddressEnumerator_virtual_next(void* fnptr, GSocketAddressEnumerator* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GSocketAddress* (*)(GSocketAddressEnumerator*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GSocketAddress* _gotk4_gio2_SocketAddressEnumerator_virtual_next_finish(void* fnptr, GSocketAddressEnumerator* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GSocketAddress* (*)(GSocketAddressEnumerator*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GSocketAddressEnumerator* _gotk4_gio2_SocketConnectable_virtual_enumerate(void* fnptr, GSocketConnectable* arg0) {
//   return ((GSocketAddressEnumerator* (*)(GSocketConnectable*))(fnptr))(arg0);
// };
// GSocketAddressEnumerator* _gotk4_gio2_SocketConnectable_virtual_proxy_enumerate(void* fnptr, GSocketConnectable* arg0) {
//   return ((GSocketAddressEnumerator* (*)(GSocketConnectable*))(fnptr))(arg0);
// };
// GSocketFamily _gotk4_gio2_SocketAddress_virtual_get_family(void* fnptr, GSocketAddress* arg0) {
//   return ((GSocketFamily (*)(GSocketAddress*))(fnptr))(arg0);
// };
// GSource* _gotk4_gio2_DatagramBased_virtual_create_source(void* fnptr, GDatagramBased* arg0, GIOCondition arg1, GCancellable* arg2) {
//   return ((GSource* (*)(GDatagramBased*, GIOCondition, GCancellable*))(fnptr))(arg0, arg1, arg2);
// };
// GSource* _gotk4_gio2_PollableInputStream_virtual_create_source(void* fnptr, GPollableInputStream* arg0, GCancellable* arg1) {
//   return ((GSource* (*)(GPollableInputStream*, GCancellable*))(fnptr))(arg0, arg1);
// };
// GSource* _gotk4_gio2_PollableOutputStream_virtual_create_source(void* fnptr, GPollableOutputStream* arg0, GCancellable* arg1) {
//   return ((GSource* (*)(GPollableOutputStream*, GCancellable*))(fnptr))(arg0, arg1);
// };
// GTlsCertificate* _gotk4_gio2_TLSDatabase_virtual_lookup_certificate_for_handle(void* fnptr, GTlsDatabase* arg0, gchar* arg1, GTlsInteraction* arg2, GTlsDatabaseLookupFlags arg3, GCancellable* arg4, GError** arg5) {
//   return ((GTlsCertificate* (*)(GTlsDatabase*, gchar*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// GTlsCertificate* _gotk4_gio2_TLSDatabase_virtual_lookup_certificate_for_handle_finish(void* fnptr, GTlsDatabase* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GTlsCertificate* (*)(GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GTlsCertificate* _gotk4_gio2_TLSDatabase_virtual_lookup_certificate_issuer(void* fnptr, GTlsDatabase* arg0, GTlsCertificate* arg1, GTlsInteraction* arg2, GTlsDatabaseLookupFlags arg3, GCancellable* arg4, GError** arg5) {
//   return ((GTlsCertificate* (*)(GTlsDatabase*, GTlsCertificate*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// GTlsCertificate* _gotk4_gio2_TLSDatabase_virtual_lookup_certificate_issuer_finish(void* fnptr, GTlsDatabase* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GTlsCertificate* (*)(GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GTlsCertificateFlags _gotk4_gio2_TLSCertificate_virtual_verify(void* fnptr, GTlsCertificate* arg0, GSocketConnectable* arg1, GTlsCertificate* arg2) {
//   return ((GTlsCertificateFlags (*)(GTlsCertificate*, GSocketConnectable*, GTlsCertificate*))(fnptr))(arg0, arg1, arg2);
// };
// GTlsCertificateFlags _gotk4_gio2_TLSDatabase_virtual_verify_chain(void* fnptr, GTlsDatabase* arg0, GTlsCertificate* arg1, gchar* arg2, GSocketConnectable* arg3, GTlsInteraction* arg4, GTlsDatabaseVerifyFlags arg5, GCancellable* arg6, GError** arg7) {
//   return ((GTlsCertificateFlags (*)(GTlsDatabase*, GTlsCertificate*, gchar*, GSocketConnectable*, GTlsInteraction*, GTlsDatabaseVerifyFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
// };
// GTlsCertificateFlags _gotk4_gio2_TLSDatabase_virtual_verify_chain_finish(void* fnptr, GTlsDatabase* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GTlsCertificateFlags (*)(GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GTlsDatabase* _gotk4_gio2_TLSBackend_virtual_get_default_database(void* fnptr, GTlsBackend* arg0) {
//   return ((GTlsDatabase* (*)(GTlsBackend*))(fnptr))(arg0);
// };
// GTlsInteractionResult _gotk4_gio2_TLSInteraction_virtual_ask_password(void* fnptr, GTlsInteraction* arg0, GTlsPassword* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GTlsInteractionResult (*)(GTlsInteraction*, GTlsPassword*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GTlsInteractionResult _gotk4_gio2_TLSInteraction_virtual_ask_password_finish(void* fnptr, GTlsInteraction* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GTlsInteractionResult (*)(GTlsInteraction*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GTlsInteractionResult _gotk4_gio2_TLSInteraction_virtual_request_certificate(void* fnptr, GTlsInteraction* arg0, GTlsConnection* arg1, GTlsCertificateRequestFlags arg2, GCancellable* arg3, GError** arg4) {
//   return ((GTlsInteractionResult (*)(GTlsInteraction*, GTlsConnection*, GTlsCertificateRequestFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// GTlsInteractionResult _gotk4_gio2_TLSInteraction_virtual_request_certificate_finish(void* fnptr, GTlsInteraction* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GTlsInteractionResult (*)(GTlsInteraction*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GType _gotk4_gio2_ListModel_virtual_get_item_type(void* fnptr, GListModel* arg0) {
//   return ((GType (*)(GListModel*))(fnptr))(arg0);
// };
// GVariant* _gotk4_gio2_ActionGroup_virtual_get_action_state(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   return ((GVariant* (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// GVariant* _gotk4_gio2_ActionGroup_virtual_get_action_state_hint(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   return ((GVariant* (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// GVariant* _gotk4_gio2_Action_virtual_get_state(void* fnptr, GAction* arg0) {
//   return ((GVariant* (*)(GAction*))(fnptr))(arg0);
// };
// GVariant* _gotk4_gio2_Action_virtual_get_state_hint(void* fnptr, GAction* arg0) {
//   return ((GVariant* (*)(GAction*))(fnptr))(arg0);
// };
// GVariant* _gotk4_gio2_DBusInterfaceSkeleton_virtual_get_properties(void* fnptr, GDBusInterfaceSkeleton* arg0) {
//   return ((GVariant* (*)(GDBusInterfaceSkeleton*))(fnptr))(arg0);
// };
// GVariant* _gotk4_gio2_Icon_virtual_serialize(void* fnptr, GIcon* arg0) {
//   return ((GVariant* (*)(GIcon*))(fnptr))(arg0);
// };
// GVariant* _gotk4_gio2_MenuModel_virtual_get_item_attribute_value(void* fnptr, GMenuModel* arg0, gint arg1, gchar* arg2, GVariantType* arg3) {
//   return ((GVariant* (*)(GMenuModel*, gint, gchar*, GVariantType*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GVariantType* _gotk4_gio2_ActionGroup_virtual_get_action_parameter_type(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   return ((GVariantType* (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// GVariantType* _gotk4_gio2_ActionGroup_virtual_get_action_state_type(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   return ((GVariantType* (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// GVariantType* _gotk4_gio2_Action_virtual_get_parameter_type(void* fnptr, GAction* arg0) {
//   return ((GVariantType* (*)(GAction*))(fnptr))(arg0);
// };
// GVariantType* _gotk4_gio2_Action_virtual_get_state_type(void* fnptr, GAction* arg0) {
//   return ((GVariantType* (*)(GAction*))(fnptr))(arg0);
// };
// GVolume* _gotk4_gio2_Mount_virtual_get_volume(void* fnptr, GMount* arg0) {
//   return ((GVolume* (*)(GMount*))(fnptr))(arg0);
// };
// GVolume* _gotk4_gio2_VolumeMonitor_virtual_get_volume_for_uuid(void* fnptr, GVolumeMonitor* arg0, char* arg1) {
//   return ((GVolume* (*)(GVolumeMonitor*, char*))(fnptr))(arg0, arg1);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_commandline(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_description(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_display_name(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_executable(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_id(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_name(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppLaunchContext_virtual_get_display(void* fnptr, GAppLaunchContext* arg0, GAppInfo* arg1, GList* arg2) {
//   return ((char* (*)(GAppLaunchContext*, GAppInfo*, GList*))(fnptr))(arg0, arg1, arg2);
// };
// char* _gotk4_gio2_AppLaunchContext_virtual_get_startup_notify_id(void* fnptr, GAppLaunchContext* arg0, GAppInfo* arg1, GList* arg2) {
//   return ((char* (*)(GAppLaunchContext*, GAppInfo*, GList*))(fnptr))(arg0, arg1, arg2);
// };
// char* _gotk4_gio2_Drive_virtual_get_identifier(void* fnptr, GDrive* arg0, char* arg1) {
//   return ((char* (*)(GDrive*, char*))(fnptr))(arg0, arg1);
// };
// char* _gotk4_gio2_Drive_virtual_get_name(void* fnptr, GDrive* arg0) {
//   return ((char* (*)(GDrive*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_FileIOStream_virtual_get_etag(void* fnptr, GFileIOStream* arg0) {
//   return ((char* (*)(GFileIOStream*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_FileOutputStream_virtual_get_etag(void* fnptr, GFileOutputStream* arg0) {
//   return ((char* (*)(GFileOutputStream*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_File_virtual_get_basename(void* fnptr, GFile* arg0) {
//   return ((char* (*)(GFile*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_File_virtual_get_parse_name(void* fnptr, GFile* arg0) {
//   return ((char* (*)(GFile*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_File_virtual_get_path(void* fnptr, GFile* arg0) {
//   return ((char* (*)(GFile*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_File_virtual_get_relative_path(void* fnptr, GFile* arg0, GFile* arg1) {
//   return ((char* (*)(GFile*, GFile*))(fnptr))(arg0, arg1);
// };
// char* _gotk4_gio2_File_virtual_get_uri(void* fnptr, GFile* arg0) {
//   return ((char* (*)(GFile*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_File_virtual_get_uri_scheme(void* fnptr, GFile* arg0) {
//   return ((char* (*)(GFile*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_Mount_virtual_get_name(void* fnptr, GMount* arg0) {
//   return ((char* (*)(GMount*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_Mount_virtual_get_uuid(void* fnptr, GMount* arg0) {
//   return ((char* (*)(GMount*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_Volume_virtual_get_identifier(void* fnptr, GVolume* arg0, char* arg1) {
//   return ((char* (*)(GVolume*, char*))(fnptr))(arg0, arg1);
// };
// char* _gotk4_gio2_Volume_virtual_get_name(void* fnptr, GVolume* arg0) {
//   return ((char* (*)(GVolume*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_Volume_virtual_get_uuid(void* fnptr, GVolume* arg0) {
//   return ((char* (*)(GVolume*))(fnptr))(arg0);
// };
// char** _gotk4_gio2_AppInfo_virtual_get_supported_types(void* fnptr, GAppInfo* arg0) {
//   return ((char** (*)(GAppInfo*))(fnptr))(arg0);
// };
// char** _gotk4_gio2_Drive_virtual_enumerate_identifiers(void* fnptr, GDrive* arg0) {
//   return ((char** (*)(GDrive*))(fnptr))(arg0);
// };
// char** _gotk4_gio2_Volume_virtual_enumerate_identifiers(void* fnptr, GVolume* arg0) {
//   return ((char** (*)(GVolume*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_ActionGroup_virtual_get_action_enabled(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   return ((gboolean (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_ActionGroup_virtual_has_action(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   return ((gboolean (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_ActionGroup_virtual_query_action(void* fnptr, GActionGroup* arg0, gchar* arg1, gboolean* arg2, GVariantType** arg3, GVariantType** arg4, GVariant** arg5, GVariant** arg6) {
//   return ((gboolean (*)(GActionGroup*, gchar*, gboolean*, GVariantType**, GVariantType**, GVariant**, GVariant**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// gboolean _gotk4_gio2_Action_virtual_get_enabled(void* fnptr, GAction* arg0) {
//   return ((gboolean (*)(GAction*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_add_supports_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_can_delete(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_can_remove_supports_type(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_do_delete(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_equal(void* fnptr, GAppInfo* arg0, GAppInfo* arg1) {
//   return ((gboolean (*)(GAppInfo*, GAppInfo*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_launch(void* fnptr, GAppInfo* arg0, GList* arg1, GAppLaunchContext* arg2, GError** arg3) {
//   return ((gboolean (*)(GAppInfo*, GList*, GAppLaunchContext*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_launch_uris(void* fnptr, GAppInfo* arg0, GList* arg1, GAppLaunchContext* arg2, GError** arg3) {
//   return ((gboolean (*)(GAppInfo*, GList*, GAppLaunchContext*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_launch_uris_finish(void* fnptr, GAppInfo* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_remove_supports_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_set_as_default_for_extension(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_set_as_default_for_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_set_as_last_used_for_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_should_show(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_supports_files(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_supports_uris(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Application_virtual_dbus_register(void* fnptr, GApplication* arg0, GDBusConnection* arg1, gchar* arg2, GError** arg3) {
//   return ((gboolean (*)(GApplication*, GDBusConnection*, gchar*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_Application_virtual_name_lost(void* fnptr, GApplication* arg0) {
//   return ((gboolean (*)(GApplication*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AsyncInitable_virtual_init_finish(void* fnptr, GAsyncInitable* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GAsyncInitable*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AsyncResult_virtual_is_tagged(void* fnptr, GAsyncResult* arg0, gpointer arg1) {
//   return ((gboolean (*)(GAsyncResult*, gpointer))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_DBusInterfaceSkeleton_virtual_g_authorize_method(void* fnptr, GDBusInterfaceSkeleton* arg0, GDBusMethodInvocation* arg1) {
//   return ((gboolean (*)(GDBusInterfaceSkeleton*, GDBusMethodInvocation*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_DBusObjectSkeleton_virtual_authorize_method(void* fnptr, GDBusObjectSkeleton* arg0, GDBusInterfaceSkeleton* arg1, GDBusMethodInvocation* arg2) {
//   return ((gboolean (*)(GDBusObjectSkeleton*, GDBusInterfaceSkeleton*, GDBusMethodInvocation*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_DTLSConnection_virtual_accept_certificate(void* fnptr, GDtlsConnection* arg0, GTlsCertificate* arg1, GTlsCertificateFlags arg2) {
//   return ((gboolean (*)(GDtlsConnection*, GTlsCertificate*, GTlsCertificateFlags))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_DTLSConnection_virtual_get_binding_data(void* fnptr, GDtlsConnection* arg0, GTlsChannelBindingType arg1, GByteArray* arg2, GError** arg3) {
//   return ((gboolean (*)(GDtlsConnection*, GTlsChannelBindingType, GByteArray*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_DTLSConnection_virtual_handshake(void* fnptr, GDtlsConnection* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GDtlsConnection*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_DTLSConnection_virtual_handshake_finish(void* fnptr, GDtlsConnection* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GDtlsConnection*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_DTLSConnection_virtual_shutdown(void* fnptr, GDtlsConnection* arg0, gboolean arg1, gboolean arg2, GCancellable* arg3, GError** arg4) {
//   return ((gboolean (*)(GDtlsConnection*, gboolean, gboolean, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gio2_DTLSConnection_virtual_shutdown_finish(void* fnptr, GDtlsConnection* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GDtlsConnection*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_DatagramBased_virtual_condition_wait(void* fnptr, GDatagramBased* arg0, GIOCondition arg1, gint64 arg2, GCancellable* arg3, GError** arg4) {
//   return ((gboolean (*)(GDatagramBased*, GIOCondition, gint64, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gio2_DebugControllerDBus_virtual_authorize(void* fnptr, GDebugControllerDBus* arg0, GDBusMethodInvocation* arg1) {
//   return ((gboolean (*)(GDebugControllerDBus*, GDBusMethodInvocation*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_Drive_virtual_can_eject(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_can_poll_for_media(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_can_start(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_can_start_degraded(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_can_stop(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_eject_finish(void* fnptr, GDrive* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GDrive*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Drive_virtual_eject_with_operation_finish(void* fnptr, GDrive* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GDrive*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Drive_virtual_has_media(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_has_volumes(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_is_media_check_automatic(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_is_media_removable(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_is_removable(void* fnptr, GDrive* arg0) {
//   return ((gboolean (*)(GDrive*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Drive_virtual_poll_for_media_finish(void* fnptr, GDrive* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GDrive*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Drive_virtual_start_finish(void* fnptr, GDrive* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GDrive*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Drive_virtual_stop_finish(void* fnptr, GDrive* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GDrive*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_FileEnumerator_virtual_close_finish(void* fnptr, GFileEnumerator* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFileEnumerator*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_FileEnumerator_virtual_close_fn(void* fnptr, GFileEnumerator* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GFileEnumerator*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_FileIOStream_virtual_can_seek(void* fnptr, GFileIOStream* arg0) {
//   return ((gboolean (*)(GFileIOStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_FileIOStream_virtual_can_truncate(void* fnptr, GFileIOStream* arg0) {
//   return ((gboolean (*)(GFileIOStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_FileIOStream_virtual_seek(void* fnptr, GFileIOStream* arg0, goffset arg1, GSeekType arg2, GCancellable* arg3, GError** arg4) {
//   return ((gboolean (*)(GFileIOStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gio2_FileIOStream_virtual_truncate_fn(void* fnptr, GFileIOStream* arg0, goffset arg1, GCancellable* arg2, GError** arg3) {
//   return ((gboolean (*)(GFileIOStream*, goffset, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_FileInputStream_virtual_can_seek(void* fnptr, GFileInputStream* arg0) {
//   return ((gboolean (*)(GFileInputStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_FileInputStream_virtual_seek(void* fnptr, GFileInputStream* arg0, goffset arg1, GSeekType arg2, GCancellable* arg3, GError** arg4) {
//   return ((gboolean (*)(GFileInputStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gio2_FileMonitor_virtual_cancel(void* fnptr, GFileMonitor* arg0) {
//   return ((gboolean (*)(GFileMonitor*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_FileOutputStream_virtual_can_seek(void* fnptr, GFileOutputStream* arg0) {
//   return ((gboolean (*)(GFileOutputStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_FileOutputStream_virtual_can_truncate(void* fnptr, GFileOutputStream* arg0) {
//   return ((gboolean (*)(GFileOutputStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_FileOutputStream_virtual_seek(void* fnptr, GFileOutputStream* arg0, goffset arg1, GSeekType arg2, GCancellable* arg3, GError** arg4) {
//   return ((gboolean (*)(GFileOutputStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gio2_FileOutputStream_virtual_truncate_fn(void* fnptr, GFileOutputStream* arg0, goffset arg1, GCancellable* arg2, GError** arg3) {
//   return ((gboolean (*)(GFileOutputStream*, goffset, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_File_virtual_copy_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_delete_file(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_delete_file_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_eject_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_eject_mountable_with_operation_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_equal(void* fnptr, GFile* arg0, GFile* arg1) {
//   return ((gboolean (*)(GFile*, GFile*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_File_virtual_has_uri_scheme(void* fnptr, GFile* arg0, char* arg1) {
//   return ((gboolean (*)(GFile*, char*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_File_virtual_is_native(void* fnptr, GFile* arg0) {
//   return ((gboolean (*)(GFile*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_File_virtual_make_directory(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_make_directory_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_make_symbolic_link(void* fnptr, GFile* arg0, char* arg1, GCancellable* arg2, GError** arg3) {
//   return ((gboolean (*)(GFile*, char*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_File_virtual_make_symbolic_link_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_measure_disk_usage_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, guint64* arg2, guint64* arg3, guint64* arg4, GError** arg5) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, guint64*, guint64*, guint64*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// gboolean _gotk4_gio2_File_virtual_mount_enclosing_volume_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_move_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_poll_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_prefix_matches(void* fnptr, GFile* arg0, GFile* arg1) {
//   return ((gboolean (*)(GFile*, GFile*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_File_virtual_set_attribute(void* fnptr, GFile* arg0, char* arg1, GFileAttributeType arg2, gpointer arg3, GFileQueryInfoFlags arg4, GCancellable* arg5, GError** arg6) {
//   return ((gboolean (*)(GFile*, char*, GFileAttributeType, gpointer, GFileQueryInfoFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// gboolean _gotk4_gio2_File_virtual_set_attributes_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GFileInfo** arg2, GError** arg3) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GFileInfo**, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_File_virtual_set_attributes_from_info(void* fnptr, GFile* arg0, GFileInfo* arg1, GFileQueryInfoFlags arg2, GCancellable* arg3, GError** arg4) {
//   return ((gboolean (*)(GFile*, GFileInfo*, GFileQueryInfoFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gio2_File_virtual_start_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_stop_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_trash(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_trash_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_unmount_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_unmount_mountable_with_operation_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_IOStream_virtual_close_finish(void* fnptr, GIOStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GIOStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_IOStream_virtual_close_fn(void* fnptr, GIOStream* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GIOStream*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Icon_virtual_equal(void* fnptr, GIcon* arg0, GIcon* arg1) {
//   return ((gboolean (*)(GIcon*, GIcon*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_Initable_virtual_init(void* fnptr, GInitable* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GInitable*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_InputStream_virtual_close_finish(void* fnptr, GInputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GInputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_InputStream_virtual_close_fn(void* fnptr, GInputStream* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GInputStream*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_MenuAttributeIter_virtual_get_next(void* fnptr, GMenuAttributeIter* arg0, gchar** arg1, GVariant** arg2) {
//   return ((gboolean (*)(GMenuAttributeIter*, gchar**, GVariant**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_MenuLinkIter_virtual_get_next(void* fnptr, GMenuLinkIter* arg0, gchar** arg1, GMenuModel** arg2) {
//   return ((gboolean (*)(GMenuLinkIter*, gchar**, GMenuModel**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_MenuModel_virtual_is_mutable(void* fnptr, GMenuModel* arg0) {
//   return ((gboolean (*)(GMenuModel*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Mount_virtual_can_eject(void* fnptr, GMount* arg0) {
//   return ((gboolean (*)(GMount*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Mount_virtual_can_unmount(void* fnptr, GMount* arg0) {
//   return ((gboolean (*)(GMount*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Mount_virtual_eject_finish(void* fnptr, GMount* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GMount*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Mount_virtual_eject_with_operation_finish(void* fnptr, GMount* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GMount*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Mount_virtual_remount_finish(void* fnptr, GMount* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GMount*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Mount_virtual_unmount_finish(void* fnptr, GMount* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GMount*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Mount_virtual_unmount_with_operation_finish(void* fnptr, GMount* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GMount*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_NetworkMonitor_virtual_can_reach(void* fnptr, GNetworkMonitor* arg0, GSocketConnectable* arg1, GCancellable* arg2, GError** arg3) {
//   return ((gboolean (*)(GNetworkMonitor*, GSocketConnectable*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_NetworkMonitor_virtual_can_reach_finish(void* fnptr, GNetworkMonitor* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GNetworkMonitor*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_OutputStream_virtual_close_finish(void* fnptr, GOutputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GOutputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_OutputStream_virtual_close_fn(void* fnptr, GOutputStream* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GOutputStream*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_OutputStream_virtual_flush(void* fnptr, GOutputStream* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GOutputStream*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_OutputStream_virtual_flush_finish(void* fnptr, GOutputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GOutputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_OutputStream_virtual_writev_finish(void* fnptr, GOutputStream* arg0, GAsyncResult* arg1, gsize* arg2, GError** arg3) {
//   return ((gboolean (*)(GOutputStream*, GAsyncResult*, gsize*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_OutputStream_virtual_writev_fn(void* fnptr, GOutputStream* arg0, GOutputVector* arg1, gsize arg2, gsize* arg3, GCancellable* arg4, GError** arg5) {
//   return ((gboolean (*)(GOutputStream*, GOutputVector*, gsize, gsize*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// gboolean _gotk4_gio2_Permission_virtual_acquire(void* fnptr, GPermission* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GPermission*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Permission_virtual_acquire_finish(void* fnptr, GPermission* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GPermission*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Permission_virtual_release(void* fnptr, GPermission* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GPermission*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Permission_virtual_release_finish(void* fnptr, GPermission* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GPermission*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_PollableInputStream_virtual_can_poll(void* fnptr, GPollableInputStream* arg0) {
//   return ((gboolean (*)(GPollableInputStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_PollableInputStream_virtual_is_readable(void* fnptr, GPollableInputStream* arg0) {
//   return ((gboolean (*)(GPollableInputStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_PollableOutputStream_virtual_can_poll(void* fnptr, GPollableOutputStream* arg0) {
//   return ((gboolean (*)(GPollableOutputStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_PollableOutputStream_virtual_is_writable(void* fnptr, GPollableOutputStream* arg0) {
//   return ((gboolean (*)(GPollableOutputStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_ProxyResolver_virtual_is_supported(void* fnptr, GProxyResolver* arg0) {
//   return ((gboolean (*)(GProxyResolver*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Proxy_virtual_supports_hostname(void* fnptr, GProxy* arg0) {
//   return ((gboolean (*)(GProxy*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Seekable_virtual_can_seek(void* fnptr, GSeekable* arg0) {
//   return ((gboolean (*)(GSeekable*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Seekable_virtual_can_truncate(void* fnptr, GSeekable* arg0) {
//   return ((gboolean (*)(GSeekable*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Seekable_virtual_seek(void* fnptr, GSeekable* arg0, goffset arg1, GSeekType arg2, GCancellable* arg3, GError** arg4) {
//   return ((gboolean (*)(GSeekable*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gio2_Seekable_virtual_truncate_fn(void* fnptr, GSeekable* arg0, goffset arg1, GCancellable* arg2, GError** arg3) {
//   return ((gboolean (*)(GSeekable*, goffset, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_Settings_virtual_change_event(void* fnptr, GSettings* arg0, GQuark* arg1, gint arg2) {
//   return ((gboolean (*)(GSettings*, GQuark*, gint))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Settings_virtual_writable_change_event(void* fnptr, GSettings* arg0, GQuark arg1) {
//   return ((gboolean (*)(GSettings*, GQuark))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_SocketAddress_virtual_to_native(void* fnptr, GSocketAddress* arg0, gpointer arg1, gsize arg2, GError** arg3) {
//   return ((gboolean (*)(GSocketAddress*, gpointer, gsize, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_SocketService_virtual_incoming(void* fnptr, GSocketService* arg0, GSocketConnection* arg1, GObject* arg2) {
//   return ((gboolean (*)(GSocketService*, GSocketConnection*, GObject*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_TLSBackend_virtual_supports_dtls(void* fnptr, GTlsBackend* arg0) {
//   return ((gboolean (*)(GTlsBackend*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_TLSBackend_virtual_supports_tls(void* fnptr, GTlsBackend* arg0) {
//   return ((gboolean (*)(GTlsBackend*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_TLSConnection_virtual_accept_certificate(void* fnptr, GTlsConnection* arg0, GTlsCertificate* arg1, GTlsCertificateFlags arg2) {
//   return ((gboolean (*)(GTlsConnection*, GTlsCertificate*, GTlsCertificateFlags))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_TLSConnection_virtual_get_binding_data(void* fnptr, GTlsConnection* arg0, GTlsChannelBindingType arg1, GByteArray* arg2, GError** arg3) {
//   return ((gboolean (*)(GTlsConnection*, GTlsChannelBindingType, GByteArray*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_TLSConnection_virtual_handshake(void* fnptr, GTlsConnection* arg0, GCancellable* arg1, GError** arg2) {
//   return ((gboolean (*)(GTlsConnection*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_TLSConnection_virtual_handshake_finish(void* fnptr, GTlsConnection* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GTlsConnection*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_ThreadedSocketService_virtual_run(void* fnptr, GThreadedSocketService* arg0, GSocketConnection* arg1, GObject* arg2) {
//   return ((gboolean (*)(GThreadedSocketService*, GSocketConnection*, GObject*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_VFS_virtual_is_active(void* fnptr, GVfs* arg0) {
//   return ((gboolean (*)(GVfs*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_VFS_virtual_local_file_set_attributes(void* fnptr, GVfs* arg0, char* arg1, GFileInfo* arg2, GFileQueryInfoFlags arg3, GCancellable* arg4, GError** arg5) {
//   return ((gboolean (*)(GVfs*, char*, GFileInfo*, GFileQueryInfoFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// gboolean _gotk4_gio2_Volume_virtual_can_eject(void* fnptr, GVolume* arg0) {
//   return ((gboolean (*)(GVolume*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Volume_virtual_can_mount(void* fnptr, GVolume* arg0) {
//   return ((gboolean (*)(GVolume*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Volume_virtual_eject_finish(void* fnptr, GVolume* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GVolume*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Volume_virtual_eject_with_operation_finish(void* fnptr, GVolume* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GVolume*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Volume_virtual_mount_finish(void* fnptr, GVolume* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GVolume*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Volume_virtual_should_automount(void* fnptr, GVolume* arg0) {
//   return ((gboolean (*)(GVolume*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_Action_virtual_get_name(void* fnptr, GAction* arg0) {
//   return ((gchar* (*)(GAction*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_DBusObjectManager_virtual_get_object_path(void* fnptr, GDBusObjectManager* arg0) {
//   return ((gchar* (*)(GDBusObjectManager*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_DBusObject_virtual_get_object_path(void* fnptr, GDBusObject* arg0) {
//   return ((gchar* (*)(GDBusObject*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_DTLSConnection_virtual_get_negotiated_protocol(void* fnptr, GDtlsConnection* arg0) {
//   return ((gchar* (*)(GDtlsConnection*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_Drive_virtual_get_sort_key(void* fnptr, GDrive* arg0) {
//   return ((gchar* (*)(GDrive*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_InetAddress_virtual_to_string(void* fnptr, GInetAddress* arg0) {
//   return ((gchar* (*)(GInetAddress*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_Mount_virtual_get_sort_key(void* fnptr, GMount* arg0) {
//   return ((gchar* (*)(GMount*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_Resolver_virtual_lookup_by_address(void* fnptr, GResolver* arg0, GInetAddress* arg1, GCancellable* arg2, GError** arg3) {
//   return ((gchar* (*)(GResolver*, GInetAddress*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gchar* _gotk4_gio2_Resolver_virtual_lookup_by_address_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gchar* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gchar* _gotk4_gio2_SocketConnectable_virtual_to_string(void* fnptr, GSocketConnectable* arg0) {
//   return ((gchar* (*)(GSocketConnectable*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_TLSConnection_virtual_get_negotiated_protocol(void* fnptr, GTlsConnection* arg0) {
//   return ((gchar* (*)(GTlsConnection*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_TLSDatabase_virtual_create_certificate_handle(void* fnptr, GTlsDatabase* arg0, GTlsCertificate* arg1) {
//   return ((gchar* (*)(GTlsDatabase*, GTlsCertificate*))(fnptr))(arg0, arg1);
// };
// gchar* _gotk4_gio2_TLSPassword_virtual_get_default_warning(void* fnptr, GTlsPassword* arg0) {
//   return ((gchar* (*)(GTlsPassword*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_Volume_virtual_get_sort_key(void* fnptr, GVolume* arg0) {
//   return ((gchar* (*)(GVolume*))(fnptr))(arg0);
// };
// gchar** _gotk4_gio2_ActionGroup_virtual_list_actions(void* fnptr, GActionGroup* arg0) {
//   return ((gchar** (*)(GActionGroup*))(fnptr))(arg0);
// };
// gchar** _gotk4_gio2_Mount_virtual_guess_content_type_finish(void* fnptr, GMount* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gchar** (*)(GMount*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gchar** _gotk4_gio2_Mount_virtual_guess_content_type_sync(void* fnptr, GMount* arg0, gboolean arg1, GCancellable* arg2, GError** arg3) {
//   return ((gchar** (*)(GMount*, gboolean, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gchar** _gotk4_gio2_ProxyResolver_virtual_lookup(void* fnptr, GProxyResolver* arg0, gchar* arg1, GCancellable* arg2, GError** arg3) {
//   return ((gchar** (*)(GProxyResolver*, gchar*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gchar** _gotk4_gio2_ProxyResolver_virtual_lookup_finish(void* fnptr, GProxyResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gchar** (*)(GProxyResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gchar** _gotk4_gio2_VFS_virtual_get_supported_uri_schemes(void* fnptr, GVfs* arg0) {
//   return ((gchar** (*)(GVfs*))(fnptr))(arg0);
// };
// gint _gotk4_gio2_Application_virtual_handle_local_options(void* fnptr, GApplication* arg0, GVariantDict* arg1) {
//   return ((gint (*)(GApplication*, GVariantDict*))(fnptr))(arg0, arg1);
// };
// gint _gotk4_gio2_DatagramBased_virtual_receive_messages(void* fnptr, GDatagramBased* arg0, GInputMessage* arg1, guint arg2, gint arg3, gint64 arg4, GCancellable* arg5, GError** arg6) {
//   return ((gint (*)(GDatagramBased*, GInputMessage*, guint, gint, gint64, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// gint _gotk4_gio2_DatagramBased_virtual_send_messages(void* fnptr, GDatagramBased* arg0, GOutputMessage* arg1, guint arg2, gint arg3, gint64 arg4, GCancellable* arg5, GError** arg6) {
//   return ((gint (*)(GDatagramBased*, GOutputMessage*, guint, gint, gint64, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// gint _gotk4_gio2_MenuModel_virtual_get_n_items(void* fnptr, GMenuModel* arg0) {
//   return ((gint (*)(GMenuModel*))(fnptr))(arg0);
// };
// goffset _gotk4_gio2_FileIOStream_virtual_tell(void* fnptr, GFileIOStream* arg0) {
//   return ((goffset (*)(GFileIOStream*))(fnptr))(arg0);
// };
// goffset _gotk4_gio2_FileInputStream_virtual_tell(void* fnptr, GFileInputStream* arg0) {
//   return ((goffset (*)(GFileInputStream*))(fnptr))(arg0);
// };
// goffset _gotk4_gio2_FileOutputStream_virtual_tell(void* fnptr, GFileOutputStream* arg0) {
//   return ((goffset (*)(GFileOutputStream*))(fnptr))(arg0);
// };
// goffset _gotk4_gio2_Seekable_virtual_tell(void* fnptr, GSeekable* arg0) {
//   return ((goffset (*)(GSeekable*))(fnptr))(arg0);
// };
// gpointer _gotk4_gio2_AsyncResult_virtual_get_user_data(void* fnptr, GAsyncResult* arg0) {
//   return ((gpointer (*)(GAsyncResult*))(fnptr))(arg0);
// };
// gpointer _gotk4_gio2_ListModel_virtual_get_item(void* fnptr, GListModel* arg0, guint arg1) {
//   return ((gpointer (*)(GListModel*, guint))(fnptr))(arg0, arg1);
// };
// gsize _gotk4_gio2_SocketControlMessage_virtual_get_size(void* fnptr, GSocketControlMessage* arg0) {
//   return ((gsize (*)(GSocketControlMessage*))(fnptr))(arg0);
// };
// gssize _gotk4_gio2_BufferedInputStream_virtual_fill(void* fnptr, GBufferedInputStream* arg0, gssize arg1, GCancellable* arg2, GError** arg3) {
//   return ((gssize (*)(GBufferedInputStream*, gssize, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gssize _gotk4_gio2_BufferedInputStream_virtual_fill_finish(void* fnptr, GBufferedInputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gssize (*)(GBufferedInputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gssize _gotk4_gio2_InputStream_virtual_read_finish(void* fnptr, GInputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gssize (*)(GInputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gssize _gotk4_gio2_InputStream_virtual_skip(void* fnptr, GInputStream* arg0, gsize arg1, GCancellable* arg2, GError** arg3) {
//   return ((gssize (*)(GInputStream*, gsize, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gssize _gotk4_gio2_InputStream_virtual_skip_finish(void* fnptr, GInputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gssize (*)(GInputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gssize _gotk4_gio2_OutputStream_virtual_splice(void* fnptr, GOutputStream* arg0, GInputStream* arg1, GOutputStreamSpliceFlags arg2, GCancellable* arg3, GError** arg4) {
//   return ((gssize (*)(GOutputStream*, GInputStream*, GOutputStreamSpliceFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gssize _gotk4_gio2_OutputStream_virtual_splice_finish(void* fnptr, GOutputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gssize (*)(GOutputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gssize _gotk4_gio2_OutputStream_virtual_write_finish(void* fnptr, GOutputStream* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gssize (*)(GOutputStream*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gssize _gotk4_gio2_OutputStream_virtual_write_fn(void* fnptr, GOutputStream* arg0, void* arg1, gsize arg2, GCancellable* arg3, GError** arg4) {
//   return ((gssize (*)(GOutputStream*, void*, gsize, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gssize _gotk4_gio2_PollableInputStream_virtual_read_nonblocking(void* fnptr, GPollableInputStream* arg0, void* arg1, gsize arg2, GError** arg3) {
//   return ((gssize (*)(GPollableInputStream*, void*, gsize, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gssize _gotk4_gio2_PollableOutputStream_virtual_write_nonblocking(void* fnptr, GPollableOutputStream* arg0, void* arg1, gsize arg2, GError** arg3) {
//   return ((gssize (*)(GPollableOutputStream*, void*, gsize, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gssize _gotk4_gio2_SocketAddress_virtual_get_native_size(void* fnptr, GSocketAddress* arg0) {
//   return ((gssize (*)(GSocketAddress*))(fnptr))(arg0);
// };
// guchar* _gotk4_gio2_TLSPassword_virtual_get_value(void* fnptr, GTlsPassword* arg0, gsize* arg1) {
//   return ((guchar* (*)(GTlsPassword*, gsize*))(fnptr))(arg0, arg1);
// };
// guint _gotk4_gio2_File_virtual_hash(void* fnptr, GFile* arg0) {
//   return ((guint (*)(GFile*))(fnptr))(arg0);
// };
// guint _gotk4_gio2_Icon_virtual_hash(void* fnptr, GIcon* arg0) {
//   return ((guint (*)(GIcon*))(fnptr))(arg0);
// };
// guint _gotk4_gio2_ListModel_virtual_get_n_items(void* fnptr, GListModel* arg0) {
//   return ((guint (*)(GListModel*))(fnptr))(arg0);
// };
// int _gotk4_gio2_Application_virtual_command_line(void* fnptr, GApplication* arg0, GApplicationCommandLine* arg1) {
//   return ((int (*)(GApplication*, GApplicationCommandLine*))(fnptr))(arg0, arg1);
// };
// int _gotk4_gio2_SocketControlMessage_virtual_get_level(void* fnptr, GSocketControlMessage* arg0) {
//   return ((int (*)(GSocketControlMessage*))(fnptr))(arg0);
// };
// int _gotk4_gio2_SocketControlMessage_virtual_get_type(void* fnptr, GSocketControlMessage* arg0) {
//   return ((int (*)(GSocketControlMessage*))(fnptr))(arg0);
// };
// void _gotk4_gio2_ActionGroup_virtual_action_added(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   ((void (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_ActionGroup_virtual_action_enabled_changed(void* fnptr, GActionGroup* arg0, gchar* arg1, gboolean arg2) {
//   ((void (*)(GActionGroup*, gchar*, gboolean))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_ActionGroup_virtual_action_removed(void* fnptr, GActionGroup* arg0, gchar* arg1) {
//   ((void (*)(GActionGroup*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_ActionGroup_virtual_action_state_changed(void* fnptr, GActionGroup* arg0, gchar* arg1, GVariant* arg2) {
//   ((void (*)(GActionGroup*, gchar*, GVariant*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_ActionGroup_virtual_activate_action(void* fnptr, GActionGroup* arg0, gchar* arg1, GVariant* arg2) {
//   ((void (*)(GActionGroup*, gchar*, GVariant*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_ActionGroup_virtual_change_action_state(void* fnptr, GActionGroup* arg0, gchar* arg1, GVariant* arg2) {
//   ((void (*)(GActionGroup*, gchar*, GVariant*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_ActionMap_virtual_add_action(void* fnptr, GActionMap* arg0, GAction* arg1) {
//   ((void (*)(GActionMap*, GAction*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_ActionMap_virtual_remove_action(void* fnptr, GActionMap* arg0, gchar* arg1) {
//   ((void (*)(GActionMap*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Action_virtual_activate(void* fnptr, GAction* arg0, GVariant* arg1) {
//   ((void (*)(GAction*, GVariant*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Action_virtual_change_state(void* fnptr, GAction* arg0, GVariant* arg1) {
//   ((void (*)(GAction*, GVariant*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_AppInfo_virtual_launch_uris_async(void* fnptr, GAppInfo* arg0, GList* arg1, GAppLaunchContext* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GAppInfo*, GList*, GAppLaunchContext*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_AppLaunchContext_virtual_launch_failed(void* fnptr, GAppLaunchContext* arg0, char* arg1) {
//   ((void (*)(GAppLaunchContext*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_AppLaunchContext_virtual_launch_started(void* fnptr, GAppLaunchContext* arg0, GAppInfo* arg1, GVariant* arg2) {
//   ((void (*)(GAppLaunchContext*, GAppInfo*, GVariant*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_AppLaunchContext_virtual_launched(void* fnptr, GAppLaunchContext* arg0, GAppInfo* arg1, GVariant* arg2) {
//   ((void (*)(GAppLaunchContext*, GAppInfo*, GVariant*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_ApplicationCommandLine_virtual_done(void* fnptr, GApplicationCommandLine* arg0) {
//   ((void (*)(GApplicationCommandLine*))(fnptr))(arg0);
// };
// void _gotk4_gio2_ApplicationCommandLine_virtual_print_literal(void* fnptr, GApplicationCommandLine* arg0, gchar* arg1) {
//   ((void (*)(GApplicationCommandLine*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_ApplicationCommandLine_virtual_printerr_literal(void* fnptr, GApplicationCommandLine* arg0, gchar* arg1) {
//   ((void (*)(GApplicationCommandLine*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_activate(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Application_virtual_add_platform_data(void* fnptr, GApplication* arg0, GVariantBuilder* arg1) {
//   ((void (*)(GApplication*, GVariantBuilder*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_after_emit(void* fnptr, GApplication* arg0, GVariant* arg1) {
//   ((void (*)(GApplication*, GVariant*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_before_emit(void* fnptr, GApplication* arg0, GVariant* arg1) {
//   ((void (*)(GApplication*, GVariant*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_dbus_unregister(void* fnptr, GApplication* arg0, GDBusConnection* arg1, gchar* arg2) {
//   ((void (*)(GApplication*, GDBusConnection*, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_Application_virtual_open(void* fnptr, GApplication* arg0, GFile** arg1, gint arg2, gchar* arg3) {
//   ((void (*)(GApplication*, GFile**, gint, gchar*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_Application_virtual_quit_mainloop(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Application_virtual_run_mainloop(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Application_virtual_shutdown(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Application_virtual_startup(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_AsyncInitable_virtual_init_async(void* fnptr, GAsyncInitable* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GAsyncInitable*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_BufferedInputStream_virtual_fill_async(void* fnptr, GBufferedInputStream* arg0, gssize arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GBufferedInputStream*, gssize, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Cancellable_virtual_cancelled(void* fnptr, GCancellable* arg0) {
//   ((void (*)(GCancellable*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Converter_virtual_reset(void* fnptr, GConverter* arg0) {
//   ((void (*)(GConverter*))(fnptr))(arg0);
// };
// void _gotk4_gio2_DBusInterfaceSkeleton_virtual_flush(void* fnptr, GDBusInterfaceSkeleton* arg0) {
//   ((void (*)(GDBusInterfaceSkeleton*))(fnptr))(arg0);
// };
// void _gotk4_gio2_DBusInterface_virtual_set_object(void* fnptr, GDBusInterface* arg0, GDBusObject* arg1) {
//   ((void (*)(GDBusInterface*, GDBusObject*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_DBusObjectManagerClient_virtual_interface_proxy_signal(void* fnptr, GDBusObjectManagerClient* arg0, GDBusObjectProxy* arg1, GDBusProxy* arg2, gchar* arg3, gchar* arg4, GVariant* arg5) {
//   ((void (*)(GDBusObjectManagerClient*, GDBusObjectProxy*, GDBusProxy*, gchar*, gchar*, GVariant*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_DBusObjectManager_virtual_interface_added(void* fnptr, GDBusObjectManager* arg0, GDBusObject* arg1, GDBusInterface* arg2) {
//   ((void (*)(GDBusObjectManager*, GDBusObject*, GDBusInterface*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_DBusObjectManager_virtual_interface_removed(void* fnptr, GDBusObjectManager* arg0, GDBusObject* arg1, GDBusInterface* arg2) {
//   ((void (*)(GDBusObjectManager*, GDBusObject*, GDBusInterface*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_DBusObjectManager_virtual_object_added(void* fnptr, GDBusObjectManager* arg0, GDBusObject* arg1) {
//   ((void (*)(GDBusObjectManager*, GDBusObject*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_DBusObjectManager_virtual_object_removed(void* fnptr, GDBusObjectManager* arg0, GDBusObject* arg1) {
//   ((void (*)(GDBusObjectManager*, GDBusObject*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_DBusObject_virtual_interface_added(void* fnptr, GDBusObject* arg0, GDBusInterface* arg1) {
//   ((void (*)(GDBusObject*, GDBusInterface*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_DBusObject_virtual_interface_removed(void* fnptr, GDBusObject* arg0, GDBusInterface* arg1) {
//   ((void (*)(GDBusObject*, GDBusInterface*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_DBusProxy_virtual_g_signal(void* fnptr, GDBusProxy* arg0, gchar* arg1, gchar* arg2, GVariant* arg3) {
//   ((void (*)(GDBusProxy*, gchar*, gchar*, GVariant*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_DTLSConnection_virtual_handshake_async(void* fnptr, GDtlsConnection* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GDtlsConnection*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_DTLSConnection_virtual_set_advertised_protocols(void* fnptr, GDtlsConnection* arg0, gchar** arg1) {
//   ((void (*)(GDtlsConnection*, gchar**))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_DTLSConnection_virtual_shutdown_async(void* fnptr, GDtlsConnection* arg0, gboolean arg1, gboolean arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GDtlsConnection*, gboolean, gboolean, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_Drive_virtual_changed(void* fnptr, GDrive* arg0) {
//   ((void (*)(GDrive*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Drive_virtual_disconnected(void* fnptr, GDrive* arg0) {
//   ((void (*)(GDrive*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Drive_virtual_eject(void* fnptr, GDrive* arg0, GMountUnmountFlags arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GDrive*, GMountUnmountFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Drive_virtual_eject_button(void* fnptr, GDrive* arg0) {
//   ((void (*)(GDrive*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Drive_virtual_eject_with_operation(void* fnptr, GDrive* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GDrive*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Drive_virtual_poll_for_media(void* fnptr, GDrive* arg0, GCancellable* arg1, GAsyncReadyCallback arg2, gpointer arg3) {
//   ((void (*)(GDrive*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_Drive_virtual_start(void* fnptr, GDrive* arg0, GDriveStartFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GDrive*, GDriveStartFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Drive_virtual_stop(void* fnptr, GDrive* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GDrive*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Drive_virtual_stop_button(void* fnptr, GDrive* arg0) {
//   ((void (*)(GDrive*))(fnptr))(arg0);
// };
// void _gotk4_gio2_FileEnumerator_virtual_close_async(void* fnptr, GFileEnumerator* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFileEnumerator*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_FileEnumerator_virtual_next_files_async(void* fnptr, GFileEnumerator* arg0, int arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFileEnumerator*, int, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_FileIOStream_virtual_query_info_async(void* fnptr, GFileIOStream* arg0, char* arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFileIOStream*, char*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_FileInputStream_virtual_query_info_async(void* fnptr, GFileInputStream* arg0, char* arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFileInputStream*, char*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_FileMonitor_virtual_changed(void* fnptr, GFileMonitor* arg0, GFile* arg1, GFile* arg2, GFileMonitorEvent arg3) {
//   ((void (*)(GFileMonitor*, GFile*, GFile*, GFileMonitorEvent))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_FileOutputStream_virtual_query_info_async(void* fnptr, GFileOutputStream* arg0, char* arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFileOutputStream*, char*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_append_to_async(void* fnptr, GFile* arg0, GFileCreateFlags arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GFileCreateFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_create_async(void* fnptr, GFile* arg0, GFileCreateFlags arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GFileCreateFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_create_readwrite_async(void* fnptr, GFile* arg0, GFileCreateFlags arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GFileCreateFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_delete_file_async(void* fnptr, GFile* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_eject_mountable(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, GMountUnmountFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_eject_mountable_with_operation(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_enumerate_children_async(void* fnptr, GFile* arg0, char* arg1, GFileQueryInfoFlags arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GFile*, char*, GFileQueryInfoFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_File_virtual_find_enclosing_mount_async(void* fnptr, GFile* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_make_directory_async(void* fnptr, GFile* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_make_symbolic_link_async(void* fnptr, GFile* arg0, char* arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, char*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_mount_enclosing_volume(void* fnptr, GFile* arg0, GMountMountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountMountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_mount_mountable(void* fnptr, GFile* arg0, GMountMountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountMountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_open_readwrite_async(void* fnptr, GFile* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_poll_mountable(void* fnptr, GFile* arg0, GCancellable* arg1, GAsyncReadyCallback arg2, gpointer arg3) {
//   ((void (*)(GFile*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_File_virtual_query_filesystem_info_async(void* fnptr, GFile* arg0, char* arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, char*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_query_info_async(void* fnptr, GFile* arg0, char* arg1, GFileQueryInfoFlags arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GFile*, char*, GFileQueryInfoFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_File_virtual_read_async(void* fnptr, GFile* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_replace_async(void* fnptr, GFile* arg0, char* arg1, gboolean arg2, GFileCreateFlags arg3, int arg4, GCancellable* arg5, GAsyncReadyCallback arg6, gpointer arg7) {
//   ((void (*)(GFile*, char*, gboolean, GFileCreateFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
// };
// void _gotk4_gio2_File_virtual_replace_readwrite_async(void* fnptr, GFile* arg0, char* arg1, gboolean arg2, GFileCreateFlags arg3, int arg4, GCancellable* arg5, GAsyncReadyCallback arg6, gpointer arg7) {
//   ((void (*)(GFile*, char*, gboolean, GFileCreateFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
// };
// void _gotk4_gio2_File_virtual_set_attributes_async(void* fnptr, GFile* arg0, GFileInfo* arg1, GFileQueryInfoFlags arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GFile*, GFileInfo*, GFileQueryInfoFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_File_virtual_set_display_name_async(void* fnptr, GFile* arg0, char* arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, char*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_start_mountable(void* fnptr, GFile* arg0, GDriveStartFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GDriveStartFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_stop_mountable(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_trash_async(void* fnptr, GFile* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_unmount_mountable(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, GMountUnmountFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_unmount_mountable_with_operation(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_FilenameCompleter_virtual_got_completion_data(void* fnptr, GFilenameCompleter* arg0) {
//   ((void (*)(GFilenameCompleter*))(fnptr))(arg0);
// };
// void _gotk4_gio2_IOStream_virtual_close_async(void* fnptr, GIOStream* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GIOStream*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_InputStream_virtual_close_async(void* fnptr, GInputStream* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GInputStream*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_InputStream_virtual_read_async(void* fnptr, GInputStream* arg0, void* arg1, gsize arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GInputStream*, void*, gsize, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_InputStream_virtual_skip_async(void* fnptr, GInputStream* arg0, gsize arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GInputStream*, gsize, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_LoadableIcon_virtual_load_async(void* fnptr, GLoadableIcon* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GLoadableIcon*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_MemoryMonitor_virtual_low_memory_warning(void* fnptr, GMemoryMonitor* arg0, GMemoryMonitorWarningLevel arg1) {
//   ((void (*)(GMemoryMonitor*, GMemoryMonitorWarningLevel))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_MenuModel_virtual_get_item_attributes(void* fnptr, GMenuModel* arg0, gint arg1, GHashTable** arg2) {
//   ((void (*)(GMenuModel*, gint, GHashTable**))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_MenuModel_virtual_get_item_links(void* fnptr, GMenuModel* arg0, gint arg1, GHashTable** arg2) {
//   ((void (*)(GMenuModel*, gint, GHashTable**))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_MountOperation_virtual_aborted(void* fnptr, GMountOperation* arg0) {
//   ((void (*)(GMountOperation*))(fnptr))(arg0);
// };
// void _gotk4_gio2_MountOperation_virtual_ask_password(void* fnptr, GMountOperation* arg0, char* arg1, char* arg2, char* arg3, GAskPasswordFlags arg4) {
//   ((void (*)(GMountOperation*, char*, char*, char*, GAskPasswordFlags))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_MountOperation_virtual_ask_question(void* fnptr, GMountOperation* arg0, char* arg1, char** arg2) {
//   ((void (*)(GMountOperation*, char*, char**))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_MountOperation_virtual_reply(void* fnptr, GMountOperation* arg0, GMountOperationResult arg1) {
//   ((void (*)(GMountOperation*, GMountOperationResult))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_MountOperation_virtual_show_unmount_progress(void* fnptr, GMountOperation* arg0, gchar* arg1, gint64 arg2, gint64 arg3) {
//   ((void (*)(GMountOperation*, gchar*, gint64, gint64))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_Mount_virtual_changed(void* fnptr, GMount* arg0) {
//   ((void (*)(GMount*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Mount_virtual_eject(void* fnptr, GMount* arg0, GMountUnmountFlags arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GMount*, GMountUnmountFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Mount_virtual_eject_with_operation(void* fnptr, GMount* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GMount*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Mount_virtual_guess_content_type(void* fnptr, GMount* arg0, gboolean arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GMount*, gboolean, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Mount_virtual_pre_unmount(void* fnptr, GMount* arg0) {
//   ((void (*)(GMount*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Mount_virtual_remount(void* fnptr, GMount* arg0, GMountMountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GMount*, GMountMountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Mount_virtual_unmount(void* fnptr, GMount* arg0, GMountUnmountFlags arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GMount*, GMountUnmountFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Mount_virtual_unmount_with_operation(void* fnptr, GMount* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GMount*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Mount_virtual_unmounted(void* fnptr, GMount* arg0) {
//   ((void (*)(GMount*))(fnptr))(arg0);
// };
// void _gotk4_gio2_NetworkMonitor_virtual_can_reach_async(void* fnptr, GNetworkMonitor* arg0, GSocketConnectable* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GNetworkMonitor*, GSocketConnectable*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_NetworkMonitor_virtual_network_changed(void* fnptr, GNetworkMonitor* arg0, gboolean arg1) {
//   ((void (*)(GNetworkMonitor*, gboolean))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_OutputStream_virtual_close_async(void* fnptr, GOutputStream* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GOutputStream*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_OutputStream_virtual_flush_async(void* fnptr, GOutputStream* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GOutputStream*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_OutputStream_virtual_splice_async(void* fnptr, GOutputStream* arg0, GInputStream* arg1, GOutputStreamSpliceFlags arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GOutputStream*, GInputStream*, GOutputStreamSpliceFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_OutputStream_virtual_write_async(void* fnptr, GOutputStream* arg0, void* arg1, gsize arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GOutputStream*, void*, gsize, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_OutputStream_virtual_writev_async(void* fnptr, GOutputStream* arg0, GOutputVector* arg1, gsize arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GOutputStream*, GOutputVector*, gsize, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_Permission_virtual_acquire_async(void* fnptr, GPermission* arg0, GCancellable* arg1, GAsyncReadyCallback arg2, gpointer arg3) {
//   ((void (*)(GPermission*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_Permission_virtual_release_async(void* fnptr, GPermission* arg0, GCancellable* arg1, GAsyncReadyCallback arg2, gpointer arg3) {
//   ((void (*)(GPermission*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_ProxyResolver_virtual_lookup_async(void* fnptr, GProxyResolver* arg0, gchar* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GProxyResolver*, gchar*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Proxy_virtual_connect_async(void* fnptr, GProxy* arg0, GIOStream* arg1, GProxyAddress* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GProxy*, GIOStream*, GProxyAddress*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_RemoteActionGroup_virtual_activate_action_full(void* fnptr, GRemoteActionGroup* arg0, gchar* arg1, GVariant* arg2, GVariant* arg3) {
//   ((void (*)(GRemoteActionGroup*, gchar*, GVariant*, GVariant*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_RemoteActionGroup_virtual_change_action_state_full(void* fnptr, GRemoteActionGroup* arg0, gchar* arg1, GVariant* arg2, GVariant* arg3) {
//   ((void (*)(GRemoteActionGroup*, gchar*, GVariant*, GVariant*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_Resolver_virtual_lookup_by_address_async(void* fnptr, GResolver* arg0, GInetAddress* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GResolver*, GInetAddress*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Resolver_virtual_lookup_by_name_async(void* fnptr, GResolver* arg0, gchar* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GResolver*, gchar*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Resolver_virtual_lookup_by_name_with_flags_async(void* fnptr, GResolver* arg0, gchar* arg1, GResolverNameLookupFlags arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GResolver*, gchar*, GResolverNameLookupFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Resolver_virtual_lookup_records_async(void* fnptr, GResolver* arg0, gchar* arg1, GResolverRecordType arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GResolver*, gchar*, GResolverRecordType, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Resolver_virtual_lookup_service_async(void* fnptr, GResolver* arg0, gchar* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GResolver*, gchar*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Resolver_virtual_reload(void* fnptr, GResolver* arg0) {
//   ((void (*)(GResolver*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Settings_virtual_changed(void* fnptr, GSettings* arg0, gchar* arg1) {
//   ((void (*)(GSettings*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Settings_virtual_writable_changed(void* fnptr, GSettings* arg0, gchar* arg1) {
//   ((void (*)(GSettings*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_SocketAddressEnumerator_virtual_next_async(void* fnptr, GSocketAddressEnumerator* arg0, GCancellable* arg1, GAsyncReadyCallback arg2, gpointer arg3) {
//   ((void (*)(GSocketAddressEnumerator*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_SocketClient_virtual_event(void* fnptr, GSocketClient* arg0, GSocketClientEvent arg1, GSocketConnectable* arg2, GIOStream* arg3) {
//   ((void (*)(GSocketClient*, GSocketClientEvent, GSocketConnectable*, GIOStream*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_SocketControlMessage_virtual_serialize(void* fnptr, GSocketControlMessage* arg0, gpointer arg1) {
//   ((void (*)(GSocketControlMessage*, gpointer))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_SocketListener_virtual_changed(void* fnptr, GSocketListener* arg0) {
//   ((void (*)(GSocketListener*))(fnptr))(arg0);
// };
// void _gotk4_gio2_SocketListener_virtual_event(void* fnptr, GSocketListener* arg0, GSocketListenerEvent arg1, GSocket* arg2) {
//   ((void (*)(GSocketListener*, GSocketListenerEvent, GSocket*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_TLSClientConnection_virtual_copy_session_state(void* fnptr, GTlsClientConnection* arg0, GTlsClientConnection* arg1) {
//   ((void (*)(GTlsClientConnection*, GTlsClientConnection*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_TLSConnection_virtual_handshake_async(void* fnptr, GTlsConnection* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GTlsConnection*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_TLSDatabase_virtual_lookup_certificate_for_handle_async(void* fnptr, GTlsDatabase* arg0, gchar* arg1, GTlsInteraction* arg2, GTlsDatabaseLookupFlags arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GTlsDatabase*, gchar*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_TLSDatabase_virtual_lookup_certificate_issuer_async(void* fnptr, GTlsDatabase* arg0, GTlsCertificate* arg1, GTlsInteraction* arg2, GTlsDatabaseLookupFlags arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GTlsDatabase*, GTlsCertificate*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_TLSDatabase_virtual_lookup_certificates_issued_by_async(void* fnptr, GTlsDatabase* arg0, GByteArray* arg1, GTlsInteraction* arg2, GTlsDatabaseLookupFlags arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GTlsDatabase*, GByteArray*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gio2_TLSDatabase_virtual_verify_chain_async(void* fnptr, GTlsDatabase* arg0, GTlsCertificate* arg1, gchar* arg2, GSocketConnectable* arg3, GTlsInteraction* arg4, GTlsDatabaseVerifyFlags arg5, GCancellable* arg6, GAsyncReadyCallback arg7, gpointer arg8) {
//   ((void (*)(GTlsDatabase*, GTlsCertificate*, gchar*, GSocketConnectable*, GTlsInteraction*, GTlsDatabaseVerifyFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
// };
// void _gotk4_gio2_TLSInteraction_virtual_ask_password_async(void* fnptr, GTlsInteraction* arg0, GTlsPassword* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GTlsInteraction*, GTlsPassword*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_TLSInteraction_virtual_request_certificate_async(void* fnptr, GTlsInteraction* arg0, GTlsConnection* arg1, GTlsCertificateRequestFlags arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GTlsInteraction*, GTlsConnection*, GTlsCertificateRequestFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_VFS_virtual_add_writable_namespaces(void* fnptr, GVfs* arg0, GFileAttributeInfoList* arg1) {
//   ((void (*)(GVfs*, GFileAttributeInfoList*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VFS_virtual_local_file_moved(void* fnptr, GVfs* arg0, char* arg1, char* arg2) {
//   ((void (*)(GVfs*, char*, char*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_VFS_virtual_local_file_removed(void* fnptr, GVfs* arg0, char* arg1) {
//   ((void (*)(GVfs*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_changed(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_connected(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_disconnected(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_eject_button(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_stop_button(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_added(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_changed(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_pre_unmount(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_removed(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_volume_added(void* fnptr, GVolumeMonitor* arg0, GVolume* arg1) {
//   ((void (*)(GVolumeMonitor*, GVolume*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_volume_changed(void* fnptr, GVolumeMonitor* arg0, GVolume* arg1) {
//   ((void (*)(GVolumeMonitor*, GVolume*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_volume_removed(void* fnptr, GVolumeMonitor* arg0, GVolume* arg1) {
//   ((void (*)(GVolumeMonitor*, GVolume*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Volume_virtual_changed(void* fnptr, GVolume* arg0) {
//   ((void (*)(GVolume*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Volume_virtual_eject(void* fnptr, GVolume* arg0, GMountUnmountFlags arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GVolume*, GMountUnmountFlags, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Volume_virtual_eject_with_operation(void* fnptr, GVolume* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GVolume*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Volume_virtual_mount_fn(void* fnptr, GVolume* arg0, GMountMountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GVolume*, GMountMountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_Volume_virtual_removed(void* fnptr, GVolume* arg0) {
//   ((void (*)(GVolume*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeBusType                      = coreglib.Type(C.g_bus_type_get_type())
	GTypeConverterResult              = coreglib.Type(C.g_converter_result_get_type())
	GTypeCredentialsType              = coreglib.Type(C.g_credentials_type_get_type())
	GTypeDBusError                    = coreglib.Type(C.g_dbus_error_get_type())
	GTypeDBusMessageByteOrder         = coreglib.Type(C.g_dbus_message_byte_order_get_type())
	GTypeDBusMessageHeaderField       = coreglib.Type(C.g_dbus_message_header_field_get_type())
	GTypeDBusMessageType              = coreglib.Type(C.g_dbus_message_type_get_type())
	GTypeDataStreamByteOrder          = coreglib.Type(C.g_data_stream_byte_order_get_type())
	GTypeDataStreamNewlineType        = coreglib.Type(C.g_data_stream_newline_type_get_type())
	GTypeDriveStartStopType           = coreglib.Type(C.g_drive_start_stop_type_get_type())
	GTypeEmblemOrigin                 = coreglib.Type(C.g_emblem_origin_get_type())
	GTypeFileAttributeStatus          = coreglib.Type(C.g_file_attribute_status_get_type())
	GTypeFileAttributeType            = coreglib.Type(C.g_file_attribute_type_get_type())
	GTypeFileMonitorEvent             = coreglib.Type(C.g_file_monitor_event_get_type())
	GTypeFileType                     = coreglib.Type(C.g_file_type_get_type())
	GTypeFilesystemPreviewType        = coreglib.Type(C.g_filesystem_preview_type_get_type())
	GTypeIOErrorEnum                  = coreglib.Type(C.g_io_error_enum_get_type())
	GTypeIOModuleScopeFlags           = coreglib.Type(C.g_io_module_scope_flags_get_type())
	GTypeMemoryMonitorWarningLevel    = coreglib.Type(C.g_memory_monitor_warning_level_get_type())
	GTypeMountOperationResult         = coreglib.Type(C.g_mount_operation_result_get_type())
	GTypeNetworkConnectivity          = coreglib.Type(C.g_network_connectivity_get_type())
	GTypeNotificationPriority         = coreglib.Type(C.g_notification_priority_get_type())
	GTypePasswordSave                 = coreglib.Type(C.g_password_save_get_type())
	GTypePollableReturn               = coreglib.Type(C.g_pollable_return_get_type())
	GTypeResolverError                = coreglib.Type(C.g_resolver_error_get_type())
	GTypeResolverRecordType           = coreglib.Type(C.g_resolver_record_type_get_type())
	GTypeResourceError                = coreglib.Type(C.g_resource_error_get_type())
	GTypeSocketClientEvent            = coreglib.Type(C.g_socket_client_event_get_type())
	GTypeSocketFamily                 = coreglib.Type(C.g_socket_family_get_type())
	GTypeSocketListenerEvent          = coreglib.Type(C.g_socket_listener_event_get_type())
	GTypeSocketProtocol               = coreglib.Type(C.g_socket_protocol_get_type())
	GTypeSocketType                   = coreglib.Type(C.g_socket_type_get_type())
	GTypeTLSAuthenticationMode        = coreglib.Type(C.g_tls_authentication_mode_get_type())
	GTypeTLSCertificateRequestFlags   = coreglib.Type(C.g_tls_certificate_request_flags_get_type())
	GTypeTLSChannelBindingError       = coreglib.Type(C.g_tls_channel_binding_error_get_type())
	GTypeTLSChannelBindingType        = coreglib.Type(C.g_tls_channel_binding_type_get_type())
	GTypeTLSDatabaseLookupFlags       = coreglib.Type(C.g_tls_database_lookup_flags_get_type())
	GTypeTLSError                     = coreglib.Type(C.g_tls_error_get_type())
	GTypeTLSInteractionResult         = coreglib.Type(C.g_tls_interaction_result_get_type())
	GTypeTLSProtocolVersion           = coreglib.Type(C.g_tls_protocol_version_get_type())
	GTypeTLSRehandshakeMode           = coreglib.Type(C.g_tls_rehandshake_mode_get_type())
	GTypeZlibCompressorFormat         = coreglib.Type(C.g_zlib_compressor_format_get_type())
	GTypeAppInfoCreateFlags           = coreglib.Type(C.g_app_info_create_flags_get_type())
	GTypeApplicationFlags             = coreglib.Type(C.g_application_flags_get_type())
	GTypeAskPasswordFlags             = coreglib.Type(C.g_ask_password_flags_get_type())
	GTypeBusNameOwnerFlags            = coreglib.Type(C.g_bus_name_owner_flags_get_type())
	GTypeBusNameWatcherFlags          = coreglib.Type(C.g_bus_name_watcher_flags_get_type())
	GTypeConverterFlags               = coreglib.Type(C.g_converter_flags_get_type())
	GTypeDBusCallFlags                = coreglib.Type(C.g_dbus_call_flags_get_type())
	GTypeDBusCapabilityFlags          = coreglib.Type(C.g_dbus_capability_flags_get_type())
	GTypeDBusConnectionFlags          = coreglib.Type(C.g_dbus_connection_flags_get_type())
	GTypeDBusInterfaceSkeletonFlags   = coreglib.Type(C.g_dbus_interface_skeleton_flags_get_type())
	GTypeDBusMessageFlags             = coreglib.Type(C.g_dbus_message_flags_get_type())
	GTypeDBusObjectManagerClientFlags = coreglib.Type(C.g_dbus_object_manager_client_flags_get_type())
	GTypeDBusPropertyInfoFlags        = coreglib.Type(C.g_dbus_property_info_flags_get_type())
	GTypeDBusProxyFlags               = coreglib.Type(C.g_dbus_proxy_flags_get_type())
	GTypeDBusSendMessageFlags         = coreglib.Type(C.g_dbus_send_message_flags_get_type())
	GTypeDBusServerFlags              = coreglib.Type(C.g_dbus_server_flags_get_type())
	GTypeDBusSignalFlags              = coreglib.Type(C.g_dbus_signal_flags_get_type())
	GTypeDBusSubtreeFlags             = coreglib.Type(C.g_dbus_subtree_flags_get_type())
	GTypeDriveStartFlags              = coreglib.Type(C.g_drive_start_flags_get_type())
	GTypeFileAttributeInfoFlags       = coreglib.Type(C.g_file_attribute_info_flags_get_type())
	GTypeFileCopyFlags                = coreglib.Type(C.g_file_copy_flags_get_type())
	GTypeFileCreateFlags              = coreglib.Type(C.g_file_create_flags_get_type())
	GTypeFileMeasureFlags             = coreglib.Type(C.g_file_measure_flags_get_type())
	GTypeFileMonitorFlags             = coreglib.Type(C.g_file_monitor_flags_get_type())
	GTypeFileQueryInfoFlags           = coreglib.Type(C.g_file_query_info_flags_get_type())
	GTypeIOStreamSpliceFlags          = coreglib.Type(C.g_io_stream_splice_flags_get_type())
	GTypeMountMountFlags              = coreglib.Type(C.g_mount_mount_flags_get_type())
	GTypeMountUnmountFlags            = coreglib.Type(C.g_mount_unmount_flags_get_type())
	GTypeOutputStreamSpliceFlags      = coreglib.Type(C.g_output_stream_splice_flags_get_type())
	GTypeResolverNameLookupFlags      = coreglib.Type(C.g_resolver_name_lookup_flags_get_type())
	GTypeResourceFlags                = coreglib.Type(C.g_resource_flags_get_type())
	GTypeResourceLookupFlags          = coreglib.Type(C.g_resource_lookup_flags_get_type())
	GTypeSettingsBindFlags            = coreglib.Type(C.g_settings_bind_flags_get_type())
	GTypeSocketMsgFlags               = coreglib.Type(C.g_socket_msg_flags_get_type())
	GTypeSubprocessFlags              = coreglib.Type(C.g_subprocess_flags_get_type())
	GTypeTestDBusFlags                = coreglib.Type(C.g_test_dbus_flags_get_type())
	GTypeTLSCertificateFlags          = coreglib.Type(C.g_tls_certificate_flags_get_type())
	GTypeTLSDatabaseVerifyFlags       = coreglib.Type(C.g_tls_database_verify_flags_get_type())
	GTypeTLSPasswordFlags             = coreglib.Type(C.g_tls_password_flags_get_type())
	GTypeAction                       = coreglib.Type(C.g_action_get_type())
	GTypeActionGroup                  = coreglib.Type(C.g_action_group_get_type())
	GTypeActionMap                    = coreglib.Type(C.g_action_map_get_type())
	GTypeAppInfo                      = coreglib.Type(C.g_app_info_get_type())
	GTypeAsyncInitable                = coreglib.Type(C.g_async_initable_get_type())
	GTypeAsyncResult                  = coreglib.Type(C.g_async_result_get_type())
	GTypeConverter                    = coreglib.Type(C.g_converter_get_type())
	GTypeDBusInterface                = coreglib.Type(C.g_dbus_interface_get_type())
	GTypeDBusObject                   = coreglib.Type(C.g_dbus_object_get_type())
	GTypeDBusObjectManager            = coreglib.Type(C.g_dbus_object_manager_get_type())
	GTypeDatagramBased                = coreglib.Type(C.g_datagram_based_get_type())
	GTypeDebugController              = coreglib.Type(C.g_debug_controller_get_type())
	GTypeDrive                        = coreglib.Type(C.g_drive_get_type())
	GTypeDTLSClientConnection         = coreglib.Type(C.g_dtls_client_connection_get_type())
	GTypeDTLSConnection               = coreglib.Type(C.g_dtls_connection_get_type())
	GTypeDTLSServerConnection         = coreglib.Type(C.g_dtls_server_connection_get_type())
	GTypeFile                         = coreglib.Type(C.g_file_get_type())
	GTypeIcon                         = coreglib.Type(C.g_icon_get_type())
	GTypeInitable                     = coreglib.Type(C.g_initable_get_type())
	GTypeListModel                    = coreglib.Type(C.g_list_model_get_type())
	GTypeLoadableIcon                 = coreglib.Type(C.g_loadable_icon_get_type())
	GTypeMemoryMonitor                = coreglib.Type(C.g_memory_monitor_get_type())
	GTypeMount                        = coreglib.Type(C.g_mount_get_type())
	GTypeNetworkMonitor               = coreglib.Type(C.g_network_monitor_get_type())
	GTypePollableInputStream          = coreglib.Type(C.g_pollable_input_stream_get_type())
	GTypePollableOutputStream         = coreglib.Type(C.g_pollable_output_stream_get_type())
	GTypePowerProfileMonitor          = coreglib.Type(C.g_power_profile_monitor_get_type())
	GTypeProxy                        = coreglib.Type(C.g_proxy_get_type())
	GTypeProxyResolver                = coreglib.Type(C.g_proxy_resolver_get_type())
	GTypeRemoteActionGroup            = coreglib.Type(C.g_remote_action_group_get_type())
	GTypeSeekable                     = coreglib.Type(C.g_seekable_get_type())
	GTypeSocketConnectable            = coreglib.Type(C.g_socket_connectable_get_type())
	GTypeTLSBackend                   = coreglib.Type(C.g_tls_backend_get_type())
	GTypeTLSClientConnection          = coreglib.Type(C.g_tls_client_connection_get_type())
	GTypeTLSFileDatabase              = coreglib.Type(C.g_tls_file_database_get_type())
	GTypeTLSServerConnection          = coreglib.Type(C.g_tls_server_connection_get_type())
	GTypeVolume                       = coreglib.Type(C.g_volume_get_type())
	GTypeAppInfoMonitor               = coreglib.Type(C.g_app_info_monitor_get_type())
	GTypeAppLaunchContext             = coreglib.Type(C.g_app_launch_context_get_type())
	GTypeApplication                  = coreglib.Type(C.g_application_get_type())
	GTypeApplicationCommandLine       = coreglib.Type(C.g_application_command_line_get_type())
	GTypeBufferedInputStream          = coreglib.Type(C.g_buffered_input_stream_get_type())
	GTypeBufferedOutputStream         = coreglib.Type(C.g_buffered_output_stream_get_type())
	GTypeBytesIcon                    = coreglib.Type(C.g_bytes_icon_get_type())
	GTypeCancellable                  = coreglib.Type(C.g_cancellable_get_type())
	GTypeCharsetConverter             = coreglib.Type(C.g_charset_converter_get_type())
	GTypeConverterInputStream         = coreglib.Type(C.g_converter_input_stream_get_type())
	GTypeConverterOutputStream        = coreglib.Type(C.g_converter_output_stream_get_type())
	GTypeCredentials                  = coreglib.Type(C.g_credentials_get_type())
	GTypeDBusActionGroup              = coreglib.Type(C.g_dbus_action_group_get_type())
	GTypeDBusAuthObserver             = coreglib.Type(C.g_dbus_auth_observer_get_type())
	GTypeDBusConnection               = coreglib.Type(C.g_dbus_connection_get_type())
	GTypeDBusInterfaceSkeleton        = coreglib.Type(C.g_dbus_interface_skeleton_get_type())
	GTypeDBusMenuModel                = coreglib.Type(C.g_dbus_menu_model_get_type())
	GTypeDBusMessage                  = coreglib.Type(C.g_dbus_message_get_type())
	GTypeDBusMethodInvocation         = coreglib.Type(C.g_dbus_method_invocation_get_type())
	GTypeDBusObjectManagerClient      = coreglib.Type(C.g_dbus_object_manager_client_get_type())
	GTypeDBusObjectManagerServer      = coreglib.Type(C.g_dbus_object_manager_server_get_type())
	GTypeDBusObjectProxy              = coreglib.Type(C.g_dbus_object_proxy_get_type())
	GTypeDBusObjectSkeleton           = coreglib.Type(C.g_dbus_object_skeleton_get_type())
	GTypeDBusProxy                    = coreglib.Type(C.g_dbus_proxy_get_type())
	GTypeDBusServer                   = coreglib.Type(C.g_dbus_server_get_type())
	GTypeDataInputStream              = coreglib.Type(C.g_data_input_stream_get_type())
	GTypeDataOutputStream             = coreglib.Type(C.g_data_output_stream_get_type())
	GTypeDebugControllerDBus          = coreglib.Type(C.g_debug_controller_dbus_get_type())
	GTypeEmblem                       = coreglib.Type(C.g_emblem_get_type())
	GTypeEmblemedIcon                 = coreglib.Type(C.g_emblemed_icon_get_type())
	GTypeFileEnumerator               = coreglib.Type(C.g_file_enumerator_get_type())
	GTypeFileIOStream                 = coreglib.Type(C.g_file_io_stream_get_type())
	GTypeFileIcon                     = coreglib.Type(C.g_file_icon_get_type())
	GTypeFileInfo                     = coreglib.Type(C.g_file_info_get_type())
	GTypeFileInputStream              = coreglib.Type(C.g_file_input_stream_get_type())
	GTypeFileMonitor                  = coreglib.Type(C.g_file_monitor_get_type())
	GTypeFileOutputStream             = coreglib.Type(C.g_file_output_stream_get_type())
	GTypeFilenameCompleter            = coreglib.Type(C.g_filename_completer_get_type())
	GTypeFilterInputStream            = coreglib.Type(C.g_filter_input_stream_get_type())
	GTypeFilterOutputStream           = coreglib.Type(C.g_filter_output_stream_get_type())
	GTypeIOStream                     = coreglib.Type(C.g_io_stream_get_type())
	GTypeInetAddress                  = coreglib.Type(C.g_inet_address_get_type())
	GTypeInetAddressMask              = coreglib.Type(C.g_inet_address_mask_get_type())
	GTypeInetSocketAddress            = coreglib.Type(C.g_inet_socket_address_get_type())
	GTypeInputStream                  = coreglib.Type(C.g_input_stream_get_type())
	GTypeListStore                    = coreglib.Type(C.g_list_store_get_type())
	GTypeMemoryInputStream            = coreglib.Type(C.g_memory_input_stream_get_type())
	GTypeMemoryOutputStream           = coreglib.Type(C.g_memory_output_stream_get_type())
	GTypeMenu                         = coreglib.Type(C.g_menu_get_type())
	GTypeMenuAttributeIter            = coreglib.Type(C.g_menu_attribute_iter_get_type())
	GTypeMenuItem                     = coreglib.Type(C.g_menu_item_get_type())
	GTypeMenuLinkIter                 = coreglib.Type(C.g_menu_link_iter_get_type())
	GTypeMenuModel                    = coreglib.Type(C.g_menu_model_get_type())
	GTypeMountOperation               = coreglib.Type(C.g_mount_operation_get_type())
	GTypeNativeSocketAddress          = coreglib.Type(C.g_native_socket_address_get_type())
	GTypeNativeVolumeMonitor          = coreglib.Type(C.g_native_volume_monitor_get_type())
	GTypeNetworkAddress               = coreglib.Type(C.g_network_address_get_type())
	GTypeNetworkService               = coreglib.Type(C.g_network_service_get_type())
	GTypeNotification                 = coreglib.Type(C.g_notification_get_type())
	GTypeOutputStream                 = coreglib.Type(C.g_output_stream_get_type())
	GTypePermission                   = coreglib.Type(C.g_permission_get_type())
	GTypePropertyAction               = coreglib.Type(C.g_property_action_get_type())
	GTypeProxyAddress                 = coreglib.Type(C.g_proxy_address_get_type())
	GTypeProxyAddressEnumerator       = coreglib.Type(C.g_proxy_address_enumerator_get_type())
	GTypeResolver                     = coreglib.Type(C.g_resolver_get_type())
	GTypeSettings                     = coreglib.Type(C.g_settings_get_type())
	GTypeSimpleAction                 = coreglib.Type(C.g_simple_action_get_type())
	GTypeSimpleActionGroup            = coreglib.Type(C.g_simple_action_group_get_type())
	GTypeSimpleAsyncResult            = coreglib.Type(C.g_simple_async_result_get_type())
	GTypeSimpleIOStream               = coreglib.Type(C.g_simple_io_stream_get_type())
	GTypeSimplePermission             = coreglib.Type(C.g_simple_permission_get_type())
	GTypeSimpleProxyResolver          = coreglib.Type(C.g_simple_proxy_resolver_get_type())
	GTypeSocket                       = coreglib.Type(C.g_socket_get_type())
	GTypeSocketAddress                = coreglib.Type(C.g_socket_address_get_type())
	GTypeSocketAddressEnumerator      = coreglib.Type(C.g_socket_address_enumerator_get_type())
	GTypeSocketClient                 = coreglib.Type(C.g_socket_client_get_type())
	GTypeSocketConnection             = coreglib.Type(C.g_socket_connection_get_type())
	GTypeSocketControlMessage         = coreglib.Type(C.g_socket_control_message_get_type())
	GTypeSocketListener               = coreglib.Type(C.g_socket_listener_get_type())
	GTypeSocketService                = coreglib.Type(C.g_socket_service_get_type())
	GTypeTask                         = coreglib.Type(C.g_task_get_type())
	GTypeTCPConnection                = coreglib.Type(C.g_tcp_connection_get_type())
	GTypeTCPWrapperConnection         = coreglib.Type(C.g_tcp_wrapper_connection_get_type())
	GTypeTestDBus                     = coreglib.Type(C.g_test_dbus_get_type())
	GTypeThemedIcon                   = coreglib.Type(C.g_themed_icon_get_type())
	GTypeThreadedSocketService        = coreglib.Type(C.g_threaded_socket_service_get_type())
	GTypeTLSCertificate               = coreglib.Type(C.g_tls_certificate_get_type())
	GTypeTLSConnection                = coreglib.Type(C.g_tls_connection_get_type())
	GTypeTLSDatabase                  = coreglib.Type(C.g_tls_database_get_type())
	GTypeTLSInteraction               = coreglib.Type(C.g_tls_interaction_get_type())
	GTypeTLSPassword                  = coreglib.Type(C.g_tls_password_get_type())
	GTypeVFS                          = coreglib.Type(C.g_vfs_get_type())
	GTypeVolumeMonitor                = coreglib.Type(C.g_volume_monitor_get_type())
	GTypeZlibCompressor               = coreglib.Type(C.g_zlib_compressor_get_type())
	GTypeZlibDecompressor             = coreglib.Type(C.g_zlib_decompressor_get_type())
	GTypeDBusAnnotationInfo           = coreglib.Type(C.g_dbus_annotation_info_get_type())
	GTypeDBusArgInfo                  = coreglib.Type(C.g_dbus_arg_info_get_type())
	GTypeDBusInterfaceInfo            = coreglib.Type(C.g_dbus_interface_info_get_type())
	GTypeDBusMethodInfo               = coreglib.Type(C.g_dbus_method_info_get_type())
	GTypeDBusNodeInfo                 = coreglib.Type(C.g_dbus_node_info_get_type())
	GTypeDBusPropertyInfo             = coreglib.Type(C.g_dbus_property_info_get_type())
	GTypeDBusSignalInfo               = coreglib.Type(C.g_dbus_signal_info_get_type())
	GTypeFileAttributeInfoList        = coreglib.Type(C.g_file_attribute_info_list_get_type())
	GTypeFileAttributeMatcher         = coreglib.Type(C.g_file_attribute_matcher_get_type())
	GTypeResource                     = coreglib.Type(C.g_resource_get_type())
	GTypeSettingsSchema               = coreglib.Type(C.g_settings_schema_get_type())
	GTypeSettingsSchemaKey            = coreglib.Type(C.g_settings_schema_key_get_type())
	GTypeSettingsSchemaSource         = coreglib.Type(C.g_settings_schema_source_get_type())
	GTypeSrvTarget                    = coreglib.Type(C.g_srv_target_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBusType, F: marshalBusType},
		coreglib.TypeMarshaler{T: GTypeConverterResult, F: marshalConverterResult},
		coreglib.TypeMarshaler{T: GTypeCredentialsType, F: marshalCredentialsType},
		coreglib.TypeMarshaler{T: GTypeDBusError, F: marshalDBusError},
		coreglib.TypeMarshaler{T: GTypeDBusMessageByteOrder, F: marshalDBusMessageByteOrder},
		coreglib.TypeMarshaler{T: GTypeDBusMessageHeaderField, F: marshalDBusMessageHeaderField},
		coreglib.TypeMarshaler{T: GTypeDBusMessageType, F: marshalDBusMessageType},
		coreglib.TypeMarshaler{T: GTypeDataStreamByteOrder, F: marshalDataStreamByteOrder},
		coreglib.TypeMarshaler{T: GTypeDataStreamNewlineType, F: marshalDataStreamNewlineType},
		coreglib.TypeMarshaler{T: GTypeDriveStartStopType, F: marshalDriveStartStopType},
		coreglib.TypeMarshaler{T: GTypeEmblemOrigin, F: marshalEmblemOrigin},
		coreglib.TypeMarshaler{T: GTypeFileAttributeStatus, F: marshalFileAttributeStatus},
		coreglib.TypeMarshaler{T: GTypeFileAttributeType, F: marshalFileAttributeType},
		coreglib.TypeMarshaler{T: GTypeFileMonitorEvent, F: marshalFileMonitorEvent},
		coreglib.TypeMarshaler{T: GTypeFileType, F: marshalFileType},
		coreglib.TypeMarshaler{T: GTypeFilesystemPreviewType, F: marshalFilesystemPreviewType},
		coreglib.TypeMarshaler{T: GTypeIOErrorEnum, F: marshalIOErrorEnum},
		coreglib.TypeMarshaler{T: GTypeIOModuleScopeFlags, F: marshalIOModuleScopeFlags},
		coreglib.TypeMarshaler{T: GTypeMemoryMonitorWarningLevel, F: marshalMemoryMonitorWarningLevel},
		coreglib.TypeMarshaler{T: GTypeMountOperationResult, F: marshalMountOperationResult},
		coreglib.TypeMarshaler{T: GTypeNetworkConnectivity, F: marshalNetworkConnectivity},
		coreglib.TypeMarshaler{T: GTypeNotificationPriority, F: marshalNotificationPriority},
		coreglib.TypeMarshaler{T: GTypePasswordSave, F: marshalPasswordSave},
		coreglib.TypeMarshaler{T: GTypePollableReturn, F: marshalPollableReturn},
		coreglib.TypeMarshaler{T: GTypeResolverError, F: marshalResolverError},
		coreglib.TypeMarshaler{T: GTypeResolverRecordType, F: marshalResolverRecordType},
		coreglib.TypeMarshaler{T: GTypeResourceError, F: marshalResourceError},
		coreglib.TypeMarshaler{T: GTypeSocketClientEvent, F: marshalSocketClientEvent},
		coreglib.TypeMarshaler{T: GTypeSocketFamily, F: marshalSocketFamily},
		coreglib.TypeMarshaler{T: GTypeSocketListenerEvent, F: marshalSocketListenerEvent},
		coreglib.TypeMarshaler{T: GTypeSocketProtocol, F: marshalSocketProtocol},
		coreglib.TypeMarshaler{T: GTypeSocketType, F: marshalSocketType},
		coreglib.TypeMarshaler{T: GTypeTLSAuthenticationMode, F: marshalTLSAuthenticationMode},
		coreglib.TypeMarshaler{T: GTypeTLSCertificateRequestFlags, F: marshalTLSCertificateRequestFlags},
		coreglib.TypeMarshaler{T: GTypeTLSChannelBindingError, F: marshalTLSChannelBindingError},
		coreglib.TypeMarshaler{T: GTypeTLSChannelBindingType, F: marshalTLSChannelBindingType},
		coreglib.TypeMarshaler{T: GTypeTLSDatabaseLookupFlags, F: marshalTLSDatabaseLookupFlags},
		coreglib.TypeMarshaler{T: GTypeTLSError, F: marshalTLSError},
		coreglib.TypeMarshaler{T: GTypeTLSInteractionResult, F: marshalTLSInteractionResult},
		coreglib.TypeMarshaler{T: GTypeTLSProtocolVersion, F: marshalTLSProtocolVersion},
		coreglib.TypeMarshaler{T: GTypeTLSRehandshakeMode, F: marshalTLSRehandshakeMode},
		coreglib.TypeMarshaler{T: GTypeZlibCompressorFormat, F: marshalZlibCompressorFormat},
		coreglib.TypeMarshaler{T: GTypeAppInfoCreateFlags, F: marshalAppInfoCreateFlags},
		coreglib.TypeMarshaler{T: GTypeApplicationFlags, F: marshalApplicationFlags},
		coreglib.TypeMarshaler{T: GTypeAskPasswordFlags, F: marshalAskPasswordFlags},
		coreglib.TypeMarshaler{T: GTypeBusNameOwnerFlags, F: marshalBusNameOwnerFlags},
		coreglib.TypeMarshaler{T: GTypeBusNameWatcherFlags, F: marshalBusNameWatcherFlags},
		coreglib.TypeMarshaler{T: GTypeConverterFlags, F: marshalConverterFlags},
		coreglib.TypeMarshaler{T: GTypeDBusCallFlags, F: marshalDBusCallFlags},
		coreglib.TypeMarshaler{T: GTypeDBusCapabilityFlags, F: marshalDBusCapabilityFlags},
		coreglib.TypeMarshaler{T: GTypeDBusConnectionFlags, F: marshalDBusConnectionFlags},
		coreglib.TypeMarshaler{T: GTypeDBusInterfaceSkeletonFlags, F: marshalDBusInterfaceSkeletonFlags},
		coreglib.TypeMarshaler{T: GTypeDBusMessageFlags, F: marshalDBusMessageFlags},
		coreglib.TypeMarshaler{T: GTypeDBusObjectManagerClientFlags, F: marshalDBusObjectManagerClientFlags},
		coreglib.TypeMarshaler{T: GTypeDBusPropertyInfoFlags, F: marshalDBusPropertyInfoFlags},
		coreglib.TypeMarshaler{T: GTypeDBusProxyFlags, F: marshalDBusProxyFlags},
		coreglib.TypeMarshaler{T: GTypeDBusSendMessageFlags, F: marshalDBusSendMessageFlags},
		coreglib.TypeMarshaler{T: GTypeDBusServerFlags, F: marshalDBusServerFlags},
		coreglib.TypeMarshaler{T: GTypeDBusSignalFlags, F: marshalDBusSignalFlags},
		coreglib.TypeMarshaler{T: GTypeDBusSubtreeFlags, F: marshalDBusSubtreeFlags},
		coreglib.TypeMarshaler{T: GTypeDriveStartFlags, F: marshalDriveStartFlags},
		coreglib.TypeMarshaler{T: GTypeFileAttributeInfoFlags, F: marshalFileAttributeInfoFlags},
		coreglib.TypeMarshaler{T: GTypeFileCopyFlags, F: marshalFileCopyFlags},
		coreglib.TypeMarshaler{T: GTypeFileCreateFlags, F: marshalFileCreateFlags},
		coreglib.TypeMarshaler{T: GTypeFileMeasureFlags, F: marshalFileMeasureFlags},
		coreglib.TypeMarshaler{T: GTypeFileMonitorFlags, F: marshalFileMonitorFlags},
		coreglib.TypeMarshaler{T: GTypeFileQueryInfoFlags, F: marshalFileQueryInfoFlags},
		coreglib.TypeMarshaler{T: GTypeIOStreamSpliceFlags, F: marshalIOStreamSpliceFlags},
		coreglib.TypeMarshaler{T: GTypeMountMountFlags, F: marshalMountMountFlags},
		coreglib.TypeMarshaler{T: GTypeMountUnmountFlags, F: marshalMountUnmountFlags},
		coreglib.TypeMarshaler{T: GTypeOutputStreamSpliceFlags, F: marshalOutputStreamSpliceFlags},
		coreglib.TypeMarshaler{T: GTypeResolverNameLookupFlags, F: marshalResolverNameLookupFlags},
		coreglib.TypeMarshaler{T: GTypeResourceFlags, F: marshalResourceFlags},
		coreglib.TypeMarshaler{T: GTypeResourceLookupFlags, F: marshalResourceLookupFlags},
		coreglib.TypeMarshaler{T: GTypeSettingsBindFlags, F: marshalSettingsBindFlags},
		coreglib.TypeMarshaler{T: GTypeSocketMsgFlags, F: marshalSocketMsgFlags},
		coreglib.TypeMarshaler{T: GTypeSubprocessFlags, F: marshalSubprocessFlags},
		coreglib.TypeMarshaler{T: GTypeTestDBusFlags, F: marshalTestDBusFlags},
		coreglib.TypeMarshaler{T: GTypeTLSCertificateFlags, F: marshalTLSCertificateFlags},
		coreglib.TypeMarshaler{T: GTypeTLSDatabaseVerifyFlags, F: marshalTLSDatabaseVerifyFlags},
		coreglib.TypeMarshaler{T: GTypeTLSPasswordFlags, F: marshalTLSPasswordFlags},
		coreglib.TypeMarshaler{T: GTypeAction, F: marshalAction},
		coreglib.TypeMarshaler{T: GTypeActionGroup, F: marshalActionGroup},
		coreglib.TypeMarshaler{T: GTypeActionMap, F: marshalActionMap},
		coreglib.TypeMarshaler{T: GTypeAppInfo, F: marshalAppInfo},
		coreglib.TypeMarshaler{T: GTypeAsyncInitable, F: marshalAsyncInitable},
		coreglib.TypeMarshaler{T: GTypeAsyncResult, F: marshalAsyncResult},
		coreglib.TypeMarshaler{T: GTypeConverter, F: marshalConverter},
		coreglib.TypeMarshaler{T: GTypeDBusInterface, F: marshalDBusInterface},
		coreglib.TypeMarshaler{T: GTypeDBusObject, F: marshalDBusObject},
		coreglib.TypeMarshaler{T: GTypeDBusObjectManager, F: marshalDBusObjectManager},
		coreglib.TypeMarshaler{T: GTypeDatagramBased, F: marshalDatagramBased},
		coreglib.TypeMarshaler{T: GTypeDebugController, F: marshalDebugController},
		coreglib.TypeMarshaler{T: GTypeDrive, F: marshalDrive},
		coreglib.TypeMarshaler{T: GTypeDTLSClientConnection, F: marshalDTLSClientConnection},
		coreglib.TypeMarshaler{T: GTypeDTLSConnection, F: marshalDTLSConnection},
		coreglib.TypeMarshaler{T: GTypeDTLSServerConnection, F: marshalDTLSServerConnection},
		coreglib.TypeMarshaler{T: GTypeFile, F: marshalFile},
		coreglib.TypeMarshaler{T: GTypeIcon, F: marshalIcon},
		coreglib.TypeMarshaler{T: GTypeInitable, F: marshalInitable},
		coreglib.TypeMarshaler{T: GTypeListModel, F: marshalListModel},
		coreglib.TypeMarshaler{T: GTypeLoadableIcon, F: marshalLoadableIcon},
		coreglib.TypeMarshaler{T: GTypeMemoryMonitor, F: marshalMemoryMonitor},
		coreglib.TypeMarshaler{T: GTypeMount, F: marshalMount},
		coreglib.TypeMarshaler{T: GTypeNetworkMonitor, F: marshalNetworkMonitor},
		coreglib.TypeMarshaler{T: GTypePollableInputStream, F: marshalPollableInputStream},
		coreglib.TypeMarshaler{T: GTypePollableOutputStream, F: marshalPollableOutputStream},
		coreglib.TypeMarshaler{T: GTypePowerProfileMonitor, F: marshalPowerProfileMonitor},
		coreglib.TypeMarshaler{T: GTypeProxy, F: marshalProxy},
		coreglib.TypeMarshaler{T: GTypeProxyResolver, F: marshalProxyResolver},
		coreglib.TypeMarshaler{T: GTypeRemoteActionGroup, F: marshalRemoteActionGroup},
		coreglib.TypeMarshaler{T: GTypeSeekable, F: marshalSeekable},
		coreglib.TypeMarshaler{T: GTypeSocketConnectable, F: marshalSocketConnectable},
		coreglib.TypeMarshaler{T: GTypeTLSBackend, F: marshalTLSBackend},
		coreglib.TypeMarshaler{T: GTypeTLSClientConnection, F: marshalTLSClientConnection},
		coreglib.TypeMarshaler{T: GTypeTLSFileDatabase, F: marshalTLSFileDatabase},
		coreglib.TypeMarshaler{T: GTypeTLSServerConnection, F: marshalTLSServerConnection},
		coreglib.TypeMarshaler{T: GTypeVolume, F: marshalVolume},
		coreglib.TypeMarshaler{T: GTypeAppInfoMonitor, F: marshalAppInfoMonitor},
		coreglib.TypeMarshaler{T: GTypeAppLaunchContext, F: marshalAppLaunchContext},
		coreglib.TypeMarshaler{T: GTypeApplication, F: marshalApplication},
		coreglib.TypeMarshaler{T: GTypeApplicationCommandLine, F: marshalApplicationCommandLine},
		coreglib.TypeMarshaler{T: GTypeBufferedInputStream, F: marshalBufferedInputStream},
		coreglib.TypeMarshaler{T: GTypeBufferedOutputStream, F: marshalBufferedOutputStream},
		coreglib.TypeMarshaler{T: GTypeBytesIcon, F: marshalBytesIcon},
		coreglib.TypeMarshaler{T: GTypeCancellable, F: marshalCancellable},
		coreglib.TypeMarshaler{T: GTypeCharsetConverter, F: marshalCharsetConverter},
		coreglib.TypeMarshaler{T: GTypeConverterInputStream, F: marshalConverterInputStream},
		coreglib.TypeMarshaler{T: GTypeConverterOutputStream, F: marshalConverterOutputStream},
		coreglib.TypeMarshaler{T: GTypeCredentials, F: marshalCredentials},
		coreglib.TypeMarshaler{T: GTypeDBusActionGroup, F: marshalDBusActionGroup},
		coreglib.TypeMarshaler{T: GTypeDBusAuthObserver, F: marshalDBusAuthObserver},
		coreglib.TypeMarshaler{T: GTypeDBusConnection, F: marshalDBusConnection},
		coreglib.TypeMarshaler{T: GTypeDBusInterfaceSkeleton, F: marshalDBusInterfaceSkeleton},
		coreglib.TypeMarshaler{T: GTypeDBusMenuModel, F: marshalDBusMenuModel},
		coreglib.TypeMarshaler{T: GTypeDBusMessage, F: marshalDBusMessage},
		coreglib.TypeMarshaler{T: GTypeDBusMethodInvocation, F: marshalDBusMethodInvocation},
		coreglib.TypeMarshaler{T: GTypeDBusObjectManagerClient, F: marshalDBusObjectManagerClient},
		coreglib.TypeMarshaler{T: GTypeDBusObjectManagerServer, F: marshalDBusObjectManagerServer},
		coreglib.TypeMarshaler{T: GTypeDBusObjectProxy, F: marshalDBusObjectProxy},
		coreglib.TypeMarshaler{T: GTypeDBusObjectSkeleton, F: marshalDBusObjectSkeleton},
		coreglib.TypeMarshaler{T: GTypeDBusProxy, F: marshalDBusProxy},
		coreglib.TypeMarshaler{T: GTypeDBusServer, F: marshalDBusServer},
		coreglib.TypeMarshaler{T: GTypeDataInputStream, F: marshalDataInputStream},
		coreglib.TypeMarshaler{T: GTypeDataOutputStream, F: marshalDataOutputStream},
		coreglib.TypeMarshaler{T: GTypeDebugControllerDBus, F: marshalDebugControllerDBus},
		coreglib.TypeMarshaler{T: GTypeEmblem, F: marshalEmblem},
		coreglib.TypeMarshaler{T: GTypeEmblemedIcon, F: marshalEmblemedIcon},
		coreglib.TypeMarshaler{T: GTypeFileEnumerator, F: marshalFileEnumerator},
		coreglib.TypeMarshaler{T: GTypeFileIOStream, F: marshalFileIOStream},
		coreglib.TypeMarshaler{T: GTypeFileIcon, F: marshalFileIcon},
		coreglib.TypeMarshaler{T: GTypeFileInfo, F: marshalFileInfo},
		coreglib.TypeMarshaler{T: GTypeFileInputStream, F: marshalFileInputStream},
		coreglib.TypeMarshaler{T: GTypeFileMonitor, F: marshalFileMonitor},
		coreglib.TypeMarshaler{T: GTypeFileOutputStream, F: marshalFileOutputStream},
		coreglib.TypeMarshaler{T: GTypeFilenameCompleter, F: marshalFilenameCompleter},
		coreglib.TypeMarshaler{T: GTypeFilterInputStream, F: marshalFilterInputStream},
		coreglib.TypeMarshaler{T: GTypeFilterOutputStream, F: marshalFilterOutputStream},
		coreglib.TypeMarshaler{T: GTypeIOStream, F: marshalIOStream},
		coreglib.TypeMarshaler{T: GTypeInetAddress, F: marshalInetAddress},
		coreglib.TypeMarshaler{T: GTypeInetAddressMask, F: marshalInetAddressMask},
		coreglib.TypeMarshaler{T: GTypeInetSocketAddress, F: marshalInetSocketAddress},
		coreglib.TypeMarshaler{T: GTypeInputStream, F: marshalInputStream},
		coreglib.TypeMarshaler{T: GTypeListStore, F: marshalListStore},
		coreglib.TypeMarshaler{T: GTypeMemoryInputStream, F: marshalMemoryInputStream},
		coreglib.TypeMarshaler{T: GTypeMemoryOutputStream, F: marshalMemoryOutputStream},
		coreglib.TypeMarshaler{T: GTypeMenu, F: marshalMenu},
		coreglib.TypeMarshaler{T: GTypeMenuAttributeIter, F: marshalMenuAttributeIter},
		coreglib.TypeMarshaler{T: GTypeMenuItem, F: marshalMenuItem},
		coreglib.TypeMarshaler{T: GTypeMenuLinkIter, F: marshalMenuLinkIter},
		coreglib.TypeMarshaler{T: GTypeMenuModel, F: marshalMenuModel},
		coreglib.TypeMarshaler{T: GTypeMountOperation, F: marshalMountOperation},
		coreglib.TypeMarshaler{T: GTypeNativeSocketAddress, F: marshalNativeSocketAddress},
		coreglib.TypeMarshaler{T: GTypeNativeVolumeMonitor, F: marshalNativeVolumeMonitor},
		coreglib.TypeMarshaler{T: GTypeNetworkAddress, F: marshalNetworkAddress},
		coreglib.TypeMarshaler{T: GTypeNetworkService, F: marshalNetworkService},
		coreglib.TypeMarshaler{T: GTypeNotification, F: marshalNotification},
		coreglib.TypeMarshaler{T: GTypeOutputStream, F: marshalOutputStream},
		coreglib.TypeMarshaler{T: GTypePermission, F: marshalPermission},
		coreglib.TypeMarshaler{T: GTypePropertyAction, F: marshalPropertyAction},
		coreglib.TypeMarshaler{T: GTypeProxyAddress, F: marshalProxyAddress},
		coreglib.TypeMarshaler{T: GTypeProxyAddressEnumerator, F: marshalProxyAddressEnumerator},
		coreglib.TypeMarshaler{T: GTypeResolver, F: marshalResolver},
		coreglib.TypeMarshaler{T: GTypeSettings, F: marshalSettings},
		coreglib.TypeMarshaler{T: GTypeSimpleAction, F: marshalSimpleAction},
		coreglib.TypeMarshaler{T: GTypeSimpleActionGroup, F: marshalSimpleActionGroup},
		coreglib.TypeMarshaler{T: GTypeSimpleAsyncResult, F: marshalSimpleAsyncResult},
		coreglib.TypeMarshaler{T: GTypeSimpleIOStream, F: marshalSimpleIOStream},
		coreglib.TypeMarshaler{T: GTypeSimplePermission, F: marshalSimplePermission},
		coreglib.TypeMarshaler{T: GTypeSimpleProxyResolver, F: marshalSimpleProxyResolver},
		coreglib.TypeMarshaler{T: GTypeSocket, F: marshalSocket},
		coreglib.TypeMarshaler{T: GTypeSocketAddress, F: marshalSocketAddress},
		coreglib.TypeMarshaler{T: GTypeSocketAddressEnumerator, F: marshalSocketAddressEnumerator},
		coreglib.TypeMarshaler{T: GTypeSocketClient, F: marshalSocketClient},
		coreglib.TypeMarshaler{T: GTypeSocketConnection, F: marshalSocketConnection},
		coreglib.TypeMarshaler{T: GTypeSocketControlMessage, F: marshalSocketControlMessage},
		coreglib.TypeMarshaler{T: GTypeSocketListener, F: marshalSocketListener},
		coreglib.TypeMarshaler{T: GTypeSocketService, F: marshalSocketService},
		coreglib.TypeMarshaler{T: GTypeTask, F: marshalTask},
		coreglib.TypeMarshaler{T: GTypeTCPConnection, F: marshalTCPConnection},
		coreglib.TypeMarshaler{T: GTypeTCPWrapperConnection, F: marshalTCPWrapperConnection},
		coreglib.TypeMarshaler{T: GTypeTestDBus, F: marshalTestDBus},
		coreglib.TypeMarshaler{T: GTypeThemedIcon, F: marshalThemedIcon},
		coreglib.TypeMarshaler{T: GTypeThreadedSocketService, F: marshalThreadedSocketService},
		coreglib.TypeMarshaler{T: GTypeTLSCertificate, F: marshalTLSCertificate},
		coreglib.TypeMarshaler{T: GTypeTLSConnection, F: marshalTLSConnection},
		coreglib.TypeMarshaler{T: GTypeTLSDatabase, F: marshalTLSDatabase},
		coreglib.TypeMarshaler{T: GTypeTLSInteraction, F: marshalTLSInteraction},
		coreglib.TypeMarshaler{T: GTypeTLSPassword, F: marshalTLSPassword},
		coreglib.TypeMarshaler{T: GTypeVFS, F: marshalVFS},
		coreglib.TypeMarshaler{T: GTypeVolumeMonitor, F: marshalVolumeMonitor},
		coreglib.TypeMarshaler{T: GTypeZlibCompressor, F: marshalZlibCompressor},
		coreglib.TypeMarshaler{T: GTypeZlibDecompressor, F: marshalZlibDecompressor},
		coreglib.TypeMarshaler{T: GTypeDBusAnnotationInfo, F: marshalDBusAnnotationInfo},
		coreglib.TypeMarshaler{T: GTypeDBusArgInfo, F: marshalDBusArgInfo},
		coreglib.TypeMarshaler{T: GTypeDBusInterfaceInfo, F: marshalDBusInterfaceInfo},
		coreglib.TypeMarshaler{T: GTypeDBusMethodInfo, F: marshalDBusMethodInfo},
		coreglib.TypeMarshaler{T: GTypeDBusNodeInfo, F: marshalDBusNodeInfo},
		coreglib.TypeMarshaler{T: GTypeDBusPropertyInfo, F: marshalDBusPropertyInfo},
		coreglib.TypeMarshaler{T: GTypeDBusSignalInfo, F: marshalDBusSignalInfo},
		coreglib.TypeMarshaler{T: GTypeFileAttributeInfoList, F: marshalFileAttributeInfoList},
		coreglib.TypeMarshaler{T: GTypeFileAttributeMatcher, F: marshalFileAttributeMatcher},
		coreglib.TypeMarshaler{T: GTypeResource, F: marshalResource},
		coreglib.TypeMarshaler{T: GTypeSettingsSchema, F: marshalSettingsSchema},
		coreglib.TypeMarshaler{T: GTypeSettingsSchemaKey, F: marshalSettingsSchemaKey},
		coreglib.TypeMarshaler{T: GTypeSettingsSchemaSource, F: marshalSettingsSchemaSource},
		coreglib.TypeMarshaler{T: GTypeSrvTarget, F: marshalSrvTarget},
	})
}

// DBUS_METHOD_INVOCATION_HANDLED: value returned by handlers of the signals
// generated by the gdbus-codegen tool to indicate that a method call has been
// handled by an implementation. It is equal to TRUE, but using this macro is
// sometimes more readable.
//
// In code that needs to be backwards-compatible with older GLib, use TRUE
// instead, often written like this:
//
//	g_dbus_method_invocation_return_error (invocation, ...);
//	return TRUE;    // handled.
const DBUS_METHOD_INVOCATION_HANDLED = true

// DBUS_METHOD_INVOCATION_UNHANDLED: value returned by handlers of the signals
// generated by the gdbus-codegen tool to indicate that a method call has not
// been handled by an implementation. It is equal to FALSE, but using this macro
// is sometimes more readable.
//
// In code that needs to be backwards-compatible with older GLib, use FALSE
// instead.
const DBUS_METHOD_INVOCATION_UNHANDLED = false

// DEBUG_CONTROLLER_EXTENSION_POINT_NAME: extension point for debug control
// functionality. See [Extending GIO][extending-gio].
const DEBUG_CONTROLLER_EXTENSION_POINT_NAME = "gio-debug-controller"

// DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: extension point for default
// handler to URI association. See [Extending GIO][extending-gio].
//
// Deprecated: The AppInfoLookup interface is deprecated and unused by GIO.
const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME = "gio-desktop-app-info-lookup"

// DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: string used to obtain a Unix device path
// with g_drive_get_identifier().
const DRIVE_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device"

// FILE_ATTRIBUTE_ACCESS_CAN_DELETE: key in the "access" namespace for checking
// deletion privileges.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
//
// This attribute will be TRUE if the user is able to delete the file.
const FILE_ATTRIBUTE_ACCESS_CAN_DELETE = "access::can-delete"

// FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: key in the "access" namespace for getting
// execution privileges.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
//
// This attribute will be TRUE if the user is able to execute the file.
const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = "access::can-execute"

// FILE_ATTRIBUTE_ACCESS_CAN_READ: key in the "access" namespace for getting
// read privileges.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
//
// This attribute will be TRUE if the user is able to read the file.
const FILE_ATTRIBUTE_ACCESS_CAN_READ = "access::can-read"

// FILE_ATTRIBUTE_ACCESS_CAN_RENAME: key in the "access" namespace for checking
// renaming privileges.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
//
// This attribute will be TRUE if the user is able to rename the file.
const FILE_ATTRIBUTE_ACCESS_CAN_RENAME = "access::can-rename"

// FILE_ATTRIBUTE_ACCESS_CAN_TRASH: key in the "access" namespace for checking
// trashing privileges.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
//
// This attribute will be TRUE if the user is able to move the file to the
// trash.
const FILE_ATTRIBUTE_ACCESS_CAN_TRASH = "access::can-trash"

// FILE_ATTRIBUTE_ACCESS_CAN_WRITE: key in the "access" namespace for getting
// write privileges.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
//
// This attribute will be TRUE if the user is able to write to the file.
const FILE_ATTRIBUTE_ACCESS_CAN_WRITE = "access::can-write"

// FILE_ATTRIBUTE_DOS_IS_ARCHIVE: key in the "dos" namespace for checking if the
// file's archive flag is set.
//
// This attribute is TRUE if the archive flag is set.
//
// This attribute is only available for DOS file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_DOS_IS_ARCHIVE = "dos::is-archive"

// FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: key in the "dos" namespace for checking if
// the file is a NTFS mount point (a volume mount or a junction point).
//
// This attribute is TRUE if file is a reparse
// point of type IO_REPARSE_TAG_MOUNT_POINT
// (https://msdn.microsoft.com/en-us/library/dd541667.aspx).
//
// This attribute is only available for DOS file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = "dos::is-mountpoint"

// FILE_ATTRIBUTE_DOS_IS_SYSTEM: key in the "dos" namespace for checking if the
// file's backup flag is set.
//
// This attribute is TRUE if the backup flag is set.
//
// This attribute is only available for DOS file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_DOS_IS_SYSTEM = "dos::is-system"

// FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: key in the "dos" namespace for getting
// the file NTFS reparse tag.
//
// This value is 0 for files that are not reparse points.
//
// See the Reparse Tags (https://msdn.microsoft.com/en-us/library/dd541667.aspx)
// page for possible reparse tag values.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = "dos::reparse-point-tag"

// FILE_ATTRIBUTE_ETAG_VALUE: key in the "etag" namespace for getting the value
// of the file's entity tag.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_ETAG_VALUE = "etag::value"

// FILE_ATTRIBUTE_FILESYSTEM_FREE: key in the "filesystem" namespace for getting
// the number of bytes of free space left on the file system.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_FILESYSTEM_FREE = "filesystem::free"

// FILE_ATTRIBUTE_FILESYSTEM_READONLY: key in the "filesystem" namespace for
// checking if the file system is read only.
//
// Is set to TRUE if the file system is read only.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_FILESYSTEM_READONLY = "filesystem::readonly"

// FILE_ATTRIBUTE_FILESYSTEM_REMOTE: key in the "filesystem" namespace for
// checking if the file system is remote.
//
// Is set to TRUE if the file system is remote.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_FILESYSTEM_REMOTE = "filesystem::remote"

// FILE_ATTRIBUTE_FILESYSTEM_SIZE: key in the "filesystem" namespace
// for getting the total size (in bytes) of the file system, used in
// g_file_query_filesystem_info().
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_FILESYSTEM_SIZE = "filesystem::size"

// FILE_ATTRIBUTE_FILESYSTEM_TYPE: key in the "filesystem" namespace for getting
// the file system's type.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_FILESYSTEM_TYPE = "filesystem::type"

// FILE_ATTRIBUTE_FILESYSTEM_USED: key in the "filesystem" namespace for getting
// the number of bytes used by data on the file system.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_FILESYSTEM_USED = "filesystem::used"

// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: key in the "filesystem" namespace for
// hinting a file manager application whether it should preview (e.g. thumbnail)
// files on the file system.
//
// The value for this key contain a PreviewType.
const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW = "filesystem::use-preview"

// FILE_ATTRIBUTE_GVFS_BACKEND: key in the "gvfs" namespace that gets the name
// of the current GVFS backend in use.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_GVFS_BACKEND = "gvfs::backend"

// FILE_ATTRIBUTE_ID_FILE: key in the "id" namespace for getting a file
// identifier.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
//
// An example use would be during listing files, to avoid recursive directory
// scanning.
const FILE_ATTRIBUTE_ID_FILE = "id::file"

// FILE_ATTRIBUTE_ID_FILESYSTEM: key in the "id" namespace for getting the file
// system identifier.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
//
// An example use would be during drag and drop to see if the source and target
// are on the same filesystem (default to move) or not (default to copy).
const FILE_ATTRIBUTE_ID_FILESYSTEM = "id::filesystem"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be ejected.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = "mountable::can-eject"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) is mountable.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = "mountable::can-mount"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be polled.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = "mountable::can-poll"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_START: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START = "mountable::can-start"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: key in the "mountable" namespace
// for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started
// degraded.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = "mountable::can-start-degraded"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be stopped.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = "mountable::can-stop"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) is unmountable.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = "mountable::can-unmount"

// FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: key in the "mountable" namespace for
// getting the HAL UDI for the mountable file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = "mountable::hal-udi"

// FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: key in the "mountable"
// namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) is
// automatically polled for media.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic"

// FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: key in the "mountable" namespace
// for getting the StartStopType.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = "mountable::start-stop-type"

// FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: key in the "mountable" namespace for
// getting the unix device.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = "mountable::unix-device"

// FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: key in the "mountable" namespace
// for getting the unix device file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = "mountable::unix-device-file"

// FILE_ATTRIBUTE_OWNER_GROUP: key in the "owner" namespace for getting the file
// owner's group.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_OWNER_GROUP = "owner::group"

// FILE_ATTRIBUTE_OWNER_USER: key in the "owner" namespace for getting the user
// name of the file's owner.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_OWNER_USER = "owner::user"

// FILE_ATTRIBUTE_OWNER_USER_REAL: key in the "owner" namespace for getting the
// real name of the user that owns the file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_OWNER_USER_REAL = "owner::user-real"

// FILE_ATTRIBUTE_PREVIEW_ICON: key in the "preview" namespace for getting a
// #GIcon that can be used to get preview of the file.
//
// For example, it may be a low resolution thumbnail without metadata.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_OBJECT.
//
// The value for this key should contain a #GIcon.
const FILE_ATTRIBUTE_PREVIEW_ICON = "preview::icon"

// FILE_ATTRIBUTE_RECENT_MODIFIED: key in the "recent" namespace for getting
// time, when the metadata for the file in recent:/// was last changed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_INT64.
const FILE_ATTRIBUTE_RECENT_MODIFIED = "recent::modified"

// FILE_ATTRIBUTE_SELINUX_CONTEXT: key in the "selinux" namespace for getting
// the file's SELinux context.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
//
// Note that this attribute is only available if GLib has been built with
// SELinux support.
const FILE_ATTRIBUTE_SELINUX_CONTEXT = "selinux::context"

// FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: key in the "standard" namespace for
// getting the amount of disk space that is consumed by the file (in bytes).
//
// This will generally be larger than the file size (due to block size overhead)
// but can occasionally be smaller (for example, for sparse files).
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE = "standard::allocated-size"

// FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: key in the "standard" namespace for
// getting the content type of the file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
//
// The value for this key should contain a valid content type.
const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = "standard::content-type"

// FILE_ATTRIBUTE_STANDARD_COPY_NAME: key in the "standard" namespace for
// getting the copy name of the file.
//
// The copy name is an optional version of the name. If available it's always in
// UTF8, and corresponds directly to the original filename (only transcoded to
// UTF8). This is useful if you want to copy the file to another filesystem that
// might have a different encoding. If the filename is not a valid string in the
// encoding selected for the filesystem it is in then the copy name will not be
// set.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_COPY_NAME = "standard::copy-name"

// FILE_ATTRIBUTE_STANDARD_DESCRIPTION: key in the "standard" namespace for
// getting the description of the file.
//
// The description is a utf8 string that describes the file, generally
// containing the filename, but can also contain further information. Example
// descriptions could be "filename (on hostname)" for a remote file or "filename
// (in trash)" for a file in the trash. This is useful for instance as the
// window title when displaying a directory or for a bookmarks menu.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_DESCRIPTION = "standard::description"

// FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: key in the "standard" namespace for
// getting the display name of the file.
//
// A display name is guaranteed to be in UTF-8 and can thus be displayed in the
// UI. It is guaranteed to be set on every file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = "standard::display-name"

// FILE_ATTRIBUTE_STANDARD_EDIT_NAME: key in the "standard" namespace for edit
// name of the file.
//
// An edit name is similar to the display name, but it is meant to be used
// when you want to rename the file in the UI. The display name might contain
// information you don't want in the new filename (such as "(invalid unicode)"
// if the filename was in an invalid encoding).
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_EDIT_NAME = "standard::edit-name"

// FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: key in the "standard" namespace
// for getting the fast content type.
//
// The fast content type isn't as reliable as the regular one, as it only uses
// the filename to guess it, but it is faster to calculate than the regular
// content type.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE = "standard::fast-content-type"

// FILE_ATTRIBUTE_STANDARD_ICON: key in the "standard" namespace for getting the
// icon for the file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_OBJECT.
//
// The value for this key should contain a #GIcon.
const FILE_ATTRIBUTE_STANDARD_ICON = "standard::icon"

// FILE_ATTRIBUTE_STANDARD_IS_BACKUP: key in the "standard" namespace for
// checking if a file is a backup file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_BACKUP = "standard::is-backup"

// FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: key in the "standard" namespace for
// checking if a file is hidden.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = "standard::is-hidden"

// FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: key in the "standard" namespace for
// checking if the file is a symlink. Typically the actual type is something
// else, if we followed the symlink to get the type.
//
// On Windows NTFS mountpoints are considered to be symlinks as well.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = "standard::is-symlink"

// FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: key in the "standard" namespace for
// checking if a file is virtual.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = "standard::is-virtual"

// FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: key in the "standard" namespace for
// checking if a file is volatile. This is meant for opaque, non-POSIX-like
// backends to indicate that the URI is not persistent. Applications should look
// at G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = "standard::is-volatile"

// FILE_ATTRIBUTE_STANDARD_NAME: key in the "standard" namespace for getting the
// name of the file.
//
// The name is the on-disk filename which may not be in any known encoding,
// and can thus not be generally displayed as is. It is guaranteed to be set on
// every file.
//
// Use G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the name in
// a user interface.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_STANDARD_NAME = "standard::name"

// FILE_ATTRIBUTE_STANDARD_SIZE: key in the "standard" namespace for getting the
// file's size (in bytes).
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_STANDARD_SIZE = "standard::size"

// FILE_ATTRIBUTE_STANDARD_SORT_ORDER: key in the "standard" namespace for
// setting the sort order of a file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_INT32.
//
// An example use would be in file managers, which would use this key to set
// the order files are displayed. Files with smaller sort order should be sorted
// first, and files without sort order as if sort order was zero.
const FILE_ATTRIBUTE_STANDARD_SORT_ORDER = "standard::sort-order"

// FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: key in the "standard" namespace for
// getting the symbolic icon for the file.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_OBJECT.
//
// The value for this key should contain a #GIcon.
const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON = "standard::symbolic-icon"

// FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: key in the "standard" namespace for
// getting the symlink target, if the file is a symlink.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET = "standard::symlink-target"

// FILE_ATTRIBUTE_STANDARD_TARGET_URI: key in the "standard" namespace for
// getting the target URI for the file, in the case of G_FILE_TYPE_SHORTCUT or
// G_FILE_TYPE_MOUNTABLE files.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_STANDARD_TARGET_URI = "standard::target-uri"

// FILE_ATTRIBUTE_STANDARD_TYPE: key in the "standard" namespace for storing
// file types.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
//
// The value for this key should contain a Type.
const FILE_ATTRIBUTE_STANDARD_TYPE = "standard::type"

// FILE_ATTRIBUTE_THUMBNAILING_FAILED: key in the "thumbnail" namespace for
// checking if thumbnailing failed.
//
// This attribute is TRUE if thumbnailing failed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAILING_FAILED = "thumbnail::failed"

// FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: key in the "thumbnail" namespace
// for checking if thumbnailing failed for the large image.
//
// This attribute is TRUE if thumbnailing failed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE = "thumbnail::failed-large"

// FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: key in the "thumbnail" namespace
// for checking if thumbnailing failed for the normal image.
//
// This attribute is TRUE if thumbnailing failed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL = "thumbnail::failed-normal"

// FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: key in the "thumbnail" namespace
// for checking if thumbnailing failed for the x-large image.
//
// This attribute is TRUE if thumbnailing failed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE = "thumbnail::failed-xlarge"

// FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: key in the "thumbnail" namespace
// for checking if thumbnailing failed for the xx-large image.
//
// This attribute is TRUE if thumbnailing failed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE = "thumbnail::failed-xxlarge"

// FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: key in the "thumbnail" namespace for
// checking whether the thumbnail is outdated.
//
// This attribute is TRUE if the thumbnail is up-to-date with the file it
// represents, and FALSE if the file has been modified since the thumbnail was
// generated.
//
// If G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is TRUE and this attribute is FALSE,
// it indicates that thumbnailing may be attempted again and may succeed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = "thumbnail::is-valid"

// FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: key in the "thumbnail" namespace for
// checking whether the large thumbnail is outdated.
//
// This attribute is TRUE if the large thumbnail is up-to-date with the file it
// represents, and FALSE if the file has been modified since the thumbnail was
// generated.
//
// If G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE is TRUE and this attribute is
// FALSE, it indicates that thumbnailing may be attempted again and may succeed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE = "thumbnail::is-valid-large"

// FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: key in the "thumbnail" namespace
// for checking whether the normal thumbnail is outdated.
//
// This attribute is TRUE if the normal thumbnail is up-to-date with the file it
// represents, and FALSE if the file has been modified since the thumbnail was
// generated.
//
// If G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL is TRUE and this attribute is
// FALSE, it indicates that thumbnailing may be attempted again and may succeed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL = "thumbnail::is-valid-normal"

// FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: key in the "thumbnail" namespace
// for checking whether the x-large thumbnail is outdated.
//
// This attribute is TRUE if the x-large thumbnail is up-to-date with the file
// it represents, and FALSE if the file has been modified since the thumbnail
// was generated.
//
// If G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE is TRUE and this attribute is
// FALSE, it indicates that thumbnailing may be attempted again and may succeed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE = "thumbnail::is-valid-xlarge"

// FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: key in the "thumbnail" namespace
// for checking whether the xx-large thumbnail is outdated.
//
// This attribute is TRUE if the x-large thumbnail is up-to-date with the file
// it represents, and FALSE if the file has been modified since the thumbnail
// was generated.
//
// If G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE is TRUE and this attribute is
// FALSE, it indicates that thumbnailing may be attempted again and may succeed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE = "thumbnail::is-valid-xxlarge"

// FILE_ATTRIBUTE_THUMBNAIL_PATH: key in the "thumbnail" namespace for getting
// the path to the thumbnail image with the biggest size available.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_THUMBNAIL_PATH = "thumbnail::path"

// FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: key in the "thumbnail" namespace for
// getting the path to the large thumbnail image.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE = "thumbnail::path-large"

// FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: key in the "thumbnail" namespace for
// getting the path to the normal thumbnail image.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL = "thumbnail::path-normal"

// FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: key in the "thumbnail" namespace for
// getting the path to the x-large thumbnail image.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE = "thumbnail::path-xlarge"

// FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: key in the "thumbnail" namespace for
// getting the path to the xx-large thumbnail image.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE = "thumbnail::path-xxlarge"

// FILE_ATTRIBUTE_TIME_ACCESS: key in the "time" namespace for getting the time
// the file was last accessed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the
// time since the file was last accessed, in seconds since the UNIX epoch.
const FILE_ATTRIBUTE_TIME_ACCESS = "time::access"

// FILE_ATTRIBUTE_TIME_ACCESS_NSEC: key in the "time" namespace for getting the
// nanoseconds of the time the file was last accessed. This should be used in
// conjunction with FILE_ATTRIBUTE_TIME_ACCESS. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_ACCESS_NSEC = "time::access-nsec"

// FILE_ATTRIBUTE_TIME_ACCESS_USEC: key in the "time" namespace for getting the
// microseconds of the time the file was last accessed.
//
// This should be used in conjunction with G_FILE_ATTRIBUTE_TIME_ACCESS.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_ACCESS_USEC = "time::access-usec"

// FILE_ATTRIBUTE_TIME_CHANGED: key in the "time" namespace for getting the time
// the file was last changed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the
// time since the file was last changed, in seconds since the UNIX epoch.
//
// This corresponds to the traditional UNIX ctime.
const FILE_ATTRIBUTE_TIME_CHANGED = "time::changed"

// FILE_ATTRIBUTE_TIME_CHANGED_NSEC: key in the "time" namespace for getting
// the nanoseconds of the time the file was last changed. This should be used in
// conjunction with FILE_ATTRIBUTE_TIME_CHANGED. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_CHANGED_NSEC = "time::changed-nsec"

// FILE_ATTRIBUTE_TIME_CHANGED_USEC: key in the "time" namespace for getting the
// microseconds of the time the file was last changed.
//
// This should be used in conjunction with G_FILE_ATTRIBUTE_TIME_CHANGED.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_CHANGED_USEC = "time::changed-usec"

// FILE_ATTRIBUTE_TIME_CREATED: key in the "time" namespace for getting the time
// the file was created.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the
// time since the file was created, in seconds since the UNIX epoch.
//
// This may correspond to Linux stx_btime, FreeBSD st_birthtim, NetBSD
// st_birthtime or NTFS ctime.
const FILE_ATTRIBUTE_TIME_CREATED = "time::created"

// FILE_ATTRIBUTE_TIME_CREATED_NSEC: key in the "time" namespace for getting
// the nanoseconds of the time the file was created. This should be used in
// conjunction with FILE_ATTRIBUTE_TIME_CREATED. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_CREATED_NSEC = "time::created-nsec"

// FILE_ATTRIBUTE_TIME_CREATED_USEC: key in the "time" namespace for getting the
// microseconds of the time the file was created.
//
// This should be used in conjunction with G_FILE_ATTRIBUTE_TIME_CREATED.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_CREATED_USEC = "time::created-usec"

// FILE_ATTRIBUTE_TIME_MODIFIED: key in the "time" namespace for getting the
// time the file was last modified.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the
// time since the file was modified, in seconds since the UNIX epoch.
const FILE_ATTRIBUTE_TIME_MODIFIED = "time::modified"

// FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: key in the "time" namespace for getting
// the nanoseconds of the time the file was last modified. This should be used
// in conjunction with FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding AttributeType
// is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_MODIFIED_NSEC = "time::modified-nsec"

// FILE_ATTRIBUTE_TIME_MODIFIED_USEC: key in the "time" namespace for getting
// the microseconds of the time the file was last modified.
//
// This should be used in conjunction with G_FILE_ATTRIBUTE_TIME_MODIFIED.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TIME_MODIFIED_USEC = "time::modified-usec"

// FILE_ATTRIBUTE_TRASH_DELETION_DATE: key in the "trash" namespace for getting
// the deletion date and time of a file inside the trash:/// folder.
//
// The format of the returned string is YYYY-MM-DDThh:mm:ss.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_TRASH_DELETION_DATE = "trash::deletion-date"

// FILE_ATTRIBUTE_TRASH_ITEM_COUNT: key in the "trash" namespace for getting the
// number of (toplevel) items that are present in the trash:/// folder.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_TRASH_ITEM_COUNT = "trash::item-count"

// FILE_ATTRIBUTE_TRASH_ORIG_PATH: key in the "trash" namespace for getting the
// original path of a file inside the trash:/// folder before it was trashed.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
const FILE_ATTRIBUTE_TRASH_ORIG_PATH = "trash::orig-path"

// FILE_ATTRIBUTE_UNIX_BLOCKS: key in the "unix" namespace for getting the
// number of blocks allocated for the file.
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_UNIX_BLOCKS = "unix::blocks"

// FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: key in the "unix" namespace for getting the
// block size for the file system.
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = "unix::block-size"

// FILE_ATTRIBUTE_UNIX_DEVICE: key in the "unix" namespace for getting the
// device id of the device the file is located on (see stat() documentation).
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_DEVICE = "unix::device"

// FILE_ATTRIBUTE_UNIX_GID: key in the "unix" namespace for getting the group ID
// for the file.
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_GID = "unix::gid"

// FILE_ATTRIBUTE_UNIX_INODE: key in the "unix" namespace for getting the inode
// of the file.
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT64.
const FILE_ATTRIBUTE_UNIX_INODE = "unix::inode"

// FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: key in the "unix" namespace for checking
// if the file represents a UNIX mount point.
//
// This attribute is TRUE if the file is a UNIX mount point.
//
// Since 2.58, / is considered to be a mount point.
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = "unix::is-mountpoint"

// FILE_ATTRIBUTE_UNIX_MODE: key in the "unix" namespace for getting the mode of
// the file (e.g. whether the file is a regular file, symlink, etc).
//
// See the documentation for lstat(): this attribute is equivalent to
// the st_mode member of struct stat, and includes both the file type and
// permissions.
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_MODE = "unix::mode"

// FILE_ATTRIBUTE_UNIX_NLINK: key in the "unix" namespace for getting the number
// of hard links for a file.
//
// See the documentation for lstat().
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_NLINK = "unix::nlink"

// FILE_ATTRIBUTE_UNIX_RDEV: key in the "unix" namespace for getting the device
// ID for the file (if it is a special file).
//
// See the documentation for lstat().
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_RDEV = "unix::rdev"

// FILE_ATTRIBUTE_UNIX_UID: key in the "unix" namespace for getting the user ID
// for the file.
//
// This attribute is only available for UNIX file systems.
//
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_UNIX_UID = "unix::uid"

// MEMORY_MONITOR_EXTENSION_POINT_NAME: extension point for memory usage
// monitoring functionality. See [Extending GIO][extending-gio].
const MEMORY_MONITOR_EXTENSION_POINT_NAME = "gio-memory-monitor"

// MENU_ATTRIBUTE_ACTION: menu item attribute which holds the action name of the
// item. Action names are namespaced with an identifier for the action group in
// which the action resides. For example, "win." for window-specific actions and
// "app." for application-wide actions.
//
// See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().
const MENU_ATTRIBUTE_ACTION = "action"

// MENU_ATTRIBUTE_ACTION_NAMESPACE: menu item attribute that holds the namespace
// for all action names in menus that are linked from this item.
const MENU_ATTRIBUTE_ACTION_NAMESPACE = "action-namespace"

// MENU_ATTRIBUTE_ICON: menu item attribute which holds the icon of the item.
//
// The icon is stored in the format returned by g_icon_serialize().
//
// This attribute is intended only to represent 'noun' icons such as favicons
// for a webpage, or application icons. It should not be used for 'verbs' (ie:
// stock icons).
const MENU_ATTRIBUTE_ICON = "icon"

// MENU_ATTRIBUTE_LABEL: menu item attribute which holds the label of the item.
const MENU_ATTRIBUTE_LABEL = "label"

// MENU_ATTRIBUTE_TARGET: menu item attribute which holds the target with which
// the item's action will be activated.
//
// See also g_menu_item_set_action_and_target().
const MENU_ATTRIBUTE_TARGET = "target"

// MENU_EXPORTER_MAX_SECTION_SIZE: maximum number of entries in a menu section
// supported by g_dbus_connection_export_menu_model().
//
// The exact value of the limit may change in future GLib versions.
const MENU_EXPORTER_MAX_SECTION_SIZE = 1000

// MENU_LINK_SECTION: name of the link that associates a menu item with a
// section. The linked menu will usually be shown in place of the menu item,
// using the item's label as a header.
//
// See also g_menu_item_set_link().
const MENU_LINK_SECTION = "section"

// MENU_LINK_SUBMENU: name of the link that associates a menu item with a
// submenu.
//
// See also g_menu_item_set_link().
const MENU_LINK_SUBMENU = "submenu"
const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-native-volume-monitor"

// NETWORK_MONITOR_EXTENSION_POINT_NAME: extension point for network status
// monitoring functionality. See [Extending GIO][extending-gio].
const NETWORK_MONITOR_EXTENSION_POINT_NAME = "gio-network-monitor"

// POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: extension point for power profile
// usage monitoring functionality. See [Extending GIO][extending-gio].
const POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME = "gio-power-profile-monitor"

// PROXY_EXTENSION_POINT_NAME: extension point for proxy functionality.
// See [Extending GIO][extending-gio].
const PROXY_EXTENSION_POINT_NAME = "gio-proxy"

// PROXY_RESOLVER_EXTENSION_POINT_NAME: extension point for proxy resolving
// functionality. See [Extending GIO][extending-gio].
const PROXY_RESOLVER_EXTENSION_POINT_NAME = "gio-proxy-resolver"

// SETTINGS_BACKEND_EXTENSION_POINT_NAME: extension point for Backend
// functionality.
const SETTINGS_BACKEND_EXTENSION_POINT_NAME = "gsettings-backend"

// TLS_BACKEND_EXTENSION_POINT_NAME: extension point for TLS functionality via
// Backend. See [Extending GIO][extending-gio].
const TLS_BACKEND_EXTENSION_POINT_NAME = "gio-tls-backend"

// TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: purpose used to verify the client
// certificate in a TLS connection. Used by TLS servers.
const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT = "1.3.6.1.5.5.7.3.2"

// TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: purpose used to verify the server
// certificate in a TLS connection. This is the most common purpose in use.
// Used by TLS clients.
const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER = "1.3.6.1.5.5.7.3.1"

// VFS_EXTENSION_POINT_NAME: extension point for #GVfs functionality. See
// [Extending GIO][extending-gio].
const VFS_EXTENSION_POINT_NAME = "gio-vfs"

// VOLUME_IDENTIFIER_KIND_CLASS: string used to obtain the volume class with
// g_volume_get_identifier().
//
// Known volume classes include device, network, and loop. Other classes may be
// added in the future.
//
// This is intended to be used by applications to classify #GVolume instances
// into different sections - for example a file manager or file chooser can use
// this information to show network volumes under a "Network" heading and device
// volumes under a "Devices" heading.
const VOLUME_IDENTIFIER_KIND_CLASS = "class"

// VOLUME_IDENTIFIER_KIND_HAL_UDI: string used to obtain a Hal UDI with
// g_volume_get_identifier().
//
// Deprecated: Do not use, HAL is deprecated.
const VOLUME_IDENTIFIER_KIND_HAL_UDI = "hal-udi"

// VOLUME_IDENTIFIER_KIND_LABEL: string used to obtain a filesystem label with
// g_volume_get_identifier().
const VOLUME_IDENTIFIER_KIND_LABEL = "label"

// VOLUME_IDENTIFIER_KIND_NFS_MOUNT: string used to obtain a NFS mount with
// g_volume_get_identifier().
const VOLUME_IDENTIFIER_KIND_NFS_MOUNT = "nfs-mount"

// VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: string used to obtain a Unix device path
// with g_volume_get_identifier().
const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device"

// VOLUME_IDENTIFIER_KIND_UUID: string used to obtain a UUID with
// g_volume_get_identifier().
const VOLUME_IDENTIFIER_KIND_UUID = "uuid"

// VOLUME_MONITOR_EXTENSION_POINT_NAME: extension point for volume monitor
// functionality. See [Extending GIO][extending-gio].
const VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-volume-monitor"

// BusType: enumeration for well-known message buses.
type BusType C.gint

const (
	// BusTypeStarter alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BusType.
func (b BusType) String() string {
	switch b {
	case BusTypeStarter:
		return "Starter"
	case BusTypeNone:
		return "None"
	case BusTypeSystem:
		return "System"
	case BusTypeSession:
		return "Session"
	default:
		return fmt.Sprintf("BusType(%d)", b)
	}
}

// ConverterResult results returned from g_converter_convert().
type ConverterResult C.gint

const (
	// ConverterError: there was an error during conversion.
	ConverterError ConverterResult = iota
	// ConverterConverted: some data was consumed or produced.
	ConverterConverted
	// ConverterFinished: conversion is finished.
	ConverterFinished
	// ConverterFlushed: flushing is finished.
	ConverterFlushed
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConverterResult.
func (c ConverterResult) String() string {
	switch c {
	case ConverterError:
		return "Error"
	case ConverterConverted:
		return "Converted"
	case ConverterFinished:
		return "Finished"
	case ConverterFlushed:
		return "Flushed"
	default:
		return fmt.Sprintf("ConverterResult(%d)", c)
	}
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType C.gint

const (
	// CredentialsTypeInvalid indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = iota
	// CredentialsTypeLinuxUcred: native credentials type is a struct ucred.
	CredentialsTypeLinuxUcred
	// CredentialsTypeFreebsdCmsgcred: native credentials type is a struct
	// cmsgcred.
	CredentialsTypeFreebsdCmsgcred
	// CredentialsTypeOpenbsdSockpeercred: native credentials type is a struct
	// sockpeercred. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred
	// CredentialsTypeSolarisUcred: native credentials type is a ucred_t.
	// Added in 2.40.
	CredentialsTypeSolarisUcred
	// CredentialsTypeNetbsdUnpcbid: native credentials type is a struct
	// unpcbid. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid
	// CredentialsTypeAppleXucred: native credentials type is a struct xucred.
	// Added in 2.66.
	CredentialsTypeAppleXucred
	// CredentialsTypeWin32Pid: native credentials type is a PID DWORD. Added in
	// 2.72.
	CredentialsTypeWin32Pid
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CredentialsType.
func (c CredentialsType) String() string {
	switch c {
	case CredentialsTypeInvalid:
		return "Invalid"
	case CredentialsTypeLinuxUcred:
		return "LinuxUcred"
	case CredentialsTypeFreebsdCmsgcred:
		return "FreebsdCmsgcred"
	case CredentialsTypeOpenbsdSockpeercred:
		return "OpenbsdSockpeercred"
	case CredentialsTypeSolarisUcred:
		return "SolarisUcred"
	case CredentialsTypeNetbsdUnpcbid:
		return "NetbsdUnpcbid"
	case CredentialsTypeAppleXucred:
		return "AppleXucred"
	case CredentialsTypeWin32Pid:
		return "Win32Pid"
	default:
		return fmt.Sprintf("CredentialsType(%d)", c)
	}
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError C.gint

const (
	// DBusErrorFailed: generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = iota
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory
	// DBusErrorServiceUnknown bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown
	// DBusErrorNameHasNoOwner bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError
	// DBusErrorBadAddress d-Bus bus address was malformed.
	DBusErrorBadAddress
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse
	// DBusErrorDisconnected: connection is disconnected and you're trying to
	// use it.
	DBusErrorDisconnected
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound
	// DBusErrorMatchRuleInvalid: match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid
	// DBusErrorSpawnServiceInvalid bus name was not valid.
	DBusErrorSpawnServiceInvalid
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound
	// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown
	// DBusErrorInvalidSignature: type signature is not valid.
	DBusErrorInvalidSignature
	// DBusErrorInvalidFileContent: file contains invalid syntax or is otherwise
	// broken.
	DBusErrorInvalidFileContent
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown
	// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse
	// DBusErrorUnknownObject: object you invoked a method on isn't known.
	// Since 2.42.
	DBusErrorUnknownObject
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42.
	DBusErrorUnknownInterface
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42.
	DBusErrorUnknownProperty
	// DBusErrorPropertyReadOnly: property you tried to set is read-only.
	// Since 2.42.
	DBusErrorPropertyReadOnly
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusError.
func (d DBusError) String() string {
	switch d {
	case DBusErrorFailed:
		return "Failed"
	case DBusErrorNoMemory:
		return "NoMemory"
	case DBusErrorServiceUnknown:
		return "ServiceUnknown"
	case DBusErrorNameHasNoOwner:
		return "NameHasNoOwner"
	case DBusErrorNoReply:
		return "NoReply"
	case DBusErrorIOError:
		return "IOError"
	case DBusErrorBadAddress:
		return "BadAddress"
	case DBusErrorNotSupported:
		return "NotSupported"
	case DBusErrorLimitsExceeded:
		return "LimitsExceeded"
	case DBusErrorAccessDenied:
		return "AccessDenied"
	case DBusErrorAuthFailed:
		return "AuthFailed"
	case DBusErrorNoServer:
		return "NoServer"
	case DBusErrorTimeout:
		return "Timeout"
	case DBusErrorNoNetwork:
		return "NoNetwork"
	case DBusErrorAddressInUse:
		return "AddressInUse"
	case DBusErrorDisconnected:
		return "Disconnected"
	case DBusErrorInvalidArgs:
		return "InvalidArgs"
	case DBusErrorFileNotFound:
		return "FileNotFound"
	case DBusErrorFileExists:
		return "FileExists"
	case DBusErrorUnknownMethod:
		return "UnknownMethod"
	case DBusErrorTimedOut:
		return "TimedOut"
	case DBusErrorMatchRuleNotFound:
		return "MatchRuleNotFound"
	case DBusErrorMatchRuleInvalid:
		return "MatchRuleInvalid"
	case DBusErrorSpawnExecFailed:
		return "SpawnExecFailed"
	case DBusErrorSpawnForkFailed:
		return "SpawnForkFailed"
	case DBusErrorSpawnChildExited:
		return "SpawnChildExited"
	case DBusErrorSpawnChildSignaled:
		return "SpawnChildSignaled"
	case DBusErrorSpawnFailed:
		return "SpawnFailed"
	case DBusErrorSpawnSetupFailed:
		return "SpawnSetupFailed"
	case DBusErrorSpawnConfigInvalid:
		return "SpawnConfigInvalid"
	case DBusErrorSpawnServiceInvalid:
		return "SpawnServiceInvalid"
	case DBusErrorSpawnServiceNotFound:
		return "SpawnServiceNotFound"
	case DBusErrorSpawnPermissionsInvalid:
		return "SpawnPermissionsInvalid"
	case DBusErrorSpawnFileInvalid:
		return "SpawnFileInvalid"
	case DBusErrorSpawnNoMemory:
		return "SpawnNoMemory"
	case DBusErrorUnixProcessIDUnknown:
		return "UnixProcessIDUnknown"
	case DBusErrorInvalidSignature:
		return "InvalidSignature"
	case DBusErrorInvalidFileContent:
		return "InvalidFileContent"
	case DBusErrorSelinuxSecurityContextUnknown:
		return "SelinuxSecurityContextUnknown"
	case DBusErrorAdtAuditDataUnknown:
		return "AdtAuditDataUnknown"
	case DBusErrorObjectPathInUse:
		return "ObjectPathInUse"
	case DBusErrorUnknownObject:
		return "UnknownObject"
	case DBusErrorUnknownInterface:
		return "UnknownInterface"
	case DBusErrorUnknownProperty:
		return "UnknownProperty"
	case DBusErrorPropertyReadOnly:
		return "PropertyReadOnly"
	default:
		return fmt.Sprintf("DBusError(%d)", d)
	}
}

// DBusErrorEncodeGError creates a D-Bus error name to use for error.
// If error matches a registered error (cf. g_dbus_error_register_error()),
// the corresponding D-Bus error name will be returned.
//
// Otherwise the a name of the form
// org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE will
// be used. This allows other GDBus applications to map the error on the wire
// back to a #GError using g_dbus_error_new_for_dbus_error().
//
// This function is typically only used in object mappings to put a #GError on
// the wire. Regular applications should not use it.
//
// The function takes the following parameters:
//
//   - err: #GError.
//
// The function returns the following values:
//
//   - utf8 d-Bus error name (never NULL). Free with g_free().
func DBusErrorEncodeGError(err error) string {
	var _arg1 *C.GError // out
	var _cret *C.gchar  // in

	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	_cret = C.g_dbus_error_encode_gerror(_arg1)
	runtime.KeepAlive(err)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusErrorGetRemoteError gets the D-Bus error name used for error, if any.
//
// This function is guaranteed to return a D-Bus error name for all
// #GErrors returned from functions handling remote method calls (e.g.
// g_dbus_connection_call_finish()) unless g_dbus_error_strip_remote_error() has
// been used on error.
//
// The function takes the following parameters:
//
//   - err: #GError.
//
// The function returns the following values:
//
//   - utf8 (optional): allocated string or NULL if the D-Bus error name could
//     not be found. Free with g_free().
func DBusErrorGetRemoteError(err error) string {
	var _arg1 *C.GError // out
	var _cret *C.gchar  // in

	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	_cret = C.g_dbus_error_get_remote_error(_arg1)
	runtime.KeepAlive(err)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// DBusErrorIsRemoteError checks if error represents an error received via D-Bus
// from a remote peer. If so, use g_dbus_error_get_remote_error() to get the
// name of the error.
//
// The function takes the following parameters:
//
//   - err: #GError.
//
// The function returns the following values:
//
//   - ok: TRUE if error represents an error from a remote peer, FALSE
//     otherwise.
func DBusErrorIsRemoteError(err error) bool {
	var _arg1 *C.GError  // out
	var _cret C.gboolean // in

	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	_cret = C.g_dbus_error_is_remote_error(_arg1)
	runtime.KeepAlive(err)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewDBusErrorForDBusError creates a #GError based on the contents of
// dbus_error_name and dbus_error_message.
//
// Errors registered with g_dbus_error_register_error() will be looked up
// using dbus_error_name and if a match is found, the error domain and code
// is used. Applications can use g_dbus_error_get_remote_error() to recover
// dbus_error_name.
//
// If a match against a registered error is not found and the D-Bus error
// name is in a form as returned by g_dbus_error_encode_gerror() the error
// domain and code encoded in the name is used to create the #GError. Also,
// dbus_error_name is added to the error message such that it can be recovered
// with g_dbus_error_get_remote_error().
//
// Otherwise, a #GError with the error code G_IO_ERROR_DBUS_ERROR in
// the G_IO_ERROR error domain is returned. Also, dbus_error_name
// is added to the error message such that it can be recovered with
// g_dbus_error_get_remote_error().
//
// In all three cases, dbus_error_name can always be recovered from the
// returned #GError using the g_dbus_error_get_remote_error() function (unless
// g_dbus_error_strip_remote_error() hasn't been used on the returned error).
//
// This function is typically only used in object mappings to prepare #GError
// instances for applications. Regular applications should not use it.
//
// The function takes the following parameters:
//
//   - dbusErrorName d-Bus error name.
//   - dbusErrorMessage d-Bus error message.
//
// The function returns the following values:
//
//   - err: allocated #GError. Free with g_error_free().
func NewDBusErrorForDBusError(dbusErrorName, dbusErrorMessage string) error {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _cret *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorMessage)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_error_new_for_dbus_error(_arg1, _arg2)
	runtime.KeepAlive(dbusErrorName)
	runtime.KeepAlive(dbusErrorMessage)

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(_cret))

	return _err
}

func DBusErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_dbus_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// DBusErrorRegisterError creates an association to map between dbus_error_name
// and #GErrors specified by error_domain and error_code.
//
// This is typically done in the routine that returns the #GQuark for an error
// domain.
//
// The function takes the following parameters:
//
//   - errorDomain for an error domain.
//   - errorCode: error code.
//   - dbusErrorName d-Bus error name.
//
// The function returns the following values:
//
//   - ok: TRUE if the association was created, FALSE if it already exists.
func DBusErrorRegisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool {
	var _arg1 C.GQuark   // out
	var _arg2 C.gint     // out
	var _arg3 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = C.GQuark(errorDomain)
	_arg2 = C.gint(errorCode)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorName)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_error_register_error(_arg1, _arg2, _arg3)
	runtime.KeepAlive(errorDomain)
	runtime.KeepAlive(errorCode)
	runtime.KeepAlive(dbusErrorName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusErrorRegisterErrorDomain: helper function for associating a #GError error
// domain with D-Bus error names.
//
// While quark_volatile has a volatile qualifier, this is a historical artifact
// and the argument passed to it should not be volatile.
//
// The function takes the following parameters:
//
//   - errorDomainQuarkName: error domain name.
//   - quarkVolatile: pointer where to store the #GQuark.
//   - entries: pointer to num_entries BusErrorEntry struct items.
func DBusErrorRegisterErrorDomain(errorDomainQuarkName string, quarkVolatile *uint, entries []DBusErrorEntry) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gsize           // out
	var _arg3 *C.GDBusErrorEntry // out
	var _arg4 C.guint

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(errorDomainQuarkName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gsize)(unsafe.Pointer(quarkVolatile))
	_arg4 = (C.guint)(len(entries))
	_arg3 = (*C.GDBusErrorEntry)(C.calloc(C.size_t(len(entries)), C.size_t(C.sizeof_GDBusErrorEntry)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GDBusErrorEntry)(_arg3), len(entries))
		for i := range entries {
			out[i] = *(*C.GDBusErrorEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
		}
	}

	C.g_dbus_error_register_error_domain(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(errorDomainQuarkName)
	runtime.KeepAlive(quarkVolatile)
	runtime.KeepAlive(entries)
}

// DBusErrorStripRemoteError looks for extra information in the error message
// used to recover the D-Bus error name and strips it if found. If stripped,
// the message field in error will correspond exactly to what was received on
// the wire.
//
// This is typically used when presenting errors to the end user.
//
// The function takes the following parameters:
//
//   - err: #GError.
//
// The function returns the following values:
//
//   - ok: TRUE if information was stripped, FALSE otherwise.
func DBusErrorStripRemoteError(err error) bool {
	var _arg1 *C.GError  // out
	var _cret C.gboolean // in

	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	_cret = C.g_dbus_error_strip_remote_error(_arg1)
	runtime.KeepAlive(err)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusErrorUnregisterError destroys an association previously set up with
// g_dbus_error_register_error().
//
// The function takes the following parameters:
//
//   - errorDomain for an error domain.
//   - errorCode: error code.
//   - dbusErrorName d-Bus error name.
//
// The function returns the following values:
//
//   - ok: TRUE if the association was destroyed, FALSE if it wasn't found.
func DBusErrorUnregisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool {
	var _arg1 C.GQuark   // out
	var _arg2 C.gint     // out
	var _arg3 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = C.GQuark(errorDomain)
	_arg2 = C.gint(errorCode)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorName)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_error_unregister_error(_arg1, _arg2, _arg3)
	runtime.KeepAlive(errorDomain)
	runtime.KeepAlive(errorCode)
	runtime.KeepAlive(dbusErrorName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder C.gint

const (
	// DBusMessageByteOrderBigEndian: byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageByteOrder.
func (d DBusMessageByteOrder) String() string {
	switch d {
	case DBusMessageByteOrderBigEndian:
		return "BigEndian"
	case DBusMessageByteOrderLittleEndian:
		return "LittleEndian"
	default:
		return fmt.Sprintf("DBusMessageByteOrder(%d)", d)
	}
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField C.gint

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = iota
	// DBusMessageHeaderFieldPath: object path.
	DBusMessageHeaderFieldPath
	// DBusMessageHeaderFieldInterface: interface name.
	DBusMessageHeaderFieldInterface
	// DBusMessageHeaderFieldMember: method or signal name.
	DBusMessageHeaderFieldMember
	// DBusMessageHeaderFieldErrorName: name of the error that occurred.
	DBusMessageHeaderFieldErrorName
	// DBusMessageHeaderFieldReplySerial: serial number the message is a reply
	// to.
	DBusMessageHeaderFieldReplySerial
	// DBusMessageHeaderFieldDestination: name the message is intended for.
	DBusMessageHeaderFieldDestination
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender
	// DBusMessageHeaderFieldSignature: signature of the message body.
	DBusMessageHeaderFieldSignature
	// DBusMessageHeaderFieldNumUnixFds: number of UNIX file descriptors that
	// accompany the message.
	DBusMessageHeaderFieldNumUnixFds
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageHeaderField.
func (d DBusMessageHeaderField) String() string {
	switch d {
	case DBusMessageHeaderFieldInvalid:
		return "Invalid"
	case DBusMessageHeaderFieldPath:
		return "Path"
	case DBusMessageHeaderFieldInterface:
		return "Interface"
	case DBusMessageHeaderFieldMember:
		return "Member"
	case DBusMessageHeaderFieldErrorName:
		return "ErrorName"
	case DBusMessageHeaderFieldReplySerial:
		return "ReplySerial"
	case DBusMessageHeaderFieldDestination:
		return "Destination"
	case DBusMessageHeaderFieldSender:
		return "Sender"
	case DBusMessageHeaderFieldSignature:
		return "Signature"
	case DBusMessageHeaderFieldNumUnixFds:
		return "NumUnixFds"
	default:
		return fmt.Sprintf("DBusMessageHeaderField(%d)", d)
	}
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType C.gint

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = iota
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageType.
func (d DBusMessageType) String() string {
	switch d {
	case DBusMessageTypeInvalid:
		return "Invalid"
	case DBusMessageTypeMethodCall:
		return "MethodCall"
	case DBusMessageTypeMethodReturn:
		return "MethodReturn"
	case DBusMessageTypeError:
		return "Error"
	case DBusMessageTypeSignal:
		return "Signal"
	default:
		return fmt.Sprintf("DBusMessageType(%d)", d)
	}
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder C.gint

const (
	// DataStreamByteOrderBigEndian selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = iota
	// DataStreamByteOrderLittleEndian selects Little Endian byte order.
	DataStreamByteOrderLittleEndian
	// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DataStreamByteOrder.
func (d DataStreamByteOrder) String() string {
	switch d {
	case DataStreamByteOrderBigEndian:
		return "BigEndian"
	case DataStreamByteOrderLittleEndian:
		return "LittleEndian"
	case DataStreamByteOrderHostEndian:
		return "HostEndian"
	default:
		return fmt.Sprintf("DataStreamByteOrder(%d)", d)
	}
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType C.gint

const (
	// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = iota
	// DataStreamNewlineTypeCr selects "CR" line endings.
	DataStreamNewlineTypeCr
	// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DataStreamNewlineType.
func (d DataStreamNewlineType) String() string {
	switch d {
	case DataStreamNewlineTypeLf:
		return "Lf"
	case DataStreamNewlineTypeCr:
		return "Cr"
	case DataStreamNewlineTypeCrLf:
		return "CrLf"
	case DataStreamNewlineTypeAny:
		return "Any"
	default:
		return fmt.Sprintf("DataStreamNewlineType(%d)", d)
	}
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType C.gint

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = iota
	// DriveStartStopTypeShutdown: stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown
	// DriveStartStopTypeNetwork: start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork
	// DriveStartStopTypeMultidisk: start/stop methods will assemble/disassemble
	// a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk
	// DriveStartStopTypePassword: start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command).
	DriveStartStopTypePassword
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DriveStartStopType.
func (d DriveStartStopType) String() string {
	switch d {
	case DriveStartStopTypeUnknown:
		return "Unknown"
	case DriveStartStopTypeShutdown:
		return "Shutdown"
	case DriveStartStopTypeNetwork:
		return "Network"
	case DriveStartStopTypeMultidisk:
		return "Multidisk"
	case DriveStartStopTypePassword:
		return "Password"
	default:
		return fmt.Sprintf("DriveStartStopType(%d)", d)
	}
}

// EmblemOrigin is used to add information about the origin of the emblem to
// #GEmblem.
type EmblemOrigin C.gint

const (
	// EmblemOriginUnknown: emblem of unknown origin.
	EmblemOriginUnknown EmblemOrigin = iota
	// EmblemOriginDevice: emblem adds device-specific information.
	EmblemOriginDevice
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly".
	EmblemOriginLivemetadata
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future).
	EmblemOriginTag
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EmblemOrigin.
func (e EmblemOrigin) String() string {
	switch e {
	case EmblemOriginUnknown:
		return "Unknown"
	case EmblemOriginDevice:
		return "Device"
	case EmblemOriginLivemetadata:
		return "Livemetadata"
	case EmblemOriginTag:
		return "Tag"
	default:
		return fmt.Sprintf("EmblemOrigin(%d)", e)
	}
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus C.gint

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = iota
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet
	// FileAttributeStatusErrorSetting indicates an error in setting the value.
	FileAttributeStatusErrorSetting
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileAttributeStatus.
func (f FileAttributeStatus) String() string {
	switch f {
	case FileAttributeStatusUnset:
		return "Unset"
	case FileAttributeStatusSet:
		return "Set"
	case FileAttributeStatusErrorSetting:
		return "ErrorSetting"
	default:
		return fmt.Sprintf("FileAttributeStatus(%d)", f)
	}
}

// FileAttributeType: data types for file attributes.
type FileAttributeType C.gint

const (
	// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = iota
	// FileAttributeTypeString: null terminated UTF8 string.
	FileAttributeTypeString
	// FileAttributeTypeByteString: zero terminated string of non-zero bytes.
	FileAttributeTypeByteString
	// FileAttributeTypeBoolean: boolean value.
	FileAttributeTypeBoolean
	// FileAttributeTypeUint32: unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32
	// FileAttributeTypeInt32: signed 4-byte/32-bit integer.
	FileAttributeTypeInt32
	// FileAttributeTypeUint64: unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64
	// FileAttributeTypeInt64: signed 8-byte/64-bit integer.
	FileAttributeTypeInt64
	// FileAttributeTypeObject: #GObject.
	FileAttributeTypeObject
	// FileAttributeTypeStringv: NULL terminated char **. Since 2.22.
	FileAttributeTypeStringv
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileAttributeType.
func (f FileAttributeType) String() string {
	switch f {
	case FileAttributeTypeInvalid:
		return "Invalid"
	case FileAttributeTypeString:
		return "String"
	case FileAttributeTypeByteString:
		return "ByteString"
	case FileAttributeTypeBoolean:
		return "Boolean"
	case FileAttributeTypeUint32:
		return "Uint32"
	case FileAttributeTypeInt32:
		return "Int32"
	case FileAttributeTypeUint64:
		return "Uint64"
	case FileAttributeTypeInt64:
		return "Int64"
	case FileAttributeTypeObject:
		return "Object"
	case FileAttributeTypeStringv:
		return "Stringv"
	default:
		return fmt.Sprintf("FileAttributeType(%d)", f)
	}
}

// FileMonitorEvent specifies what type of event a monitor event is.
type FileMonitorEvent C.gint

const (
	// FileMonitorEventChanged: file changed.
	FileMonitorEventChanged FileMonitorEvent = iota
	// FileMonitorEventChangesDoneHint: hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint
	// FileMonitorEventDeleted: file was deleted.
	FileMonitorEventDeleted
	// FileMonitorEventCreated: file was created.
	FileMonitorEventCreated
	// FileMonitorEventAttributeChanged: file attribute was changed.
	FileMonitorEventAttributeChanged
	// FileMonitorEventPreUnmount: file location will soon be unmounted.
	FileMonitorEventPreUnmount
	// FileMonitorEventUnmounted: file location was unmounted.
	FileMonitorEventUnmounted
	// FileMonitorEventMoved: file was moved -- only sent if the (deprecated)
	// G_FILE_MONITOR_SEND_MOVED flag is set.
	FileMonitorEventMoved
	// FileMonitorEventRenamed: file was renamed within the current directory --
	// only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46.
	FileMonitorEventRenamed
	// FileMonitorEventMovedIn: file was moved into the monitored directory from
	// another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is
	// set. Since: 2.46.
	FileMonitorEventMovedIn
	// FileMonitorEventMovedOut: file was moved out of the monitored directory
	// to another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedOut
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileMonitorEvent.
func (f FileMonitorEvent) String() string {
	switch f {
	case FileMonitorEventChanged:
		return "Changed"
	case FileMonitorEventChangesDoneHint:
		return "ChangesDoneHint"
	case FileMonitorEventDeleted:
		return "Deleted"
	case FileMonitorEventCreated:
		return "Created"
	case FileMonitorEventAttributeChanged:
		return "AttributeChanged"
	case FileMonitorEventPreUnmount:
		return "PreUnmount"
	case FileMonitorEventUnmounted:
		return "Unmounted"
	case FileMonitorEventMoved:
		return "Moved"
	case FileMonitorEventRenamed:
		return "Renamed"
	case FileMonitorEventMovedIn:
		return "MovedIn"
	case FileMonitorEventMovedOut:
		return "MovedOut"
	default:
		return fmt.Sprintf("FileMonitorEvent(%d)", f)
	}
}

// FileType indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type;
// use Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a
// file is a symlink or not. This is due to the fact that NTFS does not have a
// single filesystem object type for symbolic links - it has files that symlink
// to files, and directories that symlink to directories. Type enumeration
// cannot precisely represent this important distinction, which is why all
// Windows symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType C.gint

const (
	// FileTypeUnknown file's type is unknown.
	FileTypeUnknown FileType = iota
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo,
	// block device, or character device.
	FileTypeSpecial
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileType.
func (f FileType) String() string {
	switch f {
	case FileTypeUnknown:
		return "Unknown"
	case FileTypeRegular:
		return "Regular"
	case FileTypeDirectory:
		return "Directory"
	case FileTypeSymbolicLink:
		return "SymbolicLink"
	case FileTypeSpecial:
		return "Special"
	case FileTypeShortcut:
		return "Shortcut"
	case FileTypeMountable:
		return "Mountable"
	default:
		return fmt.Sprintf("FileType(%d)", f)
	}
}

// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType C.gint

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = iota
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FilesystemPreviewType.
func (f FilesystemPreviewType) String() string {
	switch f {
	case FilesystemPreviewTypeIfAlways:
		return "IfAlways"
	case FilesystemPreviewTypeIfLocal:
		return "IfLocal"
	case FilesystemPreviewTypeNever:
		return "Never"
	default:
		return fmt.Sprintf("FilesystemPreviewType(%d)", f)
	}
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases.
// In general, new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before.
// You should therefore avoid writing code like
//
//	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//	  {
//	    // Assume that this is EPRINTERONFIRE
//	    ...
//	  }
//
// but should instead treat all unrecognized error codes the same as
// G_IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum C.gint

const (
	// IOErrorFailed: generic error condition for when an operation fails and no
	// more specific OErrorEnum value is defined.
	IOErrorFailed IOErrorEnum = 0
	// IOErrorNotFound: file not found.
	IOErrorNotFound IOErrorEnum = 1
	// IOErrorExists: file already exists.
	IOErrorExists IOErrorEnum = 2
	// IOErrorIsDirectory: file is a directory.
	IOErrorIsDirectory IOErrorEnum = 3
	// IOErrorNotDirectory: file is not a directory.
	IOErrorNotDirectory IOErrorEnum = 4
	// IOErrorNotEmpty: file is a directory that isn't empty.
	IOErrorNotEmpty IOErrorEnum = 5
	// IOErrorNotRegularFile: file is not a regular file.
	IOErrorNotRegularFile IOErrorEnum = 6
	// IOErrorNotSymbolicLink: file is not a symbolic link.
	IOErrorNotSymbolicLink IOErrorEnum = 7
	// IOErrorNotMountableFile: file cannot be mounted.
	IOErrorNotMountableFile IOErrorEnum = 8
	// IOErrorFilenameTooLong: filename is too many characters.
	IOErrorFilenameTooLong IOErrorEnum = 9
	// IOErrorInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorInvalidFilename IOErrorEnum = 10
	// IOErrorTooManyLinks: file contains too many symbolic links.
	IOErrorTooManyLinks IOErrorEnum = 11
	// IOErrorNoSpace: no space left on drive.
	IOErrorNoSpace IOErrorEnum = 12
	// IOErrorInvalidArgument: invalid argument.
	IOErrorInvalidArgument IOErrorEnum = 13
	// IOErrorPermissionDenied: permission denied.
	IOErrorPermissionDenied IOErrorEnum = 14
	// IOErrorNotSupported: operation (or one of its parameters) not supported.
	IOErrorNotSupported IOErrorEnum = 15
	// IOErrorNotMounted: file isn't mounted.
	IOErrorNotMounted IOErrorEnum = 16
	// IOErrorAlreadyMounted: file is already mounted.
	IOErrorAlreadyMounted IOErrorEnum = 17
	// IOErrorClosed: file was closed.
	IOErrorClosed IOErrorEnum = 18
	// IOErrorCancelled: operation was cancelled. See #GCancellable.
	IOErrorCancelled IOErrorEnum = 19
	// IOErrorPending operations are still pending.
	IOErrorPending IOErrorEnum = 20
	// IOErrorReadOnly: file is read only.
	IOErrorReadOnly IOErrorEnum = 21
	// IOErrorCantCreateBackup: backup couldn't be created.
	IOErrorCantCreateBackup IOErrorEnum = 22
	// IOErrorWrongETag file's Entity Tag was incorrect.
	IOErrorWrongETag IOErrorEnum = 23
	// IOErrorTimedOut: operation timed out.
	IOErrorTimedOut IOErrorEnum = 24
	// IOErrorWouldRecurse: operation would be recursive.
	IOErrorWouldRecurse IOErrorEnum = 25
	// IOErrorBusy: file is busy.
	IOErrorBusy IOErrorEnum = 26
	// IOErrorWouldBlock: operation would block.
	IOErrorWouldBlock IOErrorEnum = 27
	// IOErrorHostNotFound: host couldn't be found (remote operations).
	IOErrorHostNotFound IOErrorEnum = 28
	// IOErrorWouldMerge: operation would merge files.
	IOErrorWouldMerge IOErrorEnum = 29
	// IOErrorFailedHandled: operation failed and a helper program has already
	// interacted with the user. Do not display any error dialog.
	IOErrorFailedHandled IOErrorEnum = 30
	// IOErrorTooManyOpenFiles: current process has too many files open and
	// can't open any more. Duplicate descriptors do count toward this limit.
	// Since 2.20.
	IOErrorTooManyOpenFiles IOErrorEnum = 31
	// IOErrorNotInitialized: object has not been initialized. Since 2.22.
	IOErrorNotInitialized IOErrorEnum = 32
	// IOErrorAddressInUse: requested address is already in use. Since 2.22.
	IOErrorAddressInUse IOErrorEnum = 33
	// IOErrorPartialInput: need more input to finish operation. Since 2.24.
	IOErrorPartialInput IOErrorEnum = 34
	// IOErrorInvalidData: input data was invalid. Since 2.24.
	IOErrorInvalidData IOErrorEnum = 35
	// IOErrorDBusError: remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorDBusError IOErrorEnum = 36
	// IOErrorHostUnreachable: host unreachable. Since 2.26.
	IOErrorHostUnreachable IOErrorEnum = 37
	// IOErrorNetworkUnreachable: network unreachable. Since 2.26.
	IOErrorNetworkUnreachable IOErrorEnum = 38
	// IOErrorConnectionRefused: connection refused. Since 2.26.
	IOErrorConnectionRefused IOErrorEnum = 39
	// IOErrorProxyFailed: connection to proxy server failed. Since 2.26.
	IOErrorProxyFailed IOErrorEnum = 40
	// IOErrorProxyAuthFailed: proxy authentication failed. Since 2.26.
	IOErrorProxyAuthFailed IOErrorEnum = 41
	// IOErrorProxyNeedAuth: proxy server needs authentication. Since 2.26.
	IOErrorProxyNeedAuth IOErrorEnum = 42
	// IOErrorProxyNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26.
	IOErrorProxyNotAllowed IOErrorEnum = 43
	// IOErrorBrokenPipe: broken pipe. Since 2.36.
	IOErrorBrokenPipe IOErrorEnum = 44
	// IOErrorConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorConnectionClosed IOErrorEnum = 44
	// IOErrorNotConnected: transport endpoint is not connected. Since 2.44.
	IOErrorNotConnected IOErrorEnum = 45
	// IOErrorMessageTooLarge: message too large. Since 2.48.
	IOErrorMessageTooLarge IOErrorEnum = 46
	// IOErrorNoSuchDevice: no such device found. Since 2.74.
	IOErrorNoSuchDevice IOErrorEnum = 47
	// IOErrorDestinationUnset: destination address unset. Since 2.80.
	IOErrorDestinationUnset IOErrorEnum = 48
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IOErrorEnum.
func (i IOErrorEnum) String() string {
	switch i {
	case IOErrorFailed:
		return "Failed"
	case IOErrorNotFound:
		return "NotFound"
	case IOErrorExists:
		return "Exists"
	case IOErrorIsDirectory:
		return "IsDirectory"
	case IOErrorNotDirectory:
		return "NotDirectory"
	case IOErrorNotEmpty:
		return "NotEmpty"
	case IOErrorNotRegularFile:
		return "NotRegularFile"
	case IOErrorNotSymbolicLink:
		return "NotSymbolicLink"
	case IOErrorNotMountableFile:
		return "NotMountableFile"
	case IOErrorFilenameTooLong:
		return "FilenameTooLong"
	case IOErrorInvalidFilename:
		return "InvalidFilename"
	case IOErrorTooManyLinks:
		return "TooManyLinks"
	case IOErrorNoSpace:
		return "NoSpace"
	case IOErrorInvalidArgument:
		return "InvalidArgument"
	case IOErrorPermissionDenied:
		return "PermissionDenied"
	case IOErrorNotSupported:
		return "NotSupported"
	case IOErrorNotMounted:
		return "NotMounted"
	case IOErrorAlreadyMounted:
		return "AlreadyMounted"
	case IOErrorClosed:
		return "Closed"
	case IOErrorCancelled:
		return "Cancelled"
	case IOErrorPending:
		return "Pending"
	case IOErrorReadOnly:
		return "ReadOnly"
	case IOErrorCantCreateBackup:
		return "CantCreateBackup"
	case IOErrorWrongETag:
		return "WrongETag"
	case IOErrorTimedOut:
		return "TimedOut"
	case IOErrorWouldRecurse:
		return "WouldRecurse"
	case IOErrorBusy:
		return "Busy"
	case IOErrorWouldBlock:
		return "WouldBlock"
	case IOErrorHostNotFound:
		return "HostNotFound"
	case IOErrorWouldMerge:
		return "WouldMerge"
	case IOErrorFailedHandled:
		return "FailedHandled"
	case IOErrorTooManyOpenFiles:
		return "TooManyOpenFiles"
	case IOErrorNotInitialized:
		return "NotInitialized"
	case IOErrorAddressInUse:
		return "AddressInUse"
	case IOErrorPartialInput:
		return "PartialInput"
	case IOErrorInvalidData:
		return "InvalidData"
	case IOErrorDBusError:
		return "DBusError"
	case IOErrorHostUnreachable:
		return "HostUnreachable"
	case IOErrorNetworkUnreachable:
		return "NetworkUnreachable"
	case IOErrorConnectionRefused:
		return "ConnectionRefused"
	case IOErrorProxyFailed:
		return "ProxyFailed"
	case IOErrorProxyAuthFailed:
		return "ProxyAuthFailed"
	case IOErrorProxyNeedAuth:
		return "ProxyNeedAuth"
	case IOErrorProxyNotAllowed:
		return "ProxyNotAllowed"
	case IOErrorBrokenPipe:
		return "BrokenPipe"
	case IOErrorNotConnected:
		return "NotConnected"
	case IOErrorMessageTooLarge:
		return "MessageTooLarge"
	case IOErrorNoSuchDevice:
		return "NoSuchDevice"
	case IOErrorDestinationUnset:
		return "DestinationUnset"
	default:
		return fmt.Sprintf("IOErrorEnum(%d)", i)
	}
}

// IOModuleScopeFlags flags for use with g_io_module_scope_new().
type IOModuleScopeFlags C.gint

const (
	// IOModuleScopeNone: no module scan flags.
	IOModuleScopeNone IOModuleScopeFlags = iota
	// IOModuleScopeBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeBlockDuplicates
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IOModuleScopeFlags.
func (i IOModuleScopeFlags) String() string {
	switch i {
	case IOModuleScopeNone:
		return "None"
	case IOModuleScopeBlockDuplicates:
		return "BlockDuplicates"
	default:
		return fmt.Sprintf("IOModuleScopeFlags(%d)", i)
	}
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
// Note that because new values might be added, it is recommended that
// applications check MonitorWarningLevel as ranges, for example:
//
//	if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//	  drop_caches ();.
type MemoryMonitorWarningLevel C.gint

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources.
	// If your process does not need to stay running, it is a good time for it
	// to quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MemoryMonitorWarningLevel.
func (m MemoryMonitorWarningLevel) String() string {
	switch m {
	case MemoryMonitorWarningLevelLow:
		return "Low"
	case MemoryMonitorWarningLevelMedium:
		return "Medium"
	case MemoryMonitorWarningLevelCritical:
		return "Critical"
	default:
		return fmt.Sprintf("MemoryMonitorWarningLevel(%d)", m)
	}
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult C.gint

const (
	// MountOperationHandled: request was fulfilled and the user specified data
	// is now available.
	MountOperationHandled MountOperationResult = iota
	// MountOperationAborted: user requested the mount operation to be aborted.
	MountOperationAborted
	// MountOperationUnhandled: request was unhandled (i.e. not implemented).
	MountOperationUnhandled
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MountOperationResult.
func (m MountOperationResult) String() string {
	switch m {
	case MountOperationHandled:
		return "Handled"
	case MountOperationAborted:
		return "Aborted"
	case MountOperationUnhandled:
		return "Unhandled"
	default:
		return fmt.Sprintf("MountOperationResult(%d)", m)
	}
}

// NetworkConnectivity host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity C.gint

const (
	// NetworkConnectivityLocal: host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: host is connected to a network, but does not
	// appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: host is connected to a network, and appears to
	// be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NetworkConnectivity.
func (n NetworkConnectivity) String() string {
	switch n {
	case NetworkConnectivityLocal:
		return "Local"
	case NetworkConnectivityLimited:
		return "Limited"
	case NetworkConnectivityPortal:
		return "Portal"
	case NetworkConnectivityFull:
		return "Full"
	default:
		return fmt.Sprintf("NetworkConnectivity(%d)", n)
	}
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority C.gint

const (
	// NotificationPriorityNormal: default priority, to be used for the majority
	// of notifications (for example email messages, software updates, completed
	// download/sync operations).
	NotificationPriorityNormal NotificationPriority = iota
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather.
	NotificationPriorityLow
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms).
	NotificationPriorityHigh
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings).
	NotificationPriorityUrgent
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NotificationPriority.
func (n NotificationPriority) String() string {
	switch n {
	case NotificationPriorityNormal:
		return "Normal"
	case NotificationPriorityLow:
		return "Low"
	case NotificationPriorityHigh:
		return "High"
	case NotificationPriorityUrgent:
		return "Urgent"
	default:
		return fmt.Sprintf("NotificationPriority(%d)", n)
	}
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to,
// and later retrieves it again from there.
type PasswordSave C.gint

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = iota
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PasswordSave.
func (p PasswordSave) String() string {
	switch p {
	case PasswordSaveNever:
		return "Never"
	case PasswordSaveForSession:
		return "ForSession"
	case PasswordSavePermanently:
		return "Permanently"
	default:
		return fmt.Sprintf("PasswordSave(%d)", p)
	}
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn C.gint

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOK: operation was successfully finished.
	PollableReturnOK PollableReturn = 1
	// PollableReturnWouldBlock: operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PollableReturn.
func (p PollableReturn) String() string {
	switch p {
	case PollableReturnFailed:
		return "Failed"
	case PollableReturnOK:
		return "OK"
	case PollableReturnWouldBlock:
		return "WouldBlock"
	default:
		return fmt.Sprintf("PollableReturn(%d)", p)
	}
}

// ResolverError: error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError C.gint

const (
	// ResolverErrorNotFound: requested name/address/service was not found.
	ResolverErrorNotFound ResolverError = iota
	// ResolverErrorTemporaryFailure: requested information could not be looked
	// up due to a network error or similar problem.
	ResolverErrorTemporaryFailure
	// ResolverErrorInternal: unknown error.
	ResolverErrorInternal
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResolverError.
func (r ResolverError) String() string {
	switch r {
	case ResolverErrorNotFound:
		return "NotFound"
	case ResolverErrorTemporaryFailure:
		return "TemporaryFailure"
	case ResolverErrorInternal:
		return "Internal"
	default:
		return fmt.Sprintf("ResolverError(%d)", r)
	}
}

// ResolverErrorQuark gets the #GResolver Error Quark.
//
// The function returns the following values:
//
//   - quark: #GQuark.
func ResolverErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_resolver_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// ResolverRecordType: type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// (qqqs), containing a guint16 with the priority, a guint16 with the weight,
// a guint16 with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// (qs), representing a guint16 with the preference, and a string containing the
// mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the
// signature (as), representing an array of the strings in the text
// record. Note: Most TXT records only contain a single string,
// but RFC 1035 (https://tools.ietf.org/html/rfc1035#section-3.3.14)
// does allow a record to contain multiple strings. The RFC which defines
// the interpretation of a specific TXT record will likely require
// concatenation of multiple strings if they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// (ssuuuuu), representing a string containing the primary name server,
// a string containing the administrator, the serial as a guint32, the refresh
// interval as a guint32, the retry interval as a guint32, the expire timeout as
// a guint32, and the TTL as a guint32.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature (s),
// representing a string of the hostname of the name server.
type ResolverRecordType C.gint

const (
	// ResolverRecordSrv: look up DNS SRV records for a domain.
	ResolverRecordSrv ResolverRecordType = 1
	// ResolverRecordMx: look up DNS MX records for a domain.
	ResolverRecordMx ResolverRecordType = 2
	// ResolverRecordTxt: look up DNS TXT records for a name.
	ResolverRecordTxt ResolverRecordType = 3
	// ResolverRecordSoa: look up DNS SOA records for a zone.
	ResolverRecordSoa ResolverRecordType = 4
	// ResolverRecordNs: look up DNS NS records for a domain.
	ResolverRecordNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResolverRecordType.
func (r ResolverRecordType) String() string {
	switch r {
	case ResolverRecordSrv:
		return "Srv"
	case ResolverRecordMx:
		return "Mx"
	case ResolverRecordTxt:
		return "Txt"
	case ResolverRecordSoa:
		return "Soa"
	case ResolverRecordNs:
		return "Ns"
	default:
		return fmt.Sprintf("ResolverRecordType(%d)", r)
	}
}

// ResourceError: error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError C.gint

const (
	// ResourceErrorNotFound: no file was found at the requested path.
	ResourceErrorNotFound ResourceError = iota
	// ResourceErrorInternal: unknown error.
	ResourceErrorInternal
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResourceError.
func (r ResourceError) String() string {
	switch r {
	case ResourceErrorNotFound:
		return "NotFound"
	case ResourceErrorInternal:
		return "Internal"
	default:
		return fmt.Sprintf("ResourceError(%d)", r)
	}
}

// ResourceErrorQuark gets the #GResource Error Quark.
//
// The function returns the following values:
//
//   - quark: #GQuark.
func ResourceErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_resource_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent C.gint

const (
	// SocketClientResolving: client is doing a DNS lookup.
	SocketClientResolving SocketClientEvent = iota
	// SocketClientResolved: client has completed a DNS lookup.
	SocketClientResolved
	// SocketClientConnecting: client is connecting to a remote host (either a
	// proxy or the destination server).
	SocketClientConnecting
	// SocketClientConnected: client has connected to a remote host.
	SocketClientConnected
	// SocketClientProxyNegotiating: client is negotiating with a proxy to
	// connect to the destination server.
	SocketClientProxyNegotiating
	// SocketClientProxyNegotiated: client has negotiated with the proxy server.
	SocketClientProxyNegotiated
	// SocketClientTLSHandshaking: client is performing a TLS handshake.
	SocketClientTLSHandshaking
	// SocketClientTLSHandshaked: client has performed a TLS handshake.
	SocketClientTLSHandshaked
	// SocketClientComplete: client is done with a particular Connectable.
	SocketClientComplete
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketClientEvent.
func (s SocketClientEvent) String() string {
	switch s {
	case SocketClientResolving:
		return "Resolving"
	case SocketClientResolved:
		return "Resolved"
	case SocketClientConnecting:
		return "Connecting"
	case SocketClientConnected:
		return "Connected"
	case SocketClientProxyNegotiating:
		return "ProxyNegotiating"
	case SocketClientProxyNegotiated:
		return "ProxyNegotiated"
	case SocketClientTLSHandshaking:
		return "TLSHandshaking"
	case SocketClientTLSHandshaked:
		return "TLSHandshaked"
	case SocketClientComplete:
		return "Complete"
	default:
		return fmt.Sprintf("SocketClientEvent(%d)", s)
	}
}

// SocketFamily: protocol family of a Address. (These values are identical to
// the system defines AF_INET, AF_INET6 and AF_UNIX, if available.).
type SocketFamily C.gint

const (
	// SocketFamilyInvalid: no address family.
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: UNIX domain family.
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIPv4: IPv4 family.
	SocketFamilyIPv4 SocketFamily = 2
	// SocketFamilyIPv6: IPv6 family.
	SocketFamilyIPv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketFamily.
func (s SocketFamily) String() string {
	switch s {
	case SocketFamilyInvalid:
		return "Invalid"
	case SocketFamilyUnix:
		return "Unix"
	case SocketFamilyIPv4:
		return "IPv4"
	case SocketFamilyIPv6:
		return "IPv6"
	default:
		return fmt.Sprintf("SocketFamily(%d)", s)
	}
}

// SocketListenerEvent describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent C.gint

const (
	// SocketListenerBinding: listener is about to bind a socket.
	SocketListenerBinding SocketListenerEvent = iota
	// SocketListenerBound: listener has bound a socket.
	SocketListenerBound
	// SocketListenerListening: listener is about to start listening on this
	// socket.
	SocketListenerListening
	// SocketListenerListened: listener is now listening on this socket.
	SocketListenerListened
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketListenerEvent.
func (s SocketListenerEvent) String() string {
	switch s {
	case SocketListenerBinding:
		return "Binding"
	case SocketListenerBound:
		return "Bound"
	case SocketListenerListening:
		return "Listening"
	case SocketListenerListened:
		return "Listened"
	default:
		return fmt.Sprintf("SocketListenerEvent(%d)", s)
	}
}

// SocketProtocol: protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol C.gint

const (
	// SocketProtocolUnknown: protocol type is unknown.
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: default protocol for the family/type.
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTCP: TCP over IP.
	SocketProtocolTCP SocketProtocol = 6
	// SocketProtocolUDP: UDP over IP.
	SocketProtocolUDP SocketProtocol = 17
	// SocketProtocolSCTP: SCTP over IP.
	SocketProtocolSCTP SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketProtocol.
func (s SocketProtocol) String() string {
	switch s {
	case SocketProtocolUnknown:
		return "Unknown"
	case SocketProtocolDefault:
		return "Default"
	case SocketProtocolTCP:
		return "TCP"
	case SocketProtocolUDP:
		return "UDP"
	case SocketProtocolSCTP:
		return "SCTP"
	default:
		return fmt.Sprintf("SocketProtocol(%d)", s)
	}
}

// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType C.gint

const (
	// SocketTypeInvalid: type unknown or wrong.
	SocketTypeInvalid SocketType = iota
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP).
	SocketTypeDatagram
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketType.
func (s SocketType) String() string {
	switch s {
	case SocketTypeInvalid:
		return "Invalid"
	case SocketTypeStream:
		return "Stream"
	case SocketTypeDatagram:
		return "Datagram"
	case SocketTypeSeqpacket:
		return "Seqpacket"
	default:
		return fmt.Sprintf("SocketType(%d)", s)
	}
}

// TLSAuthenticationMode: client authentication mode for a ServerConnection.
type TLSAuthenticationMode C.gint

const (
	// TLSAuthenticationNone: client authentication not required.
	TLSAuthenticationNone TLSAuthenticationMode = iota
	// TLSAuthenticationRequested: client authentication is requested.
	TLSAuthenticationRequested
	// TLSAuthenticationRequired: client authentication is required.
	TLSAuthenticationRequired
)

func marshalTLSAuthenticationMode(p uintptr) (interface{}, error) {
	return TLSAuthenticationMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSAuthenticationMode.
func (t TLSAuthenticationMode) String() string {
	switch t {
	case TLSAuthenticationNone:
		return "None"
	case TLSAuthenticationRequested:
		return "Requested"
	case TLSAuthenticationRequired:
		return "Required"
	default:
		return fmt.Sprintf("TLSAuthenticationMode(%d)", t)
	}
}

// TLSCertificateRequestFlags flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TLSCertificateRequestFlags C.gint

const (
	// TLSCertificateRequestNone: no flags.
	TLSCertificateRequestNone TLSCertificateRequestFlags = iota
)

func marshalTLSCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TLSCertificateRequestFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSCertificateRequestFlags.
func (t TLSCertificateRequestFlags) String() string {
	switch t {
	case TLSCertificateRequestNone:
		return "None"
	default:
		return fmt.Sprintf("TLSCertificateRequestFlags(%d)", t)
	}
}

// TLSChannelBindingError: error code used with G_TLS_CHANNEL_BINDING_ERROR in a
// #GError to indicate a TLS channel binding retrieval error.
type TLSChannelBindingError C.gint

const (
	// TLSChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TLSChannelBindingErrorNotImplemented TLSChannelBindingError = iota
	// TLSChannelBindingErrorInvalidState: handshake is not yet complete on the
	// connection which is a strong requirement for any existing binding type.
	TLSChannelBindingErrorInvalidState
	// TLSChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TLSChannelBindingErrorNotAvailable
	// TLSChannelBindingErrorNotSupported: binding type is not supported on
	// the current connection. This error could be triggered when requesting
	// tls-server-end-point binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TLSChannelBindingErrorNotSupported
	// TLSChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TLSChannelBindingErrorGeneralError
)

func marshalTLSChannelBindingError(p uintptr) (interface{}, error) {
	return TLSChannelBindingError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSChannelBindingError.
func (t TLSChannelBindingError) String() string {
	switch t {
	case TLSChannelBindingErrorNotImplemented:
		return "NotImplemented"
	case TLSChannelBindingErrorInvalidState:
		return "InvalidState"
	case TLSChannelBindingErrorNotAvailable:
		return "NotAvailable"
	case TLSChannelBindingErrorNotSupported:
		return "NotSupported"
	case TLSChannelBindingErrorGeneralError:
		return "GeneralError"
	default:
		return fmt.Sprintf("TLSChannelBindingError(%d)", t)
	}
}

// TLSChannelBindingErrorQuark gets the TLS channel binding error quark.
//
// The function returns the following values:
//
//   - quark: #GQuark.
func TLSChannelBindingErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_tls_channel_binding_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// TLSChannelBindingType: type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929 or RFC 9266. The
// tls-unique-for-telnet (https://tools.ietf.org/html/rfc5929#section-5) binding
// type is not currently implemented.
type TLSChannelBindingType C.gint

const (
	// TLSChannelBindingTLSUnique: tls-unique
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type.
	TLSChannelBindingTLSUnique TLSChannelBindingType = iota
	// TLSChannelBindingTLSServerEndPoint: tls-server-end-point
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type.
	TLSChannelBindingTLSServerEndPoint
	// TLSChannelBindingTLSExporter: tls-exporter
	// (https://www.rfc-editor.org/rfc/rfc9266.html) binding type. Since: 2.74.
	TLSChannelBindingTLSExporter
)

func marshalTLSChannelBindingType(p uintptr) (interface{}, error) {
	return TLSChannelBindingType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSChannelBindingType.
func (t TLSChannelBindingType) String() string {
	switch t {
	case TLSChannelBindingTLSUnique:
		return "Unique"
	case TLSChannelBindingTLSServerEndPoint:
		return "ServerEndPoint"
	case TLSChannelBindingTLSExporter:
		return "Exporter"
	default:
		return fmt.Sprintf("TLSChannelBindingType(%d)", t)
	}
}

// TLSDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TLSDatabaseLookupFlags C.gint

const (
	// TLSDatabaseLookupNone: no lookup flags.
	TLSDatabaseLookupNone TLSDatabaseLookupFlags = iota
	// TLSDatabaseLookupKeypair: restrict lookup to certificates that have a
	// private key.
	TLSDatabaseLookupKeypair
)

func marshalTLSDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSDatabaseLookupFlags.
func (t TLSDatabaseLookupFlags) String() string {
	switch t {
	case TLSDatabaseLookupNone:
		return "None"
	case TLSDatabaseLookupKeypair:
		return "Keypair"
	default:
		return fmt.Sprintf("TLSDatabaseLookupFlags(%d)", t)
	}
}

// TLSError: error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TLSError C.gint

const (
	// TLSErrorUnavailable: no TLS provider is available.
	TLSErrorUnavailable TLSError = iota
	// TLSErrorMisc miscellaneous TLS error.
	TLSErrorMisc
	// TLSErrorBadCertificate: certificate presented could not be parsed or
	// failed validation.
	TLSErrorBadCertificate
	// TLSErrorNotTLS: TLS handshake failed because the peer does not seem to be
	// a TLS server.
	TLSErrorNotTLS
	// TLSErrorHandshake: TLS handshake failed because the peer's certificate
	// was not acceptable.
	TLSErrorHandshake
	// TLSErrorCertificateRequired: TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TLSErrorCertificateRequired
	// TLSErrorEOF: TLS connection was closed without proper notice, which may
	// indicate an attack. See g_tls_connection_set_require_close_notify().
	TLSErrorEOF
	// TLSErrorInappropriateFallback: TLS handshake failed because the client
	// sent the fallback SCSV, indicating a protocol downgrade attack. Since:
	// 2.60.
	TLSErrorInappropriateFallback
	// TLSErrorBadCertificatePassword: certificate failed to load because a
	// password was incorrect. Since: 2.72.
	TLSErrorBadCertificatePassword
)

func marshalTLSError(p uintptr) (interface{}, error) {
	return TLSError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSError.
func (t TLSError) String() string {
	switch t {
	case TLSErrorUnavailable:
		return "Unavailable"
	case TLSErrorMisc:
		return "Misc"
	case TLSErrorBadCertificate:
		return "BadCertificate"
	case TLSErrorNotTLS:
		return "NotTLS"
	case TLSErrorHandshake:
		return "Handshake"
	case TLSErrorCertificateRequired:
		return "CertificateRequired"
	case TLSErrorEOF:
		return "EOF"
	case TLSErrorInappropriateFallback:
		return "InappropriateFallback"
	case TLSErrorBadCertificatePassword:
		return "BadCertificatePassword"
	default:
		return fmt.Sprintf("TLSError(%d)", t)
	}
}

// TLSErrorQuark gets the TLS error quark.
//
// The function returns the following values:
//
//   - quark: #GQuark.
func TLSErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_tls_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// TLSInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TLSInteractionResult C.gint

const (
	// TLSInteractionUnhandled: interaction was unhandled (i.e. not
	// implemented).
	TLSInteractionUnhandled TLSInteractionResult = iota
	// TLSInteractionHandled: interaction completed, and resulting data is
	// available.
	TLSInteractionHandled
	// TLSInteractionFailed: interaction has failed, or was cancelled. and the
	// operation should be aborted.
	TLSInteractionFailed
)

func marshalTLSInteractionResult(p uintptr) (interface{}, error) {
	return TLSInteractionResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSInteractionResult.
func (t TLSInteractionResult) String() string {
	switch t {
	case TLSInteractionUnhandled:
		return "Unhandled"
	case TLSInteractionHandled:
		return "Handled"
	case TLSInteractionFailed:
		return "Failed"
	default:
		return fmt.Sprintf("TLSInteractionResult(%d)", t)
	}
}

// TLSProtocolVersion: TLS or DTLS protocol version used by a Connection or
// Connection. The integer values of these versions are sequential to ensure
// newer known protocol versions compare greater than older known versions. Any
// known DTLS protocol version will compare greater than any SSL or TLS protocol
// version. The protocol version may be G_TLS_PROTOCOL_VERSION_UNKNOWN if the
// TLS backend supports a newer protocol version that GLib does not yet know
// about. This means that it's possible for an unknown DTLS protocol version to
// compare less than the TLS protocol versions.
type TLSProtocolVersion C.gint

const (
	// TLSProtocolVersionUnknown: no protocol version or unknown protocol
	// version.
	TLSProtocolVersionUnknown TLSProtocolVersion = 0
	// TLSProtocolVersionSSL30: SSL 3.0, which is insecure and should not be
	// used.
	TLSProtocolVersionSSL30 TLSProtocolVersion = 1
	// TLSProtocolVersionTLS10: TLS 1.0, which is insecure and should not be
	// used.
	TLSProtocolVersionTLS10 TLSProtocolVersion = 2
	// TLSProtocolVersionTLS11: TLS 1.1, which is insecure and should not be
	// used.
	TLSProtocolVersionTLS11 TLSProtocolVersion = 3
	// TLSProtocolVersionTLS12: TLS 1.2, defined by RFC 5246
	// (https://datatracker.ietf.org/doc/html/rfc5246).
	TLSProtocolVersionTLS12 TLSProtocolVersion = 4
	// TLSProtocolVersionTLS13: TLS 1.3, defined by RFC 8446
	// (https://datatracker.ietf.org/doc/html/rfc8446).
	TLSProtocolVersionTLS13 TLSProtocolVersion = 5
	// TLSProtocolVersionDTLS10: DTLS 1.0, which is insecure and should not be
	// used.
	TLSProtocolVersionDTLS10 TLSProtocolVersion = 201
	// TLSProtocolVersionDTLS12: DTLS 1.2, defined by RFC 6347
	// (https://datatracker.ietf.org/doc/html/rfc6347).
	TLSProtocolVersionDTLS12 TLSProtocolVersion = 202
)

func marshalTLSProtocolVersion(p uintptr) (interface{}, error) {
	return TLSProtocolVersion(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSProtocolVersion.
func (t TLSProtocolVersion) String() string {
	switch t {
	case TLSProtocolVersionUnknown:
		return "Unknown"
	case TLSProtocolVersionSSL30:
		return "SSL30"
	case TLSProtocolVersionTLS10:
		return "TLS10"
	case TLSProtocolVersionTLS11:
		return "TLS11"
	case TLSProtocolVersionTLS12:
		return "TLS12"
	case TLSProtocolVersionTLS13:
		return "TLS13"
	case TLSProtocolVersionDTLS10:
		return "DTLS10"
	case TLSProtocolVersionDTLS12:
		return "DTLS12"
	default:
		return fmt.Sprintf("TLSProtocolVersion(%d)", t)
	}
}

// TLSRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
//
// Deprecated: Changing the rehandshake mode is no longer required for
// compatibility. Also, rehandshaking has been removed from the TLS protocol in
// TLS 1.3.
type TLSRehandshakeMode C.gint

const (
	// TLSRehandshakeNever: never allow rehandshaking.
	TLSRehandshakeNever TLSRehandshakeMode = iota
	// TLSRehandshakeSafely: allow safe rehandshaking only.
	TLSRehandshakeSafely
	// TLSRehandshakeUnsafely: allow unsafe rehandshaking.
	TLSRehandshakeUnsafely
)

func marshalTLSRehandshakeMode(p uintptr) (interface{}, error) {
	return TLSRehandshakeMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSRehandshakeMode.
func (t TLSRehandshakeMode) String() string {
	switch t {
	case TLSRehandshakeNever:
		return "Never"
	case TLSRehandshakeSafely:
		return "Safely"
	case TLSRehandshakeUnsafely:
		return "Unsafely"
	default:
		return fmt.Sprintf("TLSRehandshakeMode(%d)", t)
	}
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat C.gint

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header.
	ZlibCompressorFormatZlib ZlibCompressorFormat = iota
	// ZlibCompressorFormatGzip: gzip file format.
	ZlibCompressorFormatGzip
	// ZlibCompressorFormatRaw: deflate compression with no header.
	ZlibCompressorFormatRaw
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ZlibCompressorFormat.
func (z ZlibCompressorFormat) String() string {
	switch z {
	case ZlibCompressorFormatZlib:
		return "Zlib"
	case ZlibCompressorFormatGzip:
		return "Gzip"
	case ZlibCompressorFormatRaw:
		return "Raw"
	default:
		return fmt.Sprintf("ZlibCompressorFormat(%d)", z)
	}
}

// AppInfoCreateFlags flags used when creating a Info.
type AppInfoCreateFlags C.guint

const (
	// AppInfoCreateNone: no flags.
	AppInfoCreateNone AppInfoCreateFlags = 0b0
	// AppInfoCreateNeedsTerminal: application opens in a terminal window.
	AppInfoCreateNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateSupportsURIs: application supports URI arguments.
	AppInfoCreateSupportsURIs AppInfoCreateFlags = 0b10
	// AppInfoCreateSupportsStartupNotification: application supports startup
	// notification. Since 2.26.
	AppInfoCreateSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AppInfoCreateFlags.
func (a AppInfoCreateFlags) String() string {
	if a == 0 {
		return "AppInfoCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(111)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AppInfoCreateNone:
			builder.WriteString("None|")
		case AppInfoCreateNeedsTerminal:
			builder.WriteString("NeedsTerminal|")
		case AppInfoCreateSupportsURIs:
			builder.WriteString("SupportsURIs|")
		case AppInfoCreateSupportsStartupNotification:
			builder.WriteString("SupportsStartupNotification|")
		default:
			builder.WriteString(fmt.Sprintf("AppInfoCreateFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AppInfoCreateFlags) Has(other AppInfoCreateFlags) bool {
	return (a & other) == other
}

// ApplicationFlags flags used to define the behaviour of a #GApplication.
type ApplicationFlags C.guint

const (
	// ApplicationFlagsNone: default. Deprecated in 2.74, use
	// G_APPLICATION_DEFAULT_FLAGS instead.
	ApplicationFlagsNone ApplicationFlags = 0b0
	// ApplicationDefaultFlags: default flags. Since: 2.74.
	ApplicationDefaultFlags ApplicationFlags = 0b0
	// ApplicationIsService: run as a service. In this mode, registration fails
	// if the service is already running, and the application will initially
	// wait up to 10 seconds for an initial activation message to arrive.
	ApplicationIsService ApplicationFlags = 0b1
	// ApplicationIsLauncher: don't try to become the primary instance.
	ApplicationIsLauncher ApplicationFlags = 0b10
	// ApplicationHandlesOpen: this application handles opening files
	// (in the primary instance). Note that this flag only affects the
	// default implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationHandlesOpen ApplicationFlags = 0b100
	// ApplicationHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationSendEnvironment: send the environment of the launching process
	// to the primary instance. Set this flag if your application is expected
	// to behave differently depending on certain environment variables.
	// For instance, an editor might be expected to use the GIT_COMMITTER_NAME
	// environment variable when editing a git commit message. The environment
	// is available to the #GApplication::command-line signal handler,
	// via g_application_command_line_getenv().
	ApplicationSendEnvironment ApplicationFlags = 0b10000
	// ApplicationNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID
	// is given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationNonUnique ApplicationFlags = 0b100000
	// ApplicationCanOverrideAppID: allow users to override the application ID
	// from the command line with --gapplication-app-id. Since: 2.48.
	ApplicationCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationAllowReplacement: allow another instance to take over the bus
	// name. Since: 2.60.
	ApplicationAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationReplace: take over from another instance. This flag is usually
	// set by passing --gapplication-replace on the commandline. Since: 2.60.
	ApplicationReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ApplicationFlags.
func (a ApplicationFlags) String() string {
	if a == 0 {
		return "ApplicationFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case ApplicationFlagsNone:
			builder.WriteString("FlagsNone|")
		case ApplicationIsService:
			builder.WriteString("IsService|")
		case ApplicationIsLauncher:
			builder.WriteString("IsLauncher|")
		case ApplicationHandlesOpen:
			builder.WriteString("HandlesOpen|")
		case ApplicationHandlesCommandLine:
			builder.WriteString("HandlesCommandLine|")
		case ApplicationSendEnvironment:
			builder.WriteString("SendEnvironment|")
		case ApplicationNonUnique:
			builder.WriteString("NonUnique|")
		case ApplicationCanOverrideAppID:
			builder.WriteString("CanOverrideAppID|")
		case ApplicationAllowReplacement:
			builder.WriteString("AllowReplacement|")
		case ApplicationReplace:
			builder.WriteString("Replace|")
		default:
			builder.WriteString(fmt.Sprintf("ApplicationFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a ApplicationFlags) Has(other ApplicationFlags) bool {
	return (a & other) == other
}

// AskPasswordFlags are used to request specific information from the user,
// or to notify the user of their choices in an authentication situation.
type AskPasswordFlags C.guint

const (
	// AskPasswordNeedPassword: operation requires a password.
	AskPasswordNeedPassword AskPasswordFlags = 0b1
	// AskPasswordNeedUsername: operation requires a username.
	AskPasswordNeedUsername AskPasswordFlags = 0b10
	// AskPasswordNeedDomain: operation requires a domain.
	AskPasswordNeedDomain AskPasswordFlags = 0b100
	// AskPasswordSavingSupported: operation supports saving settings.
	AskPasswordSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordAnonymousSupported: operation supports anonymous users.
	AskPasswordAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordTcrypt: operation takes TCRYPT parameters (Since: 2.58).
	AskPasswordTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AskPasswordFlags.
func (a AskPasswordFlags) String() string {
	if a == 0 {
		return "AskPasswordFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(144)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AskPasswordNeedPassword:
			builder.WriteString("NeedPassword|")
		case AskPasswordNeedUsername:
			builder.WriteString("NeedUsername|")
		case AskPasswordNeedDomain:
			builder.WriteString("NeedDomain|")
		case AskPasswordSavingSupported:
			builder.WriteString("SavingSupported|")
		case AskPasswordAnonymousSupported:
			builder.WriteString("AnonymousSupported|")
		case AskPasswordTcrypt:
			builder.WriteString("Tcrypt|")
		default:
			builder.WriteString(fmt.Sprintf("AskPasswordFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AskPasswordFlags) Has(other AskPasswordFlags) bool {
	return (a & other) == other
}

// BusNameOwnerFlags flags used in g_bus_own_name().
type BusNameOwnerFlags C.guint

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take
	// the name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns
	// the name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54).
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusNameOwnerFlags.
func (b BusNameOwnerFlags) String() string {
	if b == 0 {
		return "BusNameOwnerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(108)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusNameOwnerFlagsNone:
			builder.WriteString("None|")
		case BusNameOwnerFlagsAllowReplacement:
			builder.WriteString("AllowReplacement|")
		case BusNameOwnerFlagsReplace:
			builder.WriteString("Replace|")
		case BusNameOwnerFlagsDoNotQueue:
			builder.WriteString("DoNotQueue|")
		default:
			builder.WriteString(fmt.Sprintf("BusNameOwnerFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusNameOwnerFlags) Has(other BusNameOwnerFlags) bool {
	return (b & other) == other
}

// BusNameWatcherFlags flags used in g_bus_watch_name().
type BusNameWatcherFlags C.guint

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusNameWatcherFlags.
func (b BusNameWatcherFlags) String() string {
	if b == 0 {
		return "BusNameWatcherFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(52)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusNameWatcherFlagsNone:
			builder.WriteString("None|")
		case BusNameWatcherFlagsAutoStart:
			builder.WriteString("AutoStart|")
		default:
			builder.WriteString(fmt.Sprintf("BusNameWatcherFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusNameWatcherFlags) Has(other BusNameWatcherFlags) bool {
	return (b & other) == other
}

// ConverterFlags flags used when calling a g_converter_convert().
type ConverterFlags C.guint

const (
	// ConverterNoFlags: no flags.
	ConverterNoFlags ConverterFlags = 0b0
	// ConverterInputAtEnd: at end of input data.
	ConverterInputAtEnd ConverterFlags = 0b1
	// ConverterFlush: flush data.
	ConverterFlush ConverterFlags = 0b10
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ConverterFlags.
func (c ConverterFlags) String() string {
	if c == 0 {
		return "ConverterFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(51)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case ConverterNoFlags:
			builder.WriteString("None|")
		case ConverterInputAtEnd:
			builder.WriteString("InputAtEnd|")
		case ConverterFlush:
			builder.WriteString("Flush|")
		default:
			builder.WriteString(fmt.Sprintf("ConverterFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c ConverterFlags) Has(other ConverterFlags) bool {
	return (c & other) == other
}

// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags C.guint

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart bus must not launch an owner for the destination
	// name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: caller is prepared to wait
	// for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusCallFlags.
func (d DBusCallFlags) String() string {
	if d == 0 {
		return "DBusCallFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusCallFlagsNone:
			builder.WriteString("None|")
		case DBusCallFlagsNoAutoStart:
			builder.WriteString("NoAutoStart|")
		case DBusCallFlagsAllowInteractiveAuthorization:
			builder.WriteString("AllowInteractiveAuthorization|")
		default:
			builder.WriteString(fmt.Sprintf("DBusCallFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusCallFlags) Has(other DBusCallFlags) bool {
	return (d & other) == other
}

// DBusCapabilityFlags capabilities negotiated with the remote peer.
type DBusCapabilityFlags C.guint

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing connection supports exchanging UNIX file
	// descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusCapabilityFlags.
func (d DBusCapabilityFlags) String() string {
	if d == 0 {
		return "DBusCapabilityFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(56)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusCapabilityFlagsNone:
			builder.WriteString("None|")
		case DBusCapabilityFlagsUnixFdPassing:
			builder.WriteString("UnixFdPassing|")
		default:
			builder.WriteString(fmt.Sprintf("DBusCapabilityFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusCapabilityFlags) Has(other DBusCapabilityFlags) bool {
	return (d & other) == other
}

// DBusConnectionFlags flags used when creating a new BusConnection.
type DBusConnectionFlags C.guint

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to
	// a peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
	// DBusConnectionFlagsAuthenticationRequireSameUser: when authenticating as
	// a server, require the UID of the peer to be the same as the UID of the
	// server. (Since: 2.68).
	DBusConnectionFlagsAuthenticationRequireSameUser DBusConnectionFlags = 0b100000
	// DBusConnectionFlagsCrossNamespace: when authenticating, try to use
	// protocols that work across a Linux user namespace boundary, even if this
	// reduces interoperability with older D-Bus implementations. This currently
	// affects client-side EXTERNAL authentication, for which this flag makes
	// connections to a server in another user namespace succeed, but causes
	// a deadlock when connecting to a GDBus server older than 2.73.3. Since:
	// 2.74.
	DBusConnectionFlagsCrossNamespace DBusConnectionFlags = 0b1000000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusConnectionFlags.
func (d DBusConnectionFlags) String() string {
	if d == 0 {
		return "DBusConnectionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusConnectionFlagsNone:
			builder.WriteString("None|")
		case DBusConnectionFlagsAuthenticationClient:
			builder.WriteString("AuthenticationClient|")
		case DBusConnectionFlagsAuthenticationServer:
			builder.WriteString("AuthenticationServer|")
		case DBusConnectionFlagsAuthenticationAllowAnonymous:
			builder.WriteString("AuthenticationAllowAnonymous|")
		case DBusConnectionFlagsMessageBusConnection:
			builder.WriteString("MessageBusConnection|")
		case DBusConnectionFlagsDelayMessageProcessing:
			builder.WriteString("DelayMessageProcessing|")
		case DBusConnectionFlagsAuthenticationRequireSameUser:
			builder.WriteString("AuthenticationRequireSameUser|")
		case DBusConnectionFlagsCrossNamespace:
			builder.WriteString("CrossNamespace|")
		default:
			builder.WriteString(fmt.Sprintf("DBusConnectionFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusConnectionFlags) Has(other DBusConnectionFlags) bool {
	return (d & other) == other
}

// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags C.guint

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusInterfaceSkeletonFlags.
func (d DBusInterfaceSkeletonFlags) String() string {
	if d == 0 {
		return "DBusInterfaceSkeletonFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(88)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusInterfaceSkeletonFlagsNone:
			builder.WriteString("None|")
		case DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread:
			builder.WriteString("HandleMethodInvocationsInThread|")
		default:
			builder.WriteString(fmt.Sprintf("DBusInterfaceSkeletonFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusInterfaceSkeletonFlags) Has(other DBusInterfaceSkeletonFlags) bool {
	return (d & other) == other
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags C.guint

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusMessageFlags.
func (d DBusMessageFlags) String() string {
	if d == 0 {
		return "DBusMessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(126)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusMessageFlagsNone:
			builder.WriteString("None|")
		case DBusMessageFlagsNoReplyExpected:
			builder.WriteString("NoReplyExpected|")
		case DBusMessageFlagsNoAutoStart:
			builder.WriteString("NoAutoStart|")
		case DBusMessageFlagsAllowInteractiveAuthorization:
			builder.WriteString("AllowInteractiveAuthorization|")
		default:
			builder.WriteString(fmt.Sprintf("DBusMessageFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusMessageFlags) Has(other DBusMessageFlags) bool {
	return (d & other) == other
}

// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags C.guint

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager
	// is for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusObjectManagerClientFlags.
func (d DBusObjectManagerClientFlags) String() string {
	if d == 0 {
		return "DBusObjectManagerClientFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(75)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusObjectManagerClientFlagsNone:
			builder.WriteString("None|")
		case DBusObjectManagerClientFlagsDoNotAutoStart:
			builder.WriteString("DoNotAutoStart|")
		default:
			builder.WriteString(fmt.Sprintf("DBusObjectManagerClientFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusObjectManagerClientFlags) Has(other DBusObjectManagerClientFlags) bool {
	return (d & other) == other
}

// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags C.guint

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusPropertyInfoFlags.
func (d DBusPropertyInfoFlags) String() string {
	if d == 0 {
		return "DBusPropertyInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusPropertyInfoFlagsNone:
			builder.WriteString("None|")
		case DBusPropertyInfoFlagsReadable:
			builder.WriteString("Readable|")
		case DBusPropertyInfoFlagsWritable:
			builder.WriteString("Writable|")
		default:
			builder.WriteString(fmt.Sprintf("DBusPropertyInfoFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusPropertyInfoFlags) Has(other DBusPropertyInfoFlags) bool {
	return (d & other) == other
}

// DBusProxyFlags flags used when constructing an instance of a BusProxy derived
// class.
type DBusProxyFlags C.guint

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name,
	// do not ask the bus to launch an owner during proxy initialization or
	// a method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set,
	// the property value for any __invalidated property__ will be
	// (asynchronously) retrieved upon receiving the PropertiesChanged
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call.
	// This flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
	// DBusProxyFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually). (Since: 2.72).
	DBusProxyFlagsNoMatchRule DBusProxyFlags = 0b100000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusProxyFlags.
func (d DBusProxyFlags) String() string {
	if d == 0 {
		return "DBusProxyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(223)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusProxyFlagsNone:
			builder.WriteString("None|")
		case DBusProxyFlagsDoNotLoadProperties:
			builder.WriteString("DoNotLoadProperties|")
		case DBusProxyFlagsDoNotConnectSignals:
			builder.WriteString("DoNotConnectSignals|")
		case DBusProxyFlagsDoNotAutoStart:
			builder.WriteString("DoNotAutoStart|")
		case DBusProxyFlagsGetInvalidatedProperties:
			builder.WriteString("GetInvalidatedProperties|")
		case DBusProxyFlagsDoNotAutoStartAtConstruction:
			builder.WriteString("DoNotAutoStartAtConstruction|")
		case DBusProxyFlagsNoMatchRule:
			builder.WriteString("NoMatchRule|")
		default:
			builder.WriteString(fmt.Sprintf("DBusProxyFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusProxyFlags) Has(other DBusProxyFlags) bool {
	return (d & other) == other
}

// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags C.guint

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSendMessageFlags.
func (d DBusSendMessageFlags) String() string {
	if d == 0 {
		return "DBusSendMessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSendMessageFlagsNone:
			builder.WriteString("None|")
		case DBusSendMessageFlagsPreserveSerial:
			builder.WriteString("PreserveSerial|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSendMessageFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSendMessageFlags) Has(other DBusSendMessageFlags) bool {
	return (d & other) == other
}

// DBusServerFlags flags used when creating a BusServer.
type DBusServerFlags C.guint

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
	// DBusServerFlagsAuthenticationRequireSameUser: require the UID of the
	// peer to be the same as the UID of the server when authenticating. (Since:
	// 2.68).
	DBusServerFlagsAuthenticationRequireSameUser DBusServerFlags = 0b100
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusServerFlags.
func (d DBusServerFlags) String() string {
	if d == 0 {
		return "DBusServerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(135)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusServerFlagsNone:
			builder.WriteString("None|")
		case DBusServerFlagsRunInThread:
			builder.WriteString("RunInThread|")
		case DBusServerFlagsAuthenticationAllowAnonymous:
			builder.WriteString("AuthenticationAllowAnonymous|")
		case DBusServerFlagsAuthenticationRequireSameUser:
			builder.WriteString("AuthenticationRequireSameUser|")
		default:
			builder.WriteString(fmt.Sprintf("DBusServerFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusServerFlags) Has(other DBusServerFlags) bool {
	return (d & other) == other
}

// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags C.guint

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSignalFlags.
func (d DBusSignalFlags) String() string {
	if d == 0 {
		return "DBusSignalFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(109)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSignalFlagsNone:
			builder.WriteString("None|")
		case DBusSignalFlagsNoMatchRule:
			builder.WriteString("NoMatchRule|")
		case DBusSignalFlagsMatchArg0Namespace:
			builder.WriteString("MatchArg0Namespace|")
		case DBusSignalFlagsMatchArg0Path:
			builder.WriteString("MatchArg0Path|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSignalFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSignalFlags) Has(other DBusSignalFlags) bool {
	return (d & other) == other
}

// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags C.guint

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSubtreeFlags.
func (d DBusSubtreeFlags) String() string {
	if d == 0 {
		return "DBusSubtreeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(64)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSubtreeFlagsNone:
			builder.WriteString("None|")
		case DBusSubtreeFlagsDispatchToUnenumeratedNodes:
			builder.WriteString("DispatchToUnenumeratedNodes|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSubtreeFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSubtreeFlags) Has(other DBusSubtreeFlags) bool {
	return (d & other) == other
}

// DriveStartFlags flags used when starting a drive.
type DriveStartFlags C.guint

const (
	// DriveStartNone: no flags set.
	DriveStartNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DriveStartFlags.
func (d DriveStartFlags) String() string {
	if d == 0 {
		return "DriveStartFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(14)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DriveStartNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("DriveStartFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DriveStartFlags) Has(other DriveStartFlags) bool {
	return (d & other) == other
}

// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags C.guint

const (
	// FileAttributeInfoNone: no flags set.
	FileAttributeInfoNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoCopyWithFile: copy the attribute values when the file is
	// copied.
	FileAttributeInfoCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoCopyWhenMoved: copy the attribute values when the file
	// is moved.
	FileAttributeInfoCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileAttributeInfoFlags.
func (f FileAttributeInfoFlags) String() string {
	if f == 0 {
		return "FileAttributeInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileAttributeInfoNone:
			builder.WriteString("None|")
		case FileAttributeInfoCopyWithFile:
			builder.WriteString("CopyWithFile|")
		case FileAttributeInfoCopyWhenMoved:
			builder.WriteString("CopyWhenMoved|")
		default:
			builder.WriteString(fmt.Sprintf("FileAttributeInfoFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileAttributeInfoFlags) Has(other FileAttributeInfoFlags) bool {
	return (f & other) == other
}

// FileCopyFlags flags used when copying or moving files.
type FileCopyFlags C.guint

const (
	// FileCopyNone: no flags set.
	FileCopyNone FileCopyFlags = 0b0
	// FileCopyOverwrite: overwrite any existing files.
	FileCopyOverwrite FileCopyFlags = 0b1
	// FileCopyBackup: make a backup of any existing files.
	FileCopyBackup FileCopyFlags = 0b10
	// FileCopyNofollowSymlinks: don't follow symlinks.
	FileCopyNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyAllMetadata: copy all file metadata instead of just default set
	// used for copy (see Info).
	FileCopyAllMetadata FileCopyFlags = 0b1000
	// FileCopyNoFallbackForMove: don't use copy and delete fallback if native
	// move not supported.
	FileCopyNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyTargetDefaultPerms leaves target file with default perms, instead
	// of setting the source file perms.
	FileCopyTargetDefaultPerms FileCopyFlags = 0b100000
	// FileCopyTargetDefaultModifiedTime: use default modification timestamps
	// instead of copying them from the source file. Since 2.80.
	FileCopyTargetDefaultModifiedTime FileCopyFlags = 0b1000000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileCopyFlags.
func (f FileCopyFlags) String() string {
	if f == 0 {
		return "FileCopyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(177)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileCopyNone:
			builder.WriteString("None|")
		case FileCopyOverwrite:
			builder.WriteString("Overwrite|")
		case FileCopyBackup:
			builder.WriteString("Backup|")
		case FileCopyNofollowSymlinks:
			builder.WriteString("NofollowSymlinks|")
		case FileCopyAllMetadata:
			builder.WriteString("AllMetadata|")
		case FileCopyNoFallbackForMove:
			builder.WriteString("NoFallbackForMove|")
		case FileCopyTargetDefaultPerms:
			builder.WriteString("TargetDefaultPerms|")
		case FileCopyTargetDefaultModifiedTime:
			builder.WriteString("TargetDefaultModifiedTime|")
		default:
			builder.WriteString(fmt.Sprintf("FileCopyFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileCopyFlags) Has(other FileCopyFlags) bool {
	return (f & other) == other
}

// FileCreateFlags flags used when an operation may create a file.
type FileCreateFlags C.guint

const (
	// FileCreateNone: no flags set.
	FileCreateNone FileCreateFlags = 0b0
	// FileCreatePrivate: create a file that can only be accessed by the current
	// user.
	FileCreatePrivate FileCreateFlags = 0b1
	// FileCreateReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing
	// a "copy over" rather than a "save new version of" replace operation.
	// You can think of it as "unlink destination" before writing to it,
	// although the implementation may not be exactly like that. This flag
	// can only be used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20.
	FileCreateReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileCreateFlags.
func (f FileCreateFlags) String() string {
	if f == 0 {
		return "FileCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(61)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileCreateNone:
			builder.WriteString("None|")
		case FileCreatePrivate:
			builder.WriteString("Private|")
		case FileCreateReplaceDestination:
			builder.WriteString("ReplaceDestination|")
		default:
			builder.WriteString(fmt.Sprintf("FileCreateFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileCreateFlags) Has(other FileCreateFlags) bool {
	return (f & other) == other
}

// FileMeasureFlags flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags C.guint

const (
	// FileMeasureNone: no flags set.
	FileMeasureNone FileMeasureFlags = 0b0
	// FileMeasureReportAnyError: report any error encountered while traversing
	// the directory tree. Normally errors are only reported for the toplevel
	// file.
	FileMeasureReportAnyError FileMeasureFlags = 0b10
	// FileMeasureApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a
	// more accurate representation of disk space used. Compare with du
	// --apparent-size. Since GLib 2.78. and similarly to du since GNU Coreutils
	// 9.2, this will ignore the sizes of file types other than regular files
	// and links, as the sizes of other file types are not specified in a
	// standard way.
	FileMeasureApparentSize FileMeasureFlags = 0b100
	// FileMeasureNoXdev: do not cross mount point boundaries. Compare with du
	// -x.
	FileMeasureNoXdev FileMeasureFlags = 0b1000
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileMeasureFlags.
func (f FileMeasureFlags) String() string {
	if f == 0 {
		return "FileMeasureFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(83)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileMeasureNone:
			builder.WriteString("None|")
		case FileMeasureReportAnyError:
			builder.WriteString("ReportAnyError|")
		case FileMeasureApparentSize:
			builder.WriteString("ApparentSize|")
		case FileMeasureNoXdev:
			builder.WriteString("NoXdev|")
		default:
			builder.WriteString(fmt.Sprintf("FileMeasureFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileMeasureFlags) Has(other FileMeasureFlags) bool {
	return (f & other) == other
}

// FileMonitorFlags flags used to set what a Monitor will watch for.
type FileMonitorFlags C.guint

const (
	// FileMonitorNone: no flags set.
	FileMonitorNone FileMonitorFlags = 0b0
	// FileMonitorWatchMounts: watch for mount events.
	FileMonitorWatchMounts FileMonitorFlags = 0b1
	// FileMonitorSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorSendMoved FileMonitorFlags = 0b10
	// FileMonitorWatchHardLinks: watch for changes to the file made via another
	// hard link. Since 2.36.
	FileMonitorWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorWatchMoves: watch for rename operations on a
	// monitored directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileMonitorFlags.
func (f FileMonitorFlags) String() string {
	if f == 0 {
		return "FileMonitorFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(107)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileMonitorNone:
			builder.WriteString("None|")
		case FileMonitorWatchMounts:
			builder.WriteString("WatchMounts|")
		case FileMonitorSendMoved:
			builder.WriteString("SendMoved|")
		case FileMonitorWatchHardLinks:
			builder.WriteString("WatchHardLinks|")
		case FileMonitorWatchMoves:
			builder.WriteString("WatchMoves|")
		default:
			builder.WriteString(fmt.Sprintf("FileMonitorFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileMonitorFlags) Has(other FileMonitorFlags) bool {
	return (f & other) == other
}

// FileQueryInfoFlags flags used when querying a Info.
type FileQueryInfoFlags C.guint

const (
	// FileQueryInfoNone: no flags set.
	FileQueryInfoNone FileQueryInfoFlags = 0b0
	// FileQueryInfoNofollowSymlinks: don't follow symlinks.
	FileQueryInfoNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileQueryInfoFlags.
func (f FileQueryInfoFlags) String() string {
	if f == 0 {
		return "FileQueryInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(47)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileQueryInfoNone:
			builder.WriteString("None|")
		case FileQueryInfoNofollowSymlinks:
			builder.WriteString("NofollowSymlinks|")
		default:
			builder.WriteString(fmt.Sprintf("FileQueryInfoFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileQueryInfoFlags) Has(other FileQueryInfoFlags) bool {
	return (f & other) == other
}

// IOStreamSpliceFlags determine how streams should be spliced.
type IOStreamSpliceFlags C.guint

const (
	// IOStreamSpliceNone: do not close either stream.
	IOStreamSpliceNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceCloseStream1: close the first stream after the splice.
	IOStreamSpliceCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceCloseStream2: close the second stream after the splice.
	IOStreamSpliceCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for IOStreamSpliceFlags.
func (i IOStreamSpliceFlags) String() string {
	if i == 0 {
		return "IOStreamSpliceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(98)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IOStreamSpliceNone:
			builder.WriteString("None|")
		case IOStreamSpliceCloseStream1:
			builder.WriteString("CloseStream1|")
		case IOStreamSpliceCloseStream2:
			builder.WriteString("CloseStream2|")
		case IOStreamSpliceWaitForBoth:
			builder.WriteString("WaitForBoth|")
		default:
			builder.WriteString(fmt.Sprintf("IOStreamSpliceFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IOStreamSpliceFlags) Has(other IOStreamSpliceFlags) bool {
	return (i & other) == other
}

// MountMountFlags flags used when mounting a mount.
type MountMountFlags C.guint

const (
	// MountMountNone: no flags set.
	MountMountNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MountMountFlags.
func (m MountMountFlags) String() string {
	if m == 0 {
		return "MountMountFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(14)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MountMountNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("MountMountFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MountMountFlags) Has(other MountMountFlags) bool {
	return (m & other) == other
}

// MountUnmountFlags flags used when an unmounting a mount.
type MountUnmountFlags C.guint

const (
	// MountUnmountNone: no flags set.
	MountUnmountNone MountUnmountFlags = 0b0
	// MountUnmountForce: unmount even if there are outstanding file operations
	// on the mount.
	MountUnmountForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MountUnmountFlags.
func (m MountUnmountFlags) String() string {
	if m == 0 {
		return "MountUnmountFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(34)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MountUnmountNone:
			builder.WriteString("None|")
		case MountUnmountForce:
			builder.WriteString("Force|")
		default:
			builder.WriteString(fmt.Sprintf("MountUnmountFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MountUnmountFlags) Has(other MountUnmountFlags) bool {
	return (m & other) == other
}

// OutputStreamSpliceFlags determine how streams should be spliced.
type OutputStreamSpliceFlags C.guint

const (
	// OutputStreamSpliceNone: do not close either stream.
	OutputStreamSpliceNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceCloseSource: close the source stream after the splice.
	OutputStreamSpliceCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceCloseTarget: close the target stream after the splice.
	OutputStreamSpliceCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for OutputStreamSpliceFlags.
func (o OutputStreamSpliceFlags) String() string {
	if o == 0 {
		return "OutputStreamSpliceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for o != 0 {
		next := o & (o - 1)
		bit := o - next

		switch bit {
		case OutputStreamSpliceNone:
			builder.WriteString("None|")
		case OutputStreamSpliceCloseSource:
			builder.WriteString("CloseSource|")
		case OutputStreamSpliceCloseTarget:
			builder.WriteString("CloseTarget|")
		default:
			builder.WriteString(fmt.Sprintf("OutputStreamSpliceFlags(0b%b)|", bit))
		}

		o = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if o contains other.
func (o OutputStreamSpliceFlags) Has(other OutputStreamSpliceFlags) bool {
	return (o & other) == other
}

// ResolverNameLookupFlags flags to modify lookup behavior.
type ResolverNameLookupFlags C.guint

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name()).
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIPv4Only: only resolve ipv4 addresses.
	ResolverNameLookupFlagsIPv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIPv6Only: only resolve ipv6 addresses.
	ResolverNameLookupFlagsIPv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResolverNameLookupFlags.
func (r ResolverNameLookupFlags) String() string {
	if r == 0 {
		return "ResolverNameLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(94)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResolverNameLookupFlagsDefault:
			builder.WriteString("Default|")
		case ResolverNameLookupFlagsIPv4Only:
			builder.WriteString("IPv4Only|")
		case ResolverNameLookupFlagsIPv6Only:
			builder.WriteString("IPv6Only|")
		default:
			builder.WriteString(fmt.Sprintf("ResolverNameLookupFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResolverNameLookupFlags) Has(other ResolverNameLookupFlags) bool {
	return (r & other) == other
}

// ResourceFlags give information about a particular file inside a resource
// bundle.
type ResourceFlags C.guint

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResourceFlags.
func (r ResourceFlags) String() string {
	if r == 0 {
		return "ResourceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(41)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResourceFlagsNone:
			builder.WriteString("None|")
		case ResourceFlagsCompressed:
			builder.WriteString("Compressed|")
		default:
			builder.WriteString(fmt.Sprintf("ResourceFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResourceFlags) Has(other ResourceFlags) bool {
	return (r & other) == other
}

// ResourceLookupFlags determine how resource path lookups are handled.
type ResourceLookupFlags C.guint

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResourceLookupFlags.
func (r ResourceLookupFlags) String() string {
	if r == 0 {
		return "ResourceLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(23)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResourceLookupFlagsNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("ResourceLookupFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResourceLookupFlags) Has(other ResourceLookupFlags) bool {
	return (r & other) == other
}

// SettingsBindFlags flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags C.guint

const (
	// SettingsBindDefault: equivalent to
	// G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET.
	SettingsBindDefault SettingsBindFlags = 0b0
	// SettingsBindGet: update the #GObject property when the setting changes.
	// It is an error to use this flag if the property is not writable.
	SettingsBindGet SettingsBindFlags = 0b1
	// SettingsBindSet: update the setting when the #GObject property changes.
	// It is an error to use this flag if the property is not readable.
	SettingsBindSet SettingsBindFlags = 0b10
	// SettingsBindNoSensitivity: do not try to bind a "sensitivity" property to
	// the writability of the setting.
	SettingsBindNoSensitivity SettingsBindFlags = 0b100
	// SettingsBindGetNoChanges: when set in addition to G_SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting.
	SettingsBindGetNoChanges SettingsBindFlags = 0b1000
	// SettingsBindInvertBoolean: when passed to g_settings_bind(), uses a pair
	// of mapping functions that invert the boolean value when mapping between
	// the setting and the property. The setting and property must both be
	// booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindInvertBoolean SettingsBindFlags = 0b10000
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SettingsBindFlags.
func (s SettingsBindFlags) String() string {
	if s == 0 {
		return "SettingsBindFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(128)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SettingsBindDefault:
			builder.WriteString("Default|")
		case SettingsBindGet:
			builder.WriteString("Get|")
		case SettingsBindSet:
			builder.WriteString("Set|")
		case SettingsBindNoSensitivity:
			builder.WriteString("NoSensitivity|")
		case SettingsBindGetNoChanges:
			builder.WriteString("GetNoChanges|")
		case SettingsBindInvertBoolean:
			builder.WriteString("InvertBoolean|")
		default:
			builder.WriteString(fmt.Sprintf("SettingsBindFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SettingsBindFlags) Has(other SettingsBindFlags) bool {
	return (s & other) == other
}

// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags C.guint

const (
	// SocketMsgNone: no flags.
	SocketMsgNone SocketMsgFlags = 0b0
	// SocketMsgOob: request to send/receive out of band data.
	SocketMsgOob SocketMsgFlags = 0b1
	// SocketMsgPeek: read data from the socket without removing it from the
	// queue.
	SocketMsgPeek SocketMsgFlags = 0b10
	// SocketMsgDontroute: don't use a gateway to send out the packet, only send
	// to hosts on directly connected networks.
	SocketMsgDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SocketMsgFlags.
func (s SocketMsgFlags) String() string {
	if s == 0 {
		return "SocketMsgFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SocketMsgNone:
			builder.WriteString("None|")
		case SocketMsgOob:
			builder.WriteString("Oob|")
		case SocketMsgPeek:
			builder.WriteString("Peek|")
		case SocketMsgDontroute:
			builder.WriteString("Dontroute|")
		default:
			builder.WriteString(fmt.Sprintf("SocketMsgFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SocketMsgFlags) Has(other SocketMsgFlags) bool {
	return (s & other) == other
}

// SubprocessFlags flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from /dev/null. For stdout and
// stderr the default are for them to inherit the corresponding descriptor from
// the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags.
// For example, you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags C.guint

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0b0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 0b1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 0b10
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 0b100
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to /dev/null).
	SubprocessFlagsStdoutSilence SubprocessFlags = 0b1000
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 0b10000
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to /dev/null).
	SubprocessFlagsStderrSilence SubprocessFlags = 0b100000
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 0b1000000
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 0b10000000
	// SubprocessFlagsSearchPathFromEnvp: if path searching is needed when
	// spawning the subprocess, use the PATH in the launcher environment.
	// (Since: 2.72).
	SubprocessFlagsSearchPathFromEnvp SubprocessFlags = 0b100000000
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SubprocessFlags.
func (s SubprocessFlags) String() string {
	if s == 0 {
		return "SubprocessFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SubprocessFlagsNone:
			builder.WriteString("None|")
		case SubprocessFlagsStdinPipe:
			builder.WriteString("StdinPipe|")
		case SubprocessFlagsStdinInherit:
			builder.WriteString("StdinInherit|")
		case SubprocessFlagsStdoutPipe:
			builder.WriteString("StdoutPipe|")
		case SubprocessFlagsStdoutSilence:
			builder.WriteString("StdoutSilence|")
		case SubprocessFlagsStderrPipe:
			builder.WriteString("StderrPipe|")
		case SubprocessFlagsStderrSilence:
			builder.WriteString("StderrSilence|")
		case SubprocessFlagsStderrMerge:
			builder.WriteString("StderrMerge|")
		case SubprocessFlagsInheritFds:
			builder.WriteString("InheritFds|")
		case SubprocessFlagsSearchPathFromEnvp:
			builder.WriteString("SearchPathFromEnvp|")
		default:
			builder.WriteString(fmt.Sprintf("SubprocessFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SubprocessFlags) Has(other SubprocessFlags) bool {
	return (s & other) == other
}

// TestDBusFlags flags to define future DBus behaviour.
type TestDBusFlags C.guint

const (
	// TestDBusNone: no flags.
	TestDBusNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TestDBusFlags.
func (t TestDBusFlags) String() string {
	if t == 0 {
		return "TestDBusFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(12)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TestDBusNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("TestDBusFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TestDBusFlags) Has(other TestDBusFlags) bool {
	return (t & other) == other
}

// TLSCertificateFlags: set of flags describing TLS certification validation.
// This can be used to describe why a particular certificate was rejected (for
// example, in Connection::accept-certificate).
//
// GLib guarantees that if certificate verification fails, at least one flag
// will be set, but it does not guarantee that all possible flags will be set.
// Accordingly, you may not safely decide to ignore any particular type of
// error. For example, it would be incorrect to mask G_TLS_CERTIFICATE_EXPIRED
// if you want to allow expired certificates, because this could potentially be
// the only error flag set even if other problems exist with the certificate.
type TLSCertificateFlags C.guint

const (
	// TLSCertificateNoFlags: no flags set. Since: 2.74.
	TLSCertificateNoFlags TLSCertificateFlags = 0b0
	// TLSCertificateUnknownCa: signing certificate authority is not known.
	TLSCertificateUnknownCa TLSCertificateFlags = 0b1
	// TLSCertificateBadIdentity: certificate does not match the expected
	// identity of the site that it was retrieved from.
	TLSCertificateBadIdentity TLSCertificateFlags = 0b10
	// TLSCertificateNotActivated certificate's activation time is still in the
	// future.
	TLSCertificateNotActivated TLSCertificateFlags = 0b100
	// TLSCertificateExpired: certificate has expired.
	TLSCertificateExpired TLSCertificateFlags = 0b1000
	// TLSCertificateRevoked: certificate has been revoked according to the
	// Connection's certificate revocation list.
	TLSCertificateRevoked TLSCertificateFlags = 0b10000
	// TLSCertificateInsecure certificate's algorithm is considered insecure.
	TLSCertificateInsecure TLSCertificateFlags = 0b100000
	// TLSCertificateGenericError: some other error occurred validating the
	// certificate.
	TLSCertificateGenericError TLSCertificateFlags = 0b1000000
	// TLSCertificateValidateAll: combination of all of the above flags.
	TLSCertificateValidateAll TLSCertificateFlags = 0b1111111
)

func marshalTLSCertificateFlags(p uintptr) (interface{}, error) {
	return TLSCertificateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSCertificateFlags.
func (t TLSCertificateFlags) String() string {
	if t == 0 {
		return "TLSCertificateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(218)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSCertificateNoFlags:
			builder.WriteString("NoFlags|")
		case TLSCertificateUnknownCa:
			builder.WriteString("UnknownCa|")
		case TLSCertificateBadIdentity:
			builder.WriteString("BadIdentity|")
		case TLSCertificateNotActivated:
			builder.WriteString("NotActivated|")
		case TLSCertificateExpired:
			builder.WriteString("Expired|")
		case TLSCertificateRevoked:
			builder.WriteString("Revoked|")
		case TLSCertificateInsecure:
			builder.WriteString("Insecure|")
		case TLSCertificateGenericError:
			builder.WriteString("GenericError|")
		case TLSCertificateValidateAll:
			builder.WriteString("ValidateAll|")
		default:
			builder.WriteString(fmt.Sprintf("TLSCertificateFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSCertificateFlags) Has(other TLSCertificateFlags) bool {
	return (t & other) == other
}

// TLSDatabaseVerifyFlags flags for g_tls_database_verify_chain().
type TLSDatabaseVerifyFlags C.guint

const (
	// TLSDatabaseVerifyNone: no verification flags.
	TLSDatabaseVerifyNone TLSDatabaseVerifyFlags = 0b0
)

func marshalTLSDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseVerifyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSDatabaseVerifyFlags.
func (t TLSDatabaseVerifyFlags) String() string {
	if t == 0 {
		return "TLSDatabaseVerifyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(21)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSDatabaseVerifyNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("TLSDatabaseVerifyFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSDatabaseVerifyFlags) Has(other TLSDatabaseVerifyFlags) bool {
	return (t & other) == other
}

// TLSPasswordFlags various flags for the password.
type TLSPasswordFlags C.guint

const (
	// TLSPasswordNone: no flags.
	TLSPasswordNone TLSPasswordFlags = 0b0
	// TLSPasswordRetry: password was wrong, and the user should retry.
	TLSPasswordRetry TLSPasswordFlags = 0b10
	// TLSPasswordManyTries: hint to the user that the password has been wrong
	// many times, and the user may not have many chances left.
	TLSPasswordManyTries TLSPasswordFlags = 0b100
	// TLSPasswordFinalTry: hint to the user that this is the last try to get
	// this password right.
	TLSPasswordFinalTry TLSPasswordFlags = 0b1000
	// TLSPasswordPKCS11User: for PKCS #11, the user PIN is required. Since:
	// 2.70.
	TLSPasswordPKCS11User TLSPasswordFlags = 0b10000
	// TLSPasswordPKCS11SecurityOfficer: for PKCS #11, the security officer PIN
	// is required. Since: 2.70.
	TLSPasswordPKCS11SecurityOfficer TLSPasswordFlags = 0b100000
	// TLSPasswordPKCS11ContextSpecific: for PKCS #11, the context-specific PIN
	// is required. Since: 2.70.
	TLSPasswordPKCS11ContextSpecific TLSPasswordFlags = 0b1000000
)

func marshalTLSPasswordFlags(p uintptr) (interface{}, error) {
	return TLSPasswordFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSPasswordFlags.
func (t TLSPasswordFlags) String() string {
	if t == 0 {
		return "TLSPasswordFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(161)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSPasswordNone:
			builder.WriteString("None|")
		case TLSPasswordRetry:
			builder.WriteString("Retry|")
		case TLSPasswordManyTries:
			builder.WriteString("ManyTries|")
		case TLSPasswordFinalTry:
			builder.WriteString("FinalTry|")
		case TLSPasswordPKCS11User:
			builder.WriteString("PKCS11User|")
		case TLSPasswordPKCS11SecurityOfficer:
			builder.WriteString("PKCS11SecurityOfficer|")
		case TLSPasswordPKCS11ContextSpecific:
			builder.WriteString("PKCS11ContextSpecific|")
		default:
			builder.WriteString(fmt.Sprintf("TLSPasswordFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSPasswordFlags) Has(other TLSPasswordFlags) bool {
	return (t & other) == other
}

// AsyncReadyCallback: type definition for a function that will be called back
// when an asynchronous operation within GIO has been completed. ReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later iteration of
// the [thread-default main context][g-main-context-push-thread-default] where
// the #GTask was created. All other users of ReadyCallback must likewise call
// it asynchronously in a later iteration of the main context.
//
// The asynchronous operation is guaranteed to have held a reference to
// source_object from the time when the *_async() function was called, until
// after this callback returns.
type AsyncReadyCallback func(res AsyncResulter)

// BusAcquiredCallback: invoked when a connection to a message bus has been
// obtained.
type BusAcquiredCallback func(connection *DBusConnection, name string)

// BusNameAcquiredCallback: invoked when the name is acquired.
type BusNameAcquiredCallback func(connection *DBusConnection, name string)

// BusNameAppearedCallback: invoked when the name being watched is known to have
// to have an owner.
type BusNameAppearedCallback func(connection *DBusConnection, name, nameOwner string)

// BusNameLostCallback: invoked when the name is lost or connection has been
// closed.
type BusNameLostCallback func(connection *DBusConnection, name string)

// BusNameVanishedCallback: invoked when the name being watched is known not to
// have to have an owner.
//
// This is also invoked when the BusConnection on which the watch was
// established has been closed. In that case, connection will be NULL.
type BusNameVanishedCallback func(connection *DBusConnection, name string)

// DBusInterfaceGetPropertyFunc: type of the get_property function in
// BusInterfaceVTable.
type DBusInterfaceGetPropertyFunc func(connection *DBusConnection, sender, objectPath, interfaceName, propertyName string) (err error, variant *glib.Variant)

// DBusInterfaceMethodCallFunc: type of the method_call function in
// BusInterfaceVTable.
type DBusInterfaceMethodCallFunc func(connection *DBusConnection, sender, objectPath, interfaceName, methodName string, parameters *glib.Variant, invocation *DBusMethodInvocation)

// DBusInterfaceSetPropertyFunc: type of the set_property function in
// BusInterfaceVTable.
type DBusInterfaceSetPropertyFunc func(connection *DBusConnection, sender, objectPath, interfaceName, propertyName string, value *glib.Variant) (err error, ok bool)

// DBusMessageFilterFunction: signature for function used in
// g_dbus_connection_add_filter().
//
// A filter function is passed a BusMessage and expected to return a BusMessage
// too. Passive filter functions that don't modify the message can simply return
// the message object:
//
//	static GDBusMessage *
//	passive_filter (GDBusConnection *connection
//	                GDBusMessage    *message,
//	                gboolean         incoming,
//	                gpointer         user_data)
//	{
//	  // inspect message
//	  return message;
//	}
//
// Filter functions that wants to drop a message can simply return NULL:
//
//	static GDBusMessage *
//	drop_filter (GDBusConnection *connection
//	             GDBusMessage    *message,
//	             gboolean         incoming,
//	             gpointer         user_data)
//	{
//	  if (should_drop_message)
//	    {
//	      g_object_unref (message);
//	      message = NULL;
//	    }
//	  return message;
//	}
//
// Finally, a filter function may modify a message by copying it:
//
//	static GDBusMessage *
//	modifying_filter (GDBusConnection *connection
//	                  GDBusMessage    *message,
//	                  gboolean         incoming,
//	                  gpointer         user_data)
//	{
//	  GDBusMessage *copy;
//	  GError *error;
//
//	  error = NULL;
//	  copy = g_dbus_message_copy (message, &error);
//	  // handle error being set
//	  g_object_unref (message);
//
//	  // modify copy
//
//	  return copy;
//	}
//
// If the returned BusMessage is different from message and cannot be sent on
// connection (it could use features, such as file descriptors, not compatible
// with connection), then a warning is logged to standard error. Applications
// can check this ahead of time using g_dbus_message_to_blob() passing a
// BusCapabilityFlags value obtained from connection.
type DBusMessageFilterFunction func(connection *DBusConnection, message *DBusMessage, incoming bool) (dBusMessage *DBusMessage)

// DBusSignalCallback: signature for callback function used in
// g_dbus_connection_signal_subscribe().
type DBusSignalCallback func(connection *DBusConnection, senderName, objectPath, interfaceName, signalName string, parameters *glib.Variant)

// DBusSubtreeDispatchFunc: type of the dispatch function in BusSubtreeVTable.
//
// Subtrees are flat. node, if non-NULL, is always exactly one segment of the
// object path (ie: it never contains a slash).
type DBusSubtreeDispatchFunc func(connection *DBusConnection, sender, objectPath, interfaceName, node string) (outUserData unsafe.Pointer, dBusInterfaceVTable *DBusInterfaceVTable)

// DBusSubtreeEnumerateFunc: type of the enumerate function in BusSubtreeVTable.
//
// This function is called when generating introspection data and also
// when preparing to dispatch incoming messages in the event that the
// G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not specified
// (ie: to verify that the object path is valid).
//
// Hierarchies are not supported; the items that you return should not contain
// the / character.
//
// The return value will be freed with g_strfreev().
type DBusSubtreeEnumerateFunc func(connection *DBusConnection, sender, objectPath string) (utf8s []string)

// DBusSubtreeIntrospectFunc: type of the introspect function in
// BusSubtreeVTable.
//
// Subtrees are flat. node, if non-NULL, is always exactly one segment of the
// object path (ie: it never contains a slash).
//
// This function should return NULL to indicate that there is no object at this
// node.
//
// If this function returns non-NULL, the return value is expected to be
// a NULL-terminated array of pointers to BusInterfaceInfo structures
// describing the interfaces implemented by node. This array will have
// g_dbus_interface_info_unref() called on each item before being freed with
// g_free().
//
// The difference between returning NULL and an array containing zero items is
// that the standard DBus interfaces will returned to the remote introspector in
// the empty array case, but not in the NULL case.
type DBusSubtreeIntrospectFunc func(connection *DBusConnection, sender, objectPath, node string) (dBusInterfaceInfos []*DBusInterfaceInfo)

// SettingsBindGetMapping: type for the function that is used to convert from
// #GSettings to an object property. The value is already initialized to hold
// values of the appropriate type.
type SettingsBindGetMapping func(value *coreglib.Value, variant *glib.Variant) (ok bool)

// SettingsBindSetMapping: type for the function that is used to convert an
// object property value to a #GVariant for storing it in #GSettings.
type SettingsBindSetMapping func(value *coreglib.Value, expectedType *glib.VariantType) (variant *glib.Variant)

// SettingsGetMapping: type of the function that is used to convert from a value
// stored in a #GSettings to a value that is useful to the application.
//
// If the value is successfully mapped, the result should be stored at result
// and TRUE returned. If mapping fails (for example, if value is not in the
// right format) then FALSE should be returned.
//
// If value is NULL then it means that the mapping function is being given a
// "last chance" to successfully return a valid value. TRUE must be returned in
// this case.
type SettingsGetMapping func(value *glib.Variant) (result unsafe.Pointer, ok bool)

// VFSFileLookupFunc: this function type is used by g_vfs_register_uri_scheme()
// to make it possible for a client to associate an URI scheme to a different
// #GFile implementation.
//
// The client should return a reference to the new file that has been created
// for uri, or NULL to continue with the default implementation.
type VFSFileLookupFunc func(vfs *VFS, identifier string) (file *File)

// BusGet: asynchronously connects to the message bus specified by bus_type.
//
// When the operation is finished, callback will be invoked. You can then call
// g_bus_get_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See g_bus_get_sync() for the
// synchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - busType: Type.
//   - callback (optional) to call when the request is satisfied.
func BusGet(ctx context.Context, busType BusType, callback AsyncReadyCallback) {
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GBusType            // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GBusType(busType)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_bus_get(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(callback)
}

// BusGetFinish finishes an operation started with g_bus_get().
//
// The returned object is a singleton, that is, shared with other
// callers of g_bus_get() and g_bus_get_sync() for bus_type.
// In the event that you need a private message bus connection, use
// g_dbus_address_get_for_bus_sync() and g_dbus_connection_new_for_address()
// with G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to TRUE.
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to g_bus_get().
//
// The function returns the following values:
//
//   - dBusConnection or NULL if error is set. Free with g_object_unref().
func BusGetFinish(res AsyncResulter) (*DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_bus_get_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// BusGetSync: synchronously connects to the message bus specified by bus_type.
// Note that the returned object may shared with other callers, e.g. if two
// separate parts of a process calls this function with the same bus_type,
// they will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other
// callers of g_bus_get() and g_bus_get_sync() for bus_type.
// In the event that you need a private message bus connection, use
// g_dbus_address_get_for_bus_sync() and g_dbus_connection_new_for_address()
// with G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to TRUE.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - busType: Type.
//
// The function returns the following values:
//
//   - dBusConnection or NULL if error is set. Free with g_object_unref().
func BusGetSync(ctx context.Context, busType BusType) (*DBusConnection, error) {
	var _arg2 *C.GCancellable    // out
	var _arg1 C.GBusType         // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GBusType(busType)

	_cret = C.g_bus_get_sync(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busType)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// BusUnownName stops owning a name.
//
// Note that there may still be D-Bus traffic to process (relating to owning and
// unowning the name) in the current thread-default Context after this function
// has returned. You should continue to iterate the Context until the Notify
// function passed to g_bus_own_name() is called, in order to avoid memory leaks
// through callbacks queued on the Context after its stopped being iterated.
//
// The function takes the following parameters:
//
//   - ownerId: identifier obtained from g_bus_own_name().
func BusUnownName(ownerId uint) {
	var _arg1 C.guint // out

	_arg1 = C.guint(ownerId)

	C.g_bus_unown_name(_arg1)
	runtime.KeepAlive(ownerId)
}

// BusUnwatchName stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after its stopped being
// iterated.
//
// The function takes the following parameters:
//
//   - watcherId: identifier obtained from g_bus_watch_name().
func BusUnwatchName(watcherId uint) {
	var _arg1 C.guint // out

	_arg1 = C.guint(watcherId)

	C.g_bus_unwatch_name(_arg1)
	runtime.KeepAlive(watcherId)
}

// ContentTypeCanBeExecutable checks if a content type can be executable.
// Note that for instance things like text files can be executables (i.e.
// scripts and batch files).
//
// The function takes the following parameters:
//
//   - typ: content type string.
//
// The function returns the following values:
//
//   - ok: TRUE if the file type corresponds to a type that can be executable,
//     FALSE otherwise.
func ContentTypeCanBeExecutable(typ string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_can_be_executable(_arg1)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeEquals compares two content types for equality.
//
// The function takes the following parameters:
//
//   - type1: content type string.
//   - type2: content type string.
//
// The function returns the following values:
//
//   - ok: TRUE if the two strings are identical or equivalent, FALSE otherwise.
func ContentTypeEquals(type1, type2 string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(type1)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(type2)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_content_type_equals(_arg1, _arg2)
	runtime.KeepAlive(type1)
	runtime.KeepAlive(type2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeFromMIMEType tries to find a content type based on the mime type
// name.
//
// The function takes the following parameters:
//
//   - mimeType: mime type string.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string with content type or NULL.
//     Free with g_free().
func ContentTypeFromMIMEType(mimeType string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_from_mime_type(_arg1)
	runtime.KeepAlive(mimeType)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ContentTypeGetDescription gets the human readable description of the content
// type.
//
// The function takes the following parameters:
//
//   - typ: content type string.
//
// The function returns the following values:
//
//   - utf8: short description of the content type type. Free the returned
//     string with g_free().
func ContentTypeGetDescription(typ string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_description(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ContentTypeGetGenericIconName gets the generic icon name for a content type.
//
// See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
//
// The function takes the following parameters:
//
//   - typ: content type string.
//
// The function returns the following values:
//
//   - utf8 (optional): registered generic icon name for the given type, or NULL
//     if unknown. Free with g_free().
func ContentTypeGetGenericIconName(typ string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_generic_icon_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ContentTypeGetIcon gets the icon for a content type.
//
// The function takes the following parameters:
//
//   - typ: content type string.
//
// The function returns the following values:
//
//   - icon corresponding to the content type. Free the returned object with
//     g_object_unref().
func ContentTypeGetIcon(typ string) *Icon {
	var _arg1 *C.gchar // out
	var _cret *C.GIcon // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_icon(_arg1)
	runtime.KeepAlive(typ)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// ContentTypeGetMIMEDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated list of directories to load MIME data from,
//     including any mime/ subdirectory, and with the first directory to try
//     listed first.
func ContentTypeGetMIMEDirs() []string {
	var _cret **C.gchar // in

	_cret = C.g_content_type_get_mime_dirs()

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// ContentTypeGetMIMEType gets the mime type for the content type, if one is
// registered.
//
// The function takes the following parameters:
//
//   - typ: content type string.
//
// The function returns the following values:
//
//   - utf8 (optional): registered mime type for the given type, or NULL if
//     unknown; free with g_free().
func ContentTypeGetMIMEType(typ string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_mime_type(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ContentTypeGetSymbolicIcon gets the symbolic icon for a content type.
//
// The function takes the following parameters:
//
//   - typ: content type string.
//
// The function returns the following values:
//
//   - icon: symbolic #GIcon corresponding to the content type. Free the
//     returned object with g_object_unref().
func ContentTypeGetSymbolicIcon(typ string) *Icon {
	var _arg1 *C.gchar // out
	var _cret *C.GIcon // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_get_symbolic_icon(_arg1)
	runtime.KeepAlive(typ)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// ContentTypeGuess guesses the content type based on example data. If the
// function is uncertain, result_uncertain will be set to TRUE. Either filename
// or data may be NULL, in which case the guess will be based solely on the
// other argument.
//
// The function takes the following parameters:
//
//   - filename (optional): path, or NULL.
//   - data (optional): stream of data, or NULL.
//
// The function returns the following values:
//
//   - resultUncertain (optional): return location for the certainty of the
//     result, or NULL.
//   - utf8: string indicating a guessed content type for the given data.
//     Free with g_free().
func ContentTypeGuess(filename string, data []byte) (bool, string) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.guchar // out
	var _arg3 C.gsize
	var _arg4 C.gboolean // in
	var _cret *C.gchar   // in

	if filename != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guchar)(unsafe.Pointer(&data[0]))
	}

	_cret = C.g_content_type_guess(_arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(data)

	var _resultUncertain bool // out
	var _utf8 string          // out

	if _arg4 != 0 {
		_resultUncertain = true
	}
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _resultUncertain, _utf8
}

// ContentTypeGuessForTree tries to guess the type of the tree with root root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
//
// The types returned all have the form x-content/foo, e.g.
// x-content/audio-cdda (for audio CDs) or x-content/image-dcf
// (for a camera memory card). See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This function is useful in the implementation of
// g_mount_guess_content_type().
//
// The function takes the following parameters:
//
//   - root of the tree to guess a type for.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of zero or more content types. Free with
//     g_strfreev().
func ContentTypeGuessForTree(root Filer) []string {
	var _arg1 *C.GFile  // out
	var _cret **C.gchar // in

	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(root).Native()))

	_cret = C.g_content_type_guess_for_tree(_arg1)
	runtime.KeepAlive(root)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ContentTypeIsA determines if type is a subset of supertype.
//
// The function takes the following parameters:
//
//   - typ: content type string.
//   - supertype: content type string.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a kind of supertype, FALSE otherwise.
func ContentTypeIsA(typ, supertype string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(supertype)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_content_type_is_a(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(supertype)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeIsMIMEType determines if type is a subset of mime_type.
// Convenience wrapper around g_content_type_is_a().
//
// The function takes the following parameters:
//
//   - typ: content type string.
//   - mimeType: mime type string.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a kind of mime_type, FALSE otherwise.
func ContentTypeIsMIMEType(typ, mimeType string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_content_type_is_mime_type(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(mimeType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeIsUnknown checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
//
// The function takes the following parameters:
//
//   - typ: content type string.
//
// The function returns the following values:
//
//   - ok: TRUE if the type is the unknown type.
func ContentTypeIsUnknown(typ string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_is_unknown(_arg1)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContentTypeSetMIMEDirs: set the list of directories used by GIO to load the
// MIME database. If dirs is NULL, the directories used are the default:
//
//   - the mime subdirectory of the directory in $XDG_DATA_HOME
//   - the mime subdirectory of every directory in $XDG_DATA_DIRS
//
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
//
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the systems MIME database, you should call this function with dirs set to
// NULL before calling g_test_init(), for instance:
//
//	// Load MIME data from the system
//	g_content_type_set_mime_dirs (NULL);
//	// Isolate the environment
//	g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
//
//	
//
//	return g_test_run ();.
//
// The function takes the following parameters:
//
//   - dirs (optional): NULL-terminated list of directories to load MIME data
//     from, including any mime/ subdirectory, and with the first directory to
//     try listed first.
func ContentTypeSetMIMEDirs(dirs []string) {
	var _arg1 **C.gchar // out

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(dirs) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(dirs)+1)
			var zero *C.gchar
			out[len(dirs)] = zero
			for i := range dirs {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(dirs[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.g_content_type_set_mime_dirs(_arg1)
	runtime.KeepAlive(dirs)
}

// ContentTypesGetRegistered gets a list of strings containing all the
// registered content types known to the system. The list and its data should be
// freed using g_list_free_full (list, g_free).
//
// The function returns the following values:
//
//   - list of the registered content types.
func ContentTypesGetRegistered() []string {
	var _cret *C.GList // in

	_cret = C.g_content_types_get_registered()

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// DBusAddressEscapeValue: escape string so it can appear in a D-Bus address as
// the value part of a key-value pair.
//
// For instance, if string is /run/bus-for-:0, this function would
// return /run/bus-for-3A0, which could be used in a D-Bus address like
// unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0.
//
// The function takes the following parameters:
//
//   - str: unescaped string to be included in a D-Bus address as the value in a
//     key-value pair.
//
// The function returns the following values:
//
//   - utf8: copy of string with all non-optionally-escaped bytes escaped.
func DBusAddressEscapeValue(str string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_address_escape_value(_arg1)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusAddressGetForBusSync: synchronously looks up the D-Bus address for the
// well-known message bus instance specified by bus_type. This may involve using
// various platform specific mechanisms.
//
// The returned address will be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - busType: Type.
//
// The function returns the following values:
//
//   - utf8: valid D-Bus address string for bus_type or NULL if error is set.
func DBusAddressGetForBusSync(ctx context.Context, busType BusType) (string, error) {
	var _arg2 *C.GCancellable // out
	var _arg1 C.GBusType      // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GBusType(busType)

	_cret = C.g_dbus_address_get_for_bus_sync(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busType)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// DBusAddressGetStream: asynchronously connects to an endpoint
// specified by address and sets up the connection so it is in
// a state to run the client-side of the D-Bus authentication
// conversation. address must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// When the operation is finished, callback will be invoked. You can then call
// g_dbus_address_get_stream_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See
// g_dbus_address_get_stream_sync() for the synchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address: valid D-Bus address.
//   - callback (optional) to call when the request is satisfied.
func DBusAddressGetStream(ctx context.Context, address string, callback AsyncReadyCallback) {
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_address_get_stream(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// DBusAddressGetStreamFinish finishes an operation started with
// g_dbus_address_get_stream().
//
// A server is not required to set a GUID, so out_guid may be set to NULL even
// on success.
//
// The function takes the following parameters:
//
//   - res obtained from the GAsyncReadyCallback passed to
//     g_dbus_address_get_stream().
//
// The function returns the following values:
//
//   - outGuid (optional): NULL or return location to store the GUID extracted
//     from address, if any.
//   - ioStream or NULL if error is set.
func DBusAddressGetStreamFinish(res AsyncResulter) (string, IOStreamer, error) {
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.gchar        // in
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_address_get_stream_finish(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(res)

	var _outGuid string      // out
	var _ioStream IOStreamer // out
	var _goerr error         // out

	if _arg2 != nil {
		_outGuid = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outGuid, _ioStream, _goerr
}

// DBusAddressGetStreamSync: synchronously connects to an endpoint
// specified by address and sets up the connection so it is in
// a state to run the client-side of the D-Bus authentication
// conversation. address must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// A server is not required to set a GUID, so out_guid may be set to NULL even
// on success.
//
// This is a synchronous failable function. See g_dbus_address_get_stream() for
// the asynchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address: valid D-Bus address.
//
// The function returns the following values:
//
//   - outGuid (optional): NULL or return location to store the GUID extracted
//     from address, if any.
//   - ioStream or NULL if error is set.
func DBusAddressGetStreamSync(ctx context.Context, address string) (string, IOStreamer, error) {
	var _arg3 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // in
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_address_get_stream_sync(_arg1, &_arg2, _arg3, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _outGuid string      // out
	var _ioStream IOStreamer // out
	var _goerr error         // out

	if _arg2 != nil {
		_outGuid = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outGuid, _ioStream, _goerr
}

// DBusEscapeObjectPath: this is a language binding friendly version of
// g_dbus_escape_object_path_bytestring().
//
// The function takes the following parameters:
//
//   - s: string to escape.
//
// The function returns the following values:
//
//   - utf8: escaped version of s. Free with g_free().
func DBusEscapeObjectPath(s string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_escape_object_path(_arg1)
	runtime.KeepAlive(s)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusEscapeObjectPathBytestring escapes bytes for use in a D-Bus object path
// component. bytes is an array of zero or more nonzero bytes in an unspecified
// encoding, followed by a single zero byte.
//
// The escaping method consists of replacing all non-alphanumeric characters
// (see g_ascii_isalnum()) with their hexadecimal value preceded by an
// underscore (_). For example: foo.bar.baz will become foo_2ebar_2ebaz.
//
// This method is appropriate to use when the input is nearly a valid object
// path component but is not when your input is far from being a valid object
// path component. Other escaping algorithms are also valid to use with D-Bus
// object paths.
//
// This can be reversed with g_dbus_unescape_object_path().
//
// The function takes the following parameters:
//
//   - bytes: string of bytes to escape.
//
// The function returns the following values:
//
//   - utf8: escaped version of bytes. Free with g_free().
func DBusEscapeObjectPathBytestring(bytes []byte) string {
	var _arg1 *C.guint8 // out
	var _cret *C.gchar  // in

	{
		var zero byte
		bytes = append(bytes, zero)
		_arg1 = (*C.guint8)(unsafe.Pointer(&bytes[0]))
	}

	_cret = C.g_dbus_escape_object_path_bytestring(_arg1)
	runtime.KeepAlive(bytes)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGenerateGUID: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification
// (https://dbus.freedesktop.org/doc/dbus-specification.html#uuids) regarding
// what strings are valid D-Bus GUIDs. The specification refers to these as
// UUIDs whereas GLib (for historical reasons) refers to them as GUIDs.
// The terms are interchangeable.
//
// Note that D-Bus GUIDs do not follow RFC 4122
// (https://datatracker.ietf.org/doc/html/rfc4122).
//
// The function returns the following values:
//
//   - utf8: valid D-Bus GUID. Free with g_free().
func DBusGenerateGUID() string {
	var _cret *C.gchar // in

	_cret = C.g_dbus_generate_guid()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGValueToGVariant converts a #GValue to a #GVariant of the type indicated
// by the type parameter.
//
// The conversion is using the following rules:
//
// - G_TYPE_STRING: 's', 'o', 'g' or 'ay'
//
// - G_TYPE_STRV: 'as', 'ao' or 'aay'
//
// - G_TYPE_BOOLEAN: 'b'
//
// - G_TYPE_UCHAR: 'y'
//
// - G_TYPE_INT: 'i', 'n'
//
// - G_TYPE_UINT: 'u', 'q'
//
// - G_TYPE_INT64: 'x'
//
// - G_TYPE_UINT64: 't'
//
// - G_TYPE_DOUBLE: 'd'
//
// - G_TYPE_VARIANT: Any Type
//
// This can fail if e.g. gvalue is of type G_TYPE_STRING and type is 'i',
// i.e. G_VARIANT_TYPE_INT32. It will also fail for any #GType (including e.g.
// G_TYPE_OBJECT and G_TYPE_BOXED derived-types) not in the table above.
//
// Note that if gvalue is of type G_TYPE_VARIANT and its value is NULL,
// the empty #GVariant instance (never NULL) for type is returned (e.g. 0 for
// scalar types, the empty string for string types, '/' for object path types,
// the empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
//
// The function takes the following parameters:
//
//   - gvalue to convert to a #GVariant.
//   - typ: Type.
//
// The function returns the following values:
//
//   - variant (never floating) of Type type holding the data from gvalue or an
//     empty #GVariant in case of failure. Free with g_variant_unref().
func DBusGValueToGVariant(gvalue *coreglib.Value, typ *glib.VariantType) *glib.Variant {
	var _arg1 *C.GValue       // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GValue)(unsafe.Pointer(gvalue.Native()))
	_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_dbus_gvalue_to_gvariant(_arg1, _arg2)
	runtime.KeepAlive(gvalue)
	runtime.KeepAlive(typ)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// DBusGVariantToGValue converts a #GVariant to a #GValue. If value is floating,
// it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing
// any basic or string array type will be converted to a #GValue containing a
// basic value or string array. Any other #GVariant (handle, variant, tuple,
// dict entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// out_gvalue.
//
// The function takes the following parameters:
//
//   - value: #GVariant.
//
// The function returns the following values:
//
//   - outGvalue: return location pointing to a zero-filled (uninitialized)
//     #GValue.
func DBusGVariantToGValue(value *glib.Variant) coreglib.Value {
	var _arg1 *C.GVariant // out
	var _arg2 C.GValue    // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_dbus_gvariant_to_gvalue(_arg1, &_arg2)
	runtime.KeepAlive(value)

	var _outGvalue coreglib.Value // out

	_outGvalue = *coreglib.ValueFromNative(unsafe.Pointer((&_arg2)))

	return _outGvalue
}

// DBusIsAddress checks if string is a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This doesn't check if string is actually supported by BusServer or
// BusConnection - use g_dbus_is_supported_address() to do more checks.
//
// The function takes the following parameters:
//
//   - str: string.
//
// The function returns the following values:
//
//   - ok: TRUE if string is a valid D-Bus address, FALSE otherwise.
func DBusIsAddress(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_address(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsErrorName: check whether string is a valid D-Bus error name.
//
// This function returns the same result as g_dbus_is_interface_name(), because
// D-Bus error names are defined to have exactly the same syntax as interface
// names.
//
// The function takes the following parameters:
//
//   - str: string to check.
//
// The function returns the following values:
//
//   - ok: TRUE if valid, FALSE otherwise.
func DBusIsErrorName(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_error_name(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsGUID checks if string is a D-Bus GUID.
//
// See the documentation for g_dbus_generate_guid() for more information about
// the format of a GUID.
//
// The function takes the following parameters:
//
//   - str: string to check.
//
// The function returns the following values:
//
//   - ok: TRUE if string is a GUID, FALSE otherwise.
func DBusIsGUID(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_guid(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsInterfaceName checks if string is a valid D-Bus interface name.
//
// The function takes the following parameters:
//
//   - str: string to check.
//
// The function returns the following values:
//
//   - ok: TRUE if valid, FALSE otherwise.
func DBusIsInterfaceName(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_interface_name(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsMemberName checks if string is a valid D-Bus member (e.g. signal or
// method) name.
//
// The function takes the following parameters:
//
//   - str: string to check.
//
// The function returns the following values:
//
//   - ok: TRUE if valid, FALSE otherwise.
func DBusIsMemberName(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_member_name(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsName checks if string is a valid D-Bus bus name (either unique or
// well-known).
//
// The function takes the following parameters:
//
//   - str: string to check.
//
// The function returns the following values:
//
//   - ok: TRUE if valid, FALSE otherwise.
func DBusIsName(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_name(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsSupportedAddress: like g_dbus_is_address() but also checks if the
// library supports the transports in string and that key/value pairs for
// each transport are valid. See the specification of the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// The function takes the following parameters:
//
//   - str: string.
func DBusIsSupportedAddress(str string) error {
	var _arg1 *C.gchar  // out
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_is_supported_address(_arg1, &_cerr)
	runtime.KeepAlive(str)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DBusIsUniqueName checks if string is a valid D-Bus unique bus name.
//
// The function takes the following parameters:
//
//   - str: string to check.
//
// The function returns the following values:
//
//   - ok: TRUE if valid, FALSE otherwise.
func DBusIsUniqueName(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_is_unique_name(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusUnescapeObjectPath unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could not have
// been returned by g_dbus_escape_object_path(), this function returns NULL.
//
// Encoding alphanumeric characters which do not need to be encoded is not
// allowed (e.g _63 is not valid, the string should contain c instead).
//
// The function takes the following parameters:
//
//   - s: string to unescape.
//
// The function returns the following values:
//
//   - guint8s (optional): an unescaped version of s, or NULL if s is not a
//     string returned from g_dbus_escape_object_path(). Free with g_free().
func DBusUnescapeObjectPath(s string) []byte {
	var _arg1 *C.gchar  // out
	var _cret *C.guint8 // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_unescape_object_path(_arg1)
	runtime.KeepAlive(s)

	var _guint8s []byte // out

	if _cret != nil {
		{
			var i int
			var z C.guint8
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_guint8s = make([]byte, i)
			for i := range src {
				_guint8s[i] = byte(src[i])
			}
		}
	}

	return _guint8s
}

// IOErrorFromErrno converts errno.h error codes into GIO error codes.
//
// The fallback value G_IO_ERROR_FAILED is returned for error codes not
// currently handled (but note that future GLib releases may return a more
// specific value instead).
//
// As errno is global and may be modified by intermediate function calls,
// you should save its value immediately after the call returns, and use the
// saved value instead of errno:
//
//	int saved_errno;
//
//	ret = read (blah);
//	saved_errno = errno;
//
//	g_io_error_from_errno (saved_errno);.
//
// The function takes the following parameters:
//
//   - errNo: error number as defined in errno.h.
//
// The function returns the following values:
//
//   - ioErrorEnum value for the given errno.h error number.
func IOErrorFromErrno(errNo int) IOErrorEnum {
	var _arg1 C.gint         // out
	var _cret C.GIOErrorEnum // in

	_arg1 = C.gint(errNo)

	_cret = C.g_io_error_from_errno(_arg1)
	runtime.KeepAlive(errNo)

	var _ioErrorEnum IOErrorEnum // out

	_ioErrorEnum = IOErrorEnum(_cret)

	return _ioErrorEnum
}

// IOErrorFromFileError converts Error error codes into GIO error codes.
//
// The function takes the following parameters:
//
//   - fileError: Error.
//
// The function returns the following values:
//
//   - ioErrorEnum value for the given Error error value.
func IOErrorFromFileError(fileError glib.FileError) IOErrorEnum {
	var _arg1 C.GFileError   // out
	var _cret C.GIOErrorEnum // in

	_arg1 = C.GFileError(fileError)

	_cret = C.g_io_error_from_file_error(_arg1)
	runtime.KeepAlive(fileError)

	var _ioErrorEnum IOErrorEnum // out

	_ioErrorEnum = IOErrorEnum(_cret)

	return _ioErrorEnum
}

// IOErrorQuark gets the GIO Error Quark.
//
// The function returns the following values:
//
//   - quark: #GQuark.
func IOErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.g_io_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// IOModulesScanAllInDirectory scans all the modules in the specified directory,
// ensuring that any extension point implemented by a module is registered.
//
// This may not actually load and initialize all the types in each module,
// some modules may be lazily loaded and initialized when an extension point
// it implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules,
// use g_io_modules_load_all_in_directory().
//
// The function takes the following parameters:
//
//   - dirname: pathname for a directory containing modules to scan.
func IOModulesScanAllInDirectory(dirname string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(dirname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_io_modules_scan_all_in_directory(_arg1)
	runtime.KeepAlive(dirname)
}

// IOSchedulerCancelAllJobs cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
//
// Deprecated: You should never call this function, since you don't know how
// other libraries in your program might be making use of gioscheduler.
func IOSchedulerCancelAllJobs() {
	C.g_io_scheduler_cancel_all_jobs()
}

// NewPollableSource: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource that expects a callback of type
// SourceFunc. The new source does not actually do anything on its own;
// use g_source_add_child_source() to add other sources to it to cause it to
// trigger.
//
// The function takes the following parameters:
//
//   - pollableStream: stream associated with the new source.
//
// The function returns the following values:
//
//   - source: new #GSource.
func NewPollableSource(pollableStream *coreglib.Object) *glib.Source {
	var _arg1 *C.GObject // out
	var _cret *C.GSource // in

	_arg1 = (*C.GObject)(unsafe.Pointer(pollableStream.Native()))

	_cret = C.g_pollable_source_new(_arg1)
	runtime.KeepAlive(pollableStream)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// PollableSourceNewFull: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource, as with g_pollable_source_new(),
// but also attaching child_source (with a dummy callback), and cancellable,
// if they are non-NULL.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable to attach.
//   - pollableStream: stream associated with the new source.
//   - childSource (optional): optional child source to attach.
//
// The function returns the following values:
//
//   - source: new #GSource.
func PollableSourceNewFull(ctx context.Context, pollableStream *coreglib.Object, childSource *glib.Source) *glib.Source {
	var _arg3 *C.GCancellable // out
	var _arg1 C.gpointer      // out
	var _arg2 *C.GSource      // out
	var _cret *C.GSource      // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gpointer(unsafe.Pointer(pollableStream.Native()))
	if childSource != nil {
		_arg2 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(childSource)))
	}

	_cret = C.g_pollable_source_new_full(_arg1, _arg2, _arg3)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(pollableStream)
	runtime.KeepAlive(childSource)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// PollableStreamRead tries to read from stream, as with g_input_stream_read()
// (if blocking is TRUE) or g_pollable_input_stream_read_nonblocking() (if
// blocking is FALSE). This can be used to more easily share code between
// blocking and non-blocking implementations of a method.
//
// If blocking is FALSE, then stream must be a InputStream for which
// g_pollable_input_stream_can_poll() returns TRUE, or else the behavior
// is undefined. If blocking is TRUE, then stream does not need to be a
// InputStream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stream: Stream.
//   - buffer to read data into.
//   - blocking: whether to do blocking I/O.
//
// The function returns the following values:
//
//   - gssize: number of bytes read, or -1 on error.
func PollableStreamRead(ctx context.Context, stream InputStreamer, buffer []byte, blocking bool) (int, error) {
	var _arg5 *C.GCancellable // out
	var _arg1 *C.GInputStream // out
	var _arg2 *C.void         // out
	var _arg3 C.gsize
	var _arg4 C.gboolean // out
	var _cret C.gssize   // in
	var _cerr *C.GError  // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg3 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	if blocking {
		_arg4 = C.TRUE
	}

	_cret = C.g_pollable_stream_read(_arg1, unsafe.Pointer(_arg2), _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// PollableStreamWrite tries to write to stream, as with g_output_stream_write()
// (if blocking is TRUE) or g_pollable_output_stream_write_nonblocking() (if
// blocking is FALSE). This can be used to more easily share code between
// blocking and non-blocking implementations of a method.
//
// If blocking is FALSE, then stream must be a OutputStream for which
// g_pollable_output_stream_can_poll() returns TRUE or else the behavior
// is undefined. If blocking is TRUE, then stream does not need to be a
// OutputStream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stream: Stream.
//   - buffer: buffer containing the data to write.
//   - blocking: whether to do blocking I/O.
//
// The function returns the following values:
//
//   - gssize: number of bytes written, or -1 on error.
func PollableStreamWrite(ctx context.Context, stream OutputStreamer, buffer []byte, blocking bool) (int, error) {
	var _arg5 *C.GCancellable  // out
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.void          // out
	var _arg3 C.gsize
	var _arg4 C.gboolean // out
	var _cret C.gssize   // in
	var _cerr *C.GError  // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg3 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	if blocking {
		_arg4 = C.TRUE
	}

	_cret = C.g_pollable_stream_write(_arg1, unsafe.Pointer(_arg2), _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// PollableStreamWriteAll tries to write count bytes to stream, as with
// g_output_stream_write_all(), but using g_pollable_stream_write() rather than
// g_output_stream_write().
//
// On a successful write of count bytes, TRUE is returned, and bytes_written is
// set to count.
//
// If there is an error during the operation (including G_IO_ERROR_WOULD_BLOCK
// in the non-blocking case), FALSE is returned and error is set to indicate the
// error status, bytes_written is updated to contain the number of bytes written
// into the stream before the error occurred.
//
// As with g_pollable_stream_write(), if blocking is FALSE, then stream must be
// a OutputStream for which g_pollable_output_stream_can_poll() returns TRUE
// or else the behavior is undefined. If blocking is TRUE, then stream does not
// need to be a OutputStream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stream: Stream.
//   - buffer: buffer containing the data to write.
//   - blocking: whether to do blocking I/O.
//
// The function returns the following values:
//
//   - bytesWritten: location to store the number of bytes that was written to
//     the stream.
func PollableStreamWriteAll(ctx context.Context, stream OutputStreamer, buffer []byte, blocking bool) (uint, error) {
	var _arg6 *C.GCancellable  // out
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.void          // out
	var _arg3 C.gsize
	var _arg4 C.gboolean // out
	var _arg5 C.gsize    // in
	var _cerr *C.GError  // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg3 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg2 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	if blocking {
		_arg4 = C.TRUE
	}

	C.g_pollable_stream_write_all(_arg1, unsafe.Pointer(_arg2), _arg3, _arg4, &_arg5, _arg6, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg5)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// ResourcesEnumerateChildren returns all the names of children at the specified
// path in the set of globally registered resources. The return result is a NULL
// terminated list of strings which should be released with g_strfreev().
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - utf8s: array of constant strings.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret **C.char               // in
	var _cerr *C.GError              // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resources_enumerate_children(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// ResourcesGetInfo looks for a file at the specified path in the set of
// globally registered resources and if found returns information about it.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - size (optional): location to place the length of the contents of the
//     file, or NULL if the length is not needed.
//   - flags (optional): location to place the Flags about the file, or NULL if
//     the flags are not needed.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (uint, uint32, error) {
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _arg3 C.gsize                // in
	var _arg4 C.guint32              // in
	var _cerr *C.GError              // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	C.g_resources_get_info(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _size uint    // out
	var _flags uint32 // out
	var _goerr error  // out

	_size = uint(_arg3)
	_flags = uint32(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _size, _flags, _goerr
}

// ResourcesLookupData looks for a file at the specified path in the set of
// globally registered resources and returns a #GBytes that lets you directly
// access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - bytes or NULL on error. Free the returned object with g_bytes_unref().
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) (*glib.Bytes, error) {
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GBytes              // in
	var _cerr *C.GError              // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resources_lookup_data(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// ResourcesOpenStream looks for a file at the specified path in the set of
// globally registered resources and returns a Stream that lets you read the
// data.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - inputStream or NULL on error. Free the returned object with
//     g_object_unref().
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) (InputStreamer, error) {
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GInputStream        // in
	var _cerr *C.GError              // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resources_open_stream(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _inputStream InputStreamer // out
	var _goerr error               // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// ResourcesRegister registers the resource with the process-global set of
// resources. Once a resource is registered the files in it can be accessed with
// the global resource lookup functions like g_resources_lookup_data().
//
// The function takes the following parameters:
//
//   - resource: #GResource.
func ResourcesRegister(resource *Resource) {
	var _arg1 *C.GResource // out

	_arg1 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))

	C.g_resources_register(_arg1)
	runtime.KeepAlive(resource)
}

// ResourcesUnregister unregisters the resource from the process-global set of
// resources.
//
// The function takes the following parameters:
//
//   - resource: #GResource.
func ResourcesUnregister(resource *Resource) {
	var _arg1 *C.GResource // out

	_arg1 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))

	C.g_resources_unregister(_arg1)
	runtime.KeepAlive(resource)
}

// SimpleAsyncReportGErrorInIdle reports an error in an idle function. Similar
// to g_simple_async_report_error_in_idle(), but takes a #GError rather than
// building a new one.
//
// Deprecated: Use g_task_report_error().
//
// The function takes the following parameters:
//
//   - object (optional) or NULL.
//   - callback (optional): ReadyCallback.
//   - err to report.
func SimpleAsyncReportGErrorInIdle(object *coreglib.Object, callback AsyncReadyCallback, err error) {
	var _arg1 *C.GObject            // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer
	var _arg4 *C.GError // out

	if object != nil {
		_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}
	if err != nil {
		_arg4 = (*C.GError)(gerror.New(err))
	}

	C.g_simple_async_report_gerror_in_idle(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(object)
	runtime.KeepAlive(callback)
	runtime.KeepAlive(err)
}

// Action: GAction represents a single named action.
//
// The main interface to an action is that it can be activated with
// gio.Action.Activate(). This results in the 'activate' signal being emitted.
// An activation has a GVariant parameter (which may be NULL). The correct type
// for the parameter is determined by a static parameter type (which is given at
// construction time).
//
// An action may optionally have a state, in which case the state may be set
// with gio.Action.ChangeState(). This call takes a #GVariant. The correct
// type for the state is determined by a static state type (which is given at
// construction time).
//
// The state may have a hint associated with it, specifying its valid range.
//
// GAction is merely the interface to the concept of an action, as described
// above. Various implementations of actions exist, including gio.SimpleAction.
//
// In all cases, the implementing class is responsible for storing the name
// of the action, the parameter type, the enabled state, the optional state
// type and the state and emitting the appropriate signals when these change.
// The implementor is responsible for filtering calls to gio.Action.Activate()
// and gio.Action.ChangeState() for type safety and for the state being enabled.
//
// Probably the only useful thing to do with a GAction is to put it inside of a
// gio.SimpleActionGroup.
//
// Action wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Action struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Action)(nil)
)

// Actioner describes Action's interface methods.
type Actioner interface {
	coreglib.Objector

	// Activate activates the action.
	Activate(parameter *glib.Variant)
	// ChangeState: request for the state of action to be changed to value.
	ChangeState(value *glib.Variant)
	// Enabled checks if action is currently enabled.
	Enabled() bool
	// Name queries the name of action.
	Name() string
	// ParameterType queries the type of the parameter that must be given when
	// activating action.
	ParameterType() *glib.VariantType
	// State queries the current state of action.
	State() *glib.Variant
	// StateHint requests a hint about the valid range of values for the state
	// of action.
	StateHint() *glib.Variant
	// StateType queries the type of the state of action.
	StateType() *glib.VariantType
}

var _ Actioner = (*Action)(nil)

func wrapAction(obj *coreglib.Object) *Action {
	return &Action{
		Object: obj,
	}
}

func marshalAction(p uintptr) (interface{}, error) {
	return wrapAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Activate activates the action.
//
// parameter must be the correct type of parameter for the action (ie: the
// parameter type given at construction time). If the parameter type was NULL
// then parameter must also be NULL.
//
// If the parameter GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - parameter (optional) to the activation.
func (action *Action) Activate(parameter *glib.Variant) {
	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if parameter != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C.g_action_activate(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(parameter)
}

// ChangeState: request for the state of action to be changed to value.
//
// The action must be stateful and value must be of the correct type. See
// g_action_get_state_type().
//
// This call merely requests a change. The action may refuse to change
// its state or may change its state to something other than value. See
// g_action_get_state_hint().
//
// If the value GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - value: new state.
func (action *Action) ChangeState(value *glib.Variant) {
	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_action_change_state(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(value)
}

// Enabled checks if action is currently enabled.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// The function returns the following values:
//
//   - ok: whether the action is enabled.
func (action *Action) Enabled() bool {
	var _arg0 *C.GAction // out
	var _cret C.gboolean // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_enabled(_arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name queries the name of action.
//
// The function returns the following values:
//
//   - utf8: name of the action.
func (action *Action) Name() string {
	var _arg0 *C.GAction // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_name(_arg0)
	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ParameterType queries the type of the parameter that must be given when
// activating action.
//
// When activating the action using g_action_activate(), the #GVariant given to
// that function must be of the type returned by this function.
//
// In the case that this function returns NULL, you must not give any #GVariant,
// but NULL instead.
//
// The function returns the following values:
//
//   - variantType (optional): parameter type.
func (action *Action) ParameterType() *glib.VariantType {
	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_parameter_type(_arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// State queries the current state of action.
//
// If the action is not stateful then NULL will be returned. If the action
// is stateful then the type of the return value is the type given by
// g_action_get_state_type().
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//   - variant (optional): current state of the action.
func (action *Action) State() *glib.Variant {
	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_state(_arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// StateHint requests a hint about the valid range of values for the state of
// action.
//
// If NULL is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
//
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
//
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//   - variant (optional): state range hint.
func (action *Action) StateHint() *glib.Variant {
	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_state_hint(_arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// StateType queries the type of the state of action.
//
// If the action is stateful (e.g. created with g_simple_action_new_stateful())
// then this function returns the Type of the state. This is the type of the
// initial value given as the state. All calls to g_action_change_state()
// must give a #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
//
// If the action is not stateful (e.g. created with g_simple_action_new())
// then this function will return NULL. In that case, g_action_get_state() will
// return NULL and you must not call g_action_change_state().
//
// The function returns the following values:
//
//   - variantType (optional): state type, if the action is stateful.
func (action *Action) StateType() *glib.VariantType {
	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_state_type(_arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// Activate activates the action.
//
// parameter must be the correct type of parameter for the action (ie: the
// parameter type given at construction time). If the parameter type was NULL
// then parameter must also be NULL.
//
// If the parameter GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - parameter (optional) to the activation.
func (action *Action) activate(parameter *glib.Variant) {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.activate

	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if parameter != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C._gotk4_gio2_Action_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(parameter)
}

// changeState: request for the state of action to be changed to value.
//
// The action must be stateful and value must be of the correct type. See
// g_action_get_state_type().
//
// This call merely requests a change. The action may refuse to change
// its state or may change its state to something other than value. See
// g_action_get_state_hint().
//
// If the value GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - value: new state.
func (action *Action) changeState(value *glib.Variant) {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.change_state

	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C._gotk4_gio2_Action_virtual_change_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(value)
}

// Enabled checks if action is currently enabled.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// The function returns the following values:
//
//   - ok: whether the action is enabled.
func (action *Action) enabled() bool {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_enabled

	var _arg0 *C.GAction // out
	var _cret C.gboolean // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_enabled(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name queries the name of action.
//
// The function returns the following values:
//
//   - utf8: name of the action.
func (action *Action) name() string {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_name

	var _arg0 *C.GAction // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// parameterType queries the type of the parameter that must be given when
// activating action.
//
// When activating the action using g_action_activate(), the #GVariant given to
// that function must be of the type returned by this function.
//
// In the case that this function returns NULL, you must not give any #GVariant,
// but NULL instead.
//
// The function returns the following values:
//
//   - variantType (optional): parameter type.
func (action *Action) parameterType() *glib.VariantType {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_parameter_type

	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_parameter_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// State queries the current state of action.
//
// If the action is not stateful then NULL will be returned. If the action
// is stateful then the type of the return value is the type given by
// g_action_get_state_type().
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//   - variant (optional): current state of the action.
func (action *Action) state() *glib.Variant {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_state

	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_state(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// stateHint requests a hint about the valid range of values for the state of
// action.
//
// If NULL is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
//
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
//
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//   - variant (optional): state range hint.
func (action *Action) stateHint() *glib.Variant {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_state_hint

	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_state_hint(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// stateType queries the type of the state of action.
//
// If the action is stateful (e.g. created with g_simple_action_new_stateful())
// then this function returns the Type of the state. This is the type of the
// initial value given as the state. All calls to g_action_change_state()
// must give a #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
//
// If the action is not stateful (e.g. created with g_simple_action_new())
// then this function will return NULL. In that case, g_action_get_state() will
// return NULL and you must not call g_action_change_state().
//
// The function returns the following values:
//
//   - variantType (optional): state type, if the action is stateful.
func (action *Action) stateType() *glib.VariantType {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_state_type

	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_state_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// ActionNameIsValid checks if action_name is valid.
//
// action_name is valid if it consists only of alphanumeric characters, plus '-'
// and '.'. The empty string is not a valid action name.
//
// It is an error to call this function with a non-utf8 action_name. action_name
// must not be NULL.
//
// The function takes the following parameters:
//
//   - actionName: potential action name.
//
// The function returns the following values:
//
//   - ok: TRUE if action_name is valid.
func ActionNameIsValid(actionName string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_name_is_valid(_arg1)
	runtime.KeepAlive(actionName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActionParseDetailedName parses a detailed action name into its separate name
// and target components.
//
// Detailed action names can have three formats.
//
// The first format is used to represent an action name with no target value and
// consists of just an action name containing no whitespace nor the characters
// :, ( or ). For example: app.action.
//
// The second format is used to represent an action with a target value that is
// a non-empty string consisting only of alphanumerics, plus - and .. In that
// case, the action name and target value are separated by a double colon (::).
// For example: app.action::target.
//
// The third format is used to represent an action with any type of target
// value, including strings. The target value follows the action name,
// surrounded in parens. For example: app.action(42). The target value is
// parsed using g_variant_parse(). If a tuple-typed value is desired, it must
// be specified in the same way, resulting in two sets of parens, for example:
// app.action((1,2,3)). A string target can be specified this way as well:
// app.action('target'). For strings, this third format must be used if target
// value is empty or contains characters other than alphanumerics, - and ..
//
// If this function returns TRUE, a non-NULL value is guaranteed to be returned
// in action_name (if a pointer is passed in). A NULL value may still be
// returned in target_value, as the detailed_name may not contain a target.
//
// If returned, the #GVariant in target_value is guaranteed to not be floating.
//
// The function takes the following parameters:
//
//   - detailedName: detailed action name.
//
// The function returns the following values:
//
//   - actionName (optional): action name.
//   - targetValue (optional): target value, or NULL for no target.
func ActionParseDetailedName(detailedName string) (string, *glib.Variant, error) {
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // in
	var _arg3 *C.GVariant // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_parse_detailed_name(_arg1, &_arg2, &_arg3, &_cerr)
	runtime.KeepAlive(detailedName)

	var _actionName string         // out
	var _targetValue *glib.Variant // out
	var _goerr error               // out

	if _arg2 != nil {
		_actionName = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_targetValue = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_targetValue)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _actionName, _targetValue, _goerr
}

// ActionPrintDetailedName formats a detailed action name from action_name and
// target_value.
//
// It is an error to call this function with an invalid action name.
//
// This function is the opposite of g_action_parse_detailed_name(). It will
// produce a string that can be parsed back to the action_name and target_value
// by that function.
//
// See that function for the types of strings that will be printed by this
// function.
//
// The function takes the following parameters:
//
//   - actionName: valid action name.
//   - targetValue (optional) target value, or NULL.
//
// The function returns the following values:
//
//   - utf8: detailed format string.
func ActionPrintDetailedName(actionName string, targetValue *glib.Variant) string {
	var _arg1 *C.gchar    // out
	var _arg2 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if targetValue != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(targetValue)))
	}

	_cret = C.g_action_print_detailed_name(_arg1, _arg2)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(targetValue)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ActionGroup: GActionGroup represents a group of actions.
//
// Actions can be used to expose functionality in a structured way, either from
// one part of a program to another, or to the outside world. Action groups are
// often used together with a GMenuModel that provides additional representation
// data for displaying the actions to the user, e.g. in a menu.
//
// The main way to interact with the actions in a GActionGroup is to activate
// them with gio.ActionGroup.ActivateAction(). Activating an action may require
// a GVariant parameter. The required type of the parameter can be inquired
// with gio.ActionGroup.GetActionParameterType(). Actions may be disabled,
// see gio.ActionGroup.GetActionEnabled(). Activating a disabled action has no
// effect.
//
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with gio.ActionGroup.GetActionState().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling gio.ActionGroup.ChangeActionState().
//
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
//
// Each action in the group has a unique name (which is a string). All method
// calls, except gio.ActionGroup.ListActions() take the name of an action as an
// argument.
//
// The GActionGroup API is meant to be the 'public' API to the action group.
// The calls here are exactly the interaction that 'external forces' (eg: UI,
// incoming D-Bus messages, etc.) are supposed to have with actions. 'Internal'
// APIs (ie: ones meant only to be accessed by the action group implementation)
// are found on subclasses. This is why you will find - for example -
// gio.ActionGroup.GetActionEnabled() but not an equivalent set() call.
//
// Signals are emitted on the action group in response to state changes on
// individual actions.
//
// Implementations of GActionGroup should provide implementations
// for the virtual functions gio.ActionGroup.ListActions() and
// gio.ActionGroup.QueryAction(). The other virtual functions should not
// be implemented - their "wrappers" are actually implemented with calls to
// gio.ActionGroup.QueryAction().
//
// ActionGroup wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ActionGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ActionGroup)(nil)
)

// ActionGrouper describes ActionGroup's interface methods.
type ActionGrouper interface {
	coreglib.Objector

	// ActionAdded emits the Group::action-added signal on action_group.
	ActionAdded(actionName string)
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// action_group.
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved emits the Group::action-removed signal on action_group.
	ActionRemoved(actionName string)
	// ActionStateChanged emits the Group::action-state-changed signal on
	// action_group.
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction: activate the named action within action_group.
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState: request for the state of the named action within
	// action_group to be changed to value.
	ChangeActionState(actionName string, value *glib.Variant)
	// ActionEnabled checks if the named action within action_group is currently
	// enabled.
	ActionEnabled(actionName string) bool
	// ActionParameterType queries the type of the parameter that must be given
	// when activating the named action within action_group.
	ActionParameterType(actionName string) *glib.VariantType
	// ActionState queries the current state of the named action within
	// action_group.
	ActionState(actionName string) *glib.Variant
	// ActionStateHint requests a hint about the valid range of values for the
	// state of the named action within action_group.
	ActionStateHint(actionName string) *glib.Variant
	// ActionStateType queries the type of the state of the named action within
	// action_group.
	ActionStateType(actionName string) *glib.VariantType
	// HasAction checks if the named action exists within action_group.
	HasAction(actionName string) bool
	// ListActions lists the actions contained within action_group.
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// action_group.
	QueryAction(actionName string) (enabled bool, parameterType, stateType *glib.VariantType, stateHint, state *glib.Variant, ok bool)

	// Action-added signals that a new action was just added to the group.
	ConnectActionAdded(func(actionName string)) coreglib.SignalHandle
	// Action-enabled-changed signals that the enabled status of the named
	// action has changed.
	ConnectActionEnabledChanged(func(actionName string, enabled bool)) coreglib.SignalHandle
	// Action-removed signals that an action is just about to be removed from
	// the group.
	ConnectActionRemoved(func(actionName string)) coreglib.SignalHandle
	// Action-state-changed signals that the state of the named action has
	// changed.
	ConnectActionStateChanged(func(actionName string, value *glib.Variant)) coreglib.SignalHandle
}

var _ ActionGrouper = (*ActionGroup)(nil)

func wrapActionGroup(obj *coreglib.Object) *ActionGroup {
	return &ActionGroup{
		Object: obj,
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	return wrapActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActionAdded signals that a new action was just added to the group.
// This signal is emitted after the action has been added and is now visible.
func (actionGroup *ActionGroup) ConnectActionAdded(f func(actionName string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-added", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionAdded), f)
}

// ConnectActionEnabledChanged signals that the enabled status of the named
// action has changed.
func (actionGroup *ActionGroup) ConnectActionEnabledChanged(f func(actionName string, enabled bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-enabled-changed", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionEnabledChanged), f)
}

// ConnectActionRemoved signals that an action is just about to be removed from
// the group. This signal is emitted before the action is removed, so the action
// is still visible and can be queried from the signal handler.
func (actionGroup *ActionGroup) ConnectActionRemoved(f func(actionName string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-removed", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionRemoved), f)
}

// ConnectActionStateChanged signals that the state of the named action has
// changed.
func (actionGroup *ActionGroup) ConnectActionStateChanged(f func(actionName string, value *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-state-changed", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionStateChanged), f)
}

// ActionAdded emits the Group::action-added signal on action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
func (actionGroup *ActionGroup) ActionAdded(actionName string) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_group_action_added(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// ActionEnabledChanged emits the Group::action-enabled-changed signal on
// action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
//   - enabled: whether or not the action is now enabled.
func (actionGroup *ActionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if enabled {
		_arg2 = C.TRUE
	}

	C.g_action_group_action_enabled_changed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(enabled)
}

// ActionRemoved emits the Group::action-removed signal on action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
func (actionGroup *ActionGroup) ActionRemoved(actionName string) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_group_action_removed(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// ActionStateChanged emits the Group::action-state-changed signal on
// action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
//   - state: new state of the named action.
func (actionGroup *ActionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(state)))

	C.g_action_group_action_state_changed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(state)
}

// ActivateAction: activate the named action within action_group.
//
// If the action is expecting a parameter, then the correct type of parameter
// must be given as parameter. If the action is expecting no parameters then
// parameter must be NULL. See g_action_group_get_action_parameter_type().
//
// If the Group implementation supports asynchronous remote activation over
// D-Bus, this call may return before the relevant D-Bus traffic has been sent,
// or any replies have been received. In order to block on such asynchronous
// activation calls, g_dbus_connection_flush() should be called prior to the
// code, which depends on the result of the action activation. Without flushing
// the D-Bus connection, there is no guarantee that the action would have been
// activated.
//
// The following code which runs in a remote app instance, shows an example
// of a "quit" action being activated on the primary app instance over D-Bus.
// Here g_dbus_connection_flush() is called before exit(). Without
// g_dbus_connection_flush(), the "quit" action may fail to be activated on the
// primary instance.
//
//	// call "quit" action on primary instance
//	g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
//
//	// make sure the action is activated now
//	g_dbus_connection_flush (...);
//
//	g_debug ("application has been terminated. exiting.");
//
//	exit (0);.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to activate.
//   - parameter (optional) parameters to the activation.
func (actionGroup *ActionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameter != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C.g_action_group_activate_action(_arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(parameter)
}

// ChangeActionState: request for the state of the named action within
// action_group to be changed to value.
//
// The action must be stateful and value must be of the correct type. See
// g_action_group_get_action_state_type().
//
// This call merely requests a change. The action may refuse to change
// its state or may change its state to something other than value. See
// g_action_group_get_action_state_hint().
//
// If the value GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to request the change on.
//   - value: new state.
func (actionGroup *ActionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_action_group_change_action_state(_arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(value)
}

// ActionEnabled checks if the named action within action_group is currently
// enabled.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - ok: whether or not the action is currently enabled.
func (actionGroup *ActionGroup) ActionEnabled(actionName string) bool {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_enabled(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActionParameterType queries the type of the parameter that must be given when
// activating the named action within action_group.
//
// When activating the action using g_action_group_activate_action(),
// the #GVariant given to that function must be of the type returned by this
// function.
//
// In the case that this function returns NULL, you must not give any #GVariant,
// but NULL instead.
//
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added with
// the same name but a different parameter type.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variantType (optional): parameter type.
func (actionGroup *ActionGroup) ActionParameterType(actionName string) *glib.VariantType {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_parameter_type(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// ActionState queries the current state of the named action within
// action_group.
//
// If the action is not stateful then NULL will be returned. If the action
// is stateful then the type of the return value is the type given by
// g_action_group_get_action_state_type().
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variant (optional): current state of the action.
func (actionGroup *ActionGroup) ActionState(actionName string) *glib.Variant {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// ActionStateHint requests a hint about the valid range of values for the state
// of the named action within action_group.
//
// If NULL is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
//
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
//
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variant (optional): state range hint.
func (actionGroup *ActionGroup) ActionStateHint(actionName string) *glib.Variant {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state_hint(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// ActionStateType queries the type of the state of the named action within
// action_group.
//
// If the action is stateful then this function returns the Type of the state.
// All calls to g_action_group_change_action_state() must give a #GVariant of
// this type and g_action_group_get_action_state() will return a #GVariant of
// the same type.
//
// If the action is not stateful then this function will return NULL. In that
// case, g_action_group_get_action_state() will return NULL and you must not
// call g_action_group_change_action_state().
//
// The state type of a particular action will never change but it is possible
// for an action to be removed and for a new action to be added with the same
// name but a different state type.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variantType (optional): state type, if the action is stateful.
func (actionGroup *ActionGroup) ActionStateType(actionName string) *glib.VariantType {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state_type(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// HasAction checks if the named action exists within action_group.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to check for.
//
// The function returns the following values:
//
//   - ok: whether the named action exists.
func (actionGroup *ActionGroup) HasAction(actionName string) bool {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_has_action(_arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListActions lists the actions contained within action_group.
//
// The caller is responsible for freeing the list with g_strfreev() when it is
// no longer required.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of the names of the actions in the group.
func (actionGroup *ActionGroup) ListActions() []string {
	var _arg0 *C.GActionGroup // out
	var _cret **C.gchar       // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))

	_cret = C.g_action_group_list_actions(_arg0)
	runtime.KeepAlive(actionGroup)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// QueryAction queries all aspects of the named action within an action_group.
//
// This function acquires the information available from
// g_action_group_has_action(), g_action_group_get_action_enabled(),
// g_action_group_get_action_parameter_type(),
// g_action_group_get_action_state_type(),
// g_action_group_get_action_state_hint() and g_action_group_get_action_state()
// with a single function call.
//
// This provides two main benefits.
//
// The first is the improvement in efficiency that comes with not having to
// perform repeated lookups of the action in order to discover different things
// about it. The second is that implementing Group can now be done by only
// overriding this one virtual function.
//
// The interface provides a default implementation of this function that
// calls the individual functions, as required, to fetch the information.
// The interface also provides default implementations of those functions that
// call this function. All implementations, therefore, must override either this
// function or all of the others.
//
// If the action exists, TRUE is returned and any of the requested fields (as
// indicated by having a non-NULL reference passed in) are filled. If the action
// doesn't exist, FALSE is returned and the fields may or may not have been
// modified.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
//
// The function returns the following values:
//
//   - enabled: if the action is presently enabled.
//   - parameterType (optional): parameter type, or NULL if none needed.
//   - stateType (optional): state type, or NULL if stateless.
//   - stateHint (optional): state hint, or NULL if none.
//   - state (optional): current state, or NULL if stateless.
//   - ok: TRUE if the action exists, else FALSE.
func (actionGroup *ActionGroup) QueryAction(actionName string) (enabled bool, parameterType, stateType *glib.VariantType, stateHint, state *glib.Variant, ok bool) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // in
	var _arg3 *C.GVariantType // in
	var _arg4 *C.GVariantType // in
	var _arg5 *C.GVariant     // in
	var _arg6 *C.GVariant     // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_query_action(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _enabled bool                    // out
	var _parameterType *glib.VariantType // out
	var _stateType *glib.VariantType     // out
	var _stateHint *glib.Variant         // out
	var _state *glib.Variant             // out
	var _ok bool                         // out

	if _arg2 != 0 {
		_enabled = true
	}
	if _arg3 != nil {
		_parameterType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	}
	if _arg4 != nil {
		_stateType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_arg4)))
	}
	if _arg5 != nil {
		_stateHint = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_stateHint)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}
	if _arg6 != nil {
		_state = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_arg6)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_state)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _enabled, _parameterType, _stateType, _stateHint, _state, _ok
}

// actionAdded emits the Group::action-added signal on action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
func (actionGroup *ActionGroup) actionAdded(actionName string) {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.action_added

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_ActionGroup_virtual_action_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// actionEnabledChanged emits the Group::action-enabled-changed signal on
// action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
//   - enabled: whether or not the action is now enabled.
func (actionGroup *ActionGroup) actionEnabledChanged(actionName string, enabled bool) {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.action_enabled_changed

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if enabled {
		_arg2 = C.TRUE
	}

	C._gotk4_gio2_ActionGroup_virtual_action_enabled_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(enabled)
}

// actionRemoved emits the Group::action-removed signal on action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
func (actionGroup *ActionGroup) actionRemoved(actionName string) {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.action_removed

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_ActionGroup_virtual_action_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// actionStateChanged emits the Group::action-state-changed signal on
// action_group.
//
// This function should only be called by Group implementations.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
//   - state: new state of the named action.
func (actionGroup *ActionGroup) actionStateChanged(actionName string, state *glib.Variant) {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.action_state_changed

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(state)))

	C._gotk4_gio2_ActionGroup_virtual_action_state_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(state)
}

// activateAction: activate the named action within action_group.
//
// If the action is expecting a parameter, then the correct type of parameter
// must be given as parameter. If the action is expecting no parameters then
// parameter must be NULL. See g_action_group_get_action_parameter_type().
//
// If the Group implementation supports asynchronous remote activation over
// D-Bus, this call may return before the relevant D-Bus traffic has been sent,
// or any replies have been received. In order to block on such asynchronous
// activation calls, g_dbus_connection_flush() should be called prior to the
// code, which depends on the result of the action activation. Without flushing
// the D-Bus connection, there is no guarantee that the action would have been
// activated.
//
// The following code which runs in a remote app instance, shows an example
// of a "quit" action being activated on the primary app instance over D-Bus.
// Here g_dbus_connection_flush() is called before exit(). Without
// g_dbus_connection_flush(), the "quit" action may fail to be activated on the
// primary instance.
//
//	// call "quit" action on primary instance
//	g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
//
//	// make sure the action is activated now
//	g_dbus_connection_flush (...);
//
//	g_debug ("application has been terminated. exiting.");
//
//	exit (0);.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to activate.
//   - parameter (optional) parameters to the activation.
func (actionGroup *ActionGroup) activateAction(actionName string, parameter *glib.Variant) {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.activate_action

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameter != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C._gotk4_gio2_ActionGroup_virtual_activate_action(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(parameter)
}

// changeActionState: request for the state of the named action within
// action_group to be changed to value.
//
// The action must be stateful and value must be of the correct type. See
// g_action_group_get_action_state_type().
//
// This call merely requests a change. The action may refuse to change
// its state or may change its state to something other than value. See
// g_action_group_get_action_state_hint().
//
// If the value GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to request the change on.
//   - value: new state.
func (actionGroup *ActionGroup) changeActionState(actionName string, value *glib.Variant) {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.change_action_state

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C._gotk4_gio2_ActionGroup_virtual_change_action_state(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(value)
}

// actionEnabled checks if the named action within action_group is currently
// enabled.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - ok: whether or not the action is currently enabled.
func (actionGroup *ActionGroup) actionEnabled(actionName string) bool {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.get_action_enabled

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionGroup_virtual_get_action_enabled(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// actionParameterType queries the type of the parameter that must be given when
// activating the named action within action_group.
//
// When activating the action using g_action_group_activate_action(),
// the #GVariant given to that function must be of the type returned by this
// function.
//
// In the case that this function returns NULL, you must not give any #GVariant,
// but NULL instead.
//
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added with
// the same name but a different parameter type.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variantType (optional): parameter type.
func (actionGroup *ActionGroup) actionParameterType(actionName string) *glib.VariantType {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.get_action_parameter_type

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionGroup_virtual_get_action_parameter_type(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// actionState queries the current state of the named action within
// action_group.
//
// If the action is not stateful then NULL will be returned. If the action
// is stateful then the type of the return value is the type given by
// g_action_group_get_action_state_type().
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variant (optional): current state of the action.
func (actionGroup *ActionGroup) actionState(actionName string) *glib.Variant {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.get_action_state

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionGroup_virtual_get_action_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// actionStateHint requests a hint about the valid range of values for the state
// of the named action within action_group.
//
// If NULL is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
//
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
//
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variant (optional): state range hint.
func (actionGroup *ActionGroup) actionStateHint(actionName string) *glib.Variant {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.get_action_state_hint

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionGroup_virtual_get_action_state_hint(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// actionStateType queries the type of the state of the named action within
// action_group.
//
// If the action is stateful then this function returns the Type of the state.
// All calls to g_action_group_change_action_state() must give a #GVariant of
// this type and g_action_group_get_action_state() will return a #GVariant of
// the same type.
//
// If the action is not stateful then this function will return NULL. In that
// case, g_action_group_get_action_state() will return NULL and you must not
// call g_action_group_change_action_state().
//
// The state type of a particular action will never change but it is possible
// for an action to be removed and for a new action to be added with the same
// name but a different state type.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to query.
//
// The function returns the following values:
//
//   - variantType (optional): state type, if the action is stateful.
func (actionGroup *ActionGroup) actionStateType(actionName string) *glib.VariantType {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.get_action_state_type

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionGroup_virtual_get_action_state_type(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// hasAction checks if the named action exists within action_group.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to check for.
//
// The function returns the following values:
//
//   - ok: whether the named action exists.
func (actionGroup *ActionGroup) hasAction(actionName string) bool {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.has_action

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionGroup_virtual_has_action(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// listActions lists the actions contained within action_group.
//
// The caller is responsible for freeing the list with g_strfreev() when it is
// no longer required.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of the names of the actions in the group.
func (actionGroup *ActionGroup) listActions() []string {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.list_actions

	var _arg0 *C.GActionGroup // out
	var _cret **C.gchar       // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))

	_cret = C._gotk4_gio2_ActionGroup_virtual_list_actions(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(actionGroup)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// queryAction queries all aspects of the named action within an action_group.
//
// This function acquires the information available from
// g_action_group_has_action(), g_action_group_get_action_enabled(),
// g_action_group_get_action_parameter_type(),
// g_action_group_get_action_state_type(),
// g_action_group_get_action_state_hint() and g_action_group_get_action_state()
// with a single function call.
//
// This provides two main benefits.
//
// The first is the improvement in efficiency that comes with not having to
// perform repeated lookups of the action in order to discover different things
// about it. The second is that implementing Group can now be done by only
// overriding this one virtual function.
//
// The interface provides a default implementation of this function that
// calls the individual functions, as required, to fetch the information.
// The interface also provides default implementations of those functions that
// call this function. All implementations, therefore, must override either this
// function or all of the others.
//
// If the action exists, TRUE is returned and any of the requested fields (as
// indicated by having a non-NULL reference passed in) are filled. If the action
// doesn't exist, FALSE is returned and the fields may or may not have been
// modified.
//
// The function takes the following parameters:
//
//   - actionName: name of an action in the group.
//
// The function returns the following values:
//
//   - enabled: if the action is presently enabled.
//   - parameterType (optional): parameter type, or NULL if none needed.
//   - stateType (optional): state type, or NULL if stateless.
//   - stateHint (optional): state hint, or NULL if none.
//   - state (optional): current state, or NULL if stateless.
//   - ok: TRUE if the action exists, else FALSE.
func (actionGroup *ActionGroup) queryAction(actionName string) (enabled bool, parameterType, stateType *glib.VariantType, stateHint, state *glib.Variant, ok bool) {
	gclass := (*C.GActionGroupInterface)(coreglib.PeekParentClass(actionGroup))
	fnarg := gclass.query_action

	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // in
	var _arg3 *C.GVariantType // in
	var _arg4 *C.GVariantType // in
	var _arg5 *C.GVariant     // in
	var _arg6 *C.GVariant     // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionGroup_virtual_query_action(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var _enabled bool                    // out
	var _parameterType *glib.VariantType // out
	var _stateType *glib.VariantType     // out
	var _stateHint *glib.Variant         // out
	var _state *glib.Variant             // out
	var _ok bool                         // out

	if _arg2 != 0 {
		_enabled = true
	}
	if _arg3 != nil {
		_parameterType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	}
	if _arg4 != nil {
		_stateType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_arg4)))
	}
	if _arg5 != nil {
		_stateHint = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_stateHint)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}
	if _arg6 != nil {
		_state = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_arg6)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_state)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _enabled, _parameterType, _stateType, _stateHint, _state, _ok
}

// ActionMap: GActionMap is an interface for action containers.
//
// The GActionMap interface is implemented by gio.ActionGroup implementations
// that operate by containing a number of named gio.Action instances, such as
// gio.SimpleActionGroup.
//
// One useful application of this interface is to map the names of actions from
// various action groups to unique, prefixed names (e.g. by prepending "app." or
// "win."). This is the motivation for the 'Map' part of the interface name.
//
// ActionMap wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ActionMap struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ActionMap)(nil)
)

// ActionMapper describes ActionMap's interface methods.
type ActionMapper interface {
	coreglib.Objector

	// AddAction adds an action to the action_map.
	AddAction(action Actioner)
	// AddActionEntries: convenience function for creating multiple Action
	// instances and adding them to a Map.
	AddActionEntries(entries []ActionEntry, userData unsafe.Pointer)
	// LookupAction looks up the action with the name action_name in action_map.
	LookupAction(actionName string) *Action
	// RemoveAction removes the named action from the action map.
	RemoveAction(actionName string)
	// RemoveActionEntries: remove actions from a Map.
	RemoveActionEntries(entries []ActionEntry)
}

var _ ActionMapper = (*ActionMap)(nil)

func wrapActionMap(obj *coreglib.Object) *ActionMap {
	return &ActionMap{
		Object: obj,
	}
}

func marshalActionMap(p uintptr) (interface{}, error) {
	return wrapActionMap(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddAction adds an action to the action_map.
//
// If the action map already contains an action with the same name as action
// then the old action is dropped from the action map.
//
// The action map takes its own reference on action.
//
// The function takes the following parameters:
//
//   - action: #GAction.
func (actionMap *ActionMap) AddAction(action Actioner) {
	var _arg0 *C.GActionMap // out
	var _arg1 *C.GAction    // out

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg1 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	C.g_action_map_add_action(_arg0, _arg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(action)
}

// AddActionEntries: convenience function for creating multiple Action instances
// and adding them to a Map.
//
// Each action is constructed as per one Entry.
//
//	static void
//	activate_quit (GSimpleAction *simple,
//	               GVariant      *parameter,
//	               gpointer       user_data)
//	{
//	  exit (0);
//	}
//
//	static void
//	activate_print_string (GSimpleAction *simple,
//	                       GVariant      *parameter,
//	                       gpointer       user_data)
//	{
//	  g_print ("s\n", g_variant_get_string (parameter, NULL));
//	}
//
//	static GActionGroup *
//	create_action_group (void)
//	{
//	  const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	  };
//	  GSimpleActionGroup *group;
//
//	  group = g_simple_action_group_new ();
//	  g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
//
//	  return G_ACTION_GROUP (group);
//	}.
//
// The function takes the following parameters:
//
//   - entries: pointer to the first item in an array of Entry structs.
//   - userData (optional): user data for signal connections.
func (actionMap *ActionMap) AddActionEntries(entries []ActionEntry, userData unsafe.Pointer) {
	var _arg0 *C.GActionMap   // out
	var _arg1 *C.GActionEntry // out
	var _arg2 C.gint
	var _arg3 C.gpointer // out

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg2 = (C.gint)(len(entries))
	_arg1 = (*C.GActionEntry)(C.calloc(C.size_t(len(entries)), C.size_t(C.sizeof_GActionEntry)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GActionEntry)(_arg1), len(entries))
		for i := range entries {
			out[i] = *(*C.GActionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
		}
	}
	_arg3 = (C.gpointer)(unsafe.Pointer(userData))

	C.g_action_map_add_action_entries(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(entries)
	runtime.KeepAlive(userData)
}

// LookupAction looks up the action with the name action_name in action_map.
//
// If no such action exists, returns NULL.
//
// The function takes the following parameters:
//
//   - actionName: name of an action.
//
// The function returns the following values:
//
//   - action (optional) or NULL.
func (actionMap *ActionMap) LookupAction(actionName string) *Action {
	var _arg0 *C.GActionMap // out
	var _arg1 *C.gchar      // out
	var _cret *C.GAction    // in

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_map_lookup_action(_arg0, _arg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)

	var _action *Action // out

	if _cret != nil {
		_action = wrapAction(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _action
}

// RemoveAction removes the named action from the action map.
//
// If no action of this name is in the map then nothing happens.
//
// The function takes the following parameters:
//
//   - actionName: name of the action.
func (actionMap *ActionMap) RemoveAction(actionName string) {
	var _arg0 *C.GActionMap // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_map_remove_action(_arg0, _arg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)
}

// RemoveActionEntries: remove actions from a Map. This is meant as the reverse
// of g_action_map_add_action_entries().
//
//	static const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	};
//
//	void
//	add_actions (GActionMap *map)
//	{
//	  g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
//	}
//
//	void
//	remove_actions (GActionMap *map)
//	{
//	  g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
//	}.
//
// The function takes the following parameters:
//
//   - entries: pointer to the first item in an array of Entry structs.
func (actionMap *ActionMap) RemoveActionEntries(entries []ActionEntry) {
	var _arg0 *C.GActionMap   // out
	var _arg1 *C.GActionEntry // out
	var _arg2 C.gint

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg2 = (C.gint)(len(entries))
	_arg1 = (*C.GActionEntry)(C.calloc(C.size_t(len(entries)), C.size_t(C.sizeof_GActionEntry)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GActionEntry)(_arg1), len(entries))
		for i := range entries {
			out[i] = *(*C.GActionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
		}
	}

	C.g_action_map_remove_action_entries(_arg0, _arg1, _arg2)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(entries)
}

// addAction adds an action to the action_map.
//
// If the action map already contains an action with the same name as action
// then the old action is dropped from the action map.
//
// The action map takes its own reference on action.
//
// The function takes the following parameters:
//
//   - action: #GAction.
func (actionMap *ActionMap) addAction(action Actioner) {
	gclass := (*C.GActionMapInterface)(coreglib.PeekParentClass(actionMap))
	fnarg := gclass.add_action

	var _arg0 *C.GActionMap // out
	var _arg1 *C.GAction    // out

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg1 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	C._gotk4_gio2_ActionMap_virtual_add_action(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(action)
}

// lookupAction looks up the action with the name action_name in action_map.
//
// If no such action exists, returns NULL.
//
// The function takes the following parameters:
//
//   - actionName: name of an action.
//
// The function returns the following values:
//
//   - action (optional) or NULL.
func (actionMap *ActionMap) lookupAction(actionName string) *Action {
	gclass := (*C.GActionMapInterface)(coreglib.PeekParentClass(actionMap))
	fnarg := gclass.lookup_action

	var _arg0 *C.GActionMap // out
	var _arg1 *C.gchar      // out
	var _cret *C.GAction    // in

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ActionMap_virtual_lookup_action(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)

	var _action *Action // out

	if _cret != nil {
		_action = wrapAction(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _action
}

// removeAction removes the named action from the action map.
//
// If no action of this name is in the map then nothing happens.
//
// The function takes the following parameters:
//
//   - actionName: name of the action.
func (actionMap *ActionMap) removeAction(actionName string) {
	gclass := (*C.GActionMapInterface)(coreglib.PeekParentClass(actionMap))
	fnarg := gclass.remove_action

	var _arg0 *C.GActionMap // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GActionMap)(unsafe.Pointer(coreglib.InternObject(actionMap).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_ActionMap_virtual_remove_action(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)
}

// AppInfo: information about an installed application and methods to launch it
// (with file arguments).
//
// GAppInfo and GAppLaunchContext are used for describing and launching
// applications installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// gio.File.GetPath()) when using gio.AppInfo.Launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key totem U and a single URI, sftp://foo/file.avi,
// then /home/user/.gvfs/sftp on foo/file.avi will be passed. This will only
// work if a set of suitable GIO extensions (such as GVfs 2.26 compiled with
// FUSE support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as mailto:,
// of course cannot be mapped to a POSIX path (in GVfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for GVfs 2.26 and later, the POSIX URI will be mapped back
// to the GIO URI in the gio.File constructors (since GVfs implements the
// GVfs extension point). As such, if the application needs to examine
// the URI, it needs to use gio.File.GetURI() or similar on gio.File.
// In other words, an application cannot assume that the URI passed to e.g.
// gio.File().NewForCommandlineArg is equal to the result of gio.File.GetURI().
// The following snippet illustrates this:
//
//	GFile *f;
//	char *uri;
//
//	file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//	uri = g_file_get_uri (file);
//	strcmp (uri, uri_from_commandline) == 0;
//	g_free (uri);
//
//	if (g_file_has_uri_scheme (file, "cdda"))
//	  {
//	    // do something special with uri
//	  }
//	g_object_unref (file);
//
// This code will work when both cdda://sr0/Track 1.wav and
// /home/user/.gvfs/cdda on sr0/Track 1.wav is passed to the application.
// It should be noted that it's generally not safe for applications to rely
// on the format of a particular URIs. Different launcher applications (e.g.
// file managers) may have different ideas of what a given URI means.
//
// AppInfo wraps an interface. This means the user can get the
// underlying type by calling Cast().
type AppInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppInfo)(nil)
)

// AppInfor describes AppInfo's interface methods.
type AppInfor interface {
	coreglib.Objector

	// AddSupportsType adds a content type to the application information to
	// indicate the application is capable of opening files with the given
	// content type.
	AddSupportsType(contentType string) error
	// CanDelete obtains the information whether the Info can be deleted.
	CanDelete() bool
	// CanRemoveSupportsType checks if a supported content type can be removed
	// from an application.
	CanRemoveSupportsType() bool
	// Delete tries to delete a Info.
	Delete() bool
	// Dup creates a duplicate of a Info.
	Dup() *AppInfo
	// Equal checks if two Infos are equal.
	Equal(appinfo2 AppInfor) bool
	// Commandline gets the commandline with which the application will be
	// started.
	Commandline() string
	// Description gets a human-readable description of an installed
	// application.
	Description() string
	// DisplayName gets the display name of the application.
	DisplayName() string
	// Executable gets the executable's name for the installed application.
	Executable() string
	// Icon gets the icon for the application.
	Icon() *Icon
	// ID gets the ID of an application.
	ID() string
	// Name gets the installed name of the application.
	Name() string
	// SupportedTypes retrieves the list of content types that app_info claims
	// to support.
	SupportedTypes() []string
	// Launch launches the application.
	Launch(files []Filer, context *AppLaunchContext) error
	// LaunchURIs launches the application.
	LaunchURIs(uris []string, context *AppLaunchContext) error
	// LaunchURIsAsync: async version of g_app_info_launch_uris().
	LaunchURIsAsync(ctx context.Context, uris []string, context *AppLaunchContext, callback AsyncReadyCallback)
	// LaunchURIsFinish finishes a g_app_info_launch_uris_async() operation.
	LaunchURIsFinish(result AsyncResulter) error
	// RemoveSupportsType removes a supported type from an application,
	// if possible.
	RemoveSupportsType(contentType string) error
	// SetAsDefaultForExtension sets the application as the default handler for
	// the given file extension.
	SetAsDefaultForExtension(extension string) error
	// SetAsDefaultForType sets the application as the default handler for a
	// given type.
	SetAsDefaultForType(contentType string) error
	// SetAsLastUsedForType sets the application as the last used application
	// for a given type.
	SetAsLastUsedForType(contentType string) error
	// ShouldShow checks if the application info should be shown in menus that
	// list available applications.
	ShouldShow() bool
	// SupportsFiles checks if the application accepts files as arguments.
	SupportsFiles() bool
	// SupportsURIs checks if the application supports reading files and
	// directories from URIs.
	SupportsURIs() bool
}

var _ AppInfor = (*AppInfo)(nil)

func wrapAppInfo(obj *coreglib.Object) *AppInfo {
	return &AppInfo{
		Object: obj,
	}
}

func marshalAppInfo(p uintptr) (interface{}, error) {
	return wrapAppInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddSupportsType adds a content type to the application information to
// indicate the application is capable of opening files with the given content
// type.
//
// The function takes the following parameters:
//
//   - contentType: string.
func (appinfo *AppInfo) AddSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_add_supports_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CanDelete obtains the information whether the Info can be deleted. See
// g_app_info_delete().
//
// The function returns the following values:
//
//   - ok: TRUE if appinfo can be deleted.
func (appinfo *AppInfo) CanDelete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_can_delete(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanRemoveSupportsType checks if a supported content type can be removed from
// an application.
//
// The function returns the following values:
//
//   - ok: TRUE if it is possible to remove supported content types from a given
//     appinfo, FALSE if not.
func (appinfo *AppInfo) CanRemoveSupportsType() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_can_remove_supports_type(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Delete tries to delete a Info.
//
// On some platforms, there may be a difference between user-defined
// Infos which can be deleted, and system-wide ones which cannot. See
// g_app_info_can_delete().
//
// The function returns the following values:
//
//   - ok: TRUE if appinfo has been deleted.
func (appinfo *AppInfo) Delete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_delete(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dup creates a duplicate of a Info.
//
// The function returns the following values:
//
//   - appInfo: duplicate of appinfo.
func (appinfo *AppInfo) Dup() *AppInfo {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GAppInfo // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_dup(_arg0)
	runtime.KeepAlive(appinfo)

	var _appInfo *AppInfo // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appInfo
}

// Equal checks if two Infos are equal.
//
// Note that the check *may not* compare each individual field, and only does
// an identity check. In case detecting changes in the contents is needed,
// program code must additionally compare relevant fields.
//
// The function takes the following parameters:
//
//   - appinfo2: second Info.
//
// The function returns the following values:
//
//   - ok: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.
func (appinfo1 *AppInfo) Equal(appinfo2 AppInfor) bool {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo1).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo2).Native()))

	_cret = C.g_app_info_equal(_arg0, _arg1)
	runtime.KeepAlive(appinfo1)
	runtime.KeepAlive(appinfo2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Commandline gets the commandline with which the application will be started.
//
// The function returns the following values:
//
//   - filename (optional): string containing the appinfo's commandline, or NULL
//     if this information is not available.
func (appinfo *AppInfo) Commandline() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_commandline(_arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// Description gets a human-readable description of an installed application.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing a description of the application
//     appinfo, or NULL if none.
func (appinfo *AppInfo) Description() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_description(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DisplayName gets the display name of the application. The display name is
// often more descriptive to the user than the name itself.
//
// The function returns the following values:
//
//   - utf8: display name of the application for appinfo, or the name if no
//     display name is available.
func (appinfo *AppInfo) DisplayName() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_display_name(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Executable gets the executable's name for the installed application.
//
// This is intended to be used for debugging or labelling what program is going
// to be run. To launch the executable, use g_app_info_launch() and related
// functions, rather than spawning the return value from this function.
//
// The function returns the following values:
//
//   - filename: string containing the appinfo's application binaries name.
func (appinfo *AppInfo) Executable() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_executable(_arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Icon gets the icon for the application.
//
// The function returns the following values:
//
//   - icon (optional): default #GIcon for appinfo or NULL if there is no
//     default icon.
func (appinfo *AppInfo) Icon() *Icon {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_icon(_arg0)
	runtime.KeepAlive(appinfo)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// ID gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
//
// Note that the returned ID may be NULL, depending on how the appinfo has been
// constructed.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the application's ID.
func (appinfo *AppInfo) ID() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_id(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name gets the installed name of the application.
//
// The function returns the following values:
//
//   - utf8: name of the application for appinfo.
func (appinfo *AppInfo) Name() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_name(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SupportedTypes retrieves the list of content types that app_info claims
// to support. If this information is not provided by the environment,
// this function will return NULL. This function does not take in consideration
// associations added with g_app_info_add_supports_type(), but only those
// exported directly by the application.
//
// The function returns the following values:
//
//   - utf8s: a list of content types.
func (appinfo *AppInfo) SupportedTypes() []string {
	var _arg0 *C.GAppInfo // out
	var _cret **C.char    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_supported_types(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Launch launches the application. Passes files to the launched application as
// arguments, using the optional context to get information about the details
// of the launcher (like what screen it is on). On error, error will be set
// accordingly.
//
// To launch the application without arguments pass a NULL files list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// Some URIs can be changed when passed through a GFile (for instance
// unsupported URIs with strange formats like mailto:), so if you have a textual
// URI you want to pass in as argument, consider using g_app_info_launch_uris()
// instead.
//
// The launched application inherits the environment of the launching
// process, but it can be modified with g_app_launch_context_setenv() and
// g_app_launch_context_unsetenv().
//
// On UNIX, this function sets the GIO_LAUNCHED_DESKTOP_FILE
// environment variable with the path of the launched desktop file and
// GIO_LAUNCHED_DESKTOP_FILE_PID to the process id of the launched process. This
// can be used to ignore GIO_LAUNCHED_DESKTOP_FILE, should it be inherited by
// further processes. The DISPLAY, XDG_ACTIVATION_TOKEN and DESKTOP_STARTUP_ID
// environment variables are also set, based on information provided in context.
//
// The function takes the following parameters:
//
//   - files (optional) of #GFile objects.
//   - context (optional) or NULL.
func (appinfo *AppInfo) Launch(files []Filer, context *AppLaunchContext) error {
	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if files != nil {
		for i := len(files) - 1; i >= 0; i-- {
			src := files[i]
			var dst *C.GFile // out
			dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C.g_app_info_launch(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(files)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LaunchURIs launches the application. This passes the uris to the launched
// application as arguments, using the optional context to get information about
// the details of the launcher (like what screen it is on). On error, error will
// be set accordingly. If the application only supports one URI per invocation
// as part of their command-line, multiple instances of the application will be
// spawned.
//
// To launch the application without arguments pass a NULL uris list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// The function takes the following parameters:
//
//   - uris (optional) containing URIs to launch.
//   - context (optional) or NULL.
func (appinfo *AppInfo) LaunchURIs(uris []string, context *AppLaunchContext) error {
	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C.g_app_info_launch_uris(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LaunchURIsAsync: async version of g_app_info_launch_uris().
//
// The callback is invoked immediately after the application launch,
// but it waits for activation in case of D-Busactivated applications and also
// provides extended error information for sandboxed applications, see notes for
// g_app_info_launch_default_for_uri_async().
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - uris (optional) containing URIs to launch.
//   - context (optional) or NULL.
//   - callback (optional) to call when the request is done.
func (appinfo *AppInfo) LaunchURIsAsync(ctx context.Context, uris []string, context *AppLaunchContext, callback AsyncReadyCallback) {
	var _arg0 *C.GAppInfo           // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GList              // out
	var _arg2 *C.GAppLaunchContext  // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_app_info_launch_uris_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)
	runtime.KeepAlive(callback)
}

// LaunchURIsFinish finishes a g_app_info_launch_uris_async() operation.
//
// The function takes the following parameters:
//
//   - result: Result.
func (appinfo *AppInfo) LaunchURIsFinish(result AsyncResulter) error {
	var _arg0 *C.GAppInfo     // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_app_info_launch_uris_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveSupportsType removes a supported type from an application, if possible.
//
// The function takes the following parameters:
//
//   - contentType: string.
func (appinfo *AppInfo) RemoveSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_remove_supports_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsDefaultForExtension sets the application as the default handler for the
// given file extension.
//
// The function takes the following parameters:
//
//   - extension: string containing the file extension (without the dot).
func (appinfo *AppInfo) SetAsDefaultForExtension(extension string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_extension(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(extension)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsDefaultForType sets the application as the default handler for a given
// type.
//
// The function takes the following parameters:
//
//   - contentType: content type.
func (appinfo *AppInfo) SetAsDefaultForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsLastUsedForType sets the application as the last used application for
// a given type. This will make the application appear as first in the list
// returned by g_app_info_get_recommended_for_type(), regardless of the default
// application for that content type.
//
// The function takes the following parameters:
//
//   - contentType: content type.
func (appinfo *AppInfo) SetAsLastUsedForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_last_used_for_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ShouldShow checks if the application info should be shown in menus that list
// available applications.
//
// The function returns the following values:
//
//   - ok: TRUE if the appinfo should be shown, FALSE otherwise.
func (appinfo *AppInfo) ShouldShow() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_should_show(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsFiles checks if the application accepts files as arguments.
//
// The function returns the following values:
//
//   - ok: TRUE if the appinfo supports files.
func (appinfo *AppInfo) SupportsFiles() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_supports_files(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsURIs checks if the application supports reading files and directories
// from URIs.
//
// The function returns the following values:
//
//   - ok: TRUE if the appinfo supports URIs.
func (appinfo *AppInfo) SupportsURIs() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_supports_uris(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// addSupportsType adds a content type to the application information to
// indicate the application is capable of opening files with the given content
// type.
//
// The function takes the following parameters:
//
//   - contentType: string.
func (appinfo *AppInfo) addSupportsType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.add_supports_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_add_supports_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// canDelete obtains the information whether the Info can be deleted. See
// g_app_info_delete().
//
// The function returns the following values:
//
//   - ok: TRUE if appinfo can be deleted.
func (appinfo *AppInfo) canDelete() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.can_delete

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_can_delete(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canRemoveSupportsType checks if a supported content type can be removed from
// an application.
//
// The function returns the following values:
//
//   - ok: TRUE if it is possible to remove supported content types from a given
//     appinfo, FALSE if not.
func (appinfo *AppInfo) canRemoveSupportsType() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.can_remove_supports_type

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_can_remove_supports_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// doDelete tries to delete a Info.
//
// On some platforms, there may be a difference between user-defined
// Infos which can be deleted, and system-wide ones which cannot. See
// g_app_info_can_delete().
//
// The function returns the following values:
//
//   - ok: TRUE if appinfo has been deleted.
func (appinfo *AppInfo) doDelete() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.do_delete

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_do_delete(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dup creates a duplicate of a Info.
//
// The function returns the following values:
//
//   - appInfo: duplicate of appinfo.
func (appinfo *AppInfo) dup() *AppInfo {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.dup

	var _arg0 *C.GAppInfo // out
	var _cret *C.GAppInfo // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_dup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _appInfo *AppInfo // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appInfo
}

// Equal checks if two Infos are equal.
//
// Note that the check *may not* compare each individual field, and only does
// an identity check. In case detecting changes in the contents is needed,
// program code must additionally compare relevant fields.
//
// The function takes the following parameters:
//
//   - appinfo2: second Info.
//
// The function returns the following values:
//
//   - ok: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.
func (appinfo1 *AppInfo) equal(appinfo2 AppInfor) bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo1))
	fnarg := gclass.equal

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo1).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo2).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_equal(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appinfo1)
	runtime.KeepAlive(appinfo2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Commandline gets the commandline with which the application will be started.
//
// The function returns the following values:
//
//   - filename (optional): string containing the appinfo's commandline, or NULL
//     if this information is not available.
func (appinfo *AppInfo) commandline() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_commandline

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_commandline(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// Description gets a human-readable description of an installed application.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing a description of the application
//     appinfo, or NULL if none.
func (appinfo *AppInfo) description() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_description

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_description(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// displayName gets the display name of the application. The display name is
// often more descriptive to the user than the name itself.
//
// The function returns the following values:
//
//   - utf8: display name of the application for appinfo, or the name if no
//     display name is available.
func (appinfo *AppInfo) displayName() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_display_name

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_display_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Executable gets the executable's name for the installed application.
//
// This is intended to be used for debugging or labelling what program is going
// to be run. To launch the executable, use g_app_info_launch() and related
// functions, rather than spawning the return value from this function.
//
// The function returns the following values:
//
//   - filename: string containing the appinfo's application binaries name.
func (appinfo *AppInfo) executable() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_executable

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_executable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Icon gets the icon for the application.
//
// The function returns the following values:
//
//   - icon (optional): default #GIcon for appinfo or NULL if there is no
//     default icon.
func (appinfo *AppInfo) icon() *Icon {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_icon

	var _arg0 *C.GAppInfo // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// iD gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
//
// Note that the returned ID may be NULL, depending on how the appinfo has been
// constructed.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the application's ID.
func (appinfo *AppInfo) iD() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_id

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_id(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name gets the installed name of the application.
//
// The function returns the following values:
//
//   - utf8: name of the application for appinfo.
func (appinfo *AppInfo) name() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_name

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// supportedTypes retrieves the list of content types that app_info claims
// to support. If this information is not provided by the environment,
// this function will return NULL. This function does not take in consideration
// associations added with g_app_info_add_supports_type(), but only those
// exported directly by the application.
//
// The function returns the following values:
//
//   - utf8s: a list of content types.
func (appinfo *AppInfo) supportedTypes() []string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_supported_types

	var _arg0 *C.GAppInfo // out
	var _cret **C.char    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_supported_types(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Launch launches the application. Passes files to the launched application as
// arguments, using the optional context to get information about the details
// of the launcher (like what screen it is on). On error, error will be set
// accordingly.
//
// To launch the application without arguments pass a NULL files list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// Some URIs can be changed when passed through a GFile (for instance
// unsupported URIs with strange formats like mailto:), so if you have a textual
// URI you want to pass in as argument, consider using g_app_info_launch_uris()
// instead.
//
// The launched application inherits the environment of the launching
// process, but it can be modified with g_app_launch_context_setenv() and
// g_app_launch_context_unsetenv().
//
// On UNIX, this function sets the GIO_LAUNCHED_DESKTOP_FILE
// environment variable with the path of the launched desktop file and
// GIO_LAUNCHED_DESKTOP_FILE_PID to the process id of the launched process. This
// can be used to ignore GIO_LAUNCHED_DESKTOP_FILE, should it be inherited by
// further processes. The DISPLAY, XDG_ACTIVATION_TOKEN and DESKTOP_STARTUP_ID
// environment variables are also set, based on information provided in context.
//
// The function takes the following parameters:
//
//   - files (optional) of #GFile objects.
//   - context (optional) or NULL.
func (appinfo *AppInfo) launch(files []Filer, context *AppLaunchContext) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.launch

	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if files != nil {
		for i := len(files) - 1; i >= 0; i-- {
			src := files[i]
			var dst *C.GFile // out
			dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C._gotk4_gio2_AppInfo_virtual_launch(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(files)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// launchURIs launches the application. This passes the uris to the launched
// application as arguments, using the optional context to get information about
// the details of the launcher (like what screen it is on). On error, error will
// be set accordingly. If the application only supports one URI per invocation
// as part of their command-line, multiple instances of the application will be
// spawned.
//
// To launch the application without arguments pass a NULL uris list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// The function takes the following parameters:
//
//   - uris (optional) containing URIs to launch.
//   - context (optional) or NULL.
func (appinfo *AppInfo) launchURIs(uris []string, context *AppLaunchContext) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.launch_uris

	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C._gotk4_gio2_AppInfo_virtual_launch_uris(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// launchURIsAsync: async version of g_app_info_launch_uris().
//
// The callback is invoked immediately after the application launch,
// but it waits for activation in case of D-Busactivated applications and also
// provides extended error information for sandboxed applications, see notes for
// g_app_info_launch_default_for_uri_async().
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - uris (optional) containing URIs to launch.
//   - context (optional) or NULL.
//   - callback (optional) to call when the request is done.
func (appinfo *AppInfo) launchURIsAsync(ctx context.Context, uris []string, context *AppLaunchContext, callback AsyncReadyCallback) {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.launch_uris_async

	var _arg0 *C.GAppInfo           // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GList              // out
	var _arg2 *C.GAppLaunchContext  // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_AppInfo_virtual_launch_uris_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)
	runtime.KeepAlive(callback)
}

// launchURIsFinish finishes a g_app_info_launch_uris_async() operation.
//
// The function takes the following parameters:
//
//   - result: Result.
func (appinfo *AppInfo) launchURIsFinish(result AsyncResulter) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.launch_uris_finish

	var _arg0 *C.GAppInfo     // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_AppInfo_virtual_launch_uris_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// removeSupportsType removes a supported type from an application, if possible.
//
// The function takes the following parameters:
//
//   - contentType: string.
func (appinfo *AppInfo) removeSupportsType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.remove_supports_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_remove_supports_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAsDefaultForExtension sets the application as the default handler for the
// given file extension.
//
// The function takes the following parameters:
//
//   - extension: string containing the file extension (without the dot).
func (appinfo *AppInfo) setAsDefaultForExtension(extension string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.set_as_default_for_extension

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_set_as_default_for_extension(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(extension)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAsDefaultForType sets the application as the default handler for a given
// type.
//
// The function takes the following parameters:
//
//   - contentType: content type.
func (appinfo *AppInfo) setAsDefaultForType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.set_as_default_for_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_set_as_default_for_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAsLastUsedForType sets the application as the last used application for
// a given type. This will make the application appear as first in the list
// returned by g_app_info_get_recommended_for_type(), regardless of the default
// application for that content type.
//
// The function takes the following parameters:
//
//   - contentType: content type.
func (appinfo *AppInfo) setAsLastUsedForType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.set_as_last_used_for_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_set_as_last_used_for_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// shouldShow checks if the application info should be shown in menus that list
// available applications.
//
// The function returns the following values:
//
//   - ok: TRUE if the appinfo should be shown, FALSE otherwise.
func (appinfo *AppInfo) shouldShow() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.should_show

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_should_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// supportsFiles checks if the application accepts files as arguments.
//
// The function returns the following values:
//
//   - ok: TRUE if the appinfo supports files.
func (appinfo *AppInfo) supportsFiles() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.supports_files

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_supports_files(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// supportsURIs checks if the application supports reading files and directories
// from URIs.
//
// The function returns the following values:
//
//   - ok: TRUE if the appinfo supports URIs.
func (appinfo *AppInfo) supportsURIs() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.supports_uris

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_supports_uris(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppInfoCreateFromCommandline creates a new Info from the given information.
//
// Note that for commandline, the quoting rules of the Exec
// key of the freedesktop.org Desktop Entry Specification
// (http://freedesktop.org/Standards/desktop-entry-spec) are applied.
// For example, if the commandline contains percent-encoded URIs, the
// percent-character must be doubled in order to prevent it from being swallowed
// by Exec key unquoting. See the specification for exact quoting rules.
//
// The function takes the following parameters:
//
//   - commandline to use.
//   - applicationName (optional): application name, or NULL to use commandline.
//   - flags that can specify details of the created Info.
//
// The function returns the following values:
//
//   - appInfo: new Info for given command.
func AppInfoCreateFromCommandline(commandline, applicationName string, flags AppInfoCreateFlags) (*AppInfo, error) {
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 C.GAppInfoCreateFlags // out
	var _cret *C.GAppInfo           // in
	var _cerr *C.GError             // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(commandline)))
	defer C.free(unsafe.Pointer(_arg1))
	if applicationName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(applicationName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.GAppInfoCreateFlags(flags)

	_cret = C.g_app_info_create_from_commandline(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(commandline)
	runtime.KeepAlive(applicationName)
	runtime.KeepAlive(flags)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// AppInfoGetAll gets a list of all of the applications currently registered on
// this system.
//
// For desktop files, this includes applications that have NoDisplay=true
// set or are excluded from display by means of OnlyShowIn or NotShowIn.
// See g_app_info_should_show(). The returned list does not include applications
// which have the Hidden key set.
//
// The function returns the following values:
//
//   - list: newly allocated #GList of references to Infos.
func AppInfoGetAll() []*AppInfo {
	var _cret *C.GList // in

	_cret = C.g_app_info_get_all()

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetAllForType gets a list of all Infos for a given
// content type, including the recommended and fallback Infos. See
// g_app_info_get_recommended_for_type() and g_app_info_get_fallback_for_type().
//
// The function takes the following parameters:
//
//   - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//   - list of Infos for given content_type or NULL on error.
func AppInfoGetAllForType(contentType string) []*AppInfo {
	var _arg1 *C.char  // out
	var _cret *C.GList // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_all_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetDefaultForType gets the default Info for a given content type.
//
// The function takes the following parameters:
//
//   - contentType: content type to find a Info for.
//   - mustSupportUris: if TRUE, the Info is expected to support URIs.
//
// The function returns the following values:
//
//   - appInfo (optional) for given content_type or NULL on error.
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) *AppInfo {
	var _arg1 *C.char     // out
	var _arg2 C.gboolean  // out
	var _cret *C.GAppInfo // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))
	if mustSupportUris {
		_arg2 = C.TRUE
	}

	_cret = C.g_app_info_get_default_for_type(_arg1, _arg2)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)

	var _appInfo *AppInfo // out

	if _cret != nil {
		_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _appInfo
}

// AppInfoGetDefaultForTypeAsync: asynchronously gets the default Info for a
// given content type.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - contentType: content type to find a Info for.
//   - mustSupportUris: if TRUE, the Info is expected to support URIs.
//   - callback (optional) to call when the request is done.
func AppInfoGetDefaultForTypeAsync(ctx context.Context, contentType string, mustSupportUris bool, callback AsyncReadyCallback) {
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gboolean            // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))
	if mustSupportUris {
		_arg2 = C.TRUE
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_app_info_get_default_for_type_async(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)
	runtime.KeepAlive(callback)
}

// AppInfoGetDefaultForTypeFinish finishes a default Info lookup started by
// g_app_info_get_default_for_type_async().
//
// If no Info is found, then error will be set to G_IO_ERROR_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - appInfo for given content_type or NULL on error.
func AppInfoGetDefaultForTypeFinish(result AsyncResulter) (*AppInfo, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GAppInfo     // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_app_info_get_default_for_type_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// AppInfoGetDefaultForURIScheme gets the default application for handling URIs
// with the given URI scheme. A URI scheme is the initial part of the URI,
// up to but not including the ':', e.g. "http", "ftp" or "sip".
//
// The function takes the following parameters:
//
//   - uriScheme: string containing a URI scheme.
//
// The function returns the following values:
//
//   - appInfo (optional) for given uri_scheme or NULL on error.
func AppInfoGetDefaultForURIScheme(uriScheme string) *AppInfo {
	var _arg1 *C.char     // out
	var _cret *C.GAppInfo // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_default_for_uri_scheme(_arg1)
	runtime.KeepAlive(uriScheme)

	var _appInfo *AppInfo // out

	if _cret != nil {
		_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _appInfo
}

// AppInfoGetDefaultForURISchemeAsync: asynchronously gets the default
// application for handling URIs with the given URI scheme. A URI scheme is
// the initial part of the URI, up to but not including the ':', e.g. "http",
// "ftp" or "sip".
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - uriScheme: string containing a URI scheme.
//   - callback (optional) to call when the request is done.
func AppInfoGetDefaultForURISchemeAsync(ctx context.Context, uriScheme string, callback AsyncReadyCallback) {
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_app_info_get_default_for_uri_scheme_async(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uriScheme)
	runtime.KeepAlive(callback)
}

// AppInfoGetDefaultForURISchemeFinish finishes a default Info lookup started by
// g_app_info_get_default_for_uri_scheme_async().
//
// If no Info is found, then error will be set to G_IO_ERROR_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - appInfo for given uri_scheme or NULL on error.
func AppInfoGetDefaultForURISchemeFinish(result AsyncResulter) (*AppInfo, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GAppInfo     // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_app_info_get_default_for_uri_scheme_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// AppInfoGetFallbackForType gets a list of fallback Infos for a given content
// type, i.e. those applications which claim to support the given content type
// by MIME type subclassing and not directly.
//
// The function takes the following parameters:
//
//   - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//   - list of Infos for given content_type or NULL on error.
func AppInfoGetFallbackForType(contentType string) []*AppInfo {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_fallback_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetRecommendedForType gets a list of recommended Infos for a given
// content type, i.e. those applications which claim to support the given
// content type exactly, and not by MIME type subclassing. Note that the first
// application of the list is the last used one, i.e. the last one for which
// g_app_info_set_as_last_used_for_type() has been called.
//
// The function takes the following parameters:
//
//   - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//   - list of Infos for given content_type or NULL on error.
func AppInfoGetRecommendedForType(contentType string) []*AppInfo {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_recommended_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoLaunchDefaultForURI: utility function that launches the default
// application registered to handle the specified uri. Synchronous I/O is done
// on the uri to detect the type of the file if required.
//
// The D-Busactivated applications don't have to be started if your
// application terminates too soon after this function. To prevent this,
// use g_app_info_launch_default_for_uri_async() instead.
//
// The function takes the following parameters:
//
//   - uri to show.
//   - context (optional): optional LaunchContext.
func AppInfoLaunchDefaultForURI(uri string, context *AppLaunchContext) error {
	var _arg1 *C.char              // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C.g_app_info_launch_default_for_uri(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AppInfoLaunchDefaultForURIAsync: async version of
// g_app_info_launch_default_for_uri().
//
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
//
// This is also useful if you want to be sure that the D-Busactivated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - uri to show.
//   - context (optional): optional LaunchContext.
//   - callback (optional) to call when the request is done.
func AppInfoLaunchDefaultForURIAsync(ctx context.Context, uri string, context *AppLaunchContext, callback AsyncReadyCallback) {
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 *C.GAppLaunchContext  // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_app_info_launch_default_for_uri_async(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(context)
	runtime.KeepAlive(callback)
}

// AppInfoLaunchDefaultForURIFinish finishes an asynchronous
// launch-default-for-uri operation.
//
// The function takes the following parameters:
//
//   - result: Result.
func AppInfoLaunchDefaultForURIFinish(result AsyncResulter) error {
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_app_info_launch_default_for_uri_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AppInfoResetTypeAssociations removes all changes to the type
// associations done by g_app_info_set_as_default_for_type(),
// g_app_info_set_as_default_for_extension(), g_app_info_add_supports_type() or
// g_app_info_remove_supports_type().
//
// The function takes the following parameters:
//
//   - contentType: content type.
func AppInfoResetTypeAssociations(contentType string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_reset_type_associations(_arg1)
	runtime.KeepAlive(contentType)
}

// AsyncInitable: GAsyncInitable is an interface for asynchronously
// initializable objects.
//
// This is the asynchronous version of gio.Initable; it behaves the same in all
// ways except that initialization is asynchronous. For more details see the
// descriptions on GInitable.
//
// A class may implement both the GInitable and GAsyncInitable interfaces.
//
// Users of objects implementing this are not intended to use the interface
// method directly; instead it will be used automatically in various ways.
// For C applications you generally just call gio.AsyncInitable().NewAsync
// directly, or indirectly via a foo_thing_new_async() wrapper. This will call
// gio.AsyncInitable.InitAsync() under the covers, calling back with NULL and a
// set GError on failure.
//
// A typical implementation might look something like this:
//
//	enum {
//	   NOT_INITIALIZED,
//	   INITIALIZING,
//	   INITIALIZED
//	};
//
//	static void
//	_foo_ready_cb (Foo *self)
//	{
//	  GList *l;
//
//	  self->priv->state = INITIALIZED;
//
//	  for (l = self->priv->init_results; l != NULL; l = l->next)
//	    {
//	      GTask *task = l->data;
//
//	      if (self->priv->success)
//	        g_task_return_boolean (task, TRUE);
//	      else
//	        g_task_return_new_error (task, ...);
//	      g_object_unref (task);
//	    }
//
//	  g_list_free (self->priv->init_results);
//	  self->priv->init_results = NULL;
//	}
//
//	static void
//	foo_init_async (GAsyncInitable       *initable,
//	                int                   io_priority,
//	                GCancellable         *cancellable,
//	                GAsyncReadyCallback   callback,
//	                gpointer              user_data)
//	{
//	  Foo *self = FOO (initable);
//	  GTask *task;
//
//	  task = g_task_new (initable, cancellable, callback, user_data);
//	  g_task_set_name (task, G_STRFUNC);
//
//	  switch (self->priv->state)
//	    {
//	      case NOT_INITIALIZED:
//	        _foo_get_ready (self);
//	        self->priv->init_results = g_list_append (self->priv->init_results,
//	                                                  task);
//	        self->priv->state = INITIALIZING;
//	        break;
//	      case INITIALIZING:
//	        self->priv->init_results = g_list_append (self->priv->init_results,
//	                                                  task);
//	        break;
//	      case INITIALIZED:
//	        if (!self->priv->success)
//	          g_task_return_new_error (task, ...);
//	        else
//	          g_task_return_boolean (task, TRUE);
//	        g_object_unref (task);
//	        break;
//	    }
//	}
//
//	static gboolean
//	foo_init_finish (GAsyncInitable       *initable,
//	                 GAsyncResult         *result,
//	                 GError              **error)
//	{
//	  g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
//
//	  return g_task_propagate_boolean (G_TASK (result), error);
//	}
//
//	static void
//	foo_async_initable_iface_init (gpointer g_iface,
//	                               gpointer data)
//	{
//	  GAsyncInitableIface *iface = g_iface;
//
//	  iface->init_async = foo_init_async;
//	  iface->init_finish = foo_init_finish;
//	}.
//
// AsyncInitable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type AsyncInitable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AsyncInitable)(nil)
)

// AsyncInitabler describes AsyncInitable's interface methods.
type AsyncInitabler interface {
	coreglib.Objector

	// InitAsync starts asynchronous initialization of the object implementing
	// the interface.
	InitAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// InitFinish finishes asynchronous initialization and returns the result.
	InitFinish(res AsyncResulter) error
	// NewFinish finishes the async construction for the various
	// g_async_initable_new calls, returning the created object or NULL on
	// error.
	NewFinish(res AsyncResulter) (*coreglib.Object, error)
}

var _ AsyncInitabler = (*AsyncInitable)(nil)

func wrapAsyncInitable(obj *coreglib.Object) *AsyncInitable {
	return &AsyncInitable{
		Object: obj,
	}
}

func marshalAsyncInitable(p uintptr) (interface{}, error) {
	return wrapAsyncInitable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// InitAsync starts asynchronous initialization of the object implementing the
// interface. This must be done before any real use of the object after initial
// construction. If the object also implements #GInitable you can optionally
// call g_initable_init() instead.
//
// This method is intended for language bindings. If writing in C,
// g_async_initable_new_async() should typically be used instead.
//
// When the initialization is finished, callback will be called. You can then
// call g_async_initable_init_finish() to get the result of the initialization.
//
// Implementations may also support cancellation. If cancellable is not NULL,
// then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL,
// and the object doesn't support cancellable initialization, the error
// G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// As with #GInitable, if the object is not initialized, or initialization
// returns with an error, then all operations on the object except
// g_object_ref() and g_object_unref() are considered to be invalid, and have
// undefined behaviour. They will often fail with g_critical() or g_warning(),
// but this must not be relied on.
//
// Callers should not assume that a class which implements Initable can be
// initialized multiple times; for more information, see g_initable_init(). If
// a class explicitly supports being initialized multiple times, implementation
// requires yielding all subsequent calls to init_async() on the results of the
// first call.
//
// For classes that also support the #GInitable interface, the default
// implementation of this method will run the g_initable_init() function in a
// thread, so if you want to support asynchronous initialization via threads,
// just implement the Initable interface without overriding any interface
// methods.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the operation.
//   - callback (optional) to call when the request is satisfied.
func (initable *AsyncInitable) InitAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GAsyncInitable     // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(coreglib.InternObject(initable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_async_initable_init_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// InitFinish finishes asynchronous initialization and returns the result.
// See g_async_initable_init_async().
//
// The function takes the following parameters:
//
//   - res: Result.
func (initable *AsyncInitable) InitFinish(res AsyncResulter) error {
	var _arg0 *C.GAsyncInitable // out
	var _arg1 *C.GAsyncResult   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(coreglib.InternObject(initable).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_async_initable_init_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(res)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// NewFinish finishes the async construction for the various
// g_async_initable_new calls, returning the created object or NULL on error.
//
// The function takes the following parameters:
//
//   - res from the callback.
//
// The function returns the following values:
//
//   - object: newly created #GObject, or NULL on error. Free with
//     g_object_unref().
func (initable *AsyncInitable) NewFinish(res AsyncResulter) (*coreglib.Object, error) {
	var _arg0 *C.GAsyncInitable // out
	var _arg1 *C.GAsyncResult   // out
	var _cret *C.GObject        // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(coreglib.InternObject(initable).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_async_initable_new_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(res)

	var _object *coreglib.Object // out
	var _goerr error             // out

	_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _object, _goerr
}

// initAsync starts asynchronous initialization of the object implementing the
// interface. This must be done before any real use of the object after initial
// construction. If the object also implements #GInitable you can optionally
// call g_initable_init() instead.
//
// This method is intended for language bindings. If writing in C,
// g_async_initable_new_async() should typically be used instead.
//
// When the initialization is finished, callback will be called. You can then
// call g_async_initable_init_finish() to get the result of the initialization.
//
// Implementations may also support cancellation. If cancellable is not NULL,
// then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL,
// and the object doesn't support cancellable initialization, the error
// G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// As with #GInitable, if the object is not initialized, or initialization
// returns with an error, then all operations on the object except
// g_object_ref() and g_object_unref() are considered to be invalid, and have
// undefined behaviour. They will often fail with g_critical() or g_warning(),
// but this must not be relied on.
//
// Callers should not assume that a class which implements Initable can be
// initialized multiple times; for more information, see g_initable_init(). If
// a class explicitly supports being initialized multiple times, implementation
// requires yielding all subsequent calls to init_async() on the results of the
// first call.
//
// For classes that also support the #GInitable interface, the default
// implementation of this method will run the g_initable_init() function in a
// thread, so if you want to support asynchronous initialization via threads,
// just implement the Initable interface without overriding any interface
// methods.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the operation.
//   - callback (optional) to call when the request is satisfied.
func (initable *AsyncInitable) initAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GAsyncInitableIface)(coreglib.PeekParentClass(initable))
	fnarg := gclass.init_async

	var _arg0 *C.GAsyncInitable     // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(coreglib.InternObject(initable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_AsyncInitable_virtual_init_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// initFinish finishes asynchronous initialization and returns the result.
// See g_async_initable_init_async().
//
// The function takes the following parameters:
//
//   - res: Result.
func (initable *AsyncInitable) initFinish(res AsyncResulter) error {
	gclass := (*C.GAsyncInitableIface)(coreglib.PeekParentClass(initable))
	fnarg := gclass.init_finish

	var _arg0 *C.GAsyncInitable // out
	var _arg1 *C.GAsyncResult   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GAsyncInitable)(unsafe.Pointer(coreglib.InternObject(initable).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C._gotk4_gio2_AsyncInitable_virtual_init_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(res)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AsyncResult: GAsyncResult provides a base class for implementing asynchronous
// function results.
//
// Asynchronous operations are broken up into two separate operations which
// are chained together by a GAsyncReadyCallback. To begin an asynchronous
// operation, provide a GAsyncReadyCallback to the asynchronous function.
// This callback will be triggered when the operation has completed,
// and must be run in a later iteration of the thread-default main context (see
// glib.MainContext.PushThreadDefault()) from where the operation was initiated.
// It will be passed a GAsyncResult instance filled with the details of the
// operation's success or failure, the object the asynchronous function was
// started for and any error codes returned. The asynchronous callback function
// is then expected to call the corresponding _finish() function, passing
// the object the function was called for, the GAsyncResult instance, and
// (optionally) an error to grab any error conditions that may have occurred.
//
// The _finish() function for an operation takes the generic result (of type
// GAsyncResult) and returns the specific result that the operation in question
// yields (e.g. a gio.FileEnumerator for a "enumerate children" operation).
// If the result or error status of the operation is not needed, there is no
// need to call the _finish() function; GIO will take care of cleaning up the
// result and error information after the GAsyncReadyCallback returns. You can
// pass NULL for the GAsyncReadyCallback if you don't need to take any action
// at all after the operation completes. Applications may also take a reference
// to the GAsyncResult and call _finish() later; however, the _finish() function
// may be called at most once.
//
// Example of a typical asynchronous operation flow:
//
//	void _theoretical_frobnitz_async (Theoretical         *t,
//	                                  GCancellable        *c,
//	                                  GAsyncReadyCallback  cb,
//	                                  gpointer             u);
//
//	gboolean _theoretical_frobnitz_finish (Theoretical   *t,
//	                                       GAsyncResult  *res,
//	                                       GError       **e);
//
//	static void
//	frobnitz_result_func (GObject      *source_object,
//			 GAsyncResult *res,
//			 gpointer      user_data)
//	{
//	  gboolean success = FALSE;
//
//	  success = _theoretical_frobnitz_finish (source_object, res, NULL);
//
//	  if (success)
//	    g_printf ("Hurray!\n");
//	  else
//	    g_printf ("Uh oh!\n");
//
//	  ...
//
//	}
//
//	int main (int argc, void *argv[])
//	{
//	   ...
//
//	   _theoretical_frobnitz_async (theoretical_data,
//	                                NULL,
//	                                frobnitz_result_func,
//	                                NULL);
//
//	   ...
//	}
//
// The callback for an asynchronous operation is called only once, and is always
// called, even in the case of a cancelled operation. On cancellation the result
// is a G_IO_ERROR_CANCELLED error.
//
// I/O Priority
//
// Many I/O-related asynchronous operations have a priority parameter,
// which is used in certain cases to determine the order in which operations
// are executed. They are not used to determine system-wide I/O scheduling.
// Priorities are integers, with lower numbers indicating higher priority. It is
// recommended to choose priorities between G_PRIORITY_LOW and G_PRIORITY_HIGH,
// with G_PRIORITY_DEFAULT as a default.
//
// AsyncResult wraps an interface. This means the user can get the
// underlying type by calling Cast().
type AsyncResult struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AsyncResult)(nil)
)

// AsyncResulter describes AsyncResult's interface methods.
type AsyncResulter interface {
	coreglib.Objector

	// SourceObject gets the source object from a Result.
	SourceObject() *coreglib.Object
	// UserData gets the user data from a Result.
	UserData() unsafe.Pointer
	// IsTagged checks if res has the given source_tag (generally a function
	// pointer indicating the function res was created by).
	IsTagged(sourceTag unsafe.Pointer) bool
	// LegacyPropagateError: if res is a AsyncResult, this is equivalent to
	// g_simple_async_result_propagate_error().
	LegacyPropagateError() error
}

var _ AsyncResulter = (*AsyncResult)(nil)

func wrapAsyncResult(obj *coreglib.Object) *AsyncResult {
	return &AsyncResult{
		Object: obj,
	}
}

func marshalAsyncResult(p uintptr) (interface{}, error) {
	return wrapAsyncResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SourceObject gets the source object from a Result.
//
// The function returns the following values:
//
//   - object (optional): new reference to the source object for the res,
//     or NULL if there is none.
func (res *AsyncResult) SourceObject() *coreglib.Object {
	var _arg0 *C.GAsyncResult // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_async_result_get_source_object(_arg0)
	runtime.KeepAlive(res)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// UserData gets the user data from a Result.
//
// The function returns the following values:
//
//   - gpointer (optional): user data for res.
func (res *AsyncResult) UserData() unsafe.Pointer {
	var _arg0 *C.GAsyncResult // out
	var _cret C.gpointer      // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_async_result_get_user_data(_arg0)
	runtime.KeepAlive(res)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// IsTagged checks if res has the given source_tag (generally a function pointer
// indicating the function res was created by).
//
// The function takes the following parameters:
//
//   - sourceTag (optional): application-defined tag.
//
// The function returns the following values:
//
//   - ok: TRUE if res has the indicated source_tag, FALSE if not.
func (res *AsyncResult) IsTagged(sourceTag unsafe.Pointer) bool {
	var _arg0 *C.GAsyncResult // out
	var _arg1 C.gpointer      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(sourceTag))

	_cret = C.g_async_result_is_tagged(_arg0, _arg1)
	runtime.KeepAlive(res)
	runtime.KeepAlive(sourceTag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LegacyPropagateError: if res is a AsyncResult, this is equivalent to
// g_simple_async_result_propagate_error(). Otherwise it returns FALSE.
//
// This can be used for legacy error handling in async *_finish() wrapper
// functions that traditionally handled AsyncResult error returns themselves
// rather than calling into the virtual method. This should not be used in new
// code; Result errors that are set by virtual methods should also be extracted
// by virtual methods, to enable subclasses to chain up correctly.
func (res *AsyncResult) LegacyPropagateError() error {
	var _arg0 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_async_result_legacy_propagate_error(_arg0, &_cerr)
	runtime.KeepAlive(res)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// sourceObject gets the source object from a Result.
//
// The function returns the following values:
//
//   - object (optional): new reference to the source object for the res,
//     or NULL if there is none.
func (res *AsyncResult) sourceObject() *coreglib.Object {
	gclass := (*C.GAsyncResultIface)(coreglib.PeekParentClass(res))
	fnarg := gclass.get_source_object

	var _arg0 *C.GAsyncResult // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_AsyncResult_virtual_get_source_object(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(res)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// userData gets the user data from a Result.
//
// The function returns the following values:
//
//   - gpointer (optional): user data for res.
func (res *AsyncResult) userData() unsafe.Pointer {
	gclass := (*C.GAsyncResultIface)(coreglib.PeekParentClass(res))
	fnarg := gclass.get_user_data

	var _arg0 *C.GAsyncResult // out
	var _cret C.gpointer      // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_AsyncResult_virtual_get_user_data(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(res)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// isTagged checks if res has the given source_tag (generally a function pointer
// indicating the function res was created by).
//
// The function takes the following parameters:
//
//   - sourceTag (optional): application-defined tag.
//
// The function returns the following values:
//
//   - ok: TRUE if res has the indicated source_tag, FALSE if not.
func (res *AsyncResult) isTagged(sourceTag unsafe.Pointer) bool {
	gclass := (*C.GAsyncResultIface)(coreglib.PeekParentClass(res))
	fnarg := gclass.is_tagged

	var _arg0 *C.GAsyncResult // out
	var _arg1 C.gpointer      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(sourceTag))

	_cret = C._gotk4_gio2_AsyncResult_virtual_is_tagged(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(res)
	runtime.KeepAlive(sourceTag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Converter: GConverter is an interface for streaming conversions.
//
// GConverter is implemented by objects that convert binary data in various
// ways. The conversion can be stateful and may fail at any place.
//
// Some example conversions are: character set conversion, compression,
// decompression and regular expression replace.
//
// Converter wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Converter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Converter)(nil)
)

// Converterer describes Converter's interface methods.
type Converterer interface {
	coreglib.Objector

	// Convert: this is the main operation used when converting data.
	Convert(inbuf, outbuf []byte, flags ConverterFlags) (bytesRead, bytesWritten uint, converterResult ConverterResult, goerr error)
	// Reset resets all internal state in the converter, making it behave as if
	// it was just created.
	Reset()
}

var _ Converterer = (*Converter)(nil)

func wrapConverter(obj *coreglib.Object) *Converter {
	return &Converter{
		Object: obj,
	}
}

func marshalConverter(p uintptr) (interface{}, error) {
	return wrapConverter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Convert: this is the main operation used when converting data. It is to be
// called multiple times in a loop, and each time it will do some work, i.e.
// producing some output (in outbuf) or consuming some input (from inbuf) or
// both. If its not possible to do any work an error is returned.
//
// Note that a single call may not consume all input (or any input at all).
// Also a call may produce output even if given no input, due to state stored in
// the converter producing output.
//
// If any data was either produced or consumed, and then an error happens,
// then only the successful conversion is reported and the error is returned on
// the next call.
//
// A full conversion loop involves calling this method repeatedly, each time
// giving it new input and space output space. When there is no more input data
// after the data in inbuf, the flag G_CONVERTER_INPUT_AT_END must be set.
// The loop will be (unless some error happens) returning G_CONVERTER_CONVERTED
// each time until all data is consumed and all output is produced, then
// G_CONVERTER_FINISHED is returned instead. Note, that G_CONVERTER_FINISHED
// may be returned even if G_CONVERTER_INPUT_AT_END is not set, for instance in
// a decompression converter where the end of data is detectable from the data
// (and there might even be other data after the end of the compressed data).
//
// When some data has successfully been converted bytes_read and is set to
// the number of bytes read from inbuf, and bytes_written is set to indicate
// how many bytes was written to outbuf. If there are more data to output
// or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then
// G_CONVERTER_CONVERTED is returned, and if no more data is to be output then
// G_CONVERTER_FINISHED is returned.
//
// On error G_CONVERTER_ERROR is returned and error is set accordingly. Some
// errors need special handling:
//
// G_IO_ERROR_NO_SPACE is returned if there is not enough space to write the
// resulting converted data, the application should call the function again with
// a larger outbuf to continue.
//
// G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough input
// to fully determine what the conversion should produce, and the
// G_CONVERTER_INPUT_AT_END flag is not set. This happens for example with an
// incomplete multibyte sequence when converting text, or when a regexp matches
// up to the end of the input (and may match further input). It may also happen
// when inbuf_size is zero and there is no more data to produce.
//
// When this happens the application should read more input and then call the
// function again. If further input shows that there is no more data call the
// function again with the same data but with the G_CONVERTER_INPUT_AT_END flag
// set. This may cause the conversion to finish as e.g. in the regexp match case
// (or, to fail again with G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion
// where the input is actually partial).
//
// After g_converter_convert() has returned G_CONVERTER_FINISHED the
// converter object is in an invalid state where its not allowed to call
// g_converter_convert() anymore. At this time you can only free the object or
// call g_converter_reset() to reset it to the initial state.
//
// If the flag G_CONVERTER_FLUSH is set then conversion is modified to try to
// write out all internal state to the output. The application has to call
// the function multiple times with the flag set, and when the available
// input has been consumed and all internal state has been produced then
// G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if really at the end) is
// returned instead of G_CONVERTER_CONVERTED. This is somewhat similar to what
// happens at the end of the input stream, but done in the middle of the data.
//
// This has different meanings for different conversions. For instance in a
// compression converter it would mean that we flush all the compression state
// into output such that if you uncompress the compressed data you get back all
// the input data. Doing this may make the final file larger due to padding
// though. Another example is a regexp conversion, where if you at the end of
// the flushed data have a match, but there is also a potential longer match.
// In the non-flushed case we would ask for more input, but when flushing we
// treat this as the end of input and do the match.
//
// Flushing is not always possible (like if a charset converter flushes
// at a partial multibyte sequence). Converters are supposed to try to
// produce as much output as possible and then return an error (typically
// G_IO_ERROR_PARTIAL_INPUT).
//
// The function takes the following parameters:
//
//   - inbuf: buffer containing the data to convert.
//   - outbuf: a buffer to write converted data in.
//   - flags controlling the conversion details.
//
// The function returns the following values:
//
//   - bytesRead will be set to the number of bytes read from inbuf on success.
//   - bytesWritten will be set to the number of bytes written to outbuf on
//     success.
//   - converterResult G_CONVERTER_ERROR on error.
func (converter *Converter) Convert(inbuf, outbuf []byte, flags ConverterFlags) (bytesRead, bytesWritten uint, converterResult ConverterResult, goerr error) {
	var _arg0 *C.GConverter // out
	var _arg1 *C.void       // out
	var _arg2 C.gsize
	var _arg3 *C.void // out
	var _arg4 C.gsize
	var _arg5 C.GConverterFlags  // out
	var _arg6 C.gsize            // in
	var _arg7 C.gsize            // in
	var _cret C.GConverterResult // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))
	_arg2 = (C.gsize)(len(inbuf))
	if len(inbuf) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&inbuf[0]))
	}
	_arg4 = (C.gsize)(len(outbuf))
	if len(outbuf) > 0 {
		_arg3 = (*C.void)(unsafe.Pointer(&outbuf[0]))
	}
	_arg5 = C.GConverterFlags(flags)

	_cret = C.g_converter_convert(_arg0, unsafe.Pointer(_arg1), _arg2, unsafe.Pointer(_arg3), _arg4, _arg5, &_arg6, &_arg7, &_cerr)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(flags)

	var _bytesRead uint                  // out
	var _bytesWritten uint               // out
	var _converterResult ConverterResult // out
	var _goerr error                     // out

	_bytesRead = uint(_arg6)
	_bytesWritten = uint(_arg7)
	_converterResult = ConverterResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _converterResult, _goerr
}

// Reset resets all internal state in the converter, making it behave as if it
// was just created. If the converter has any internal state that would produce
// output then that output is lost.
func (converter *Converter) Reset() {
	var _arg0 *C.GConverter // out

	_arg0 = (*C.GConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))

	C.g_converter_reset(_arg0)
	runtime.KeepAlive(converter)
}

// Convert: this is the main operation used when converting data. It is to be
// called multiple times in a loop, and each time it will do some work, i.e.
// producing some output (in outbuf) or consuming some input (from inbuf) or
// both. If its not possible to do any work an error is returned.
//
// Note that a single call may not consume all input (or any input at all).
// Also a call may produce output even if given no input, due to state stored in
// the converter producing output.
//
// If any data was either produced or consumed, and then an error happens,
// then only the successful conversion is reported and the error is returned on
// the next call.
//
// A full conversion loop involves calling this method repeatedly, each time
// giving it new input and space output space. When there is no more input data
// after the data in inbuf, the flag G_CONVERTER_INPUT_AT_END must be set.
// The loop will be (unless some error happens) returning G_CONVERTER_CONVERTED
// each time until all data is consumed and all output is produced, then
// G_CONVERTER_FINISHED is returned instead. Note, that G_CONVERTER_FINISHED
// may be returned even if G_CONVERTER_INPUT_AT_END is not set, for instance in
// a decompression converter where the end of data is detectable from the data
// (and there might even be other data after the end of the compressed data).
//
// When some data has successfully been converted bytes_read and is set to
// the number of bytes read from inbuf, and bytes_written is set to indicate
// how many bytes was written to outbuf. If there are more data to output
// or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then
// G_CONVERTER_CONVERTED is returned, and if no more data is to be output then
// G_CONVERTER_FINISHED is returned.
//
// On error G_CONVERTER_ERROR is returned and error is set accordingly. Some
// errors need special handling:
//
// G_IO_ERROR_NO_SPACE is returned if there is not enough space to write the
// resulting converted data, the application should call the function again with
// a larger outbuf to continue.
//
// G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough input
// to fully determine what the conversion should produce, and the
// G_CONVERTER_INPUT_AT_END flag is not set. This happens for example with an
// incomplete multibyte sequence when converting text, or when a regexp matches
// up to the end of the input (and may match further input). It may also happen
// when inbuf_size is zero and there is no more data to produce.
//
// When this happens the application should read more input and then call the
// function again. If further input shows that there is no more data call the
// function again with the same data but with the G_CONVERTER_INPUT_AT_END flag
// set. This may cause the conversion to finish as e.g. in the regexp match case
// (or, to fail again with G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion
// where the input is actually partial).
//
// After g_converter_convert() has returned G_CONVERTER_FINISHED the
// converter object is in an invalid state where its not allowed to call
// g_converter_convert() anymore. At this time you can only free the object or
// call g_converter_reset() to reset it to the initial state.
//
// If the flag G_CONVERTER_FLUSH is set then conversion is modified to try to
// write out all internal state to the output. The application has to call
// the function multiple times with the flag set, and when the available
// input has been consumed and all internal state has been produced then
// G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if really at the end) is
// returned instead of G_CONVERTER_CONVERTED. This is somewhat similar to what
// happens at the end of the input stream, but done in the middle of the data.
//
// This has different meanings for different conversions. For instance in a
// compression converter it would mean that we flush all the compression state
// into output such that if you uncompress the compressed data you get back all
// the input data. Doing this may make the final file larger due to padding
// though. Another example is a regexp conversion, where if you at the end of
// the flushed data have a match, but there is also a potential longer match.
// In the non-flushed case we would ask for more input, but when flushing we
// treat this as the end of input and do the match.
//
// Flushing is not always possible (like if a charset converter flushes
// at a partial multibyte sequence). Converters are supposed to try to
// produce as much output as possible and then return an error (typically
// G_IO_ERROR_PARTIAL_INPUT).
//
// The function takes the following parameters:
//
//   - inbuf (optional): buffer containing the data to convert.
//   - outbuf: a buffer to write converted data in.
//   - flags controlling the conversion details.
//
// The function returns the following values:
//
//   - bytesRead will be set to the number of bytes read from inbuf on success.
//   - bytesWritten will be set to the number of bytes written to outbuf on
//     success.
//   - converterResult G_CONVERTER_ERROR on error.
func (converter *Converter) convert(inbuf, outbuf []byte, flags ConverterFlags) (bytesRead, bytesWritten uint, converterResult ConverterResult, goerr error) {
	gclass := (*C.GConverterIface)(coreglib.PeekParentClass(converter))
	fnarg := gclass.convert

	var _arg0 *C.GConverter // out
	var _arg1 *C.void       // out
	var _arg2 C.gsize
	var _arg3 *C.void // out
	var _arg4 C.gsize
	var _arg5 C.GConverterFlags  // out
	var _arg6 C.gsize            // in
	var _arg7 C.gsize            // in
	var _cret C.GConverterResult // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))
	_arg2 = (C.gsize)(len(inbuf))
	if len(inbuf) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&inbuf[0]))
	}
	_arg4 = (C.gsize)(len(outbuf))
	if len(outbuf) > 0 {
		_arg3 = (*C.void)(unsafe.Pointer(&outbuf[0]))
	}
	_arg5 = C.GConverterFlags(flags)

	_cret = C._gotk4_gio2_Converter_virtual_convert(unsafe.Pointer(fnarg), _arg0, unsafe.Pointer(_arg1), _arg2, unsafe.Pointer(_arg3), _arg4, _arg5, &_arg6, &_arg7, &_cerr)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(flags)

	var _bytesRead uint                  // out
	var _bytesWritten uint               // out
	var _converterResult ConverterResult // out
	var _goerr error                     // out

	_bytesRead = uint(_arg6)
	_bytesWritten = uint(_arg7)
	_converterResult = ConverterResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _converterResult, _goerr
}

// Reset resets all internal state in the converter, making it behave as if it
// was just created. If the converter has any internal state that would produce
// output then that output is lost.
func (converter *Converter) reset() {
	gclass := (*C.GConverterIface)(coreglib.PeekParentClass(converter))
	fnarg := gclass.reset

	var _arg0 *C.GConverter // out

	_arg0 = (*C.GConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))

	C._gotk4_gio2_Converter_virtual_reset(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(converter)
}

// DBusInterface: base type for D-Bus interfaces.
//
// The GDBusInterface type is the base type for D-Bus interfaces both on
// the service side (see gio.DBusInterfaceSkeleton) and client side (see
// gio.DBusProxy).
//
// DBusInterface wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DBusInterface struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DBusInterface)(nil)
)

// DBusInterfacer describes DBusInterface's interface methods.
type DBusInterfacer interface {
	coreglib.Objector

	// GetObject gets the BusObject that interface_ belongs to, if any.
	GetObject() *DBusObject
	// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by interface_.
	Info() *DBusInterfaceInfo
	// SetObject sets the BusObject for interface_ to object.
	SetObject(object DBusObjector)
}

var _ DBusInterfacer = (*DBusInterface)(nil)

func wrapDBusInterface(obj *coreglib.Object) *DBusInterface {
	return &DBusInterface{
		Object: obj,
	}
}

func marshalDBusInterface(p uintptr) (interface{}, error) {
	return wrapDBusInterface(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GetObject gets the BusObject that interface_ belongs to, if any.
//
// The function returns the following values:
//
//   - dBusObject (optional) or NULL. The returned reference should be freed
//     with g_object_unref().
func (interface_ *DBusInterface) GetObject() *DBusObject {
	var _arg0 *C.GDBusInterface // out
	var _cret *C.GDBusObject    // in

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_dup_object(_arg0)
	runtime.KeepAlive(interface_)

	var _dBusObject *DBusObject // out

	if _cret != nil {
		_dBusObject = wrapDBusObject(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusObject
}

// Info gets D-Bus introspection information for the D-Bus interface implemented
// by interface_.
//
// The function returns the following values:
//
//   - dBusInterfaceInfo Do not free.
func (interface_ *DBusInterface) Info() *DBusInterfaceInfo {
	var _arg0 *C.GDBusInterface     // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_get_info(_arg0)
	runtime.KeepAlive(interface_)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_dbus_interface_info_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
		},
	)

	return _dBusInterfaceInfo
}

// SetObject sets the BusObject for interface_ to object.
//
// Note that interface_ will hold a weak reference to object.
//
// The function takes the following parameters:
//
//   - object (optional) or NULL.
func (interface_ *DBusInterface) SetObject(object DBusObjector) {
	var _arg0 *C.GDBusInterface // out
	var _arg1 *C.GDBusObject    // out

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	if object != nil {
		_arg1 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	}

	C.g_dbus_interface_set_object(_arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(object)
}

// dupObject gets the BusObject that interface_ belongs to, if any.
//
// The function returns the following values:
//
//   - dBusObject (optional) or NULL. The returned reference should be freed
//     with g_object_unref().
func (interface_ *DBusInterface) dupObject() *DBusObject {
	gclass := (*C.GDBusInterfaceIface)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.dup_object

	var _arg0 *C.GDBusInterface // out
	var _cret *C.GDBusObject    // in

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C._gotk4_gio2_DBusInterface_virtual_dup_object(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(interface_)

	var _dBusObject *DBusObject // out

	if _cret != nil {
		_dBusObject = wrapDBusObject(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusObject
}

// Info gets D-Bus introspection information for the D-Bus interface implemented
// by interface_.
//
// The function returns the following values:
//
//   - dBusInterfaceInfo Do not free.
func (interface_ *DBusInterface) info() *DBusInterfaceInfo {
	gclass := (*C.GDBusInterfaceIface)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.get_info

	var _arg0 *C.GDBusInterface     // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C._gotk4_gio2_DBusInterface_virtual_get_info(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(interface_)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_dbus_interface_info_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
		},
	)

	return _dBusInterfaceInfo
}

// setObject sets the BusObject for interface_ to object.
//
// Note that interface_ will hold a weak reference to object.
//
// The function takes the following parameters:
//
//   - object (optional) or NULL.
func (interface_ *DBusInterface) setObject(object DBusObjector) {
	gclass := (*C.GDBusInterfaceIface)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.set_object

	var _arg0 *C.GDBusInterface // out
	var _arg1 *C.GDBusObject    // out

	_arg0 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	if object != nil {
		_arg1 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	}

	C._gotk4_gio2_DBusInterface_virtual_set_object(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(object)
}

// DBusObject: GDBusObject type is the base type for D-Bus objects on both
// the service side (see gio.DBusObjectSkeleton) and the client side (see
// gio.DBusObjectProxy). It is essentially just a container of interfaces.
//
// DBusObject wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DBusObject struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DBusObject)(nil)
)

// DBusObjector describes DBusObject's interface methods.
type DBusObjector interface {
	coreglib.Objector

	// Interface gets the D-Bus interface with name interface_name associated
	// with object, if any.
	Interface(interfaceName string) *DBusInterface
	// Interfaces gets the D-Bus interfaces associated with object.
	Interfaces() []*DBusInterface
	// ObjectPath gets the object path for object.
	ObjectPath() string

	// Interface-added is emitted when interface is added to object.
	ConnectInterfaceAdded(func(iface DBusInterfacer)) coreglib.SignalHandle
	// Interface-removed is emitted when interface is removed from object.
	ConnectInterfaceRemoved(func(iface DBusInterfacer)) coreglib.SignalHandle
}

var _ DBusObjector = (*DBusObject)(nil)

func wrapDBusObject(obj *coreglib.Object) *DBusObject {
	return &DBusObject{
		Object: obj,
	}
}

func marshalDBusObject(p uintptr) (interface{}, error) {
	return wrapDBusObject(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectInterfaceAdded is emitted when interface is added to object.
func (object *DBusObject) ConnectInterfaceAdded(f func(iface DBusInterfacer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(object, "interface-added", false, unsafe.Pointer(C._gotk4_gio2_DBusObject_ConnectInterfaceAdded), f)
}

// ConnectInterfaceRemoved is emitted when interface is removed from object.
func (object *DBusObject) ConnectInterfaceRemoved(f func(iface DBusInterfacer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(object, "interface-removed", false, unsafe.Pointer(C._gotk4_gio2_DBusObject_ConnectInterfaceRemoved), f)
}

// Interface gets the D-Bus interface with name interface_name associated with
// object, if any.
//
// The function takes the following parameters:
//
//   - interfaceName d-Bus interface name.
//
// The function returns the following values:
//
//   - dBusInterface (optional): NULL if not found, otherwise a BusInterface
//     that must be freed with g_object_unref().
func (object *DBusObject) Interface(interfaceName string) *DBusInterface {
	var _arg0 *C.GDBusObject    // out
	var _arg1 *C.gchar          // out
	var _cret *C.GDBusInterface // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_get_interface(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interfaceName)

	var _dBusInterface *DBusInterface // out

	if _cret != nil {
		_dBusInterface = wrapDBusInterface(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusInterface
}

// Interfaces gets the D-Bus interfaces associated with object.
//
// The function returns the following values:
//
//   - list of BusInterface instances. The returned list must be freed by
//     g_list_free() after each element has been freed with g_object_unref().
func (object *DBusObject) Interfaces() []*DBusInterface {
	var _arg0 *C.GDBusObject // out
	var _cret *C.GList       // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.g_dbus_object_get_interfaces(_arg0)
	runtime.KeepAlive(object)

	var _list []*DBusInterface // out

	_list = make([]*DBusInterface, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDBusInterface)(v)
		var dst *DBusInterface // out
		dst = wrapDBusInterface(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// ObjectPath gets the object path for object.
//
// The function returns the following values:
//
//   - utf8: string owned by object. Do not free.
func (object *DBusObject) ObjectPath() string {
	var _arg0 *C.GDBusObject // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.g_dbus_object_get_object_path(_arg0)
	runtime.KeepAlive(object)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Iface gets the D-Bus interface with name interface_name associated with
// object, if any.
//
// The function takes the following parameters:
//
//   - interfaceName d-Bus interface name.
//
// The function returns the following values:
//
//   - dBusInterface (optional): NULL if not found, otherwise a BusInterface
//     that must be freed with g_object_unref().
func (object *DBusObject) iface(interfaceName string) *DBusInterface {
	gclass := (*C.GDBusObjectIface)(coreglib.PeekParentClass(object))
	fnarg := gclass.get_interface

	var _arg0 *C.GDBusObject    // out
	var _arg1 *C.gchar          // out
	var _cret *C.GDBusInterface // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_DBusObject_virtual_get_interface(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interfaceName)

	var _dBusInterface *DBusInterface // out

	if _cret != nil {
		_dBusInterface = wrapDBusInterface(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusInterface
}

// Interfaces gets the D-Bus interfaces associated with object.
//
// The function returns the following values:
//
//   - list of BusInterface instances. The returned list must be freed by
//     g_list_free() after each element has been freed with g_object_unref().
func (object *DBusObject) interfaces() []*DBusInterface {
	gclass := (*C.GDBusObjectIface)(coreglib.PeekParentClass(object))
	fnarg := gclass.get_interfaces

	var _arg0 *C.GDBusObject // out
	var _cret *C.GList       // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C._gotk4_gio2_DBusObject_virtual_get_interfaces(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(object)

	var _list []*DBusInterface // out

	_list = make([]*DBusInterface, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDBusInterface)(v)
		var dst *DBusInterface // out
		dst = wrapDBusInterface(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// objectPath gets the object path for object.
//
// The function returns the following values:
//
//   - utf8: string owned by object. Do not free.
func (object *DBusObject) objectPath() string {
	gclass := (*C.GDBusObjectIface)(coreglib.PeekParentClass(object))
	fnarg := gclass.get_object_path

	var _arg0 *C.GDBusObject // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C._gotk4_gio2_DBusObject_virtual_get_object_path(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(object)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// interfaceAdded: signal handler for the BusObject::interface-added signal.
func (object *DBusObject) interfaceAdded(interface_ DBusInterfacer) {
	gclass := (*C.GDBusObjectIface)(coreglib.PeekParentClass(object))
	fnarg := gclass.interface_added

	var _arg0 *C.GDBusObject    // out
	var _arg1 *C.GDBusInterface // out

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C._gotk4_gio2_DBusObject_virtual_interface_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interface_)
}

// interfaceRemoved: signal handler for the BusObject::interface-removed signal.
func (object *DBusObject) interfaceRemoved(interface_ DBusInterfacer) {
	gclass := (*C.GDBusObjectIface)(coreglib.PeekParentClass(object))
	fnarg := gclass.interface_removed

	var _arg0 *C.GDBusObject    // out
	var _arg1 *C.GDBusInterface // out

	_arg0 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C._gotk4_gio2_DBusObject_virtual_interface_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interface_)
}

// DBusObjectManager: GDBusObjectManager type is the base
// type for service- and client-side implementations of
// the standardized org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface.
//
// See gio.DBusObjectManagerClient for the client-side implementation and
// gio.DBusObjectManagerServer for the service-side implementation.
//
// DBusObjectManager wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DBusObjectManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DBusObjectManager)(nil)
)

// DBusObjectManagerer describes DBusObjectManager's interface methods.
type DBusObjectManagerer interface {
	coreglib.Objector

	// Interface gets the interface proxy for interface_name at object_path,
	// if any.
	Interface(objectPath, interfaceName string) *DBusInterface
	// GetObject gets the BusObject at object_path, if any.
	GetObject(objectPath string) *DBusObject
	// ObjectPath gets the object path that manager is for.
	ObjectPath() string
	// Objects gets all BusObject objects known to manager.
	Objects() []*DBusObject

	// Interface-added is emitted when interface is added to object.
	ConnectInterfaceAdded(func(object DBusObjector, iface DBusInterfacer)) coreglib.SignalHandle
	// Interface-removed is emitted when interface has been removed from object.
	ConnectInterfaceRemoved(func(object DBusObjector, iface DBusInterfacer)) coreglib.SignalHandle
	// Object-added is emitted when object is added to manager.
	ConnectObjectAdded(func(object DBusObjector)) coreglib.SignalHandle
	// Object-removed is emitted when object is removed from manager.
	ConnectObjectRemoved(func(object DBusObjector)) coreglib.SignalHandle
}

var _ DBusObjectManagerer = (*DBusObjectManager)(nil)

func wrapDBusObjectManager(obj *coreglib.Object) *DBusObjectManager {
	return &DBusObjectManager{
		Object: obj,
	}
}

func marshalDBusObjectManager(p uintptr) (interface{}, error) {
	return wrapDBusObjectManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectInterfaceAdded is emitted when interface is added to object.
//
// This signal exists purely as a convenience to avoid having to connect signals
// to all objects managed by manager.
func (manager *DBusObjectManager) ConnectInterfaceAdded(f func(object DBusObjector, iface DBusInterfacer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "interface-added", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManager_ConnectInterfaceAdded), f)
}

// ConnectInterfaceRemoved is emitted when interface has been removed from
// object.
//
// This signal exists purely as a convenience to avoid having to connect signals
// to all objects managed by manager.
func (manager *DBusObjectManager) ConnectInterfaceRemoved(f func(object DBusObjector, iface DBusInterfacer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "interface-removed", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManager_ConnectInterfaceRemoved), f)
}

// ConnectObjectAdded is emitted when object is added to manager.
func (manager *DBusObjectManager) ConnectObjectAdded(f func(object DBusObjector)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "object-added", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManager_ConnectObjectAdded), f)
}

// ConnectObjectRemoved is emitted when object is removed from manager.
func (manager *DBusObjectManager) ConnectObjectRemoved(f func(object DBusObjector)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "object-removed", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManager_ConnectObjectRemoved), f)
}

// Interface gets the interface proxy for interface_name at object_path, if any.
//
// The function takes the following parameters:
//
//   - objectPath: object path to look up.
//   - interfaceName d-Bus interface name to look up.
//
// The function returns the following values:
//
//   - dBusInterface (optional) instance or NULL. Free with g_object_unref().
func (manager *DBusObjectManager) Interface(objectPath, interfaceName string) *DBusInterface {
	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _cret *C.GDBusInterface     // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_object_manager_get_interface(_arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)

	var _dBusInterface *DBusInterface // out

	if _cret != nil {
		_dBusInterface = wrapDBusInterface(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusInterface
}

// GetObject gets the BusObject at object_path, if any.
//
// The function takes the following parameters:
//
//   - objectPath: object path to look up.
//
// The function returns the following values:
//
//   - dBusObject (optional) or NULL. Free with g_object_unref().
func (manager *DBusObjectManager) GetObject(objectPath string) *DBusObject {
	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusObject        // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_manager_get_object(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(objectPath)

	var _dBusObject *DBusObject // out

	if _cret != nil {
		_dBusObject = wrapDBusObject(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusObject
}

// ObjectPath gets the object path that manager is for.
//
// The function returns the following values:
//
//   - utf8: string owned by manager. Do not free.
func (manager *DBusObjectManager) ObjectPath() string {
	var _arg0 *C.GDBusObjectManager // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.g_dbus_object_manager_get_object_path(_arg0)
	runtime.KeepAlive(manager)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Objects gets all BusObject objects known to manager.
//
// The function returns the following values:
//
//   - list of BusObject objects. The returned list should be freed with
//     g_list_free() after each element has been freed with g_object_unref().
func (manager *DBusObjectManager) Objects() []*DBusObject {
	var _arg0 *C.GDBusObjectManager // out
	var _cret *C.GList              // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.g_dbus_object_manager_get_objects(_arg0)
	runtime.KeepAlive(manager)

	var _list []*DBusObject // out

	_list = make([]*DBusObject, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDBusObject)(v)
		var dst *DBusObject // out
		dst = wrapDBusObject(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Iface gets the interface proxy for interface_name at object_path, if any.
//
// The function takes the following parameters:
//
//   - objectPath: object path to look up.
//   - interfaceName d-Bus interface name to look up.
//
// The function returns the following values:
//
//   - dBusInterface (optional) instance or NULL. Free with g_object_unref().
func (manager *DBusObjectManager) iface(objectPath, interfaceName string) *DBusInterface {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.get_interface

	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _cret *C.GDBusInterface     // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gio2_DBusObjectManager_virtual_get_interface(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)

	var _dBusInterface *DBusInterface // out

	if _cret != nil {
		_dBusInterface = wrapDBusInterface(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusInterface
}

// getObject gets the BusObject at object_path, if any.
//
// The function takes the following parameters:
//
//   - objectPath: object path to look up.
//
// The function returns the following values:
//
//   - dBusObject (optional) or NULL. Free with g_object_unref().
func (manager *DBusObjectManager) getObject(objectPath string) *DBusObject {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.get_object

	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusObject        // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_DBusObjectManager_virtual_get_object(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(objectPath)

	var _dBusObject *DBusObject // out

	if _cret != nil {
		_dBusObject = wrapDBusObject(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusObject
}

// objectPath gets the object path that manager is for.
//
// The function returns the following values:
//
//   - utf8: string owned by manager. Do not free.
func (manager *DBusObjectManager) objectPath() string {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.get_object_path

	var _arg0 *C.GDBusObjectManager // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C._gotk4_gio2_DBusObjectManager_virtual_get_object_path(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(manager)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Objects gets all BusObject objects known to manager.
//
// The function returns the following values:
//
//   - list of BusObject objects. The returned list should be freed with
//     g_list_free() after each element has been freed with g_object_unref().
func (manager *DBusObjectManager) objects() []*DBusObject {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.get_objects

	var _arg0 *C.GDBusObjectManager // out
	var _cret *C.GList              // in

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C._gotk4_gio2_DBusObjectManager_virtual_get_objects(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(manager)

	var _list []*DBusObject // out

	_list = make([]*DBusObject, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDBusObject)(v)
		var dst *DBusObject // out
		dst = wrapDBusObject(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// interfaceAdded: signal handler for the BusObjectManager::interface-added
// signal.
//
// The function takes the following parameters:
//
//   - object
//   - interface_
func (manager *DBusObjectManager) interfaceAdded(object DBusObjector, interface_ DBusInterfacer) {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.interface_added

	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.GDBusObject        // out
	var _arg2 *C.GDBusInterface     // out

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg2 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C._gotk4_gio2_DBusObjectManager_virtual_interface_added(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interface_)
}

// interfaceRemoved: signal handler for the BusObjectManager::interface-removed
// signal.
//
// The function takes the following parameters:
//
//   - object
//   - interface_
func (manager *DBusObjectManager) interfaceRemoved(object DBusObjector, interface_ DBusInterfacer) {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.interface_removed

	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.GDBusObject        // out
	var _arg2 *C.GDBusInterface     // out

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg2 = (*C.GDBusInterface)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C._gotk4_gio2_DBusObjectManager_virtual_interface_removed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interface_)
}

// objectAdded: signal handler for the BusObjectManager::object-added signal.
func (manager *DBusObjectManager) objectAdded(object DBusObjector) {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.object_added

	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.GDBusObject        // out

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	C._gotk4_gio2_DBusObjectManager_virtual_object_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(object)
}

// objectRemoved: signal handler for the BusObjectManager::object-removed
// signal.
func (manager *DBusObjectManager) objectRemoved(object DBusObjector) {
	gclass := (*C.GDBusObjectManagerIface)(coreglib.PeekParentClass(manager))
	fnarg := gclass.object_removed

	var _arg0 *C.GDBusObjectManager // out
	var _arg1 *C.GDBusObject        // out

	_arg0 = (*C.GDBusObjectManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	C._gotk4_gio2_DBusObjectManager_virtual_object_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(object)
}

// DatagramBased: interface for socket-like objects with datagram semantics.
//
// A GDatagramBased is a networking interface for representing datagram-based
// communications. It is a more or less direct mapping of the core parts of
// the BSD socket API in a portable GObject interface. It is implemented by
// gio.Socket, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
//
// GDatagramBased is entirely platform independent, and is intended to be used
// alongside higher-level networking APIs such as gio.IOStream.
//
// It uses vectored scatter/gather I/O by default, allowing for many messages
// to be sent or received in a single call. Where possible, implementations of
// the interface should take advantage of vectored I/O to minimise processing
// or system calls. For example, GSocket uses recvmmsg() and sendmmsg() where
// possible. Callers should take advantage of scatter/gather I/O (the use
// of multiple buffers per message) to avoid unnecessary copying of data to
// assemble or disassemble a message.
//
// Each GDatagramBased operation has a timeout parameter which may be negative
// for blocking behaviour, zero for non-blocking behaviour, or positive for
// timeout behaviour. A blocking operation blocks until finished or there
// is an error. A non-blocking operation will return immediately with a
// G_IO_ERROR_WOULD_BLOCK error if it cannot make progress. A timeout operation
// will block until the operation is complete or the timeout expires; if the
// timeout expires it will return what progress it made, or G_IO_ERROR_TIMED_OUT
// if no progress was made. To know when a call would successfully run you can
// call gio.DatagramBased.ConditionCheck() or gio.DatagramBased.ConditionWait().
// You can also use gio.DatagramBased.CreateSource() and attach it to a
// glib.MainContext to get callbacks when I/O is possible.
//
// When running a non-blocking operation applications should always be able
// to handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other
// function said that I/O was possible. This can easily happen in case of a
// race condition in the application, but it can also happen for other reasons.
// For instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// As with GSocket, GDatagramBaseds can be either connection oriented (for
// example, SCTP) or connectionless (for example, UDP). GDatagramBaseds
// must be datagram-based, not stream-based. The interface does not cover
// connection establishment  use methods on the underlying type to establish a
// connection before sending and receiving data through the GDatagramBased API.
// For connectionless socket types the target/source address is specified or
// received in each I/O operation.
//
// Like most other APIs in GLib, GDatagramBased is not inherently thread safe.
// To use a GDatagramBased concurrently from multiple threads, you must
// implement your own locking.
//
// DatagramBased wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DatagramBased struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DatagramBased)(nil)
)

// DatagramBasedder describes DatagramBased's interface methods.
type DatagramBasedder interface {
	coreglib.Objector

	// ConditionCheck checks on the readiness of datagram_based to perform
	// operations.
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	// ConditionWait waits for up to timeout microseconds for condition to
	// become true on datagram_based.
	ConditionWait(ctx context.Context, condition glib.IOCondition, timeout int64) error
	// CreateSource creates a #GSource that can be attached to a Context to
	// monitor for the availability of the specified condition on the Based.
	CreateSource(ctx context.Context, condition glib.IOCondition) *glib.Source
	// ReceiveMessages: receive one or more data messages from datagram_based in
	// one go.
	ReceiveMessages(ctx context.Context, messages []InputMessage, flags int, timeout int64) (int, error)
	// SendMessages: send one or more data messages from datagram_based in one
	// go.
	SendMessages(ctx context.Context, messages []OutputMessage, flags int, timeout int64) (int, error)
}

var _ DatagramBasedder = (*DatagramBased)(nil)

func wrapDatagramBased(obj *coreglib.Object) *DatagramBased {
	return &DatagramBased{
		Object: obj,
	}
}

func marshalDatagramBased(p uintptr) (interface{}, error) {
	return wrapDatagramBased(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConditionCheck checks on the readiness of datagram_based to perform
// operations. The operations specified in condition are checked for and masked
// against the currently-satisfied conditions on datagram_based. The result is
// returned.
//
// G_IO_IN will be set in the return value if data is available to read
// with g_datagram_based_receive_messages(), or if the connection is closed
// remotely (EOS); and if the datagram_based has not been closed locally
// using some implementation-specific method (such as g_socket_close() or
// g_socket_shutdown() with shutdown_read set, if its a #GSocket).
//
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with shutdown_read set, if its a #GSocket, for example),
// all calls to this function will return G_IO_ERROR_CLOSED.
//
// G_IO_OUT will be set if it is expected that at least one byte can be sent
// using g_datagram_based_send_messages() without blocking. It will not be set
// if the datagram_based has been closed locally.
//
// G_IO_HUP will be set if the connection has been closed locally.
//
// G_IO_ERR will be set if there was an asynchronous error in transmitting data
// previously enqueued using g_datagram_based_send_messages().
//
// Note that on Windows, it is possible for an operation
// to return G_IO_ERROR_WOULD_BLOCK even immediately after
// g_datagram_based_condition_check() has claimed that the Based is ready for
// writing. Rather than calling g_datagram_based_condition_check() and then
// writing to the Based if it succeeds, it is generally better to simply try
// writing right away, and try again later if the initial attempt returns
// G_IO_ERROR_WOULD_BLOCK.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be set in the output if they are true. Apart from
// these flags, the output is guaranteed to be masked by condition.
//
// This call never blocks.
//
// The function takes the following parameters:
//
//   - condition mask to check.
//
// The function returns the following values:
//
//   - ioCondition mask of the current state.
func (datagramBased *DatagramBased) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var _arg0 *C.GDatagramBased // out
	var _arg1 C.GIOCondition    // out
	var _cret C.GIOCondition    // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	_arg1 = C.GIOCondition(condition)

	_cret = C.g_datagram_based_condition_check(_arg0, _arg1)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(condition)

	var _ioCondition glib.IOCondition // out

	_ioCondition = glib.IOCondition(_cret)

	return _ioCondition
}

// ConditionWait waits for up to timeout microseconds for condition to become
// true on datagram_based. If the condition is met, TRUE is returned.
//
// If cancellable is cancelled before the condition is met, or if timeout is
// reached before the condition is met, then FALSE is returned and error is set
// appropriately (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - condition mask to wait for.
//   - timeout: maximum time (in microseconds) to wait, 0 to not block, or -1 to
//     block indefinitely.
func (datagramBased *DatagramBased) ConditionWait(ctx context.Context, condition glib.IOCondition, timeout int64) error {
	var _arg0 *C.GDatagramBased // out
	var _arg3 *C.GCancellable   // out
	var _arg1 C.GIOCondition    // out
	var _arg2 C.gint64          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GIOCondition(condition)
	_arg2 = C.gint64(timeout)

	C.g_datagram_based_condition_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeout)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CreateSource creates a #GSource that can be attached to a Context to monitor
// for the availability of the specified condition on the Based. The #GSource
// keeps a reference to the datagram_based.
//
// The callback on the source is of the BasedSourceFunc type.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be reported in the callback if they are true.
//
// If non-NULL, cancellable can be used to cancel the source, which will cause
// the source to trigger, reporting the current condition (which is likely
// 0 unless cancellation happened at the same time as a condition change).
// You can check for this in the callback using g_cancellable_is_cancelled().
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - condition mask to monitor.
//
// The function returns the following values:
//
//   - source: newly allocated #GSource.
func (datagramBased *DatagramBased) CreateSource(ctx context.Context, condition glib.IOCondition) *glib.Source {
	var _arg0 *C.GDatagramBased // out
	var _arg2 *C.GCancellable   // out
	var _arg1 C.GIOCondition    // out
	var _cret *C.GSource        // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GIOCondition(condition)

	_cret = C.g_datagram_based_create_source(_arg0, _arg1, _arg2)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// ReceiveMessages: receive one or more data messages from datagram_based in one
// go.
//
// messages must point to an array of Message structs and num_messages must
// be the length of this array. Each Message contains a pointer to an array of
// Vector structs describing the buffers that the data received in each message
// will be written to.
//
// flags modify how all messages are received. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can
// pass in system-specific flags too. These flags affect the overall receive
// operation. Flags affecting individual messages are returned in Message.flags.
//
// The other members of Message are treated as described in its documentation.
//
// If timeout is negative the call will block until num_messages have been
// received, the connection is closed remotely (EOS), cancellable is cancelled,
// or an error occurs.
//
// If timeout is 0 the call will return up to num_messages without blocking,
// or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
// to be received.
//
// If timeout is positive the call will block on the same conditions as if
// timeout were negative. If the timeout is reached before any messages are
// received, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
// number of messages received before timing out. (Note: This is effectively the
// behaviour of MSG_WAITFORONE with recvmmsg().)
//
// To be notified when messages are available, wait for the G_IO_IN condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_receive_messages() even if you were previously notified of a
// G_IO_IN condition.
//
// If the remote peer closes the connection, any messages queued in the
// underlying receive buffer will be returned, and subsequent calls to
// g_datagram_based_receive_messages() will return 0 (with no error set).
//
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with shutdown_read set, if its a #GSocket, for example),
// all calls to this function will return G_IO_ERROR_CLOSED.
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be received; otherwise the number of messages
// successfully received before the error will be returned. If cancellable is
// cancelled, G_IO_ERROR_CANCELLED is returned as with any other error.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable.
//   - messages: array of Message structs.
//   - flags: int containing MsgFlags flags for the overall operation.
//   - timeout: maximum time (in microseconds) to wait, 0 to not block, or -1 to
//     block indefinitely.
//
// The function returns the following values:
//
//   - gint: number of messages received, or -1 on error. Note that the number
//     of messages received may be smaller than num_messages if timeout is zero
//     or positive, if the peer closed the connection, or if num_messages was
//     larger than UIO_MAXIOV (1024), in which case the caller may re-try to
//     receive the remaining messages.
func (datagramBased *DatagramBased) ReceiveMessages(ctx context.Context, messages []InputMessage, flags int, timeout int64) (int, error) {
	var _arg0 *C.GDatagramBased // out
	var _arg5 *C.GCancellable   // out
	var _arg1 *C.GInputMessage  // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _arg4 C.gint64  // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GInputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GInputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GInputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GInputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)
	_arg4 = C.gint64(timeout)

	_cret = C.g_datagram_based_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// SendMessages: send one or more data messages from datagram_based in one go.
//
// messages must point to an array of Message structs and num_messages must be
// the length of this array. Each Message contains an address to send the data
// to, and a pointer to an array of Vector structs to describe the buffers that
// the data to be sent for each message will be gathered from.
//
// flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same
// as the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
//
// The other members of Message are treated as described in its documentation.
//
// If timeout is negative the call will block until num_messages have been sent,
// cancellable is cancelled, or an error occurs.
//
// If timeout is 0 the call will send up to num_messages without blocking,
// or will return G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
//
// If timeout is positive the call will block on the same conditions as if
// timeout were negative. If the timeout is reached before any messages are
// sent, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
// of messages sent before timing out.
//
// To be notified when messages can be sent, wait for the G_IO_OUT condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_send_messages() even if you were previously notified of a
// G_IO_OUT condition. (On Windows in particular, this is very common due to the
// way the underlying APIs work.)
//
// If the connection is shut down or closed (by calling g_socket_close()
// or g_socket_shutdown() with shutdown_write set, if its a #GSocket, for
// example), all calls to this function will return G_IO_ERROR_CLOSED.
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned. If cancellable is
// cancelled, G_IO_ERROR_CANCELLED is returned as with any other error.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable.
//   - messages: array of Message structs.
//   - flags: int containing MsgFlags flags.
//   - timeout: maximum time (in microseconds) to wait, 0 to not block, or -1 to
//     block indefinitely.
//
// The function returns the following values:
//
//   - gint: number of messages sent, or -1 on error. Note that the number of
//     messages sent may be smaller than num_messages if timeout is zero or
//     positive, or if num_messages was larger than UIO_MAXIOV (1024), in which
//     case the caller may re-try to send the remaining messages.
func (datagramBased *DatagramBased) SendMessages(ctx context.Context, messages []OutputMessage, flags int, timeout int64) (int, error) {
	var _arg0 *C.GDatagramBased // out
	var _arg5 *C.GCancellable   // out
	var _arg1 *C.GOutputMessage // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _arg4 C.gint64  // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GOutputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GOutputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GOutputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)
	_arg4 = C.gint64(timeout)

	_cret = C.g_datagram_based_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// conditionCheck checks on the readiness of datagram_based to perform
// operations. The operations specified in condition are checked for and masked
// against the currently-satisfied conditions on datagram_based. The result is
// returned.
//
// G_IO_IN will be set in the return value if data is available to read
// with g_datagram_based_receive_messages(), or if the connection is closed
// remotely (EOS); and if the datagram_based has not been closed locally
// using some implementation-specific method (such as g_socket_close() or
// g_socket_shutdown() with shutdown_read set, if its a #GSocket).
//
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with shutdown_read set, if its a #GSocket, for example),
// all calls to this function will return G_IO_ERROR_CLOSED.
//
// G_IO_OUT will be set if it is expected that at least one byte can be sent
// using g_datagram_based_send_messages() without blocking. It will not be set
// if the datagram_based has been closed locally.
//
// G_IO_HUP will be set if the connection has been closed locally.
//
// G_IO_ERR will be set if there was an asynchronous error in transmitting data
// previously enqueued using g_datagram_based_send_messages().
//
// Note that on Windows, it is possible for an operation
// to return G_IO_ERROR_WOULD_BLOCK even immediately after
// g_datagram_based_condition_check() has claimed that the Based is ready for
// writing. Rather than calling g_datagram_based_condition_check() and then
// writing to the Based if it succeeds, it is generally better to simply try
// writing right away, and try again later if the initial attempt returns
// G_IO_ERROR_WOULD_BLOCK.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be set in the output if they are true. Apart from
// these flags, the output is guaranteed to be masked by condition.
//
// This call never blocks.
//
// The function takes the following parameters:
//
//   - condition mask to check.
//
// The function returns the following values:
//
//   - ioCondition mask of the current state.
func (datagramBased *DatagramBased) conditionCheck(condition glib.IOCondition) glib.IOCondition {
	gclass := (*C.GDatagramBasedInterface)(coreglib.PeekParentClass(datagramBased))
	fnarg := gclass.condition_check

	var _arg0 *C.GDatagramBased // out
	var _arg1 C.GIOCondition    // out
	var _cret C.GIOCondition    // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	_arg1 = C.GIOCondition(condition)

	_cret = C._gotk4_gio2_DatagramBased_virtual_condition_check(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(condition)

	var _ioCondition glib.IOCondition // out

	_ioCondition = glib.IOCondition(_cret)

	return _ioCondition
}

// conditionWait waits for up to timeout microseconds for condition to become
// true on datagram_based. If the condition is met, TRUE is returned.
//
// If cancellable is cancelled before the condition is met, or if timeout is
// reached before the condition is met, then FALSE is returned and error is set
// appropriately (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - condition mask to wait for.
//   - timeout: maximum time (in microseconds) to wait, 0 to not block, or -1 to
//     block indefinitely.
func (datagramBased *DatagramBased) conditionWait(ctx context.Context, condition glib.IOCondition, timeout int64) error {
	gclass := (*C.GDatagramBasedInterface)(coreglib.PeekParentClass(datagramBased))
	fnarg := gclass.condition_wait

	var _arg0 *C.GDatagramBased // out
	var _arg3 *C.GCancellable   // out
	var _arg1 C.GIOCondition    // out
	var _arg2 C.gint64          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GIOCondition(condition)
	_arg2 = C.gint64(timeout)

	C._gotk4_gio2_DatagramBased_virtual_condition_wait(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeout)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// createSource creates a #GSource that can be attached to a Context to monitor
// for the availability of the specified condition on the Based. The #GSource
// keeps a reference to the datagram_based.
//
// The callback on the source is of the BasedSourceFunc type.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be reported in the callback if they are true.
//
// If non-NULL, cancellable can be used to cancel the source, which will cause
// the source to trigger, reporting the current condition (which is likely
// 0 unless cancellation happened at the same time as a condition change).
// You can check for this in the callback using g_cancellable_is_cancelled().
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - condition mask to monitor.
//
// The function returns the following values:
//
//   - source: newly allocated #GSource.
func (datagramBased *DatagramBased) createSource(ctx context.Context, condition glib.IOCondition) *glib.Source {
	gclass := (*C.GDatagramBasedInterface)(coreglib.PeekParentClass(datagramBased))
	fnarg := gclass.create_source

	var _arg0 *C.GDatagramBased // out
	var _arg2 *C.GCancellable   // out
	var _arg1 C.GIOCondition    // out
	var _cret *C.GSource        // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GIOCondition(condition)

	_cret = C._gotk4_gio2_DatagramBased_virtual_create_source(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// receiveMessages: receive one or more data messages from datagram_based in one
// go.
//
// messages must point to an array of Message structs and num_messages must
// be the length of this array. Each Message contains a pointer to an array of
// Vector structs describing the buffers that the data received in each message
// will be written to.
//
// flags modify how all messages are received. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can
// pass in system-specific flags too. These flags affect the overall receive
// operation. Flags affecting individual messages are returned in Message.flags.
//
// The other members of Message are treated as described in its documentation.
//
// If timeout is negative the call will block until num_messages have been
// received, the connection is closed remotely (EOS), cancellable is cancelled,
// or an error occurs.
//
// If timeout is 0 the call will return up to num_messages without blocking,
// or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
// to be received.
//
// If timeout is positive the call will block on the same conditions as if
// timeout were negative. If the timeout is reached before any messages are
// received, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the
// number of messages received before timing out. (Note: This is effectively the
// behaviour of MSG_WAITFORONE with recvmmsg().)
//
// To be notified when messages are available, wait for the G_IO_IN condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_receive_messages() even if you were previously notified of a
// G_IO_IN condition.
//
// If the remote peer closes the connection, any messages queued in the
// underlying receive buffer will be returned, and subsequent calls to
// g_datagram_based_receive_messages() will return 0 (with no error set).
//
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with shutdown_read set, if its a #GSocket, for example),
// all calls to this function will return G_IO_ERROR_CLOSED.
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be received; otherwise the number of messages
// successfully received before the error will be returned. If cancellable is
// cancelled, G_IO_ERROR_CANCELLED is returned as with any other error.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable.
//   - messages: array of Message structs.
//   - flags: int containing MsgFlags flags for the overall operation.
//   - timeout: maximum time (in microseconds) to wait, 0 to not block, or -1 to
//     block indefinitely.
//
// The function returns the following values:
//
//   - gint: number of messages received, or -1 on error. Note that the number
//     of messages received may be smaller than num_messages if timeout is zero
//     or positive, if the peer closed the connection, or if num_messages was
//     larger than UIO_MAXIOV (1024), in which case the caller may re-try to
//     receive the remaining messages.
func (datagramBased *DatagramBased) receiveMessages(ctx context.Context, messages []InputMessage, flags int, timeout int64) (int, error) {
	gclass := (*C.GDatagramBasedInterface)(coreglib.PeekParentClass(datagramBased))
	fnarg := gclass.receive_messages

	var _arg0 *C.GDatagramBased // out
	var _arg5 *C.GCancellable   // out
	var _arg1 *C.GInputMessage  // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _arg4 C.gint64  // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GInputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GInputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GInputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GInputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)
	_arg4 = C.gint64(timeout)

	_cret = C._gotk4_gio2_DatagramBased_virtual_receive_messages(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// sendMessages: send one or more data messages from datagram_based in one go.
//
// messages must point to an array of Message structs and num_messages must be
// the length of this array. Each Message contains an address to send the data
// to, and a pointer to an array of Vector structs to describe the buffers that
// the data to be sent for each message will be gathered from.
//
// flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same
// as the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
//
// The other members of Message are treated as described in its documentation.
//
// If timeout is negative the call will block until num_messages have been sent,
// cancellable is cancelled, or an error occurs.
//
// If timeout is 0 the call will send up to num_messages without blocking,
// or will return G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
//
// If timeout is positive the call will block on the same conditions as if
// timeout were negative. If the timeout is reached before any messages are
// sent, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
// of messages sent before timing out.
//
// To be notified when messages can be sent, wait for the G_IO_OUT condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_send_messages() even if you were previously notified of a
// G_IO_OUT condition. (On Windows in particular, this is very common due to the
// way the underlying APIs work.)
//
// If the connection is shut down or closed (by calling g_socket_close()
// or g_socket_shutdown() with shutdown_write set, if its a #GSocket, for
// example), all calls to this function will return G_IO_ERROR_CLOSED.
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned. If cancellable is
// cancelled, G_IO_ERROR_CANCELLED is returned as with any other error.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable.
//   - messages: array of Message structs.
//   - flags: int containing MsgFlags flags.
//   - timeout: maximum time (in microseconds) to wait, 0 to not block, or -1 to
//     block indefinitely.
//
// The function returns the following values:
//
//   - gint: number of messages sent, or -1 on error. Note that the number of
//     messages sent may be smaller than num_messages if timeout is zero or
//     positive, or if num_messages was larger than UIO_MAXIOV (1024), in which
//     case the caller may re-try to send the remaining messages.
func (datagramBased *DatagramBased) sendMessages(ctx context.Context, messages []OutputMessage, flags int, timeout int64) (int, error) {
	gclass := (*C.GDatagramBasedInterface)(coreglib.PeekParentClass(datagramBased))
	fnarg := gclass.send_messages

	var _arg0 *C.GDatagramBased // out
	var _arg5 *C.GCancellable   // out
	var _arg1 *C.GOutputMessage // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _arg4 C.gint64  // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(datagramBased).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GOutputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GOutputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GOutputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)
	_arg4 = C.gint64(timeout)

	_cret = C._gotk4_gio2_DatagramBased_virtual_send_messages(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// DebugControllerOverrider contains methods that are overridable.
type DebugControllerOverrider interface {
}

// DebugController: GDebugController is an interface to expose control of
// debugging features and debug output.
//
// It is implemented on Linux using gio.DebugControllerDBus, which exposes a
// D-Bus interface to allow authenticated peers to control debug features in
// this process.
//
// Whether debug output is enabled is exposed as
// gio.DebugController:debug-enabled. This controls glib.LogSetDebugEnabled()
// by default. Application code may connect to the gobject.Object::notify signal
// for it to control other parts of its debug infrastructure as necessary.
//
// If your application or service is using the default GLib log writer function,
// creating one of the built-in implementations of GDebugController should be
// all thats needed to dynamically enable or disable debug output.
//
// DebugController wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DebugController struct {
	_ [0]func() // equal guard
	Initable
}

var ()

// DebugControllerer describes DebugController's interface methods.
type DebugControllerer interface {
	coreglib.Objector

	// DebugEnabled: get the value of Controller:debug-enabled.
	DebugEnabled() bool
	// SetDebugEnabled: set the value of Controller:debug-enabled.
	SetDebugEnabled(debugEnabled bool)
}

var _ DebugControllerer = (*DebugController)(nil)

func ifaceInitDebugControllerer(gifacePtr, data C.gpointer) {
}

func wrapDebugController(obj *coreglib.Object) *DebugController {
	return &DebugController{
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDebugController(p uintptr) (interface{}, error) {
	return wrapDebugController(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DebugEnabled: get the value of Controller:debug-enabled.
//
// The function returns the following values:
//
//   - ok: TRUE if debug output should be exposed, FALSE otherwise.
func (self *DebugController) DebugEnabled() bool {
	var _arg0 *C.GDebugController // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GDebugController)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.g_debug_controller_get_debug_enabled(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDebugEnabled: set the value of Controller:debug-enabled.
//
// The function takes the following parameters:
//
//   - debugEnabled: TRUE if debug output should be exposed, FALSE otherwise.
func (self *DebugController) SetDebugEnabled(debugEnabled bool) {
	var _arg0 *C.GDebugController // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GDebugController)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if debugEnabled {
		_arg1 = C.TRUE
	}

	C.g_debug_controller_set_debug_enabled(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(debugEnabled)
}

// Drive: GDrive represents a piece of hardware connected to the machine.
// Its generally only created for removable hardware or hardware with removable
// media.
//
// GDrive is a container class for gio.Volume objects that stem from the same
// piece of media. As such, GDrive abstracts a drive with (or without) removable
// media and provides operations for querying whether media is available,
// determining whether media change is automatically detected and ejecting the
// media.
//
// If the GDrive reports that media isnt automatically detected, one can poll
// for media; typically one should not do this periodically as a poll for media
// operation is potentially expensive and may spin up the drive creating noise.
//
// GDrive supports starting and stopping drives with authentication support
// for the former. This can be used to support a diverse set of use cases
// including connecting/disconnecting iSCSI devices, powering down external disk
// enclosures and starting/stopping multi-disk devices such as RAID devices.
// Note that the actual semantics and side-effects of starting/stopping a GDrive
// may vary according to implementation. To choose the correct verbs in e.g.
// a file manager, use gio.Drive.GetStartStopType().
//
// For porting from GnomeVFS (migrating-gnome-vfs.html) note that there is no
// equivalent of GDrive in that API.
//
// Drive wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Drive struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Drive)(nil)
)

// Driver describes Drive's interface methods.
type Driver interface {
	coreglib.Objector

	// CanEject checks if a drive can be ejected.
	CanEject() bool
	// CanPollForMedia checks if a drive can be polled for media changes.
	CanPollForMedia() bool
	// CanStart checks if a drive can be started.
	CanStart() bool
	// CanStartDegraded checks if a drive can be started degraded.
	CanStartDegraded() bool
	// CanStop checks if a drive can be stopped.
	CanStop() bool
	// Eject: asynchronously ejects a drive.
	Eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback)
	// EjectFinish finishes ejecting a drive.
	EjectFinish(result AsyncResulter) error
	// EjectWithOperation ejects a drive.
	EjectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// EjectWithOperationFinish finishes ejecting a drive.
	EjectWithOperationFinish(result AsyncResulter) error
	// EnumerateIdentifiers gets the kinds of identifiers that drive has.
	EnumerateIdentifiers() []string
	// Icon gets the icon for drive.
	Icon() *Icon
	// Identifier gets the identifier of the given kind for drive.
	Identifier(kind string) string
	// Name gets the name of drive.
	Name() string
	// SortKey gets the sort key for drive, if any.
	SortKey() string
	// StartStopType gets a hint about how a drive can be started/stopped.
	StartStopType() DriveStartStopType
	// SymbolicIcon gets the icon for drive.
	SymbolicIcon() *Icon
	// Volumes: get a list of mountable volumes for drive.
	Volumes() []*Volume
	// HasMedia checks if the drive has media.
	HasMedia() bool
	// HasVolumes: check if drive has any mountable volumes.
	HasVolumes() bool
	// IsMediaCheckAutomatic checks if drive is capable of automatically
	// detecting media changes.
	IsMediaCheckAutomatic() bool
	// IsMediaRemovable checks if the drive supports removable media.
	IsMediaRemovable() bool
	// IsRemovable checks if the #GDrive and/or its media is considered
	// removable by the user.
	IsRemovable() bool
	// PollForMedia: asynchronously polls drive to see if media has been
	// inserted or removed.
	PollForMedia(ctx context.Context, callback AsyncReadyCallback)
	// PollForMediaFinish finishes an operation started with
	// g_drive_poll_for_media() on a drive.
	PollForMediaFinish(result AsyncResulter) error
	// Start: asynchronously starts a drive.
	Start(ctx context.Context, flags DriveStartFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// StartFinish finishes starting a drive.
	StartFinish(result AsyncResulter) error
	// Stop: asynchronously stops a drive.
	Stop(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// StopFinish finishes stopping a drive.
	StopFinish(result AsyncResulter) error

	// Changed is emitted when the drive's state has changed.
	ConnectChanged(func()) coreglib.SignalHandle
	// Disconnected: this signal is emitted when the #GDrive have been
	// disconnected.
	ConnectDisconnected(func()) coreglib.SignalHandle
	// Eject-button is emitted when the physical eject button (if any) of a
	// drive has been pressed.
	ConnectEjectButton(func()) coreglib.SignalHandle
	// Stop-button is emitted when the physical stop button (if any) of a drive
	// has been pressed.
	ConnectStopButton(func()) coreglib.SignalHandle
}

var _ Driver = (*Drive)(nil)

func wrapDrive(obj *coreglib.Object) *Drive {
	return &Drive{
		Object: obj,
	}
}

func marshalDrive(p uintptr) (interface{}, error) {
	return wrapDrive(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the drive's state has changed.
func (drive *Drive) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(drive, "changed", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectChanged), f)
}

// ConnectDisconnected: this signal is emitted when the #GDrive have been
// disconnected. If the recipient is holding references to the object they
// should release them so the object can be finalized.
func (drive *Drive) ConnectDisconnected(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(drive, "disconnected", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectDisconnected), f)
}

// ConnectEjectButton is emitted when the physical eject button (if any) of a
// drive has been pressed.
func (drive *Drive) ConnectEjectButton(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(drive, "eject-button", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectEjectButton), f)
}

// ConnectStopButton is emitted when the physical stop button (if any) of a
// drive has been pressed.
func (drive *Drive) ConnectStopButton(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(drive, "stop-button", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectStopButton), f)
}

// CanEject checks if a drive can be ejected.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be ejected, FALSE otherwise.
func (drive *Drive) CanEject() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_can_eject(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanPollForMedia checks if a drive can be polled for media changes.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be polled for media changes, FALSE otherwise.
func (drive *Drive) CanPollForMedia() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_can_poll_for_media(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanStart checks if a drive can be started.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be started, FALSE otherwise.
func (drive *Drive) CanStart() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_can_start(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanStartDegraded checks if a drive can be started degraded.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be started degraded, FALSE otherwise.
func (drive *Drive) CanStartDegraded() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_can_start_degraded(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanStop checks if a drive can be stopped.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be stopped, FALSE otherwise.
func (drive *Drive) CanStop() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_can_stop(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Eject: asynchronously ejects a drive.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_eject_finish() to obtain the result of the operation.
//
// Deprecated: Use g_drive_eject_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - callback (optional) or NULL.
func (drive *Drive) Eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GDrive             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_drive_eject(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// EjectFinish finishes ejecting a drive.
//
// Deprecated: Use g_drive_eject_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) EjectFinish(result AsyncResulter) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_drive_eject_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EjectWithOperation ejects a drive. This is an asynchronous operation, and is
// finished by calling g_drive_eject_with_operation_finish() with the drive and
// Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (drive *Drive) EjectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GDrive             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_drive_eject_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish finishes ejecting a drive. If any errors occurred
// during the operation, error will be set to contain the errors and FALSE will
// be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) EjectWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_drive_eject_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EnumerateIdentifiers gets the kinds of identifiers that drive has. Use
// g_drive_get_identifier() to obtain the identifiers themselves.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings containing kinds of identifiers.
//     Use g_strfreev() to free.
func (drive *Drive) EnumerateIdentifiers() []string {
	var _arg0 *C.GDrive // out
	var _cret **C.char  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_enumerate_identifiers(_arg0)
	runtime.KeepAlive(drive)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Icon gets the icon for drive.
//
// The function returns the following values:
//
//   - icon for the drive. Free the returned object with g_object_unref().
func (drive *Drive) Icon() *Icon {
	var _arg0 *C.GDrive // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_get_icon(_arg0)
	runtime.KeepAlive(drive)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Identifier gets the identifier of the given kind for drive. The only
// identifier currently available is G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
//
// The function takes the following parameters:
//
//   - kind of identifier to return.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing the requested
//     identifier, or NULL if the #GDrive doesn't have this kind of identifier.
func (drive *Drive) Identifier(kind string) string {
	var _arg0 *C.GDrive // out
	var _arg1 *C.char   // out
	var _cret *C.char   // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_drive_get_identifier(_arg0, _arg1)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(kind)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Name gets the name of drive.
//
// The function returns the following values:
//
//   - utf8: string containing drive's name. The returned string should be freed
//     when no longer needed.
func (drive *Drive) Name() string {
	var _arg0 *C.GDrive // out
	var _cret *C.char   // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_get_name(_arg0)
	runtime.KeepAlive(drive)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SortKey gets the sort key for drive, if any.
//
// The function returns the following values:
//
//   - utf8 (optional): sorting key for drive or NULL if no such key is
//     available.
func (drive *Drive) SortKey() string {
	var _arg0 *C.GDrive // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_get_sort_key(_arg0)
	runtime.KeepAlive(drive)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// StartStopType gets a hint about how a drive can be started/stopped.
//
// The function returns the following values:
//
//   - driveStartStopType: value from the StartStopType enumeration.
func (drive *Drive) StartStopType() DriveStartStopType {
	var _arg0 *C.GDrive             // out
	var _cret C.GDriveStartStopType // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_get_start_stop_type(_arg0)
	runtime.KeepAlive(drive)

	var _driveStartStopType DriveStartStopType // out

	_driveStartStopType = DriveStartStopType(_cret)

	return _driveStartStopType
}

// SymbolicIcon gets the icon for drive.
//
// The function returns the following values:
//
//   - icon: symbolic #GIcon for the drive. Free the returned object with
//     g_object_unref().
func (drive *Drive) SymbolicIcon() *Icon {
	var _arg0 *C.GDrive // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_get_symbolic_icon(_arg0)
	runtime.KeepAlive(drive)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Volumes: get a list of mountable volumes for drive.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list containing any #GVolume objects on the given drive.
func (drive *Drive) Volumes() []*Volume {
	var _arg0 *C.GDrive // out
	var _cret *C.GList  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_get_volumes(_arg0)
	runtime.KeepAlive(drive)

	var _list []*Volume // out

	_list = make([]*Volume, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst *Volume // out
		dst = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// HasMedia checks if the drive has media. Note that the OS may not be polling
// the drive for media changes; see g_drive_is_media_check_automatic() for more
// details.
//
// The function returns the following values:
//
//   - ok: TRUE if drive has media, FALSE otherwise.
func (drive *Drive) HasMedia() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_has_media(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasVolumes: check if drive has any mountable volumes.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive contains volumes, FALSE otherwise.
func (drive *Drive) HasVolumes() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_has_volumes(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMediaCheckAutomatic checks if drive is capable of automatically detecting
// media changes.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive is capable of automatically detecting media
//     changes, FALSE otherwise.
func (drive *Drive) IsMediaCheckAutomatic() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_is_media_check_automatic(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMediaRemovable checks if the drive supports removable media.
//
// The function returns the following values:
//
//   - ok: TRUE if drive supports removable media, FALSE otherwise.
func (drive *Drive) IsMediaRemovable() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_is_media_removable(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRemovable checks if the #GDrive and/or its media is considered removable by
// the user. See g_drive_is_media_removable().
//
// The function returns the following values:
//
//   - ok: TRUE if drive and/or its media is considered removable, FALSE
//     otherwise.
func (drive *Drive) IsRemovable() bool {
	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C.g_drive_is_removable(_arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PollForMedia: asynchronously polls drive to see if media has been inserted or
// removed.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_poll_for_media_finish() to obtain the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - callback (optional) or NULL.
func (drive *Drive) PollForMedia(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GDrive             // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_drive_poll_for_media(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// PollForMediaFinish finishes an operation started with
// g_drive_poll_for_media() on a drive.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) PollForMediaFinish(result AsyncResulter) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_drive_poll_for_media_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Start: asynchronously starts a drive.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_start_finish() to obtain the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the start operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (drive *Drive) Start(ctx context.Context, flags DriveStartFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GDrive             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GDriveStartFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GDriveStartFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_drive_start(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// StartFinish finishes starting a drive.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) StartFinish(result AsyncResulter) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_drive_start_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Stop: asynchronously stops a drive.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_stop_finish() to obtain the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for stopping.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (drive *Drive) Stop(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GDrive             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_drive_stop(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// StopFinish finishes stopping a drive.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) StopFinish(result AsyncResulter) error {
	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_drive_stop_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// canEject checks if a drive can be ejected.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be ejected, FALSE otherwise.
func (drive *Drive) canEject() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.can_eject

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_can_eject(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canPollForMedia checks if a drive can be polled for media changes.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be polled for media changes, FALSE otherwise.
func (drive *Drive) canPollForMedia() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.can_poll_for_media

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_can_poll_for_media(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canStart checks if a drive can be started.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be started, FALSE otherwise.
func (drive *Drive) canStart() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.can_start

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_can_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canStartDegraded checks if a drive can be started degraded.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be started degraded, FALSE otherwise.
func (drive *Drive) canStartDegraded() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.can_start_degraded

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_can_start_degraded(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canStop checks if a drive can be stopped.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive can be stopped, FALSE otherwise.
func (drive *Drive) canStop() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.can_stop

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_can_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Changed: signal emitted when the drive is changed.
func (drive *Drive) changed() {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.changed

	var _arg0 *C.GDrive // out

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_Drive_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)
}

// Disconnected: removed signal that is emitted when the #GDrive have been
// disconnected. If the recipient is holding references to the object they
// should release them so the object can be finalized.
func (drive *Drive) disconnected() {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.disconnected

	var _arg0 *C.GDrive // out

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_Drive_virtual_disconnected(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)
}

// Eject: asynchronously ejects a drive.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_eject_finish() to obtain the result of the operation.
//
// Deprecated: Use g_drive_eject_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - callback (optional) or NULL.
func (drive *Drive) eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.eject

	var _arg0 *C.GDrive             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Drive_virtual_eject(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ejectButton: signal emitted when the physical eject button (if any) of a
// drive have been pressed.
func (drive *Drive) ejectButton() {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.eject_button

	var _arg0 *C.GDrive // out

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_Drive_virtual_eject_button(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)
}

// ejectFinish finishes ejecting a drive.
//
// Deprecated: Use g_drive_eject_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) ejectFinish(result AsyncResulter) error {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.eject_finish

	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Drive_virtual_eject_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ejectWithOperation ejects a drive. This is an asynchronous operation, and is
// finished by calling g_drive_eject_with_operation_finish() with the drive and
// Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (drive *Drive) ejectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.eject_with_operation

	var _arg0 *C.GDrive             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Drive_virtual_eject_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// ejectWithOperationFinish finishes ejecting a drive. If any errors occurred
// during the operation, error will be set to contain the errors and FALSE will
// be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) ejectWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.eject_with_operation_finish

	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Drive_virtual_eject_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// enumerateIdentifiers gets the kinds of identifiers that drive has. Use
// g_drive_get_identifier() to obtain the identifiers themselves.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings containing kinds of identifiers.
//     Use g_strfreev() to free.
func (drive *Drive) enumerateIdentifiers() []string {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.enumerate_identifiers

	var _arg0 *C.GDrive // out
	var _cret **C.char  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_enumerate_identifiers(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Icon gets the icon for drive.
//
// The function returns the following values:
//
//   - icon for the drive. Free the returned object with g_object_unref().
func (drive *Drive) icon() *Icon {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.get_icon

	var _arg0 *C.GDrive // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_get_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Identifier gets the identifier of the given kind for drive. The only
// identifier currently available is G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
//
// The function takes the following parameters:
//
//   - kind of identifier to return.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing the requested
//     identifier, or NULL if the #GDrive doesn't have this kind of identifier.
func (drive *Drive) identifier(kind string) string {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.get_identifier

	var _arg0 *C.GDrive // out
	var _arg1 *C.char   // out
	var _cret *C.char   // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_Drive_virtual_get_identifier(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(kind)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Name gets the name of drive.
//
// The function returns the following values:
//
//   - utf8: string containing drive's name. The returned string should be freed
//     when no longer needed.
func (drive *Drive) name() string {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.get_name

	var _arg0 *C.GDrive // out
	var _cret *C.char   // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// sortKey gets the sort key for drive, if any.
//
// The function returns the following values:
//
//   - utf8 (optional): sorting key for drive or NULL if no such key is
//     available.
func (drive *Drive) sortKey() string {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.get_sort_key

	var _arg0 *C.GDrive // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_get_sort_key(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// startStopType gets a hint about how a drive can be started/stopped.
//
// The function returns the following values:
//
//   - driveStartStopType: value from the StartStopType enumeration.
func (drive *Drive) startStopType() DriveStartStopType {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.get_start_stop_type

	var _arg0 *C.GDrive             // out
	var _cret C.GDriveStartStopType // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_get_start_stop_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _driveStartStopType DriveStartStopType // out

	_driveStartStopType = DriveStartStopType(_cret)

	return _driveStartStopType
}

// symbolicIcon gets the icon for drive.
//
// The function returns the following values:
//
//   - icon: symbolic #GIcon for the drive. Free the returned object with
//     g_object_unref().
func (drive *Drive) symbolicIcon() *Icon {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.get_symbolic_icon

	var _arg0 *C.GDrive // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_get_symbolic_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Volumes: get a list of mountable volumes for drive.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list containing any #GVolume objects on the given drive.
func (drive *Drive) volumes() []*Volume {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.get_volumes

	var _arg0 *C.GDrive // out
	var _cret *C.GList  // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_get_volumes(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _list []*Volume // out

	_list = make([]*Volume, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst *Volume // out
		dst = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// hasMedia checks if the drive has media. Note that the OS may not be polling
// the drive for media changes; see g_drive_is_media_check_automatic() for more
// details.
//
// The function returns the following values:
//
//   - ok: TRUE if drive has media, FALSE otherwise.
func (drive *Drive) hasMedia() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.has_media

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_has_media(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// hasVolumes: check if drive has any mountable volumes.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive contains volumes, FALSE otherwise.
func (drive *Drive) hasVolumes() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.has_volumes

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_has_volumes(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// isMediaCheckAutomatic checks if drive is capable of automatically detecting
// media changes.
//
// The function returns the following values:
//
//   - ok: TRUE if the drive is capable of automatically detecting media
//     changes, FALSE otherwise.
func (drive *Drive) isMediaCheckAutomatic() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.is_media_check_automatic

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_is_media_check_automatic(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// isMediaRemovable checks if the drive supports removable media.
//
// The function returns the following values:
//
//   - ok: TRUE if drive supports removable media, FALSE otherwise.
func (drive *Drive) isMediaRemovable() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.is_media_removable

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_is_media_removable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// isRemovable checks if the #GDrive and/or its media is considered removable by
// the user. See g_drive_is_media_removable().
//
// The function returns the following values:
//
//   - ok: TRUE if drive and/or its media is considered removable, FALSE
//     otherwise.
func (drive *Drive) isRemovable() bool {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.is_removable

	var _arg0 *C.GDrive  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	_cret = C._gotk4_gio2_Drive_virtual_is_removable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// pollForMedia: asynchronously polls drive to see if media has been inserted or
// removed.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_poll_for_media_finish() to obtain the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - callback (optional) or NULL.
func (drive *Drive) pollForMedia(ctx context.Context, callback AsyncReadyCallback) {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.poll_for_media

	var _arg0 *C.GDrive             // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Drive_virtual_poll_for_media(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// pollForMediaFinish finishes an operation started with
// g_drive_poll_for_media() on a drive.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) pollForMediaFinish(result AsyncResulter) error {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.poll_for_media_finish

	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Drive_virtual_poll_for_media_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Start: asynchronously starts a drive.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_start_finish() to obtain the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the start operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (drive *Drive) start(ctx context.Context, flags DriveStartFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.start

	var _arg0 *C.GDrive             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GDriveStartFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GDriveStartFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Drive_virtual_start(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// startFinish finishes starting a drive.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) startFinish(result AsyncResulter) error {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.start_finish

	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Drive_virtual_start_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Stop: asynchronously stops a drive.
//
// When the operation is finished, callback will be called. You can then call
// g_drive_stop_finish() to obtain the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for stopping.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (drive *Drive) stop(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.stop

	var _arg0 *C.GDrive             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Drive_virtual_stop(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// stopButton: signal emitted when the physical stop button (if any) of a drive
// have been pressed. Since 2.22.
func (drive *Drive) stopButton() {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.stop_button

	var _arg0 *C.GDrive // out

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_Drive_virtual_stop_button(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(drive)
}

// stopFinish finishes stopping a drive.
//
// The function takes the following parameters:
//
//   - result: Result.
func (drive *Drive) stopFinish(result AsyncResulter) error {
	gclass := (*C.GDriveIface)(coreglib.PeekParentClass(drive))
	fnarg := gclass.stop_finish

	var _arg0 *C.GDrive       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Drive_virtual_stop_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DTLSClientConnectionOverrider contains methods that are overridable.
type DTLSClientConnectionOverrider interface {
}

// DTLSClientConnection: GDtlsClientConnection is the client-side subclass of
// gio.DTLSConnection, representing a client-side DTLS connection.
//
// DTLSClientConnection wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DTLSClientConnection struct {
	_ [0]func() // equal guard
	DTLSConnection
}

var ()

// DTLSClientConnectioner describes DTLSClientConnection's interface methods.
type DTLSClientConnectioner interface {
	coreglib.Objector

	// ServerIdentity gets conn's expected server identity.
	ServerIdentity() *SocketConnectable
	// ValidationFlags gets conn's validation flags.
	ValidationFlags() TLSCertificateFlags
	// SetServerIdentity sets conn's expected server identity, which is used
	// both to tell servers on virtual hosts which certificate to present,
	// and also to let conn know what name to look for in the certificate when
	// performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	SetServerIdentity(identity SocketConnectabler)
	// SetValidationFlags sets conn's validation flags, to override the default
	// set of checks performed when validating a server certificate.
	SetValidationFlags(flags TLSCertificateFlags)
}

var _ DTLSClientConnectioner = (*DTLSClientConnection)(nil)

func ifaceInitDTLSClientConnectioner(gifacePtr, data C.gpointer) {
}

func wrapDTLSClientConnection(obj *coreglib.Object) *DTLSClientConnection {
	return &DTLSClientConnection{
		DTLSConnection: DTLSConnection{
			DatagramBased: DatagramBased{
				Object: obj,
			},
		},
	}
}

func marshalDTLSClientConnection(p uintptr) (interface{}, error) {
	return wrapDTLSClientConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ServerIdentity gets conn's expected server identity.
//
// The function returns the following values:
//
//   - socketConnectable describing the expected server identity, or NULL if the
//     expected identity is not known.
func (conn *DTLSClientConnection) ServerIdentity() *SocketConnectable {
	var _arg0 *C.GDtlsClientConnection // out
	var _cret *C.GSocketConnectable    // in

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_client_connection_get_server_identity(_arg0)
	runtime.KeepAlive(conn)

	var _socketConnectable *SocketConnectable // out

	_socketConnectable = wrapSocketConnectable(coreglib.Take(unsafe.Pointer(_cret)))

	return _socketConnectable
}

// ValidationFlags gets conn's validation flags
//
// This function does not work as originally designed and is impossible to use
// correctly. See ClientConnection:validation-flags for more information.
//
// Deprecated: Do not attempt to ignore validation errors.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: validation flags.
func (conn *DTLSClientConnection) ValidationFlags() TLSCertificateFlags {
	var _arg0 *C.GDtlsClientConnection // out
	var _cret C.GTlsCertificateFlags   // in

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_client_connection_get_validation_flags(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// SetServerIdentity sets conn's expected server identity, which is used both
// to tell servers on virtual hosts which certificate to present, and also
// to let conn know what name to look for in the certificate when performing
// G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
//
// The function takes the following parameters:
//
//   - identity describing the expected server identity.
func (conn *DTLSClientConnection) SetServerIdentity(identity SocketConnectabler) {
	var _arg0 *C.GDtlsClientConnection // out
	var _arg1 *C.GSocketConnectable    // out

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))

	C.g_dtls_client_connection_set_server_identity(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(identity)
}

// SetValidationFlags sets conn's validation flags, to override the default
// set of checks performed when validating a server certificate. By default,
// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
//
// This function does not work as originally designed and is impossible to use
// correctly. See ClientConnection:validation-flags for more information.
//
// Deprecated: Do not attempt to ignore validation errors.
//
// The function takes the following parameters:
//
//   - flags to use.
func (conn *DTLSClientConnection) SetValidationFlags(flags TLSCertificateFlags) {
	var _arg0 *C.GDtlsClientConnection // out
	var _arg1 C.GTlsCertificateFlags   // out

	_arg0 = (*C.GDtlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsCertificateFlags(flags)

	C.g_dtls_client_connection_set_validation_flags(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(flags)
}

// NewDTLSClientConnection creates a new ClientConnection wrapping
// base_socket which is assumed to communicate with the server identified by
// server_identity.
//
// The function takes the following parameters:
//
//   - baseSocket to wrap.
//   - serverIdentity (optional): expected identity of the server.
//
// The function returns the following values:
//
//   - dtlsClientConnection: new ClientConnection, or NULL on error.
func NewDTLSClientConnection(baseSocket DatagramBasedder, serverIdentity SocketConnectabler) (*DTLSClientConnection, error) {
	var _arg1 *C.GDatagramBased     // out
	var _arg2 *C.GSocketConnectable // out
	var _cret *C.GDatagramBased     // in
	var _cerr *C.GError             // in

	_arg1 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(baseSocket).Native()))
	if serverIdentity != nil {
		_arg2 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(serverIdentity).Native()))
	}

	_cret = C.g_dtls_client_connection_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(baseSocket)
	runtime.KeepAlive(serverIdentity)

	var _dtlsClientConnection *DTLSClientConnection // out
	var _goerr error                                // out

	_dtlsClientConnection = wrapDTLSClientConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dtlsClientConnection, _goerr
}

// DTLSConnection: GDtlsConnection is the base DTLS connection class type,
// which wraps a gio.DatagramBased and provides DTLS encryption on top of it.
// Its subclasses, gio.DTLSClientConnection and gio.DTLSServerConnection,
// implement client-side and server-side DTLS, respectively.
//
// For TLS support, see gio.TLSConnection.
//
// As DTLS is datagram based, GDtlsConnection implements gio.DatagramBased,
// presenting a datagram-socket-like API for the encrypted connection.
// This operates over a base datagram connection, which is also a GDatagramBased
// (gio.DTLSConnection:base-socket).
//
// To close a DTLS connection, use gio.DTLSConnection.Close().
//
// Neither gio.DTLSServerConnection or gio.DTLSClientConnection set the peer
// address on their base gio.DatagramBased if it is a gio.Socket  it is up to
// the caller to do that if they wish. If they do not, and gio.Socket.Close()
// is called on the base socket, the GDtlsConnection will not raise a
// G_IO_ERROR_NOT_CONNECTED error on further I/O.
//
// DTLSConnection wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DTLSConnection struct {
	_ [0]func() // equal guard
	DatagramBased
}

var ()

// DTLSConnectioner describes DTLSConnection's interface methods.
type DTLSConnectioner interface {
	coreglib.Objector

	// Close the DTLS connection.
	Close(ctx context.Context) error
	// CloseAsync: asynchronously close the DTLS connection.
	CloseAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// CloseFinish: finish an asynchronous TLS close operation.
	CloseFinish(result AsyncResulter) error
	// EmitAcceptCertificate: used by Connection implementations to emit the
	// Connection::accept-certificate signal.
	EmitAcceptCertificate(peerCert TLSCertificater, errors TLSCertificateFlags) bool
	// Certificate gets conn's certificate, as set by
	// g_dtls_connection_set_certificate().
	Certificate() TLSCertificater
	// ChannelBindingData: query the TLS backend for TLS channel binding data of
	// type for conn.
	ChannelBindingData(typ TLSChannelBindingType) ([]byte, error)
	// CiphersuiteName returns the name of the current DTLS ciphersuite,
	// or NULL if the connection has not handshaked or has been closed.
	CiphersuiteName() string
	// Database gets the certificate database that conn uses to verify peer
	// certificates.
	Database() TLSDatabaser
	// Interaction: get the object that will be used to interact with the user.
	Interaction() *TLSInteraction
	// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	NegotiatedProtocol() string
	// PeerCertificate gets conn's peer's certificate after the handshake has
	// completed or failed.
	PeerCertificate() TLSCertificater
	// PeerCertificateErrors gets the errors associated with validating conn's
	// peer's certificate, after the handshake has completed or failed.
	PeerCertificateErrors() TLSCertificateFlags
	// ProtocolVersion returns the current DTLS protocol version, which may be
	// G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked,
	// or has been closed, or if the TLS backend has implemented a protocol
	// version that is not a recognized ProtocolVersion.
	ProtocolVersion() TLSProtocolVersion
	// RehandshakeMode gets conn rehandshaking mode.
	RehandshakeMode() TLSRehandshakeMode
	// RequireCloseNotify tests whether or not conn expects a proper TLS close
	// notification when the connection is closed.
	RequireCloseNotify() bool
	// Handshake attempts a TLS handshake on conn.
	Handshake(ctx context.Context) error
	// HandshakeAsync: asynchronously performs a TLS handshake on conn.
	HandshakeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// HandshakeFinish: finish an asynchronous TLS handshake operation.
	HandshakeFinish(result AsyncResulter) error
	// SetAdvertisedProtocols sets the list of application-layer protocols to
	// advertise that the caller is willing to speak on this connection.
	SetAdvertisedProtocols(protocols []string)
	// SetCertificate: this sets the certificate that conn will present to its
	// peer during the TLS handshake.
	SetCertificate(certificate TLSCertificater)
	// SetDatabase sets the certificate database that is used to verify peer
	// certificates.
	SetDatabase(database TLSDatabaser)
	// SetInteraction: set the object that will be used to interact with the
	// user.
	SetInteraction(interaction *TLSInteraction)
	// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
	// longer supported and will have no effect.
	SetRehandshakeMode(mode TLSRehandshakeMode)
	// SetRequireCloseNotify sets whether or not conn expects a proper TLS close
	// notification before the connection is closed.
	SetRequireCloseNotify(requireCloseNotify bool)
	// Shutdown: shut down part or all of a DTLS connection.
	Shutdown(ctx context.Context, shutdownRead, shutdownWrite bool) error
	// ShutdownAsync: asynchronously shut down part or all of the DTLS
	// connection.
	ShutdownAsync(ctx context.Context, shutdownRead, shutdownWrite bool, ioPriority int, callback AsyncReadyCallback)
	// ShutdownFinish: finish an asynchronous TLS shutdown operation.
	ShutdownFinish(result AsyncResulter) error

	// Accept-certificate is emitted during the TLS handshake after the peer
	// certificate has been received.
	ConnectAcceptCertificate(func(peerCert TLSCertificater, errors TLSCertificateFlags) (ok bool)) coreglib.SignalHandle
}

var _ DTLSConnectioner = (*DTLSConnection)(nil)

func wrapDTLSConnection(obj *coreglib.Object) *DTLSConnection {
	return &DTLSConnection{
		DatagramBased: DatagramBased{
			Object: obj,
		},
	}
}

func marshalDTLSConnection(p uintptr) (interface{}, error) {
	return wrapDTLSConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAcceptCertificate is emitted during the TLS handshake after the peer
// certificate has been received. You can examine peer_cert's certification path
// by calling g_tls_certificate_get_issuer() on it.
//
// For a client-side connection, peer_cert is the server's certificate,
// and the signal will only be emitted if the certificate was not acceptable
// according to conn's ClientConnection:validation_flags. If you would like
// the certificate to be accepted despite errors, return TRUE from the signal
// handler. Otherwise, if no handler accepts the certificate, the handshake will
// fail with G_TLS_ERROR_BAD_CERTIFICATE.
//
// GLib guarantees that if certificate verification fails, this signal will
// be emitted with at least one error will be set in errors, but it does not
// guarantee that all possible errors will be set. Accordingly, you may not
// safely decide to ignore any particular type of error. For example, it would
// be incorrect to ignore G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
// certificates, because this could potentially be the only error flag set even
// if other problems exist with the certificate.
//
// For a server-side connection, peer_cert is the certificate
// presented by the client, if this was requested via the server's
// ServerConnection:authentication_mode. On the server side, the signal is
// always emitted when the client presents a certificate, and the certificate
// will only be accepted if a handler returns TRUE.
//
// Note that if this signal is emitted as part of asynchronous I/O in the
// main thread, then you should not attempt to interact with the user before
// returning from the signal handler. If you want to let the user decide whether
// or not to accept the certificate, you would have to return FALSE from the
// signal handler on the first attempt, and then after the connection attempt
// returns a G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user,
// and if the user decides to accept the certificate, remember that fact, create
// a new connection, and return TRUE from the signal handler the next time.
//
// If you are doing I/O in another thread, you do not need to worry about this,
// and can simply block in the signal handler until the UI thread returns an
// answer.
func (conn *DTLSConnection) ConnectAcceptCertificate(f func(peerCert TLSCertificater, errors TLSCertificateFlags) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(conn, "accept-certificate", false, unsafe.Pointer(C._gotk4_gio2_DtlsConnection_ConnectAcceptCertificate), f)
}

// Close the DTLS connection. This is equivalent to calling
// g_dtls_connection_shutdown() to shut down both sides of the connection.
//
// Closing a Connection waits for all buffered but untransmitted data to be sent
// before it completes. It then sends a close_notify DTLS alert to the peer and
// may wait for a close_notify to be received from the peer. It does not close
// the underlying Connection:base-socket; that must be closed separately.
//
// Once conn is closed, all other operations will return G_IO_ERROR_CLOSED.
// Closing a Connection multiple times will not return an error.
//
// Connections will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are released
// as early as possible.
//
// If cancellable is cancelled, the Connection may be left partially-closed and
// any pending untransmitted data may be lost. Call g_dtls_connection_close()
// again to complete closing the Connection.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (conn *DTLSConnection) Close(ctx context.Context) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_dtls_connection_close(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CloseAsync: asynchronously close the DTLS connection. See
// g_dtls_connection_close() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the close operation is complete.
func (conn *DTLSConnection) CloseAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GDtlsConnection    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dtls_connection_close_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CloseFinish: finish an asynchronous TLS close operation. See
// g_dtls_connection_close() for more information.
//
// The function takes the following parameters:
//
//   - result: Result.
func (conn *DTLSConnection) CloseFinish(result AsyncResulter) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_dtls_connection_close_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EmitAcceptCertificate: used by Connection implementations to emit the
// Connection::accept-certificate signal.
//
// The function takes the following parameters:
//
//   - peerCert peer's Certificate.
//   - errors problems with peer_cert.
//
// The function returns the following values:
//
//   - ok: TRUE if one of the signal handlers has returned TRUE to accept
//     peer_cert.
func (conn *DTLSConnection) EmitAcceptCertificate(peerCert TLSCertificater, errors TLSCertificateFlags) bool {
	var _arg0 *C.GDtlsConnection     // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(peerCert).Native()))
	_arg2 = C.GTlsCertificateFlags(errors)

	_cret = C.g_dtls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Certificate gets conn's certificate, as set by
// g_dtls_connection_set_certificate().
//
// The function returns the following values:
//
//   - tlsCertificate (optional) conn's certificate, or NULL.
func (conn *DTLSConnection) Certificate() TLSCertificater {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_certificate(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificate TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// ChannelBindingData: query the TLS backend for TLS channel binding data of
// type for conn.
//
// This call retrieves TLS channel binding data as specified
// in RFC 5056 (https://tools.ietf.org/html/rfc5056), RFC 5929
// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding
// data is returned in data. The data is resized by the callee using
// Array buffer management and will be freed when the data is destroyed by
// g_byte_array_unref(). If data is NULL, it will only check whether TLS
// backend is able to fetch the data (e.g. whether type is supported by the
// TLS backend). It does not guarantee that the data will be available though.
// That could happen if TLS connection does not support type or the binding data
// is not available yet due to additional negotiation or input required.
//
// The function takes the following parameters:
//
//   - typ type of data to fetch.
//
// The function returns the following values:
//
//   - data (optional) is filled with the binding data, or NULL.
func (conn *DTLSConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
	var _arg0 *C.GDtlsConnection       // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 C.GByteArray             // in
	var _cerr *C.GError                // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsChannelBindingType(typ)

	C.g_dtls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(typ)

	var _data []byte // out
	var _goerr error // out

	_data = make([]byte, _arg2.len)
	copy(_data, unsafe.Slice((*byte)(_arg2.data), _arg2.len))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _data, _goerr
}

// CiphersuiteName returns the name of the current DTLS ciphersuite, or NULL
// if the connection has not handshaked or has been closed. Beware that the TLS
// backend may use any of multiple different naming conventions, because OpenSSL
// and GnuTLS have their own ciphersuite naming conventions that are different
// from each other and different from the standard, IANA- registered ciphersuite
// names. The ciphersuite name is intended to be displayed to the user for
// informative purposes only, and parsing it is not recommended.
//
// The function returns the following values:
//
//   - utf8 (optional): name of the current DTLS ciphersuite, or NULL.
func (conn *DTLSConnection) CiphersuiteName() string {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_ciphersuite_name(_arg0)
	runtime.KeepAlive(conn)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Database gets the certificate database that conn uses to verify peer
// certificates. See g_dtls_connection_set_database().
//
// The function returns the following values:
//
//   - tlsDatabase (optional): certificate database that conn uses or NULL.
func (conn *DTLSConnection) Database() TLSDatabaser {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsDatabase    // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_database(_arg0)
	runtime.KeepAlive(conn)

	var _tlsDatabase TLSDatabaser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSDatabaser)
				return ok
			})
			rv, ok := casted.(TLSDatabaser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
			}
			_tlsDatabase = rv
		}
	}

	return _tlsDatabase
}

// Interaction: get the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords. If NULL is
// returned, then no user interaction will occur for this connection.
//
// The function returns the following values:
//
//   - tlsInteraction (optional): interaction object.
func (conn *DTLSConnection) Interaction() *TLSInteraction {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_interaction(_arg0)
	runtime.KeepAlive(conn)

	var _tlsInteraction *TLSInteraction // out

	if _cret != nil {
		_tlsInteraction = wrapTLSInteraction(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _tlsInteraction
}

// NegotiatedProtocol gets the name of the application-layer protocol negotiated
// during the handshake.
//
// If the peer did not use the ALPN extension, or did not advertise
// a protocol that matched one of conn's protocols, or the TLS
// backend does not support ALPN, then this will be NULL. See
// g_dtls_connection_set_advertised_protocols().
//
// The function returns the following values:
//
//   - utf8 (optional): negotiated protocol, or NULL.
func (conn *DTLSConnection) NegotiatedProtocol() string {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_negotiated_protocol(_arg0)
	runtime.KeepAlive(conn)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PeerCertificate gets conn's peer's certificate after the handshake
// has completed or failed. (It is not set during the emission of
// Connection::accept-certificate.).
//
// The function returns the following values:
//
//   - tlsCertificate (optional) conn's peer's certificate, or NULL.
func (conn *DTLSConnection) PeerCertificate() TLSCertificater {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_peer_certificate(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificate TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// PeerCertificateErrors gets the errors associated with validating conn's
// peer's certificate, after the handshake has completed or failed. (It is not
// set during the emission of Connection::accept-certificate.).
//
// The function returns the following values:
//
//   - tlsCertificateFlags conn's peer's certificate errors.
func (conn *DTLSConnection) PeerCertificateErrors() TLSCertificateFlags {
	var _arg0 *C.GDtlsConnection     // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_peer_certificate_errors(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// ProtocolVersion returns the current DTLS protocol version, which may be
// G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or has
// been closed, or if the TLS backend has implemented a protocol version that is
// not a recognized ProtocolVersion.
//
// The function returns the following values:
//
//   - tlsProtocolVersion: current DTLS protocol version.
func (conn *DTLSConnection) ProtocolVersion() TLSProtocolVersion {
	var _arg0 *C.GDtlsConnection    // out
	var _cret C.GTlsProtocolVersion // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_protocol_version(_arg0)
	runtime.KeepAlive(conn)

	var _tlsProtocolVersion TLSProtocolVersion // out

	_tlsProtocolVersion = TLSProtocolVersion(_cret)

	return _tlsProtocolVersion
}

// RehandshakeMode gets conn rehandshaking mode. See
// g_dtls_connection_set_rehandshake_mode() for details.
//
// Deprecated: Changing the rehandshake mode is no longer required for
// compatibility. Also, rehandshaking has been removed from the TLS protocol in
// TLS 1.3.
//
// The function returns the following values:
//
//   - tlsRehandshakeMode: G_TLS_REHANDSHAKE_SAFELY.
func (conn *DTLSConnection) RehandshakeMode() TLSRehandshakeMode {
	var _arg0 *C.GDtlsConnection    // out
	var _cret C.GTlsRehandshakeMode // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_rehandshake_mode(_arg0)
	runtime.KeepAlive(conn)

	var _tlsRehandshakeMode TLSRehandshakeMode // out

	_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

	return _tlsRehandshakeMode
}

// RequireCloseNotify tests whether or not conn expects a proper
// TLS close notification when the connection is closed. See
// g_dtls_connection_set_require_close_notify() for details.
//
// The function returns the following values:
//
//   - ok: TRUE if conn requires a proper TLS close notification.
func (conn *DTLSConnection) RequireCloseNotify() bool {
	var _arg0 *C.GDtlsConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_dtls_connection_get_require_close_notify(_arg0)
	runtime.KeepAlive(conn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Handshake attempts a TLS handshake on conn.
//
// On the client side, it is never necessary to call this method; although the
// connection needs to perform a handshake after connecting, Connection will
// handle this for you automatically when you try to send or receive data on the
// connection. You can call g_dtls_connection_handshake() manually if you want
// to know whether the initial handshake succeeded or failed (as opposed to just
// immediately trying to use conn to read or write, in which case, if it fails,
// it may not be possible to tell if it failed before or after completing the
// handshake), but beware that servers may reject client authentication after
// the handshake has completed, so a successful handshake does not indicate the
// connection will be usable.
//
// Likewise, on the server side, although a handshake is necessary at the
// beginning of the communication, you do not need to call this function
// explicitly unless you want clearer error reporting.
//
// Previously, calling g_dtls_connection_handshake() after the initial handshake
// would trigger a rehandshake; however, this usage was deprecated in GLib
// 2.60 because rehandshaking was removed from the TLS protocol in TLS 1.3.
// Since GLib 2.64, calling this function after the initial handshake will no
// longer do anything.
//
// Connection::accept_certificate may be emitted during the handshake.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (conn *DTLSConnection) Handshake(ctx context.Context) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_dtls_connection_handshake(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// HandshakeAsync: asynchronously performs a TLS handshake on conn. See
// g_dtls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the handshake is complete.
func (conn *DTLSConnection) HandshakeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GDtlsConnection    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dtls_connection_handshake_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// HandshakeFinish: finish an asynchronous TLS handshake operation. See
// g_dtls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - result: Result.
func (conn *DTLSConnection) HandshakeFinish(result AsyncResulter) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_dtls_connection_handshake_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAdvertisedProtocols sets the list of application-layer protocols
// to advertise that the caller is willing to speak on this connection.
// The Application-Layer Protocol Negotiation (ALPN) extension will
// be used to negotiate a compatible protocol with the peer; use
// g_dtls_connection_get_negotiated_protocol() to find the negotiated protocol
// after the handshake. Specifying NULL for the the value of protocols will
// disable ALPN negotiation.
//
// See IANA TLS ALPN Protocol IDs
// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
//
// The function takes the following parameters:
//
//   - protocols (optional): NULL-terminated array of ALPN protocol names (eg,
//     "http/1.1", "h2"), or NULL.
func (conn *DTLSConnection) SetAdvertisedProtocols(protocols []string) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 **C.gchar          // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(protocols) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(protocols)+1)
			var zero *C.gchar
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.g_dtls_connection_set_advertised_protocols(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(protocols)
}

// SetCertificate: this sets the certificate that conn will present to its peer
// during the TLS handshake. For a ServerConnection, it is mandatory to set
// this, and that will normally be done at construct time.
//
// For a ClientConnection, this is optional. If a handshake fails with
// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
// certificate, and if you try connecting again, you should call this method
// first. You can call g_dtls_client_connection_get_accepted_cas() on the failed
// connection to get a list of Certificate Authorities that the server will
// accept certificates from.
//
// (It is also possible that a server will allow the connection with or
// without a certificate; in that case, if you don't provide a certificate,
// you can tell that the server requested one by the fact that
// g_dtls_client_connection_get_accepted_cas() will return non-NULL.).
//
// The function takes the following parameters:
//
//   - certificate to use for conn.
func (conn *DTLSConnection) SetCertificate(certificate TLSCertificater) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))

	C.g_dtls_connection_set_certificate(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(certificate)
}

// SetDatabase sets the certificate database that is used to verify
// peer certificates. This is set to the default database by default.
// See g_tls_backend_get_default_database(). If set to NULL, then peer
// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA
// error (meaning Connection::accept-certificate will always be
// emitted on client-side connections, unless that bit is not set in
// ClientConnection:validation-flags).
//
// There are nonintuitive security implications when using a non-default
// database. See Connection:database for details.
//
// The function takes the following parameters:
//
//   - database (optional): Database.
func (conn *DTLSConnection) SetDatabase(database TLSDatabaser) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsDatabase    // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if database != nil {
		_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(database).Native()))
	}

	C.g_dtls_connection_set_database(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(database)
}

// SetInteraction: set the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords.
//
// The interaction argument will normally be a derived subclass of Interaction.
// NULL can also be provided if no user interaction should occur for this
// connection.
//
// The function takes the following parameters:
//
//   - interaction (optional) object, or NULL.
func (conn *DTLSConnection) SetInteraction(interaction *TLSInteraction) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if interaction != nil {
		_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}

	C.g_dtls_connection_set_interaction(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(interaction)
}

// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
// longer supported and will have no effect. With TLS 1.3, rehandshaking has
// been removed from the TLS protocol, replaced by separate post-handshake
// authentication and rekey operations.
//
// Deprecated: Changing the rehandshake mode is no longer required for
// compatibility. Also, rehandshaking has been removed from the TLS protocol in
// TLS 1.3.
//
// The function takes the following parameters:
//
//   - mode: rehandshaking mode.
func (conn *DTLSConnection) SetRehandshakeMode(mode TLSRehandshakeMode) {
	var _arg0 *C.GDtlsConnection    // out
	var _arg1 C.GTlsRehandshakeMode // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsRehandshakeMode(mode)

	C.g_dtls_connection_set_rehandshake_mode(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(mode)
}

// SetRequireCloseNotify sets whether or not conn expects a proper TLS close
// notification before the connection is closed. If this is TRUE (the default),
// then conn will expect to receive a TLS close notification from its peer
// before the connection is closed, and will return a G_TLS_ERROR_EOF error if
// the connection is closed without proper notification (since this may indicate
// a network error, or man-in-the-middle attack).
//
// In some protocols, the application will know whether or not the
// connection was closed cleanly based on application-level data (because
// the application-level data includes a length field, or is somehow
// self-delimiting); in this case, the close notify is redundant and may be
// omitted. You can use g_dtls_connection_set_require_close_notify() to tell
// conn to allow an "unannounced" connection close, in which case the close
// will show up as a 0-length read, as in a non-TLS Based, and it is up to the
// application to check that the data has been fully received.
//
// Note that this only affects the behavior when the peer closes the connection;
// when the application calls g_dtls_connection_close_async() on conn itself,
// this will send a close notification regardless of the setting of this
// property. If you explicitly want to do an unclean close, you can close conn's
// Connection:base-socket rather than closing conn itself.
//
// The function takes the following parameters:
//
//   - requireCloseNotify: whether or not to require close notification.
func (conn *DTLSConnection) SetRequireCloseNotify(requireCloseNotify bool) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if requireCloseNotify {
		_arg1 = C.TRUE
	}

	C.g_dtls_connection_set_require_close_notify(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(requireCloseNotify)
}

// Shutdown: shut down part or all of a DTLS connection.
//
// If shutdown_read is TRUE then the receiving side of the connection
// is shut down, and further reading is disallowed. Subsequent calls to
// g_datagram_based_receive_messages() will return G_IO_ERROR_CLOSED.
//
// If shutdown_write is TRUE then the sending side of the connection
// is shut down, and further writing is disallowed. Subsequent calls to
// g_datagram_based_send_messages() will return G_IO_ERROR_CLOSED.
//
// It is allowed for both shutdown_read and shutdown_write to be TRUE  this is
// equivalent to calling g_dtls_connection_close().
//
// If cancellable is cancelled, the Connection may be left partially-closed and
// any pending untransmitted data may be lost. Call g_dtls_connection_shutdown()
// again to complete closing the Connection.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - shutdownRead: TRUE to stop reception of incoming datagrams.
//   - shutdownWrite: TRUE to stop sending outgoing datagrams.
func (conn *DTLSConnection) Shutdown(ctx context.Context, shutdownRead, shutdownWrite bool) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg3 *C.GCancellable    // out
	var _arg1 C.gboolean         // out
	var _arg2 C.gboolean         // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}

	C.g_dtls_connection_shutdown(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ShutdownAsync: asynchronously shut down part or all of the DTLS connection.
// See g_dtls_connection_shutdown() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - shutdownRead: TRUE to stop reception of incoming datagrams.
//   - shutdownWrite: TRUE to stop sending outgoing datagrams.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the shutdown operation is complete.
func (conn *DTLSConnection) ShutdownAsync(ctx context.Context, shutdownRead, shutdownWrite bool, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GDtlsConnection    // out
	var _arg4 *C.GCancellable       // out
	var _arg1 C.gboolean            // out
	var _arg2 C.gboolean            // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dtls_connection_shutdown_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ShutdownFinish: finish an asynchronous TLS shutdown operation. See
// g_dtls_connection_shutdown() for more information.
//
// The function takes the following parameters:
//
//   - result: Result.
func (conn *DTLSConnection) ShutdownFinish(result AsyncResulter) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_dtls_connection_shutdown_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// acceptCertificate: check whether to accept a certificate.
//
// The function takes the following parameters:
//
//   - peerCert
//   - errors
func (connection *DTLSConnection) acceptCertificate(peerCert TLSCertificater, errors TLSCertificateFlags) bool {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(connection))
	fnarg := gclass.accept_certificate

	var _arg0 *C.GDtlsConnection     // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(peerCert).Native()))
	_arg2 = C.GTlsCertificateFlags(errors)

	_cret = C._gotk4_gio2_DTLSConnection_virtual_accept_certificate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// bindingData: retrieve TLS channel binding data (Since: 2.66).
//
// The function takes the following parameters:
//
//   - typ
//   - data
func (conn *DTLSConnection) bindingData(typ TLSChannelBindingType, data []byte) error {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.get_binding_data

	var _arg0 *C.GDtlsConnection       // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 *C.GByteArray            // out
	var _cerr *C.GError                // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsChannelBindingType(typ)
	_arg2 = C.g_byte_array_sized_new(C.guint(len(data)))
	if len(data) > 0 {
		_arg2 = C.g_byte_array_append(_arg2, (*C.guint8)(&data[0]), C.guint(len(data)))
	}
	defer C.g_byte_array_unref(_arg2)

	C._gotk4_gio2_DTLSConnection_virtual_get_binding_data(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// negotiatedProtocol gets the name of the application-layer protocol negotiated
// during the handshake.
//
// If the peer did not use the ALPN extension, or did not advertise
// a protocol that matched one of conn's protocols, or the TLS
// backend does not support ALPN, then this will be NULL. See
// g_dtls_connection_set_advertised_protocols().
//
// The function returns the following values:
//
//   - utf8 (optional): negotiated protocol, or NULL.
func (conn *DTLSConnection) negotiatedProtocol() string {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.get_negotiated_protocol

	var _arg0 *C.GDtlsConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C._gotk4_gio2_DTLSConnection_virtual_get_negotiated_protocol(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(conn)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Handshake attempts a TLS handshake on conn.
//
// On the client side, it is never necessary to call this method; although the
// connection needs to perform a handshake after connecting, Connection will
// handle this for you automatically when you try to send or receive data on the
// connection. You can call g_dtls_connection_handshake() manually if you want
// to know whether the initial handshake succeeded or failed (as opposed to just
// immediately trying to use conn to read or write, in which case, if it fails,
// it may not be possible to tell if it failed before or after completing the
// handshake), but beware that servers may reject client authentication after
// the handshake has completed, so a successful handshake does not indicate the
// connection will be usable.
//
// Likewise, on the server side, although a handshake is necessary at the
// beginning of the communication, you do not need to call this function
// explicitly unless you want clearer error reporting.
//
// Previously, calling g_dtls_connection_handshake() after the initial handshake
// would trigger a rehandshake; however, this usage was deprecated in GLib
// 2.60 because rehandshaking was removed from the TLS protocol in TLS 1.3.
// Since GLib 2.64, calling this function after the initial handshake will no
// longer do anything.
//
// Connection::accept_certificate may be emitted during the handshake.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (conn *DTLSConnection) handshake(ctx context.Context) error {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.handshake

	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_DTLSConnection_virtual_handshake(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// handshakeAsync: asynchronously performs a TLS handshake on conn. See
// g_dtls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the handshake is complete.
func (conn *DTLSConnection) handshakeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.handshake_async

	var _arg0 *C.GDtlsConnection    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_DTLSConnection_virtual_handshake_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// handshakeFinish: finish an asynchronous TLS handshake operation. See
// g_dtls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - result: Result.
func (conn *DTLSConnection) handshakeFinish(result AsyncResulter) error {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.handshake_finish

	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_DTLSConnection_virtual_handshake_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAdvertisedProtocols sets the list of application-layer protocols
// to advertise that the caller is willing to speak on this connection.
// The Application-Layer Protocol Negotiation (ALPN) extension will
// be used to negotiate a compatible protocol with the peer; use
// g_dtls_connection_get_negotiated_protocol() to find the negotiated protocol
// after the handshake. Specifying NULL for the the value of protocols will
// disable ALPN negotiation.
//
// See IANA TLS ALPN Protocol IDs
// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
//
// The function takes the following parameters:
//
//   - protocols (optional): NULL-terminated array of ALPN protocol names (eg,
//     "http/1.1", "h2"), or NULL.
func (conn *DTLSConnection) setAdvertisedProtocols(protocols []string) {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.set_advertised_protocols

	var _arg0 *C.GDtlsConnection // out
	var _arg1 **C.gchar          // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(protocols) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(protocols)+1)
			var zero *C.gchar
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C._gotk4_gio2_DTLSConnection_virtual_set_advertised_protocols(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(protocols)
}

// Shutdown: shut down part or all of a DTLS connection.
//
// If shutdown_read is TRUE then the receiving side of the connection
// is shut down, and further reading is disallowed. Subsequent calls to
// g_datagram_based_receive_messages() will return G_IO_ERROR_CLOSED.
//
// If shutdown_write is TRUE then the sending side of the connection
// is shut down, and further writing is disallowed. Subsequent calls to
// g_datagram_based_send_messages() will return G_IO_ERROR_CLOSED.
//
// It is allowed for both shutdown_read and shutdown_write to be TRUE  this is
// equivalent to calling g_dtls_connection_close().
//
// If cancellable is cancelled, the Connection may be left partially-closed and
// any pending untransmitted data may be lost. Call g_dtls_connection_shutdown()
// again to complete closing the Connection.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - shutdownRead: TRUE to stop reception of incoming datagrams.
//   - shutdownWrite: TRUE to stop sending outgoing datagrams.
func (conn *DTLSConnection) shutdown(ctx context.Context, shutdownRead, shutdownWrite bool) error {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.shutdown

	var _arg0 *C.GDtlsConnection // out
	var _arg3 *C.GCancellable    // out
	var _arg1 C.gboolean         // out
	var _arg2 C.gboolean         // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}

	C._gotk4_gio2_DTLSConnection_virtual_shutdown(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// shutdownAsync: asynchronously shut down part or all of the DTLS connection.
// See g_dtls_connection_shutdown() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - shutdownRead: TRUE to stop reception of incoming datagrams.
//   - shutdownWrite: TRUE to stop sending outgoing datagrams.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the shutdown operation is complete.
func (conn *DTLSConnection) shutdownAsync(ctx context.Context, shutdownRead, shutdownWrite bool, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.shutdown_async

	var _arg0 *C.GDtlsConnection    // out
	var _arg4 *C.GCancellable       // out
	var _arg1 C.gboolean            // out
	var _arg2 C.gboolean            // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_DTLSConnection_virtual_shutdown_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// shutdownFinish: finish an asynchronous TLS shutdown operation. See
// g_dtls_connection_shutdown() for more information.
//
// The function takes the following parameters:
//
//   - result: Result.
func (conn *DTLSConnection) shutdownFinish(result AsyncResulter) error {
	gclass := (*C.GDtlsConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.shutdown_finish

	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_DTLSConnection_virtual_shutdown_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DTLSServerConnectionOverrider contains methods that are overridable.
type DTLSServerConnectionOverrider interface {
}

// DTLSServerConnection: GDtlsServerConnection is the server-side subclass of
// gio.DTLSConnection, representing a server-side DTLS connection.
//
// DTLSServerConnection wraps an interface. This means the user can get the
// underlying type by calling Cast().
type DTLSServerConnection struct {
	_ [0]func() // equal guard
	DTLSConnection
}

var ()

// DTLSServerConnectioner describes DTLSServerConnection's interface methods.
type DTLSServerConnectioner interface {
	coreglib.Objector

	baseDTLSServerConnection() *DTLSServerConnection
}

var _ DTLSServerConnectioner = (*DTLSServerConnection)(nil)

func ifaceInitDTLSServerConnectioner(gifacePtr, data C.gpointer) {
}

func wrapDTLSServerConnection(obj *coreglib.Object) *DTLSServerConnection {
	return &DTLSServerConnection{
		DTLSConnection: DTLSConnection{
			DatagramBased: DatagramBased{
				Object: obj,
			},
		},
	}
}

func marshalDTLSServerConnection(p uintptr) (interface{}, error) {
	return wrapDTLSServerConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *DTLSServerConnection) baseDTLSServerConnection() *DTLSServerConnection {
	return v
}

// BaseDTLSServerConnection returns the underlying base object.
func BaseDTLSServerConnection(obj DTLSServerConnectioner) *DTLSServerConnection {
	return obj.baseDTLSServerConnection()
}

// NewDTLSServerConnection creates a new ServerConnection wrapping base_socket.
//
// The function takes the following parameters:
//
//   - baseSocket to wrap.
//   - certificate (optional): default server certificate, or NULL.
//
// The function returns the following values:
//
//   - dtlsServerConnection: new ServerConnection, or NULL on error.
func NewDTLSServerConnection(baseSocket DatagramBasedder, certificate TLSCertificater) (*DTLSServerConnection, error) {
	var _arg1 *C.GDatagramBased  // out
	var _arg2 *C.GTlsCertificate // out
	var _cret *C.GDatagramBased  // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GDatagramBased)(unsafe.Pointer(coreglib.InternObject(baseSocket).Native()))
	if certificate != nil {
		_arg2 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	}

	_cret = C.g_dtls_server_connection_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(baseSocket)
	runtime.KeepAlive(certificate)

	var _dtlsServerConnection *DTLSServerConnection // out
	var _goerr error                                // out

	_dtlsServerConnection = wrapDTLSServerConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dtlsServerConnection, _goerr
}

// File: GFile is a high level abstraction for manipulating files on a virtual
// file system. GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see gio.InputStream and gio.OutputStream).
//
// To construct a GFile, you can use:
//
// - gio.File().NewForPath if you have a path.
//
// - gio.File().NewForURI if you have a URI.
//
// - gio.File().NewForCommandlineArg or gio.File().NewForCommandlineArgAndCwd
// for a command line argument.
//
// - gio.File().NewTmp to create a temporary file from a template.
//
// - gio.File().NewTmpAsync to asynchronously create a temporary file.
//
// - gio.File().NewTmpDirAsync to asynchronously create a temporary directory.
//
// - gio.File().ParseName from a UTF-8 string gotten from
// gio.File.GetParseName().
//
// - gio.File().NewBuildFilename or gio.File().NewBuildFilenamev to create a
// file from path elements.
//
// One way to think of a GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
//
// GFiles make up hierarchies of directories and files that correspond to
// the files on a filesystem. You can move through the file system with
// GFile using gio.File.GetParent() to get an identifier for the parent
// directory, gio.File.GetChild() to get a child within a directory, and
// gio.File.ResolveRelativePath() to resolve a relative path between two GFiles.
// There can be multiple hierarchies, so you may not end up at the same root if
// you repeatedly call gio.File.GetParent() on two different files.
//
// All GFiles have a basename (get with gio.File.GetBasename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// gio.File.QueryInfo(). This is guaranteed to be in UTF-8 and can be used in
// a user interface. But always store the real basename or the GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
//
// Using GFile as an identifier has the same weaknesses as using a path in
// that there may be multiple aliases for the same file. For instance, hard or
// soft links may cause two different GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and
// long names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, . or .. path segments, etc) does
// not create different GFiles.
//
// Many GFile operations have both synchronous and asynchronous versions to suit
// your application. Asynchronous versions of synchronous functions simply have
// _async() appended to their function names. The asynchronous I/O functions
// call a gio.AsyncReadyCallback which is then used to finalize the operation,
// producing a gio.AsyncResult which is then passed to the functions matching
// _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within
// a shared main loop, such as in the main thread of an application.
// This avoids I/O operations blocking other sources on the main loop from
// being dispatched. Synchronous I/O operations should be performed from
// worker threads. See the introduction to asynchronous programming section
// (overview.html#asynchronous-programming) for more.
//
// Some GFile operations almost always take a noticeable amount of time,
// and so do not have synchronous analogs. Notable cases include:
//
// - gio.File.MountMountable() to mount a mountable file.
//
// - gio.File.UnmountMountableWithOperation() to unmount a mountable file.
//
// - gio.File.EjectMountableWithOperation() to eject a mountable file.
//
// # Entity Tags
//
// One notable feature of GFiles are entity tags, or etags for short.
// Entity tags are somewhat like a more abstract version of the traditional
// mtime, and can be used to quickly determine if the file has been modified
// from the version on the file system. See the HTTP 1.1 specification
// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP ETag
// headers, which are a very similar concept.
//
// File wraps an interface. This means the user can get the
// underlying type by calling Cast().
type File struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*File)(nil)
)

// Filer describes File's interface methods.
type Filer interface {
	coreglib.Objector

	// AppendTo gets an output stream for appending data to the file.
	AppendTo(ctx context.Context, flags FileCreateFlags) (*FileOutputStream, error)
	// AppendToAsync: asynchronously opens file for appending.
	AppendToAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback)
	// AppendToFinish finishes an asynchronous file append operation started
	// with g_file_append_to_async().
	AppendToFinish(res AsyncResulter) (*FileOutputStream, error)
	// BuildAttributeListForCopy prepares the file attribute query string for
	// copying to file.
	BuildAttributeListForCopy(ctx context.Context, flags FileCopyFlags) (string, error)
	// CopyAttributes copies the file attributes from source to destination.
	CopyAttributes(ctx context.Context, destination Filer, flags FileCopyFlags) error
	// CopyFinish finishes copying the file started with g_file_copy_async().
	CopyFinish(res AsyncResulter) error
	// Create creates a new file and returns an output stream for writing to it.
	Create(ctx context.Context, flags FileCreateFlags) (*FileOutputStream, error)
	// CreateAsync: asynchronously creates a new file and returns an output
	// stream for writing to it.
	CreateAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback)
	// CreateFinish finishes an asynchronous file create operation started with
	// g_file_create_async().
	CreateFinish(res AsyncResulter) (*FileOutputStream, error)
	// CreateReadwrite creates a new file and returns a stream for reading and
	// writing to it.
	CreateReadwrite(ctx context.Context, flags FileCreateFlags) (*FileIOStream, error)
	// CreateReadwriteAsync: asynchronously creates a new file and returns a
	// stream for reading and writing to it.
	CreateReadwriteAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback)
	// CreateReadwriteFinish finishes an asynchronous file create operation
	// started with g_file_create_readwrite_async().
	CreateReadwriteFinish(res AsyncResulter) (*FileIOStream, error)
	// Delete deletes a file.
	Delete(ctx context.Context) error
	// DeleteAsync: asynchronously delete a file.
	DeleteAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// DeleteFinish finishes deleting a file started with g_file_delete_async().
	DeleteFinish(result AsyncResulter) error
	// Dup duplicates a #GFile handle.
	Dup() *File
	// EjectMountable starts an asynchronous eject on a mountable.
	EjectMountable(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback)
	// EjectMountableFinish finishes an asynchronous eject operation started by
	// g_file_eject_mountable().
	EjectMountableFinish(result AsyncResulter) error
	// EjectMountableWithOperation starts an asynchronous eject on a mountable.
	EjectMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// EjectMountableWithOperationFinish finishes an asynchronous eject
	// operation started by g_file_eject_mountable_with_operation().
	EjectMountableWithOperationFinish(result AsyncResulter) error
	// EnumerateChildren gets the requested information about the files in a
	// directory.
	EnumerateChildren(ctx context.Context, attributes string, flags FileQueryInfoFlags) (*FileEnumerator, error)
	// EnumerateChildrenAsync: asynchronously gets the requested information
	// about the files in a directory.
	EnumerateChildrenAsync(ctx context.Context, attributes string, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback)
	// EnumerateChildrenFinish finishes an async enumerate children operation.
	EnumerateChildrenFinish(res AsyncResulter) (*FileEnumerator, error)
	// Equal checks if the two given #GFiles refer to the same file.
	Equal(file2 Filer) bool
	// FindEnclosingMount gets a #GMount for the #GFile.
	FindEnclosingMount(ctx context.Context) (*Mount, error)
	// FindEnclosingMountAsync: asynchronously gets the mount for the file.
	FindEnclosingMountAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// FindEnclosingMountFinish finishes an asynchronous find mount request.
	FindEnclosingMountFinish(res AsyncResulter) (*Mount, error)
	// Basename gets the base name (the last component of the path) for a given
	// #GFile.
	Basename() string
	// Child gets a child of file with basename equal to name.
	Child(name string) *File
	// ChildForDisplayName gets the child of file for a given display_name (i.e.
	ChildForDisplayName(displayName string) (*File, error)
	// Parent gets the parent directory for the file.
	Parent() *File
	// ParseName gets the parse name of the file.
	ParseName() string
	// Path gets the local pathname for #GFile, if one exists.
	Path() string
	// RelativePath gets the path for descendant relative to parent.
	RelativePath(descendant Filer) string
	// URI gets the URI for the file.
	URI() string
	// URIScheme gets the URI scheme for a #GFile.
	URIScheme() string
	// HasParent checks if file has a parent, and optionally, if it is parent.
	HasParent(parent Filer) bool
	// HasPrefix checks whether file has the prefix specified by prefix.
	HasPrefix(prefix Filer) bool
	// HasURIScheme checks to see if a #GFile has a given URI scheme.
	HasURIScheme(uriScheme string) bool
	// Hash creates a hash value for a #GFile.
	Hash() uint
	// IsNative checks to see if a file is native to the platform.
	IsNative() bool
	// LoadBytes loads the contents of file and returns it as #GBytes.
	LoadBytes(ctx context.Context) (string, *glib.Bytes, error)
	// LoadBytesAsync: asynchronously loads the contents of file as #GBytes.
	LoadBytesAsync(ctx context.Context, callback AsyncReadyCallback)
	// LoadBytesFinish completes an asynchronous request to
	// g_file_load_bytes_async().
	LoadBytesFinish(result AsyncResulter) (string, *glib.Bytes, error)
	// LoadContents loads the content of the file into memory.
	LoadContents(ctx context.Context) ([]byte, string, error)
	// LoadContentsAsync starts an asynchronous load of the file's contents.
	LoadContentsAsync(ctx context.Context, callback AsyncReadyCallback)
	// LoadContentsFinish finishes an asynchronous load of the file's contents.
	LoadContentsFinish(res AsyncResulter) ([]byte, string, error)
	// LoadPartialContentsFinish finishes an asynchronous partial load operation
	// that was started with g_file_load_partial_contents_async().
	LoadPartialContentsFinish(res AsyncResulter) ([]byte, string, error)
	// MakeDirectory creates a directory.
	MakeDirectory(ctx context.Context) error
	// MakeDirectoryAsync: asynchronously creates a directory.
	MakeDirectoryAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// MakeDirectoryFinish finishes an asynchronous directory creation, started
	// with g_file_make_directory_async().
	MakeDirectoryFinish(result AsyncResulter) error
	// MakeDirectoryWithParents creates a directory and any parent directories
	// that may not exist similar to 'mkdir -p'.
	MakeDirectoryWithParents(ctx context.Context) error
	// MakeSymbolicLink creates a symbolic link named file which contains the
	// string symlink_value.
	MakeSymbolicLink(ctx context.Context, symlinkValue string) error
	// MakeSymbolicLinkAsync: asynchronously creates a symbolic link named file
	// which contains the string symlink_value.
	MakeSymbolicLinkAsync(ctx context.Context, symlinkValue string, ioPriority int, callback AsyncReadyCallback)
	// MakeSymbolicLinkFinish finishes an asynchronous symbolic link creation,
	// started with g_file_make_symbolic_link_async().
	MakeSymbolicLinkFinish(result AsyncResulter) error
	// MeasureDiskUsageFinish collects the results from an earlier call to
	// g_file_measure_disk_usage_async().
	MeasureDiskUsageFinish(result AsyncResulter) (diskUsage, numDirs, numFiles uint64, goerr error)
	// Monitor obtains a file or directory monitor for the given file, depending
	// on the type of the file.
	Monitor(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error)
	// MonitorDirectory obtains a directory monitor for the given file.
	MonitorDirectory(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error)
	// MonitorFile obtains a file monitor for the given file.
	MonitorFile(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error)
	// MountEnclosingVolume starts a mount_operation, mounting the volume that
	// contains the file location.
	MountEnclosingVolume(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// MountEnclosingVolumeFinish finishes a mount operation started by
	// g_file_mount_enclosing_volume().
	MountEnclosingVolumeFinish(result AsyncResulter) error
	// MountMountable mounts a file of type G_FILE_TYPE_MOUNTABLE.
	MountMountable(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// MountMountableFinish finishes a mount operation.
	MountMountableFinish(result AsyncResulter) (*File, error)
	// MoveFinish finishes an asynchronous file movement, started with
	// g_file_move_async().
	MoveFinish(result AsyncResulter) error
	// OpenReadwrite opens an existing file for reading and writing.
	OpenReadwrite(ctx context.Context) (*FileIOStream, error)
	// OpenReadwriteAsync: asynchronously opens file for reading and writing.
	OpenReadwriteAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// OpenReadwriteFinish finishes an asynchronous file read operation started
	// with g_file_open_readwrite_async().
	OpenReadwriteFinish(res AsyncResulter) (*FileIOStream, error)
	// PeekPath: exactly like g_file_get_path(), but caches the result via
	// g_object_set_qdata_full().
	PeekPath() string
	// PollMountable polls a file of type G_FILE_TYPE_MOUNTABLE.
	PollMountable(ctx context.Context, callback AsyncReadyCallback)
	// PollMountableFinish finishes a poll operation.
	PollMountableFinish(result AsyncResulter) error
	// QueryDefaultHandler returns the Info that is registered as the default
	// application to handle the file specified by file.
	QueryDefaultHandler(ctx context.Context) (*AppInfo, error)
	// QueryDefaultHandlerAsync: async version of
	// g_file_query_default_handler().
	QueryDefaultHandlerAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
	// operation.
	QueryDefaultHandlerFinish(result AsyncResulter) (*AppInfo, error)
	// QueryExists: utility function to check if a particular file exists.
	QueryExists(ctx context.Context) bool
	// QueryFileType: utility function to inspect the Type of a file.
	QueryFileType(ctx context.Context, flags FileQueryInfoFlags) FileType
	// QueryFilesystemInfo: similar to g_file_query_info(), but obtains
	// information about the filesystem the file is on, rather than the file
	// itself.
	QueryFilesystemInfo(ctx context.Context, attributes string) (*FileInfo, error)
	// QueryFilesystemInfoAsync: asynchronously gets the requested information
	// about the filesystem that the specified file is on.
	QueryFilesystemInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback)
	// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
	QueryFilesystemInfoFinish(res AsyncResulter) (*FileInfo, error)
	// QueryInfo gets the requested information about specified file.
	QueryInfo(ctx context.Context, attributes string, flags FileQueryInfoFlags) (*FileInfo, error)
	// QueryInfoAsync: asynchronously gets the requested information about
	// specified file.
	QueryInfoAsync(ctx context.Context, attributes string, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback)
	// QueryInfoFinish finishes an asynchronous file info query.
	QueryInfoFinish(res AsyncResulter) (*FileInfo, error)
	// QuerySettableAttributes: obtain the list of settable attributes for the
	// file.
	QuerySettableAttributes(ctx context.Context) (*FileAttributeInfoList, error)
	// QueryWritableNamespaces: obtain the list of attribute namespaces where
	// new attributes can be created by a user.
	QueryWritableNamespaces(ctx context.Context) (*FileAttributeInfoList, error)
	// Read opens a file for reading.
	Read(ctx context.Context) (*FileInputStream, error)
	// ReadAsync: asynchronously opens file for reading.
	ReadAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// ReadFinish finishes an asynchronous file read operation started with
	// g_file_read_async().
	ReadFinish(res AsyncResulter) (*FileInputStream, error)
	// Replace returns an output stream for overwriting the file, possibly
	// creating a backup copy of the file first.
	Replace(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileOutputStream, error)
	// ReplaceAsync: asynchronously overwrites the file, replacing the contents,
	// possibly creating a backup copy of the file first.
	ReplaceAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback)
	// ReplaceContents replaces the contents of file with contents of length
	// bytes.
	ReplaceContents(ctx context.Context, contents, etag string, makeBackup bool, flags FileCreateFlags) (string, error)
	// ReplaceContentsAsync starts an asynchronous replacement of file with the
	// given contents of length bytes.
	ReplaceContentsAsync(ctx context.Context, contents, etag string, makeBackup bool, flags FileCreateFlags, callback AsyncReadyCallback)
	// ReplaceContentsBytesAsync: same as g_file_replace_contents_async() but
	// takes a #GBytes input instead.
	ReplaceContentsBytesAsync(ctx context.Context, contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, callback AsyncReadyCallback)
	// ReplaceContentsFinish finishes an asynchronous replace of the given file.
	ReplaceContentsFinish(res AsyncResulter) (string, error)
	// ReplaceFinish finishes an asynchronous file replace operation started
	// with g_file_replace_async().
	ReplaceFinish(res AsyncResulter) (*FileOutputStream, error)
	// ReplaceReadwrite returns an output stream for overwriting the file in
	// readwrite mode, possibly creating a backup copy of the file first.
	ReplaceReadwrite(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileIOStream, error)
	// ReplaceReadwriteAsync: asynchronously overwrites the file in read-write
	// mode, replacing the contents, possibly creating a backup copy of the file
	// first.
	ReplaceReadwriteAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback)
	// ReplaceReadwriteFinish finishes an asynchronous file replace operation
	// started with g_file_replace_readwrite_async().
	ReplaceReadwriteFinish(res AsyncResulter) (*FileIOStream, error)
	// ResolveRelativePath resolves a relative path for file to an absolute
	// path.
	ResolveRelativePath(relativePath string) *File
	// SetAttribute sets an attribute in the file with attribute name attribute
	// to value_p.
	SetAttribute(ctx context.Context, attribute string, typ FileAttributeType, valueP unsafe.Pointer, flags FileQueryInfoFlags) error
	// SetAttributeByteString sets attribute of type
	// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to value.
	SetAttributeByteString(ctx context.Context, attribute, value string, flags FileQueryInfoFlags) error
	// SetAttributeInt32 sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to
	// value.
	SetAttributeInt32(ctx context.Context, attribute string, value int32, flags FileQueryInfoFlags) error
	// SetAttributeInt64 sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to
	// value.
	SetAttributeInt64(ctx context.Context, attribute string, value int64, flags FileQueryInfoFlags) error
	// SetAttributeString sets attribute of type G_FILE_ATTRIBUTE_TYPE_STRING to
	// value.
	SetAttributeString(ctx context.Context, attribute, value string, flags FileQueryInfoFlags) error
	// SetAttributeUint32 sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32 to
	// value.
	SetAttributeUint32(ctx context.Context, attribute string, value uint32, flags FileQueryInfoFlags) error
	// SetAttributeUint64 sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64 to
	// value.
	SetAttributeUint64(ctx context.Context, attribute string, value uint64, flags FileQueryInfoFlags) error
	// SetAttributesAsync: asynchronously sets the attributes of file with info.
	SetAttributesAsync(ctx context.Context, info *FileInfo, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback)
	// SetAttributesFinish finishes setting an attribute started in
	// g_file_set_attributes_async().
	SetAttributesFinish(result AsyncResulter) (*FileInfo, error)
	// SetAttributesFromInfo tries to set all attributes in the Info on the
	// target values, not stopping on the first error.
	SetAttributesFromInfo(ctx context.Context, info *FileInfo, flags FileQueryInfoFlags) error
	// SetDisplayName renames file to the specified display name.
	SetDisplayName(ctx context.Context, displayName string) (*File, error)
	// SetDisplayNameAsync: asynchronously sets the display name for a given
	// #GFile.
	SetDisplayNameAsync(ctx context.Context, displayName string, ioPriority int, callback AsyncReadyCallback)
	// SetDisplayNameFinish finishes setting a display name started with
	// g_file_set_display_name_async().
	SetDisplayNameFinish(res AsyncResulter) (*File, error)
	// StartMountable starts a file of type G_FILE_TYPE_MOUNTABLE.
	StartMountable(ctx context.Context, flags DriveStartFlags, startOperation *MountOperation, callback AsyncReadyCallback)
	// StartMountableFinish finishes a start operation.
	StartMountableFinish(result AsyncResulter) error
	// StopMountable stops a file of type G_FILE_TYPE_MOUNTABLE.
	StopMountable(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// StopMountableFinish finishes a stop operation, see
	// g_file_stop_mountable() for details.
	StopMountableFinish(result AsyncResulter) error
	// SupportsThreadContexts checks if file supports [thread-default
	// contexts][g-main-context-push-thread-default-context].
	SupportsThreadContexts() bool
	// Trash sends file to the "Trashcan", if possible.
	Trash(ctx context.Context) error
	// TrashAsync: asynchronously sends file to the Trash location, if possible.
	TrashAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback)
	// TrashFinish finishes an asynchronous file trashing operation, started
	// with g_file_trash_async().
	TrashFinish(result AsyncResulter) error
	// UnmountMountable unmounts a file of type G_FILE_TYPE_MOUNTABLE.
	UnmountMountable(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback)
	// UnmountMountableFinish finishes an unmount operation, see
	// g_file_unmount_mountable() for details.
	UnmountMountableFinish(result AsyncResulter) error
	// UnmountMountableWithOperation unmounts a file of type
	// G_FILE_TYPE_MOUNTABLE.
	UnmountMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// UnmountMountableWithOperationFinish finishes an unmount operation,
	// see g_file_unmount_mountable_with_operation() for details.
	UnmountMountableWithOperationFinish(result AsyncResulter) error
}

var _ Filer = (*File)(nil)

func wrapFile(obj *coreglib.Object) *File {
	return &File{
		Object: obj,
	}
}

func marshalFile(p uintptr) (interface{}, error) {
	return wrapFile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AppendTo gets an output stream for appending data to the file. If the file
// doesn't already exist it is created.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// Some file systems don't allow all file names, and may return an
// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
// too, and depend on what kind of filesystem the file is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) AppendTo(ctx context.Context, flags FileCreateFlags) (*FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.GFileCreateFlags   // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C.g_file_append_to(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// AppendToAsync: asynchronously opens file for appending.
//
// For more details, see g_file_append_to() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_append_to_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) AppendToAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_append_to_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// AppendToFinish finishes an asynchronous file append operation started with
// g_file_append_to_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileOutputStream: valid OutputStream or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) AppendToFinish(res AsyncResulter) (*FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_append_to_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// BuildAttributeListForCopy prepares the file attribute query string for
// copying to file.
//
// This function prepares an attribute query string to be passed to
// g_file_query_info() to get a list of attributes normally copied with the file
// (see g_file_copy_attributes() for the detailed description). This function is
// used by the implementation of g_file_copy_attributes() and is useful when one
// needs to query and set the attributes in two stages (e.g., for recursive move
// of a directory).
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CopyFlags.
//
// The function returns the following values:
//
//   - utf8: attribute query string for g_file_query_info(), or NULL if an error
//     occurs.
func (file *File) BuildAttributeListForCopy(ctx context.Context, flags FileCopyFlags) (string, error) {
	var _arg0 *C.GFile         // out
	var _arg2 *C.GCancellable  // out
	var _arg1 C.GFileCopyFlags // out
	var _cret *C.char          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCopyFlags(flags)

	_cret = C.g_file_build_attribute_list_for_copy(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// CopyAttributes copies the file attributes from source to destination.
//
// Normally only a subset of the file attributes are copied, those that are
// copies in a normal file copy operation (which for instance does not include
// e.g. owner). However if G_FILE_COPY_ALL_METADATA is specified in flags,
// then all the metadata that is possible to copy is copied. This is useful when
// implementing move by copy + delete source.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - destination to copy attributes to.
//   - flags: set of CopyFlags.
func (source *File) CopyAttributes(ctx context.Context, destination Filer, flags FileCopyFlags) error {
	var _arg0 *C.GFile         // out
	var _arg3 *C.GCancellable  // out
	var _arg1 *C.GFile         // out
	var _arg2 C.GFileCopyFlags // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(destination).Native()))
	_arg2 = C.GFileCopyFlags(flags)

	C.g_file_copy_attributes(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(source)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(destination)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CopyFinish finishes copying the file started with g_file_copy_async().
//
// The function takes the following parameters:
//
//   - res: Result.
func (file *File) CopyFinish(res AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_file_copy_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Create creates a new file and returns an output stream for writing to it.
// The file must not already exist.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and
// may return an G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileOutputStream for the newly created file, or NULL on error. Free the
//     returned object with g_object_unref().
func (file *File) Create(ctx context.Context, flags FileCreateFlags) (*FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.GFileCreateFlags   // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C.g_file_create(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// CreateAsync: asynchronously creates a new file and returns an output stream
// for writing to it. The file must not already exist.
//
// For more details, see g_file_create() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_create_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) CreateAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_create_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CreateFinish finishes an asynchronous file create operation started with
// g_file_create_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) CreateFinish(res AsyncResulter) (*FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_create_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// CreateReadwrite creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists, the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and may
// return an G_IO_ERROR_INVALID_FILENAME error, and if the name is too long,
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileIOStream for the newly created file, or NULL on error. Free the
//     returned object with g_object_unref().
func (file *File) CreateReadwrite(ctx context.Context, flags FileCreateFlags) (*FileIOStream, error) {
	var _arg0 *C.GFile           // out
	var _arg2 *C.GCancellable    // out
	var _arg1 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C.g_file_create_readwrite(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// CreateReadwriteAsync: asynchronously creates a new file and returns a stream
// for reading and writing to it. The file must not already exist.
//
// For more details, see g_file_create_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_create_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) CreateReadwriteAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_create_readwrite_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CreateReadwriteFinish finishes an asynchronous file create operation started
// with g_file_create_readwrite_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) CreateReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_create_readwrite_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// Delete deletes a file. If the file is a directory, it will only be deleted if
// it is empty. This has the same semantics as g_unlink().
//
// If file doesnt exist, G_IO_ERROR_NOT_FOUND will be returned. This allows
// for deletion to be implemented avoiding time-of-check to time-of-use races
// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
//
//	g_autoptr(GError) local_error = NULL;
//	if (!g_file_delete (my_file, my_cancellable, &local_error) &&
//	    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//	  {
//	    // deletion failed for some reason other than the file not existing:
//	    // so report the error
//	    g_warning ("Failed to delete s: s",
//	               g_file_peek_path (my_file), local_error->message);
//	  }
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (file *File) Delete(ctx context.Context) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_delete(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DeleteAsync: asynchronously delete a file. If the file is a directory,
// it will only be deleted if it is empty. This has the same semantics as
// g_unlink().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) DeleteAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_delete_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// DeleteFinish finishes deleting a file started with g_file_delete_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) DeleteFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_delete_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Dup duplicates a #GFile handle. This operation does not duplicate the actual
// file or directory represented by the #GFile; see g_file_copy() if attempting
// to copy a file.
//
// g_file_dup() is useful when a second handle is needed to the same underlying
// file, for use in a separate thread (#GFile is not thread-safe). For use
// within the same thread, use g_object_ref() to increment the existing objects
// reference count.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - ret: new #GFile that is a duplicate of the given #GFile.
func (file *File) Dup() *File {
	var _arg0 *C.GFile // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_dup(_arg0)
	runtime.KeepAlive(file)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// EjectMountable starts an asynchronous eject on a mountable. When this
// operation has completed, callback will be called with user_user data, and the
// operation can be finalized with g_file_eject_mountable_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// Deprecated: Use g_file_eject_mountable_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) EjectMountable(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_eject_mountable(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// EjectMountableFinish finishes an asynchronous eject operation started by
// g_file_eject_mountable().
//
// Deprecated: Use g_file_eject_mountable_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) EjectMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_eject_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EjectMountableWithOperation starts an asynchronous eject on a
// mountable. When this operation has completed, callback will be
// called with user_user data, and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) EjectMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_eject_mountable_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// EjectMountableWithOperationFinish finishes an asynchronous eject operation
// started by g_file_eject_mountable_with_operation().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) EjectMountableWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_eject_mountable_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EnumerateChildren gets the requested information about the files in a
// directory. The result is a Enumerator object that will give out Info objects
// for all the files in the directory.
//
// The attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set. attributes
// should be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like "standard::*"
// means all attributes in the standard namespace. An example attribute query be
// "standard::*,owner::user". The standard attributes are available as defines,
// like G_FILE_ATTRIBUTE_STANDARD_NAME. G_FILE_ATTRIBUTE_STANDARD_NAME should
// always be specified if you plan to call g_file_enumerator_get_child() or
// g_file_enumerator_iterate() on the returned enumerator.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY error will be
// returned. Other errors are possible too.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//
// The function returns the following values:
//
//   - fileEnumerator if successful, NULL on error. Free the returned object
//     with g_object_unref().
func (file *File) EnumerateChildren(ctx context.Context, attributes string, flags FileQueryInfoFlags) (*FileEnumerator, error) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _cret *C.GFileEnumerator    // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)

	_cret = C.g_file_enumerate_children(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)

	var _fileEnumerator *FileEnumerator // out
	var _goerr error                    // out

	_fileEnumerator = wrapFileEnumerator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileEnumerator, _goerr
}

// EnumerateChildrenAsync: asynchronously gets the requested information about
// the files in a directory. The result is a Enumerator object that will give
// out Info objects for all the files in the directory.
//
// For more details, see g_file_enumerate_children() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_enumerate_children_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) EnumerateChildrenAsync(ctx context.Context, attributes string, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_enumerate_children_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// EnumerateChildrenFinish finishes an async enumerate children operation.
// See g_file_enumerate_children_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileEnumerator or NULL if an error occurred. Free the returned object
//     with g_object_unref().
func (file *File) EnumerateChildrenFinish(res AsyncResulter) (*FileEnumerator, error) {
	var _arg0 *C.GFile           // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GFileEnumerator // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_enumerate_children_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileEnumerator *FileEnumerator // out
	var _goerr error                    // out

	_fileEnumerator = wrapFileEnumerator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileEnumerator, _goerr
}

// Equal checks if the two given #GFiles refer to the same file.
//
// Note that two #GFiles that differ can still refer to the same file on the
// filesystem due to various forms of filename aliasing.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - file2: second #GFile.
//
// The function returns the following values:
//
//   - ok: TRUE if file1 and file2 are equal.
func (file1 *File) Equal(file2 Filer) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file1).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file2).Native()))

	_cret = C.g_file_equal(_arg0, _arg1)
	runtime.KeepAlive(file1)
	runtime.KeepAlive(file2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FindEnclosingMount gets a #GMount for the #GFile.
//
// #GMount is returned only for user interesting locations, see Monitor.
// If the Iface for file does not have a #mount, error will be set to
// G_IO_ERROR_NOT_FOUND and NULL #will be returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - mount where the file is located or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) FindEnclosingMount(ctx context.Context) (*Mount, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GMount       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_find_enclosing_mount(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _mount *Mount // out
	var _goerr error  // out

	_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _mount, _goerr
}

// FindEnclosingMountAsync: asynchronously gets the mount for the file.
//
// For more details, see g_file_find_enclosing_mount() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_find_enclosing_mount_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) FindEnclosingMountAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_find_enclosing_mount_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// FindEnclosingMountFinish finishes an asynchronous find mount request.
// See g_file_find_enclosing_mount_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - mount for given file or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) FindEnclosingMountFinish(res AsyncResulter) (*Mount, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GMount       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_find_enclosing_mount_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _mount *Mount // out
	var _goerr error  // out

	_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _mount, _goerr
}

// Basename gets the base name (the last component of the path) for a given
// #GFile.
//
// If called for the top level of a system (such as the filesystem root or a
// uri like sftp://host/) it will return a single directory separator (and on
// Windows, possibly a drive letter).
//
// The base name is a byte string (not UTF-8). It has no defined encoding
// or rules other than it may not contain zero bytes. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info().
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - filename (optional): string containing the #GFile's base name, or NULL
//     if given #GFile is invalid. The returned string should be freed with
//     g_free() when no longer needed.
func (file *File) Basename() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_get_basename(_arg0)
	runtime.KeepAlive(file)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// Child gets a child of file with basename equal to name.
//
// Note that the file with that specific name might not exist, but you can still
// have a #GFile that points to it. You can use this for instance to create that
// file.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - name: string containing the child's basename.
//
// The function returns the following values:
//
//   - ret to a child specified by name. Free the returned object with
//     g_object_unref().
func (file *File) Child(name string) *File {
	var _arg0 *C.GFile // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_get_child(_arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(name)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ChildForDisplayName gets the child of file for a given display_name (i.e.
// a UTF-8 version of the name). If this function fails, it returns NULL and
// error will be set. This is very useful when constructing a #GFile for a new
// file and the user entered the filename in the user interface, for instance
// when you select a directory and type a filename in the file selector.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - displayName: string to a possible child.
//
// The function returns the following values:
//
//   - ret to the specified child, or NULL if the display name couldn't be
//     converted. Free the returned object with g_object_unref().
func (file *File) ChildForDisplayName(displayName string) (*File, error) {
	var _arg0 *C.GFile  // out
	var _arg1 *C.char   // out
	var _cret *C.GFile  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_get_child_for_display_name(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// Parent gets the parent directory for the file. If the file represents the
// root directory of the file system, then NULL will be returned.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - ret (optional) structure to the parent of the given #GFile or NULL if
//     there is no parent. Free the returned object with g_object_unref().
func (file *File) Parent() *File {
	var _arg0 *C.GFile // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_get_parent(_arg0)
	runtime.KeepAlive(file)

	var _ret *File // out

	if _cret != nil {
		_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// ParseName gets the parse name of the file. A parse name is a UTF-8 string
// that describes the file such that one can get the #GFile back using
// g_file_parse_name().
//
// This is generally used to show the #GFile as a nice full-pathname kind of
// string in a user interface, like in a location entry.
//
// For local files with names that can safely be converted to UTF-8 the
// pathname is used, otherwise the IRI is used (a form of URI that allows UTF-8
// characters unescaped).
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - utf8: string containing the #GFile's parse name. The returned string
//     should be freed with g_free() when no longer needed.
func (file *File) ParseName() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_get_parse_name(_arg0)
	runtime.KeepAlive(file)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Path gets the local pathname for #GFile, if one exists. If non-NULL, this is
// guaranteed to be an absolute, canonical path. It might contain symlinks.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - filename (optional): string containing the #GFile's path, or NULL if no
//     such path exists. The returned string should be freed with g_free() when
//     no longer needed.
func (file *File) Path() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_get_path(_arg0)
	runtime.KeepAlive(file)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// RelativePath gets the path for descendant relative to parent.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - descendant: input #GFile.
//
// The function returns the following values:
//
//   - filename (optional): string with the relative path from descendant to
//     parent, or NULL if descendant doesn't have parent as prefix. The returned
//     string should be freed with g_free() when no longer needed.
func (parent *File) RelativePath(descendant Filer) string {
	var _arg0 *C.GFile // out
	var _arg1 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(descendant).Native()))

	_cret = C.g_file_get_relative_path(_arg0, _arg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(descendant)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// URI gets the URI for the file.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - utf8: string containing the #GFile's URI. If the #GFile was constructed
//     with an invalid URI, an invalid URI is returned. The returned string
//     should be freed with g_free() when no longer needed.
func (file *File) URI() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_get_uri(_arg0)
	runtime.KeepAlive(file)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme as:
//
//	URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include "file", "http", "ftp", etc.
//
// The scheme can be different from the one used to construct the #GFile,
// in that it might be replaced with one that is logically equivalent to the
// #GFile.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the URI scheme for the given #GFile
//     or NULL if the #GFile was constructed with an invalid URI. The returned
//     string should be freed with g_free() when no longer needed.
func (file *File) URIScheme() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_get_uri_scheme(_arg0)
	runtime.KeepAlive(file)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// HasParent checks if file has a parent, and optionally, if it is parent.
//
// If parent is NULL then this function returns TRUE if file has any parent at
// all. If parent is non-NULL then TRUE is only returned if file is an immediate
// child of parent.
//
// The function takes the following parameters:
//
//   - parent (optional) to check for, or NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if file is an immediate child of parent (or any parent in the
//     case that parent is NULL).
func (file *File) HasParent(parent Filer) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	if parent != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.g_file_has_parent(_arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(parent)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasPrefix checks whether file has the prefix specified by prefix.
//
// In other words, if the names of initial elements of file's pathname match
// prefix. Only full pathname elements are matched, so a path like /foo is not
// considered a prefix of /foobar, only of /foo/bar.
//
// A #GFile is not a prefix of itself. If you want to check for equality,
// use g_file_equal().
//
// This call does no I/O, as it works purely on names. As such it can sometimes
// return FALSE even if file is inside a prefix (from a filesystem point of
// view), because the prefix of file is an alias of prefix.
//
// The function takes the following parameters:
//
//   - prefix: input #GFile.
//
// The function returns the following values:
//
//   - ok: TRUE if the file's parent, grandparent, etc is prefix, FALSE
//     otherwise.
func (file *File) HasPrefix(prefix Filer) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(prefix).Native()))

	_cret = C.g_file_has_prefix(_arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(prefix)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasURIScheme checks to see if a #GFile has a given URI scheme.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - uriScheme: string containing a URI scheme.
//
// The function returns the following values:
//
//   - ok: TRUE if #GFile's backend supports the given URI scheme, FALSE if URI
//     scheme is NULL, not supported, or #GFile is invalid.
func (file *File) HasURIScheme(uriScheme string) bool {
	var _arg0 *C.GFile   // out
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_has_uri_scheme(_arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(uriScheme)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash creates a hash value for a #GFile.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - guint: 0 if file is not a valid #GFile, otherwise an integer that can be
//     used as hash value for the #GFile. This function is intended for easily
//     hashing a #GFile to add to a Table or similar data structure.
func (file *File) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_hash(_arg0)
	runtime.KeepAlive(file)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsNative checks to see if a file is native to the platform.
//
// A native file is one expressed in the platform-native filename format,
// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
// as it might be on a locally mounted remote filesystem.
//
// On some systems non-native files may be available using the native filesystem
// via a userspace filesystem (FUSE), in these cases this call will return
// FALSE, but g_file_get_path() will still return a native path.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - ok: TRUE if file is native.
func (file *File) IsNative() bool {
	var _arg0 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_is_native(_arg0)
	runtime.KeepAlive(file)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadBytes loads the contents of file and returns it as #GBytes.
//
// If file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents() and g_bytes_new_take().
//
// For resources, etag_out will be set to NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated,
// but this is not included in the #GBytes length. The resulting #GBytes should
// be freed with g_bytes_unref() when no longer in use.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//
// The function returns the following values:
//
//   - etagOut (optional): location to place the current entity tag for the
//     file, or NULL if the entity tag is not needed.
//   - bytes or NULL and error is set.
func (file *File) LoadBytes(ctx context.Context) (string, *glib.Bytes, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _arg2 *C.gchar        // in
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_load_bytes(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _etagOut string    // out
	var _bytes *glib.Bytes // out
	var _goerr error       // out

	if _arg2 != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _etagOut, _bytes, _goerr
}

// LoadBytesAsync: asynchronously loads the contents of file as #GBytes.
//
// If file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents_async() and g_bytes_new_take().
//
// callback should call g_file_load_bytes_finish() to get the result of this
// asynchronous operation.
//
// See g_file_load_bytes() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) LoadBytesAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_load_bytes_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// LoadBytesFinish completes an asynchronous request to
// g_file_load_bytes_async().
//
// For resources, etag_out will be set to NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated,
// but this is not included in the #GBytes length. The resulting #GBytes should
// be freed with g_bytes_unref() when no longer in use.
//
// See g_file_load_bytes() for more information.
//
// The function takes the following parameters:
//
//   - result provided to the callback.
//
// The function returns the following values:
//
//   - etagOut (optional): location to place the current entity tag for the
//     file, or NULL if the entity tag is not needed.
//   - bytes or NULL and error is set.
func (file *File) LoadBytesFinish(result AsyncResulter) (string, *glib.Bytes, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.gchar        // in
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_load_bytes_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _etagOut string    // out
	var _bytes *glib.Bytes // out
	var _goerr error       // out

	if _arg2 != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _etagOut, _bytes, _goerr
}

// LoadContents loads the content of the file into memory. The data is
// always zero-terminated, but this is not included in the resultant length.
// The returned contents should be freed with g_free() when no longer needed.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - contents: location to place the contents of the file.
//   - etagOut (optional): location to place the current entity tag for the
//     file, or NULL if the entity tag is not needed.
func (file *File) LoadContents(ctx context.Context) ([]byte, string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _arg2 *C.char         // in
	var _arg3 C.gsize         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_load_contents(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _contents []byte // out
	var _etagOut string  // out
	var _goerr error     // out

	defer C.free(unsafe.Pointer(_arg2))
	_contents = make([]byte, _arg3)
	copy(_contents, unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3))
	if _arg4 != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _contents, _etagOut, _goerr
}

// LoadContentsAsync starts an asynchronous load of the file's contents.
//
// For more details, see g_file_load_contents() which is the synchronous version
// of this call.
//
// When the load operation has completed, callback will be called with user
// data. To finish the operation, call g_file_load_contents_finish() with the
// Result returned by the callback.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - callback (optional) to call when the request is satisfied.
func (file *File) LoadContentsAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_load_contents_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// LoadContentsFinish finishes an asynchronous load of the file's contents.
// The contents are placed in contents, and length is set to the size of the
// contents string. The contents should be freed with g_free() when no longer
// needed. If etag_out is present, it will be set to the new entity tag for the
// file.
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - contents: location to place the contents of the file.
//   - etagOut (optional): location to place the current entity tag for the
//     file, or NULL if the entity tag is not needed.
func (file *File) LoadContentsFinish(res AsyncResulter) ([]byte, string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _arg3 C.gsize         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_file_load_contents_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _contents []byte // out
	var _etagOut string  // out
	var _goerr error     // out

	defer C.free(unsafe.Pointer(_arg2))
	_contents = make([]byte, _arg3)
	copy(_contents, unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3))
	if _arg4 != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _contents, _etagOut, _goerr
}

// LoadPartialContentsFinish finishes an asynchronous partial load operation
// that was started with g_file_load_partial_contents_async(). The data is
// always zero-terminated, but this is not included in the resultant length.
// The returned contents should be freed with g_free() when no longer needed.
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - contents: location to place the contents of the file.
//   - etagOut (optional): location to place the current entity tag for the
//     file, or NULL if the entity tag is not needed.
func (file *File) LoadPartialContentsFinish(res AsyncResulter) ([]byte, string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _arg3 C.gsize         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_file_load_partial_contents_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _contents []byte // out
	var _etagOut string  // out
	var _goerr error     // out

	defer C.free(unsafe.Pointer(_arg2))
	_contents = make([]byte, _arg3)
	copy(_contents, unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3))
	if _arg4 != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _contents, _etagOut, _goerr
}

// MakeDirectory creates a directory. Note that this will only create
// a child directory of the immediate parent directory of the path
// or URI given by the #GFile. To recursively create directories, see
// g_file_make_directory_with_parents(). This function will fail if the parent
// directory does not exist, setting error to G_IO_ERROR_NOT_FOUND. If the
// file system doesn't support creating directories, this function will fail,
// setting error to G_IO_ERROR_NOT_SUPPORTED.
//
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (file *File) MakeDirectory(ctx context.Context) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_make_directory(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MakeDirectoryAsync: asynchronously creates a directory.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) MakeDirectoryAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_make_directory_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// MakeDirectoryFinish finishes an asynchronous directory creation, started with
// g_file_make_directory_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) MakeDirectoryFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_make_directory_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MakeDirectoryWithParents creates a directory and any parent directories
// that may not exist similar to 'mkdir -p'. If the file system does not
// support creating directories, this function will fail, setting error to
// G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this
// function will fail setting error to G_IO_ERROR_EXISTS, unlike the similar
// g_mkdir_with_parents().
//
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (file *File) MakeDirectoryWithParents(ctx context.Context) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_make_directory_with_parents(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MakeSymbolicLink creates a symbolic link named file which contains the string
// symlink_value.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - symlinkValue: string with the path for the target of the new symlink.
func (file *File) MakeSymbolicLink(ctx context.Context, symlinkValue string) error {
	var _arg0 *C.GFile        // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_make_symbolic_link(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(symlinkValue)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MakeSymbolicLinkAsync: asynchronously creates a symbolic link named file
// which contains the string symlink_value.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - symlinkValue: string with the path for the target of the new symlink.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) MakeSymbolicLinkAsync(ctx context.Context, symlinkValue string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_make_symbolic_link_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(symlinkValue)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// MakeSymbolicLinkFinish finishes an asynchronous symbolic link creation,
// started with g_file_make_symbolic_link_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) MakeSymbolicLinkFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_make_symbolic_link_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MeasureDiskUsageFinish collects the results from an earlier call to
// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for more
// information.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - diskUsage (optional): number of bytes of disk space used.
//   - numDirs (optional): number of directories encountered.
//   - numFiles (optional): number of non-directories encountered.
func (file *File) MeasureDiskUsageFinish(result AsyncResulter) (diskUsage, numDirs, numFiles uint64, goerr error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.guint64       // in
	var _arg3 C.guint64       // in
	var _arg4 C.guint64       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_measure_disk_usage_finish(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _diskUsage uint64 // out
	var _numDirs uint64   // out
	var _numFiles uint64  // out
	var _goerr error      // out

	_diskUsage = uint64(_arg2)
	_numDirs = uint64(_arg3)
	_numFiles = uint64(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _diskUsage, _numDirs, _numFiles, _goerr
}

// Monitor obtains a file or directory monitor for the given file, depending on
// the type of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of MonitorFlags.
//
// The function returns the following values:
//
//   - fileMonitor for the given file, or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) Monitor(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error) {
	var _arg0 *C.GFile            // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.GFileMonitorFlags // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileMonitorFlags(flags)

	_cret = C.g_file_monitor(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileMonitor FileMonitorrer // out
	var _goerr error                // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.FileMonitorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FileMonitorrer)
			return ok
		})
		rv, ok := casted.(FileMonitorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.FileMonitorrer")
		}
		_fileMonitor = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileMonitor, _goerr
}

// MonitorDirectory obtains a directory monitor for the given file. This may
// fail if directory monitoring is not supported.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// It does not make sense for flags to contain G_FILE_MONITOR_WATCH_HARD_LINKS,
// since hard links can not be made to directories. It is not possible to
// monitor all the files in a directory for changes made via hard links;
// if you want to do this then you must register individual watches with
// g_file_monitor().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of MonitorFlags.
//
// The function returns the following values:
//
//   - fileMonitor for the given file, or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) MonitorDirectory(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error) {
	var _arg0 *C.GFile            // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.GFileMonitorFlags // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileMonitorFlags(flags)

	_cret = C.g_file_monitor_directory(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileMonitor FileMonitorrer // out
	var _goerr error                // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.FileMonitorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FileMonitorrer)
			return ok
		})
		rv, ok := casted.(FileMonitorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.FileMonitorrer")
		}
		_fileMonitor = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileMonitor, _goerr
}

// MonitorFile obtains a file monitor for the given file. If no file
// notification mechanism exists, then regular polling of the file is used.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will
// also attempt to report changes made to the file via another filename (ie,
// a hard link). Without this flag, you can only rely on changes made through
// the filename contained in file to be reported. Using this flag may result in
// an increase in resource usage, and may not have any effect depending on the
// Monitor backend and/or filesystem type.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of MonitorFlags.
//
// The function returns the following values:
//
//   - fileMonitor for the given file, or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) MonitorFile(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error) {
	var _arg0 *C.GFile            // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.GFileMonitorFlags // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileMonitorFlags(flags)

	_cret = C.g_file_monitor_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileMonitor FileMonitorrer // out
	var _goerr error                // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.FileMonitorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FileMonitorrer)
			return ok
		})
		rv, ok := casted.(FileMonitorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.FileMonitorrer")
		}
		_fileMonitor = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileMonitor, _goerr
}

// MountEnclosingVolume starts a mount_operation, mounting the volume that
// contains the file location.
//
// When this operation has completed, callback will be called
// with user_user data, and the operation can be finalized with
// g_file_mount_enclosing_volume_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation or NULL to avoid user interaction.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (location *File) MountEnclosingVolume(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(location).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_mount_enclosing_volume(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(location)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// MountEnclosingVolumeFinish finishes a mount operation started by
// g_file_mount_enclosing_volume().
//
// The function takes the following parameters:
//
//   - result: Result.
func (location *File) MountEnclosingVolumeFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(location).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_mount_enclosing_volume_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(location)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MountMountable mounts a file of type G_FILE_TYPE_MOUNTABLE. Using
// mount_operation, you can request callbacks when, for instance, passwords are
// needed during authentication.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) MountMountable(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_mount_mountable(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// MountMountableFinish finishes a mount operation. See g_file_mount_mountable()
// for details.
//
// Finish an asynchronous mount operation that was started with
// g_file_mount_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - ret or NULL on error. Free the returned object with g_object_unref().
func (file *File) MountMountableFinish(result AsyncResulter) (*File, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_mount_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// MoveFinish finishes an asynchronous file movement, started with
// g_file_move_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) MoveFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_move_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// OpenReadwrite opens an existing file for reading and writing. The result is a
// IOStream that can be used to read and write the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on. Note that in many non-local file cases read and
// write streams are not supported, so make sure you really need to do read and
// write streaming, rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) OpenReadwrite(ctx context.Context) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GCancellable  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_open_readwrite(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// OpenReadwriteAsync: asynchronously opens file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_open_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) OpenReadwriteAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_open_readwrite_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// OpenReadwriteFinish finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) OpenReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_open_readwrite_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// PeekPath: exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full(). This is useful for example in C applications which
// mix g_file_* APIs with native ones. It also avoids an extra duplicated string
// when possible, so will be generally more efficient.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - filename (optional): string containing the #GFile's path, or NULL if no
//     such path exists. The returned string is owned by file.
func (file *File) PeekPath() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_peek_path(_arg0)
	runtime.KeepAlive(file)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// PollMountable polls a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (file *File) PollMountable(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_poll_mountable(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// PollMountableFinish finishes a poll operation. See g_file_poll_mountable()
// for details.
//
// Finish an asynchronous poll operation that was polled with
// g_file_poll_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) PollMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_poll_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// QueryDefaultHandler returns the Info that is registered as the default
// application to handle the file specified by file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - appInfo if the handle was found, NULL if there were errors. When you are
//     done with it, release it with g_object_unref().
func (file *File) QueryDefaultHandler(ctx context.Context) (*AppInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GAppInfo     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_query_default_handler(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// QueryDefaultHandlerAsync: async version of g_file_query_default_handler().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is done.
func (file *File) QueryDefaultHandlerAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_query_default_handler_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
// operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - appInfo if the handle was found, NULL if there were errors. When you are
//     done with it, release it with g_object_unref().
func (file *File) QueryDefaultHandlerFinish(result AsyncResulter) (*AppInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GAppInfo     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_query_default_handler_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// QueryExists: utility function to check if a particular file exists. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// Note that in many cases it is racy to first check for file existence
// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then
// execute something based on the outcome of that, because the file might have
// been created or removed in between the operations. The general approach
// to handling that is to not check, but just do the operation and handle the
// errors as they come.
//
// As an example of race-free checking, take the case of reading a file,
// and if it doesn't exist, creating it. There are two racy versions: read it,
// and on error create it; and: check if it exists, if not create it. These can
// both result in two processes creating the file (with perhaps a partially
// written file as the result). The correct approach is to always try to create
// the file with g_file_create() which will either atomically create the file or
// fail with a G_IO_ERROR_EXISTS error.
//
// However, in many cases an existence check is useful in a user interface, for
// instance to make a menu item sensitive/insensitive, so that you don't have
// to fool users that something is possible and then just show an error dialog.
// If you do this, you should make sure to also handle the errors that can
// happen due to races when you execute the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - ok: TRUE if the file exists (and can be detected without error), FALSE
//     otherwise (or if cancelled).
func (file *File) QueryExists(ctx context.Context) bool {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_query_exists(_arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryFileType: utility function to inspect the Type of a file. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// The primary use case of this method is to check if a file is a regular file,
// directory, or symlink.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of QueryInfoFlags passed to g_file_query_info().
//
// The function returns the following values:
//
//   - fileType of the file and G_FILE_TYPE_UNKNOWN if the file does not exist.
func (file *File) QueryFileType(ctx context.Context, flags FileQueryInfoFlags) FileType {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GFileQueryInfoFlags // out
	var _cret C.GFileType           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileQueryInfoFlags(flags)

	_cret = C.g_file_query_file_type(_arg0, _arg1, _arg2)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileType FileType // out

	_fileType = FileType(_cret)

	return _fileType
}

// QueryFilesystemInfo: similar to g_file_query_info(), but obtains information
// about the filesystem the file is on, rather than the file itself. For
// instance the amount of space available and the type of the filesystem.
//
// The attributes value is a string that specifies the attributes that should
// be gathered. It is not an error if it's not possible to read a particular
// requested attribute from a file - it just won't be set. attributes
// should be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like "filesystem::*"
// means all attributes in the filesystem namespace. The standard namespace
// for filesystem attributes is "filesystem". Common attributes of interest
// are G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
// in bytes), G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
// and G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//
// The function returns the following values:
//
//   - fileInfo or NULL if there was an error. Free the returned object with
//     g_object_unref().
func (file *File) QueryFilesystemInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_query_filesystem_info(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// QueryFilesystemInfoAsync: asynchronously gets the requested information about
// the filesystem that the specified file is on. The result is a Info object
// that contains key-value attributes (such as type or size for the file).
//
// For more details, see g_file_query_filesystem_info() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_query_info_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) QueryFilesystemInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_query_filesystem_info_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
// See g_file_query_filesystem_info_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileInfo for given file or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) QueryFilesystemInfoFinish(res AsyncResulter) (*FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_query_filesystem_info_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// QueryInfo gets the requested information about specified file. The result is
// a Info object that contains key-value attributes (such as the type or size of
// the file).
//
// The attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set. attributes
// should be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like "standard::*"
// means all attributes in the standard namespace. An example attribute query be
// "standard::*,owner::user". The standard attributes are available as defines,
// like G_FILE_ATTRIBUTE_STANDARD_NAME.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// For symlinks, normally the information about the target of the symlink is
// returned, rather than information about the symlink itself. However if you
// pass G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in flags the information about
// the symlink itself will be returned. Also, for symlinks that point to
// non-existing files the information about the symlink itself will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//
// The function returns the following values:
//
//   - fileInfo for the given file, or NULL on error. Free the returned object
//     with g_object_unref().
func (file *File) QueryInfo(ctx context.Context, attributes string, flags FileQueryInfoFlags) (*FileInfo, error) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _cret *C.GFileInfo          // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)

	_cret = C.g_file_query_info(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// QueryInfoAsync: asynchronously gets the requested information about specified
// file. The result is a Info object that contains key-value attributes (such as
// type or size for the file).
//
// For more details, see g_file_query_info() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_query_info_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) QueryInfoAsync(ctx context.Context, attributes string, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_query_info_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish finishes an asynchronous file info query. See
// g_file_query_info_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileInfo for given file or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) QueryInfoFinish(res AsyncResulter) (*FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_query_info_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// QuerySettableAttributes: obtain the list of settable attributes for the file.
//
// Returns the type and full attribute name of all the attributes that can be
// set on this file. This doesn't mean setting it will always succeed though,
// you might get an access failure, or some specific file may not support a
// specific attribute.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - fileAttributeInfoList describing the settable attributes. When you are
//     done with it, release it with g_file_attribute_info_list_unref().
func (file *File) QuerySettableAttributes(ctx context.Context) (*FileAttributeInfoList, error) {
	var _arg0 *C.GFile                  // out
	var _arg1 *C.GCancellable           // out
	var _cret *C.GFileAttributeInfoList // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_query_settable_attributes(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_info_list_unref((*C.GFileAttributeInfoList)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileAttributeInfoList, _goerr
}

// QueryWritableNamespaces: obtain the list of attribute namespaces where
// new attributes can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - fileAttributeInfoList describing the writable namespaces. When you are
//     done with it, release it with g_file_attribute_info_list_unref().
func (file *File) QueryWritableNamespaces(ctx context.Context) (*FileAttributeInfoList, error) {
	var _arg0 *C.GFile                  // out
	var _arg1 *C.GCancellable           // out
	var _cret *C.GFileAttributeInfoList // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_query_writable_namespaces(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_info_list_unref((*C.GFileAttributeInfoList)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileAttributeInfoList, _goerr
}

// Read opens a file for reading. The result is a InputStream that can be used
// to read the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//   - fileInputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) Read(ctx context.Context) (*FileInputStream, error) {
	var _arg0 *C.GFile            // out
	var _arg1 *C.GCancellable     // out
	var _cret *C.GFileInputStream // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_read(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileInputStream *FileInputStream // out
	var _goerr error                      // out

	_fileInputStream = wrapFileInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInputStream, _goerr
}

// ReadAsync: asynchronously opens file for reading.
//
// For more details, see g_file_read() which is the synchronous version of this
// call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_read_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) ReadAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_read_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadFinish finishes an asynchronous file read operation started with
// g_file_read_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileInputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) ReadFinish(res AsyncResulter) (*FileInputStream, error) {
	var _arg0 *C.GFile            // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GFileInputStream // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_read_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInputStream *FileInputStream // out
	var _goerr error                      // out

	_fileInputStream = wrapFileInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInputStream, _goerr
}

// Replace returns an output stream for overwriting the file, possibly creating
// a backup copy of the file first. If the file doesn't exist, it will be
// created.
//
// This will try to replace the file in the safest way possible so that any
// errors during the writing will not affect an already existing copy of the
// file. For instance, for local files it may write to a temporary file and then
// atomically rename over the destination when the stream is closed.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If you pass in a non-NULL etag value and file already exists, then this
// value is compared to the current entity tag of the file, and if they
// differ an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
// that the file has been changed since you last read it. You can get the
// new etag from g_file_output_stream_get_etag() after you've finished
// writing and closed the OutputStream. When you load a new file you can use
// g_file_input_stream_query_info() to get the etag of the file.
//
// If make_backup is TRUE, this function will attempt to make a
// backup of the current file before overwriting it. If this fails a
// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to replace
// anyway, try again with make_backup set to FALSE.
//
// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
// returned, and if the file is some other form of non-regular file then a
// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems don't
// allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME error,
// and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): optional entity tag (#entity-tags) for the current
//     #GFile, or LL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) Replace(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg4 *C.GCancellable      // out
	var _arg1 *C.char              // out
	var _arg2 C.gboolean           // out
	var _arg3 C.GFileCreateFlags   // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)

	_cret = C.g_file_replace(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// ReplaceAsync: asynchronously overwrites the file, replacing the contents,
// possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_replace_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): entity tag (#entity-tags) for the current #GFile,
//     or NULL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) ReplaceAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gboolean            // out
	var _arg3 C.GFileCreateFlags    // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_replace_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReplaceContents replaces the contents of file with contents of length bytes.
//
// If etag is specified (not NULL), any existing file must have that etag,
// or the error G_IO_ERROR_WRONG_ETAG will be returned.
//
// If make_backup is TRUE, this function will attempt to make a backup of file.
// Internally, it uses g_file_replace(), so will try to replace the file
// contents in the safest way possible. For example, atomic renames are used
// when replacing local files contents.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The returned new_etag can be used to verify that the file hasn't changed the
// next time it is saved over.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - contents: string containing the new contents for file.
//   - etag (optional): old entity-tag (#entity-tags) for the document, or NULL.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - newEtag (optional): location to a new entity tag (#entity-tags) for the
//     document. This should be freed with g_free() when no longer needed,
//     or NULL.
func (file *File) ReplaceContents(ctx context.Context, contents, etag string, makeBackup bool, flags FileCreateFlags) (string, error) {
	var _arg0 *C.GFile        // out
	var _arg7 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _arg2 C.gsize
	var _arg3 *C.char            // out
	var _arg4 C.gboolean         // out
	var _arg5 C.GFileCreateFlags // out
	var _arg6 *C.char            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(contents))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(contents) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(contents)), contents)
	defer C.free(unsafe.Pointer(_arg1))
	if etag != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if makeBackup {
		_arg4 = C.TRUE
	}
	_arg5 = C.GFileCreateFlags(flags)

	C.g_file_replace_contents(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, _arg7, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)

	var _newEtag string // out
	var _goerr error    // out

	if _arg6 != nil {
		_newEtag = C.GoString((*C.gchar)(unsafe.Pointer(_arg6)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _newEtag, _goerr
}

// ReplaceContentsAsync starts an asynchronous replacement of file with the
// given contents of length bytes. etag will replace the document's current
// entity tag.
//
// When this operation has completed, callback will be called
// with user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If make_backup is TRUE, this function will attempt to make a backup of file.
//
// Note that no copy of contents will be made, so it must stay valid until
// callback is called. See g_file_replace_contents_bytes_async() for a #GBytes
// version that will automatically hold a reference to the contents (without
// copying) for the duration of the call.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - contents: string of contents to replace the file with.
//   - etag (optional): new entity tag (#entity-tags) for the file, or NULL.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//   - callback (optional) to call when the request is satisfied.
func (file *File) ReplaceContentsAsync(ctx context.Context, contents, etag string, makeBackup bool, flags FileCreateFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GFile        // out
	var _arg6 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _arg2 C.gsize
	var _arg3 *C.char               // out
	var _arg4 C.gboolean            // out
	var _arg5 C.GFileCreateFlags    // out
	var _arg7 C.GAsyncReadyCallback // out
	var _arg8 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(contents))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(contents) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(contents)), contents)
	defer C.free(unsafe.Pointer(_arg1))
	if etag != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if makeBackup {
		_arg4 = C.TRUE
	}
	_arg5 = C.GFileCreateFlags(flags)
	if callback != nil {
		_arg7 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg8 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_replace_contents_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ReplaceContentsBytesAsync: same as g_file_replace_contents_async() but takes
// a #GBytes input instead. This function will keep a ref on contents until
// the operation is done. Unlike g_file_replace_contents_async() this allows
// forgetting about the content without waiting for the callback.
//
// When this operation has completed, callback will be called
// with user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - contents: #GBytes.
//   - etag (optional): new entity tag (#entity-tags) for the file, or NULL.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//   - callback (optional) to call when the request is satisfied.
func (file *File) ReplaceContentsBytesAsync(ctx context.Context, contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.GBytes             // out
	var _arg2 *C.char               // out
	var _arg3 C.gboolean            // out
	var _arg4 C.GFileCreateFlags    // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(contents)))
	if etag != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if makeBackup {
		_arg3 = C.TRUE
	}
	_arg4 = C.GFileCreateFlags(flags)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_replace_contents_bytes_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ReplaceContentsFinish finishes an asynchronous replace of the given file.
// See g_file_replace_contents_async(). Sets new_etag to the new entity tag for
// the document, if present.
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - newEtag (optional): location of a new entity tag (#entity-tags) for the
//     document. This should be freed with g_free() when it is no longer needed,
//     or NULL.
func (file *File) ReplaceContentsFinish(res AsyncResulter) (string, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_file_replace_contents_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _newEtag string // out
	var _goerr error    // out

	if _arg2 != nil {
		_newEtag = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _newEtag, _goerr
}

// ReplaceFinish finishes an asynchronous file replace operation started with
// g_file_replace_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) ReplaceFinish(res AsyncResulter) (*FileOutputStream, error) {
	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_replace_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// ReplaceReadwrite returns an output stream for overwriting the file in
// readwrite mode, possibly creating a backup copy of the file first. If the
// file doesn't exist, it will be created.
//
// For details about the behaviour, see g_file_replace() which does the same
// thing but returns an output stream only.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): optional entity tag (#entity-tags) for the current
//     #GFile, or LL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) ReplaceReadwrite(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileIOStream, error) {
	var _arg0 *C.GFile           // out
	var _arg4 *C.GCancellable    // out
	var _arg1 *C.char            // out
	var _arg2 C.gboolean         // out
	var _arg3 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)

	_cret = C.g_file_replace_readwrite(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// ReplaceReadwriteAsync: asynchronously overwrites the file in read-write mode,
// replacing the contents, possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_replace_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): entity tag (#entity-tags) for the current #GFile,
//     or NULL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) ReplaceReadwriteAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gboolean            // out
	var _arg3 C.GFileCreateFlags    // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_replace_readwrite_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReplaceReadwriteFinish finishes an asynchronous file replace operation
// started with g_file_replace_readwrite_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) ReplaceReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_replace_readwrite_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// ResolveRelativePath resolves a relative path for file to an absolute path.
//
// This call does no blocking I/O.
//
// If the relative_path is an absolute path name, the resolution is done
// absolutely (without taking file path as base).
//
// The function takes the following parameters:
//
//   - relativePath: given relative path string.
//
// The function returns the following values:
//
//   - ret for the resolved path.
func (file *File) ResolveRelativePath(relativePath string) *File {
	var _arg0 *C.GFile // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(relativePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_resolve_relative_path(_arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(relativePath)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// SetAttribute sets an attribute in the file with attribute name attribute to
// value_p.
//
// Some attributes can be unset by setting type to G_FILE_ATTRIBUTE_TYPE_INVALID
// and value_p to NULL.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - typ: type of the attribute.
//   - valueP (optional): pointer to the value (or the pointer itself if the
//     type is a pointer type).
//   - flags: set of QueryInfoFlags.
func (file *File) SetAttribute(ctx context.Context, attribute string, typ FileAttributeType, valueP unsafe.Pointer, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileAttributeType  // out
	var _arg3 C.gpointer            // out
	var _arg4 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeType(typ)
	_arg3 = (C.gpointer)(unsafe.Pointer(valueP))
	_arg4 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attribute(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(valueP)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributeByteString sets attribute of type
// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to value. If attribute is of a different
// type, this operation will fail, returning FALSE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - value: string containing the attribute's new value.
//   - flags: QueryInfoFlags.
func (file *File) SetAttributeByteString(ctx context.Context, attribute, value string, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attribute_byte_string(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributeInt32 sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to
// value. If attribute is of a different type, this operation will fail.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - value containing the attribute's new value.
//   - flags: QueryInfoFlags.
func (file *File) SetAttributeInt32(ctx context.Context, attribute string, value int32, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gint32              // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint32(value)
	_arg3 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attribute_int32(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributeInt64 sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to
// value. If attribute is of a different type, this operation will fail.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - value containing the attribute's new value.
//   - flags: QueryInfoFlags.
func (file *File) SetAttributeInt64(ctx context.Context, attribute string, value int64, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gint64              // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint64(value)
	_arg3 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attribute_int64(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributeString sets attribute of type G_FILE_ATTRIBUTE_TYPE_STRING to
// value. If attribute is of a different type, this operation will fail.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - value: string containing the attribute's value.
//   - flags: QueryInfoFlags.
func (file *File) SetAttributeString(ctx context.Context, attribute, value string, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attribute_string(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributeUint32 sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32 to
// value. If attribute is of a different type, this operation will fail.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - value containing the attribute's new value.
//   - flags: QueryInfoFlags.
func (file *File) SetAttributeUint32(ctx context.Context, attribute string, value uint32, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.guint32             // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint32(value)
	_arg3 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attribute_uint32(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributeUint64 sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64 to
// value. If attribute is of a different type, this operation will fail.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - value containing the attribute's new value.
//   - flags: QueryInfoFlags.
func (file *File) SetAttributeUint64(ctx context.Context, attribute string, value uint64, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.guint64             // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint64(value)
	_arg3 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attribute_uint64(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributesAsync: asynchronously sets the attributes of file with info.
//
// For more details, see g_file_set_attributes_from_info(), which is the
// synchronous version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_set_attributes_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - info: Info.
//   - flags: QueryInfoFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) SetAttributesAsync(ctx context.Context, info *FileInfo, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.GFileInfo          // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg2 = C.GFileQueryInfoFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_set_attributes_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// SetAttributesFinish finishes setting an attribute started in
// g_file_set_attributes_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - info: Info.
func (file *File) SetAttributesFinish(result AsyncResulter) (*FileInfo, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_set_attributes_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _info *FileInfo // out
	var _goerr error    // out

	_info = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _info, _goerr
}

// SetAttributesFromInfo tries to set all attributes in the Info on the target
// values, not stopping on the first error.
//
// If there is any error during this operation then error will be set to the
// first error. Error on particular fields are flagged by setting the "status"
// field in the attribute value to G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING,
// which means you can also detect further errors.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - info: Info.
//   - flags: QueryInfoFlags.
func (file *File) SetAttributesFromInfo(ctx context.Context, info *FileInfo, flags FileQueryInfoFlags) error {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GFileInfo          // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg2 = C.GFileQueryInfoFlags(flags)

	C.g_file_set_attributes_from_info(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetDisplayName renames file to the specified display name.
//
// The display name is converted from UTF-8 to the correct encoding for the
// target filesystem if possible and the file is renamed to this.
//
// If you want to implement a rename operation in the user interface the edit
// name (G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial
// value in the rename widget, and then the result after editing should be
// passed to g_file_set_display_name().
//
// On success the resulting converted filename is returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - displayName: string.
//
// The function returns the following values:
//
//   - ret specifying what file was renamed to, or NULL if there was an error.
//     Free the returned object with g_object_unref().
func (file *File) SetDisplayName(ctx context.Context, displayName string) (*File, error) {
	var _arg0 *C.GFile        // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_set_display_name(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(displayName)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// SetDisplayNameAsync: asynchronously sets the display name for a given #GFile.
//
// For more details, see g_file_set_display_name() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_set_display_name_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - displayName: string.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) SetDisplayNameAsync(ctx context.Context, displayName string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_set_display_name_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// SetDisplayNameFinish finishes setting a display name started with
// g_file_set_display_name_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - ret or NULL on error. Free the returned object with g_object_unref().
func (file *File) SetDisplayNameFinish(res AsyncResulter) (*File, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_set_display_name_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// StartMountable starts a file of type G_FILE_TYPE_MOUNTABLE. Using
// start_operation, you can request callbacks when, for instance, passwords are
// needed during authentication.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - startOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (file *File) StartMountable(ctx context.Context, flags DriveStartFlags, startOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GDriveStartFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GDriveStartFlags(flags)
	if startOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(startOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_start_mountable(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startOperation)
	runtime.KeepAlive(callback)
}

// StartMountableFinish finishes a start operation. See g_file_start_mountable()
// for details.
//
// Finish an asynchronous start operation that was started with
// g_file_start_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) StartMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_start_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// StopMountable stops a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_stop_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (file *File) StopMountable(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_stop_mountable(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// StopMountableFinish finishes a stop operation, see g_file_stop_mountable()
// for details.
//
// Finish an asynchronous stop operation that was started with
// g_file_stop_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) StopMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_stop_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SupportsThreadContexts checks if file supports [thread-default
// contexts][g-main-context-push-thread-default-context]. If this returns FALSE,
// you cannot perform asynchronous operations on file in a thread that has a
// thread-default context.
//
// The function returns the following values:
//
//   - ok: whether or not file supports thread-default contexts.
func (file *File) SupportsThreadContexts() bool {
	var _arg0 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_supports_thread_contexts(_arg0)
	runtime.KeepAlive(file)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Trash sends file to the "Trashcan", if possible. This is similar to
// deleting it, but the user can recover it before emptying the trashcan.
// Not all file systems support trashing, so this call can return the
// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the x-gvfs-notrash unix
// mount option can be used to disable g_file_trash() support for certain
// mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (file *File) Trash(ctx context.Context) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_trash(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// TrashAsync: asynchronously sends file to the Trash location, if possible.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) TrashAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_trash_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// TrashFinish finishes an asynchronous file trashing operation, started with
// g_file_trash_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) TrashFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_trash_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// UnmountMountable unmounts a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_unmount_mountable_finish() to get the result of the operation.
//
// Deprecated: Use g_file_unmount_mountable_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) UnmountMountable(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_unmount_mountable(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// UnmountMountableFinish finishes an unmount operation, see
// g_file_unmount_mountable() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable().
//
// Deprecated: Use g_file_unmount_mountable_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) UnmountMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_unmount_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// UnmountMountableWithOperation unmounts a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_unmount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) UnmountMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_unmount_mountable_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// UnmountMountableWithOperationFinish finishes an unmount operation, see
// g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable_with_operation().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) UnmountMountableWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_unmount_mountable_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// appendTo gets an output stream for appending data to the file. If the file
// doesn't already exist it is created.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// Some file systems don't allow all file names, and may return an
// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
// too, and depend on what kind of filesystem the file is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) appendTo(ctx context.Context, flags FileCreateFlags) (*FileOutputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.append_to

	var _arg0 *C.GFile             // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.GFileCreateFlags   // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_append_to(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// appendToAsync: asynchronously opens file for appending.
//
// For more details, see g_file_append_to() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_append_to_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) appendToAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.append_to_async

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_append_to_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// appendToFinish finishes an asynchronous file append operation started with
// g_file_append_to_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileOutputStream: valid OutputStream or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) appendToFinish(res AsyncResulter) (*FileOutputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.append_to_finish

	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_append_to_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// copyFinish finishes copying the file started with g_file_copy_async().
//
// The function takes the following parameters:
//
//   - res: Result.
func (file *File) copyFinish(res AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.copy_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C._gotk4_gio2_File_virtual_copy_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Create creates a new file and returns an output stream for writing to it.
// The file must not already exist.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and
// may return an G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileOutputStream for the newly created file, or NULL on error. Free the
//     returned object with g_object_unref().
func (file *File) create(ctx context.Context, flags FileCreateFlags) (*FileOutputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create

	var _arg0 *C.GFile             // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.GFileCreateFlags   // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_create(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// createAsync: asynchronously creates a new file and returns an output stream
// for writing to it. The file must not already exist.
//
// For more details, see g_file_create() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_create_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) createAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_async

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_create_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// createFinish finishes an asynchronous file create operation started with
// g_file_create_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) createFinish(res AsyncResulter) (*FileOutputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_finish

	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_create_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// createReadwrite creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists, the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and may
// return an G_IO_ERROR_INVALID_FILENAME error, and if the name is too long,
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileIOStream for the newly created file, or NULL on error. Free the
//     returned object with g_object_unref().
func (file *File) createReadwrite(ctx context.Context, flags FileCreateFlags) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_readwrite

	var _arg0 *C.GFile           // out
	var _arg2 *C.GCancellable    // out
	var _arg1 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_create_readwrite(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// createReadwriteAsync: asynchronously creates a new file and returns a stream
// for reading and writing to it. The file must not already exist.
//
// For more details, see g_file_create_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_create_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) createReadwriteAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_readwrite_async

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_create_readwrite_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// createReadwriteFinish finishes an asynchronous file create operation started
// with g_file_create_readwrite_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) createReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_readwrite_finish

	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_create_readwrite_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// deleteFile deletes a file. If the file is a directory, it will only be
// deleted if it is empty. This has the same semantics as g_unlink().
//
// If file doesnt exist, G_IO_ERROR_NOT_FOUND will be returned. This allows
// for deletion to be implemented avoiding time-of-check to time-of-use races
// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
//
//	g_autoptr(GError) local_error = NULL;
//	if (!g_file_delete (my_file, my_cancellable, &local_error) &&
//	    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//	  {
//	    // deletion failed for some reason other than the file not existing:
//	    // so report the error
//	    g_warning ("Failed to delete s: s",
//	               g_file_peek_path (my_file), local_error->message);
//	  }
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (file *File) deleteFile(ctx context.Context) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.delete_file

	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_File_virtual_delete_file(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// deleteFileAsync: asynchronously delete a file. If the file is a directory,
// it will only be deleted if it is empty. This has the same semantics as
// g_unlink().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) deleteFileAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.delete_file_async

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_delete_file_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// deleteFileFinish finishes deleting a file started with g_file_delete_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) deleteFileFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.delete_file_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_delete_file_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Dup duplicates a #GFile handle. This operation does not duplicate the actual
// file or directory represented by the #GFile; see g_file_copy() if attempting
// to copy a file.
//
// g_file_dup() is useful when a second handle is needed to the same underlying
// file, for use in a separate thread (#GFile is not thread-safe). For use
// within the same thread, use g_object_ref() to increment the existing objects
// reference count.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - ret: new #GFile that is a duplicate of the given #GFile.
func (file *File) dup() *File {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.dup

	var _arg0 *C.GFile // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_dup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ejectMountable starts an asynchronous eject on a mountable. When this
// operation has completed, callback will be called with user_user data, and the
// operation can be finalized with g_file_eject_mountable_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// Deprecated: Use g_file_eject_mountable_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) ejectMountable(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.eject_mountable

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_eject_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ejectMountableFinish finishes an asynchronous eject operation started by
// g_file_eject_mountable().
//
// Deprecated: Use g_file_eject_mountable_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) ejectMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.eject_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_eject_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ejectMountableWithOperation starts an asynchronous eject on a
// mountable. When this operation has completed, callback will be
// called with user_user data, and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) ejectMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.eject_mountable_with_operation

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_eject_mountable_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// ejectMountableWithOperationFinish finishes an asynchronous eject operation
// started by g_file_eject_mountable_with_operation().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) ejectMountableWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.eject_mountable_with_operation_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_eject_mountable_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// enumerateChildren gets the requested information about the files in a
// directory. The result is a Enumerator object that will give out Info objects
// for all the files in the directory.
//
// The attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set. attributes
// should be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like "standard::*"
// means all attributes in the standard namespace. An example attribute query be
// "standard::*,owner::user". The standard attributes are available as defines,
// like G_FILE_ATTRIBUTE_STANDARD_NAME. G_FILE_ATTRIBUTE_STANDARD_NAME should
// always be specified if you plan to call g_file_enumerator_get_child() or
// g_file_enumerator_iterate() on the returned enumerator.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY error will be
// returned. Other errors are possible too.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//
// The function returns the following values:
//
//   - fileEnumerator if successful, NULL on error. Free the returned object
//     with g_object_unref().
func (file *File) enumerateChildren(ctx context.Context, attributes string, flags FileQueryInfoFlags) (*FileEnumerator, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.enumerate_children

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _cret *C.GFileEnumerator    // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_enumerate_children(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)

	var _fileEnumerator *FileEnumerator // out
	var _goerr error                    // out

	_fileEnumerator = wrapFileEnumerator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileEnumerator, _goerr
}

// enumerateChildrenAsync: asynchronously gets the requested information about
// the files in a directory. The result is a Enumerator object that will give
// out Info objects for all the files in the directory.
//
// For more details, see g_file_enumerate_children() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_enumerate_children_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) enumerateChildrenAsync(ctx context.Context, attributes string, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.enumerate_children_async

	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_enumerate_children_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// enumerateChildrenFinish finishes an async enumerate children operation.
// See g_file_enumerate_children_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileEnumerator or NULL if an error occurred. Free the returned object
//     with g_object_unref().
func (file *File) enumerateChildrenFinish(res AsyncResulter) (*FileEnumerator, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.enumerate_children_finish

	var _arg0 *C.GFile           // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GFileEnumerator // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_enumerate_children_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileEnumerator *FileEnumerator // out
	var _goerr error                    // out

	_fileEnumerator = wrapFileEnumerator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileEnumerator, _goerr
}

// Equal checks if the two given #GFiles refer to the same file.
//
// Note that two #GFiles that differ can still refer to the same file on the
// filesystem due to various forms of filename aliasing.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - file2: second #GFile.
//
// The function returns the following values:
//
//   - ok: TRUE if file1 and file2 are equal.
func (file1 *File) equal(file2 Filer) bool {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file1))
	fnarg := gclass.equal

	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file1).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file2).Native()))

	_cret = C._gotk4_gio2_File_virtual_equal(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(file1)
	runtime.KeepAlive(file2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// findEnclosingMount gets a #GMount for the #GFile.
//
// #GMount is returned only for user interesting locations, see Monitor.
// If the Iface for file does not have a #mount, error will be set to
// G_IO_ERROR_NOT_FOUND and NULL #will be returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - mount where the file is located or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) findEnclosingMount(ctx context.Context) (*Mount, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.find_enclosing_mount

	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GMount       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_File_virtual_find_enclosing_mount(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _mount *Mount // out
	var _goerr error  // out

	_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _mount, _goerr
}

// findEnclosingMountAsync: asynchronously gets the mount for the file.
//
// For more details, see g_file_find_enclosing_mount() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_find_enclosing_mount_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) findEnclosingMountAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.find_enclosing_mount_async

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_find_enclosing_mount_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// findEnclosingMountFinish finishes an asynchronous find mount request.
// See g_file_find_enclosing_mount_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - mount for given file or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) findEnclosingMountFinish(res AsyncResulter) (*Mount, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.find_enclosing_mount_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GMount       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_find_enclosing_mount_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _mount *Mount // out
	var _goerr error  // out

	_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _mount, _goerr
}

// Basename gets the base name (the last component of the path) for a given
// #GFile.
//
// If called for the top level of a system (such as the filesystem root or a
// uri like sftp://host/) it will return a single directory separator (and on
// Windows, possibly a drive letter).
//
// The base name is a byte string (not UTF-8). It has no defined encoding
// or rules other than it may not contain zero bytes. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info().
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - filename (optional): string containing the #GFile's base name, or NULL
//     if given #GFile is invalid. The returned string should be freed with
//     g_free() when no longer needed.
func (file *File) basename() string {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.get_basename

	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_get_basename(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// childForDisplayName gets the child of file for a given display_name (i.e.
// a UTF-8 version of the name). If this function fails, it returns NULL and
// error will be set. This is very useful when constructing a #GFile for a new
// file and the user entered the filename in the user interface, for instance
// when you select a directory and type a filename in the file selector.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - displayName: string to a possible child.
//
// The function returns the following values:
//
//   - ret to the specified child, or NULL if the display name couldn't be
//     converted. Free the returned object with g_object_unref().
func (file *File) childForDisplayName(displayName string) (*File, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.get_child_for_display_name

	var _arg0 *C.GFile  // out
	var _arg1 *C.char   // out
	var _cret *C.GFile  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_File_virtual_get_child_for_display_name(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// Parent gets the parent directory for the file. If the file represents the
// root directory of the file system, then NULL will be returned.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - ret (optional) structure to the parent of the given #GFile or NULL if
//     there is no parent. Free the returned object with g_object_unref().
func (file *File) parent() *File {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.get_parent

	var _arg0 *C.GFile // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_get_parent(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _ret *File // out

	if _cret != nil {
		_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// parseName gets the parse name of the file. A parse name is a UTF-8 string
// that describes the file such that one can get the #GFile back using
// g_file_parse_name().
//
// This is generally used to show the #GFile as a nice full-pathname kind of
// string in a user interface, like in a location entry.
//
// For local files with names that can safely be converted to UTF-8 the
// pathname is used, otherwise the IRI is used (a form of URI that allows UTF-8
// characters unescaped).
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - utf8: string containing the #GFile's parse name. The returned string
//     should be freed with g_free() when no longer needed.
func (file *File) parseName() string {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.get_parse_name

	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_get_parse_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Path gets the local pathname for #GFile, if one exists. If non-NULL, this is
// guaranteed to be an absolute, canonical path. It might contain symlinks.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - filename (optional): string containing the #GFile's path, or NULL if no
//     such path exists. The returned string should be freed with g_free() when
//     no longer needed.
func (file *File) path() string {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.get_path

	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_get_path(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// relativePath gets the path for descendant relative to parent.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - descendant: input #GFile.
//
// The function returns the following values:
//
//   - filename (optional): string with the relative path from descendant to
//     parent, or NULL if descendant doesn't have parent as prefix. The returned
//     string should be freed with g_free() when no longer needed.
func (parent *File) relativePath(descendant Filer) string {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(parent))
	fnarg := gclass.get_relative_path

	var _arg0 *C.GFile // out
	var _arg1 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(descendant).Native()))

	_cret = C._gotk4_gio2_File_virtual_get_relative_path(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(descendant)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// urI gets the URI for the file.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - utf8: string containing the #GFile's URI. If the #GFile was constructed
//     with an invalid URI, an invalid URI is returned. The returned string
//     should be freed with g_free() when no longer needed.
func (file *File) urI() string {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.get_uri

	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_get_uri(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// uriScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme as:
//
//	URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include "file", "http", "ftp", etc.
//
// The scheme can be different from the one used to construct the #GFile,
// in that it might be replaced with one that is logically equivalent to the
// #GFile.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the URI scheme for the given #GFile
//     or NULL if the #GFile was constructed with an invalid URI. The returned
//     string should be freed with g_free() when no longer needed.
func (file *File) uriScheme() string {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.get_uri_scheme

	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_get_uri_scheme(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// hasURIScheme checks to see if a #GFile has a given URI scheme.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//   - uriScheme: string containing a URI scheme.
//
// The function returns the following values:
//
//   - ok: TRUE if #GFile's backend supports the given URI scheme, FALSE if URI
//     scheme is NULL, not supported, or #GFile is invalid.
func (file *File) hasURIScheme(uriScheme string) bool {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.has_uri_scheme

	var _arg0 *C.GFile   // out
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_File_virtual_has_uri_scheme(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(uriScheme)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash creates a hash value for a #GFile.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - guint: 0 if file is not a valid #GFile, otherwise an integer that can be
//     used as hash value for the #GFile. This function is intended for easily
//     hashing a #GFile to add to a Table or similar data structure.
func (file *File) hash() uint {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.hash

	var _arg0 *C.GFile // out
	var _cret C.guint  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_hash(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// isNative checks to see if a file is native to the platform.
//
// A native file is one expressed in the platform-native filename format,
// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
// as it might be on a locally mounted remote filesystem.
//
// On some systems non-native files may be available using the native filesystem
// via a userspace filesystem (FUSE), in these cases this call will return
// FALSE, but g_file_get_path() will still return a native path.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//   - ok: TRUE if file is native.
func (file *File) isNative() bool {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.is_native

	var _arg0 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_is_native(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(file)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// makeDirectory creates a directory. Note that this will only create
// a child directory of the immediate parent directory of the path
// or URI given by the #GFile. To recursively create directories, see
// g_file_make_directory_with_parents(). This function will fail if the parent
// directory does not exist, setting error to G_IO_ERROR_NOT_FOUND. If the
// file system doesn't support creating directories, this function will fail,
// setting error to G_IO_ERROR_NOT_SUPPORTED.
//
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (file *File) makeDirectory(ctx context.Context) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.make_directory

	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_File_virtual_make_directory(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// makeDirectoryAsync: asynchronously creates a directory.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) makeDirectoryAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.make_directory_async

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_make_directory_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// makeDirectoryFinish finishes an asynchronous directory creation, started with
// g_file_make_directory_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) makeDirectoryFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.make_directory_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_make_directory_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// makeSymbolicLink creates a symbolic link named file which contains the string
// symlink_value.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - symlinkValue: string with the path for the target of the new symlink.
func (file *File) makeSymbolicLink(ctx context.Context, symlinkValue string) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.make_symbolic_link

	var _arg0 *C.GFile        // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_File_virtual_make_symbolic_link(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(symlinkValue)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// makeSymbolicLinkAsync: asynchronously creates a symbolic link named file
// which contains the string symlink_value.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - symlinkValue: string with the path for the target of the new symlink.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) makeSymbolicLinkAsync(ctx context.Context, symlinkValue string, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.make_symbolic_link_async

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_make_symbolic_link_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(symlinkValue)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// makeSymbolicLinkFinish finishes an asynchronous symbolic link creation,
// started with g_file_make_symbolic_link_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) makeSymbolicLinkFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.make_symbolic_link_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_make_symbolic_link_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// measureDiskUsageFinish collects the results from an earlier call to
// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for more
// information.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - diskUsage (optional): number of bytes of disk space used.
//   - numDirs (optional): number of directories encountered.
//   - numFiles (optional): number of non-directories encountered.
func (file *File) measureDiskUsageFinish(result AsyncResulter) (diskUsage, numDirs, numFiles uint64, goerr error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.measure_disk_usage_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.guint64       // in
	var _arg3 C.guint64       // in
	var _arg4 C.guint64       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_measure_disk_usage_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _diskUsage uint64 // out
	var _numDirs uint64   // out
	var _numFiles uint64  // out
	var _goerr error      // out

	_diskUsage = uint64(_arg2)
	_numDirs = uint64(_arg3)
	_numFiles = uint64(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _diskUsage, _numDirs, _numFiles, _goerr
}

// monitorDir obtains a directory monitor for the given file. This may fail if
// directory monitoring is not supported.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// It does not make sense for flags to contain G_FILE_MONITOR_WATCH_HARD_LINKS,
// since hard links can not be made to directories. It is not possible to
// monitor all the files in a directory for changes made via hard links;
// if you want to do this then you must register individual watches with
// g_file_monitor().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of MonitorFlags.
//
// The function returns the following values:
//
//   - fileMonitor for the given file, or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) monitorDir(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.monitor_dir

	var _arg0 *C.GFile            // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.GFileMonitorFlags // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileMonitorFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_monitor_dir(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileMonitor FileMonitorrer // out
	var _goerr error                // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.FileMonitorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FileMonitorrer)
			return ok
		})
		rv, ok := casted.(FileMonitorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.FileMonitorrer")
		}
		_fileMonitor = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileMonitor, _goerr
}

// monitorFile obtains a file monitor for the given file. If no file
// notification mechanism exists, then regular polling of the file is used.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will
// also attempt to report changes made to the file via another filename (ie,
// a hard link). Without this flag, you can only rely on changes made through
// the filename contained in file to be reported. Using this flag may result in
// an increase in resource usage, and may not have any effect depending on the
// Monitor backend and/or filesystem type.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags: set of MonitorFlags.
//
// The function returns the following values:
//
//   - fileMonitor for the given file, or NULL on error. Free the returned
//     object with g_object_unref().
func (file *File) monitorFile(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.monitor_file

	var _arg0 *C.GFile            // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.GFileMonitorFlags // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileMonitorFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_monitor_file(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileMonitor FileMonitorrer // out
	var _goerr error                // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.FileMonitorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FileMonitorrer)
			return ok
		})
		rv, ok := casted.(FileMonitorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.FileMonitorrer")
		}
		_fileMonitor = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileMonitor, _goerr
}

// mountEnclosingVolume starts a mount_operation, mounting the volume that
// contains the file location.
//
// When this operation has completed, callback will be called
// with user_user data, and the operation can be finalized with
// g_file_mount_enclosing_volume_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation or NULL to avoid user interaction.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (location *File) mountEnclosingVolume(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(location))
	fnarg := gclass.mount_enclosing_volume

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(location).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_mount_enclosing_volume(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(location)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// mountEnclosingVolumeFinish finishes a mount operation started by
// g_file_mount_enclosing_volume().
//
// The function takes the following parameters:
//
//   - result: Result.
func (location *File) mountEnclosingVolumeFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(location))
	fnarg := gclass.mount_enclosing_volume_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(location).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_mount_enclosing_volume_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(location)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// mountMountable mounts a file of type G_FILE_TYPE_MOUNTABLE. Using
// mount_operation, you can request callbacks when, for instance, passwords are
// needed during authentication.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) mountMountable(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.mount_mountable

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_mount_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// mountMountableFinish finishes a mount operation. See g_file_mount_mountable()
// for details.
//
// Finish an asynchronous mount operation that was started with
// g_file_mount_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - ret or NULL on error. Free the returned object with g_object_unref().
func (file *File) mountMountableFinish(result AsyncResulter) (*File, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.mount_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_File_virtual_mount_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// moveFinish finishes an asynchronous file movement, started with
// g_file_move_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) moveFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.move_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_move_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// openReadwrite opens an existing file for reading and writing. The result is a
// IOStream that can be used to read and write the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on. Note that in many non-local file cases read and
// write streams are not supported, so make sure you really need to do read and
// write streaming, rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) openReadwrite(ctx context.Context) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.open_readwrite

	var _arg0 *C.GFile         // out
	var _arg1 *C.GCancellable  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_File_virtual_open_readwrite(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// openReadwriteAsync: asynchronously opens file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_open_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) openReadwriteAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.open_readwrite_async

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_open_readwrite_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// openReadwriteFinish finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) openReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.open_readwrite_finish

	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_open_readwrite_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// pollMountable polls a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (file *File) pollMountable(ctx context.Context, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.poll_mountable

	var _arg0 *C.GFile              // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_poll_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// pollMountableFinish finishes a poll operation. See g_file_poll_mountable()
// for details.
//
// Finish an asynchronous poll operation that was polled with
// g_file_poll_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) pollMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.poll_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_poll_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// prefixMatches checks whether file has the prefix specified by prefix.
//
// In other words, if the names of initial elements of file's pathname match
// prefix. Only full pathname elements are matched, so a path like /foo is not
// considered a prefix of /foobar, only of /foo/bar.
//
// A #GFile is not a prefix of itself. If you want to check for equality,
// use g_file_equal().
//
// This call does no I/O, as it works purely on names. As such it can sometimes
// return FALSE even if file is inside a prefix (from a filesystem point of
// view), because the prefix of file is an alias of prefix.
//
// The function takes the following parameters:
//
//   - file: input #GFile.
//
// The function returns the following values:
//
//   - ok: TRUE if the file's parent, grandparent, etc is prefix, FALSE
//     otherwise.
func (prefix *File) prefixMatches(file Filer) bool {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(prefix))
	fnarg := gclass.prefix_matches

	var _arg0 *C.GFile   // out
	var _arg1 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(prefix).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C._gotk4_gio2_File_virtual_prefix_matches(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(prefix)
	runtime.KeepAlive(file)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// queryFilesystemInfo: similar to g_file_query_info(), but obtains information
// about the filesystem the file is on, rather than the file itself. For
// instance the amount of space available and the type of the filesystem.
//
// The attributes value is a string that specifies the attributes that should
// be gathered. It is not an error if it's not possible to read a particular
// requested attribute from a file - it just won't be set. attributes
// should be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like "filesystem::*"
// means all attributes in the filesystem namespace. The standard namespace
// for filesystem attributes is "filesystem". Common attributes of interest
// are G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
// in bytes), G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
// and G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//
// The function returns the following values:
//
//   - fileInfo or NULL if there was an error. Free the returned object with
//     g_object_unref().
func (file *File) queryFilesystemInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_filesystem_info

	var _arg0 *C.GFile        // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_File_virtual_query_filesystem_info(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// queryFilesystemInfoAsync: asynchronously gets the requested information about
// the filesystem that the specified file is on. The result is a Info object
// that contains key-value attributes (such as type or size for the file).
//
// For more details, see g_file_query_filesystem_info() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_query_info_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) queryFilesystemInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_filesystem_info_async

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_query_filesystem_info_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// queryFilesystemInfoFinish finishes an asynchronous filesystem info query.
// See g_file_query_filesystem_info_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileInfo for given file or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) queryFilesystemInfoFinish(res AsyncResulter) (*FileInfo, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_filesystem_info_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_query_filesystem_info_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// queryInfo gets the requested information about specified file. The result is
// a Info object that contains key-value attributes (such as the type or size of
// the file).
//
// The attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set. attributes
// should be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like "standard::*"
// means all attributes in the standard namespace. An example attribute query be
// "standard::*,owner::user". The standard attributes are available as defines,
// like G_FILE_ATTRIBUTE_STANDARD_NAME.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// For symlinks, normally the information about the target of the symlink is
// returned, rather than information about the symlink itself. However if you
// pass G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in flags the information about
// the symlink itself will be returned. Also, for symlinks that point to
// non-existing files the information about the symlink itself will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//
// The function returns the following values:
//
//   - fileInfo for the given file, or NULL on error. Free the returned object
//     with g_object_unref().
func (file *File) queryInfo(ctx context.Context, attributes string, flags FileQueryInfoFlags) (*FileInfo, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_info

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _cret *C.GFileInfo          // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_query_info(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// queryInfoAsync: asynchronously gets the requested information about specified
// file. The result is a Info object that contains key-value attributes (such as
// type or size for the file).
//
// For more details, see g_file_query_info() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_query_info_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: attribute query string.
//   - flags: set of QueryInfoFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) queryInfoAsync(ctx context.Context, attributes string, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_info_async

	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileQueryInfoFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_query_info_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// queryInfoFinish finishes an asynchronous file info query. See
// g_file_query_info_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileInfo for given file or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) queryInfoFinish(res AsyncResulter) (*FileInfo, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_info_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_query_info_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// querySettableAttributes: obtain the list of settable attributes for the file.
//
// Returns the type and full attribute name of all the attributes that can be
// set on this file. This doesn't mean setting it will always succeed though,
// you might get an access failure, or some specific file may not support a
// specific attribute.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - fileAttributeInfoList describing the settable attributes. When you are
//     done with it, release it with g_file_attribute_info_list_unref().
func (file *File) querySettableAttributes(ctx context.Context) (*FileAttributeInfoList, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_settable_attributes

	var _arg0 *C.GFile                  // out
	var _arg1 *C.GCancellable           // out
	var _cret *C.GFileAttributeInfoList // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_File_virtual_query_settable_attributes(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_info_list_unref((*C.GFileAttributeInfoList)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileAttributeInfoList, _goerr
}

// queryWritableNamespaces: obtain the list of attribute namespaces where
// new attributes can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - fileAttributeInfoList describing the writable namespaces. When you are
//     done with it, release it with g_file_attribute_info_list_unref().
func (file *File) queryWritableNamespaces(ctx context.Context) (*FileAttributeInfoList, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.query_writable_namespaces

	var _arg0 *C.GFile                  // out
	var _arg1 *C.GCancellable           // out
	var _cret *C.GFileAttributeInfoList // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_File_virtual_query_writable_namespaces(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_info_list_unref((*C.GFileAttributeInfoList)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileAttributeInfoList, _goerr
}

// readAsync: asynchronously opens file for reading.
//
// For more details, see g_file_read() which is the synchronous version of this
// call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_read_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) readAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.read_async

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_read_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// readFinish finishes an asynchronous file read operation started with
// g_file_read_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileInputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) readFinish(res AsyncResulter) (*FileInputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.read_finish

	var _arg0 *C.GFile            // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GFileInputStream // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_read_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInputStream *FileInputStream // out
	var _goerr error                      // out

	_fileInputStream = wrapFileInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInputStream, _goerr
}

// readFn opens a file for reading. The result is a InputStream that can be used
// to read the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//   - fileInputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) readFn(ctx context.Context) (*FileInputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.read_fn

	var _arg0 *C.GFile            // out
	var _arg1 *C.GCancellable     // out
	var _cret *C.GFileInputStream // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_File_virtual_read_fn(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileInputStream *FileInputStream // out
	var _goerr error                      // out

	_fileInputStream = wrapFileInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInputStream, _goerr
}

// Replace returns an output stream for overwriting the file, possibly creating
// a backup copy of the file first. If the file doesn't exist, it will be
// created.
//
// This will try to replace the file in the safest way possible so that any
// errors during the writing will not affect an already existing copy of the
// file. For instance, for local files it may write to a temporary file and then
// atomically rename over the destination when the stream is closed.
//
// By default files created are generally readable by everyone, but if you pass
// G_FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If you pass in a non-NULL etag value and file already exists, then this
// value is compared to the current entity tag of the file, and if they
// differ an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
// that the file has been changed since you last read it. You can get the
// new etag from g_file_output_stream_get_etag() after you've finished
// writing and closed the OutputStream. When you load a new file you can use
// g_file_input_stream_query_info() to get the etag of the file.
//
// If make_backup is TRUE, this function will attempt to make a
// backup of the current file before overwriting it. If this fails a
// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to replace
// anyway, try again with make_backup set to FALSE.
//
// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
// returned, and if the file is some other form of non-regular file then a
// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems don't
// allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME error,
// and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): optional entity tag (#entity-tags) for the current
//     #GFile, or LL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) replace(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileOutputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace

	var _arg0 *C.GFile             // out
	var _arg4 *C.GCancellable      // out
	var _arg1 *C.char              // out
	var _arg2 C.gboolean           // out
	var _arg3 C.GFileCreateFlags   // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_replace(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// replaceAsync: asynchronously overwrites the file, replacing the contents,
// possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace() which is the synchronous version of
// this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_replace_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): entity tag (#entity-tags) for the current #GFile,
//     or NULL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) replaceAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_async

	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gboolean            // out
	var _arg3 C.GFileCreateFlags    // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_replace_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// replaceFinish finishes an asynchronous file replace operation started with
// g_file_replace_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileOutputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) replaceFinish(res AsyncResulter) (*FileOutputStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_finish

	var _arg0 *C.GFile             // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileOutputStream // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_replace_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileOutputStream, _goerr
}

// replaceReadwrite returns an output stream for overwriting the file in
// readwrite mode, possibly creating a backup copy of the file first. If the
// file doesn't exist, it will be created.
//
// For details about the behaviour, see g_file_replace() which does the same
// thing but returns an output stream only.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): optional entity tag (#entity-tags) for the current
//     #GFile, or LL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) replaceReadwrite(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_readwrite

	var _arg0 *C.GFile           // out
	var _arg4 *C.GCancellable    // out
	var _arg1 *C.char            // out
	var _arg2 C.gboolean         // out
	var _arg3 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_replace_readwrite(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// replaceReadwriteAsync: asynchronously overwrites the file in read-write mode,
// replacing the contents, possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_replace_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - etag (optional): entity tag (#entity-tags) for the current #GFile,
//     or NULL to ignore.
//   - makeBackup: TRUE if a backup should be created.
//   - flags: set of CreateFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) replaceReadwriteAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_readwrite_async

	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gboolean            // out
	var _arg3 C.GFileCreateFlags    // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_replace_readwrite_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// replaceReadwriteFinish finishes an asynchronous file replace operation
// started with g_file_replace_readwrite_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - fileIOStream or NULL on error. Free the returned object with
//     g_object_unref().
func (file *File) replaceReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_readwrite_finish

	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_replace_readwrite_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// resolveRelativePath resolves a relative path for file to an absolute path.
//
// This call does no blocking I/O.
//
// If the relative_path is an absolute path name, the resolution is done
// absolutely (without taking file path as base).
//
// The function takes the following parameters:
//
//   - relativePath: given relative path string.
//
// The function returns the following values:
//
//   - ret for the resolved path.
func (file *File) resolveRelativePath(relativePath string) *File {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.resolve_relative_path

	var _arg0 *C.GFile // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(relativePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_File_virtual_resolve_relative_path(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(relativePath)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// setAttribute sets an attribute in the file with attribute name attribute to
// value_p.
//
// Some attributes can be unset by setting type to G_FILE_ATTRIBUTE_TYPE_INVALID
// and value_p to NULL.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attribute: string containing the attribute's name.
//   - typ: type of the attribute.
//   - valueP (optional): pointer to the value (or the pointer itself if the
//     type is a pointer type).
//   - flags: set of QueryInfoFlags.
func (file *File) setAttribute(ctx context.Context, attribute string, typ FileAttributeType, valueP unsafe.Pointer, flags FileQueryInfoFlags) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.set_attribute

	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.GFileAttributeType  // out
	var _arg3 C.gpointer            // out
	var _arg4 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeType(typ)
	_arg3 = (C.gpointer)(unsafe.Pointer(valueP))
	_arg4 = C.GFileQueryInfoFlags(flags)

	C._gotk4_gio2_File_virtual_set_attribute(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(valueP)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAttributesAsync: asynchronously sets the attributes of file with info.
//
// For more details, see g_file_set_attributes_from_info(), which is the
// synchronous version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_set_attributes_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - info: Info.
//   - flags: QueryInfoFlags.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) setAttributesAsync(ctx context.Context, info *FileInfo, flags FileQueryInfoFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.set_attributes_async

	var _arg0 *C.GFile              // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.GFileInfo          // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg2 = C.GFileQueryInfoFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_set_attributes_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// setAttributesFinish finishes setting an attribute started in
// g_file_set_attributes_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - info: Info.
func (file *File) setAttributesFinish(result AsyncResulter) (*FileInfo, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.set_attributes_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.GFileInfo    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_set_attributes_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _info *FileInfo // out
	var _goerr error    // out

	_info = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _info, _goerr
}

// setAttributesFromInfo tries to set all attributes in the Info on the target
// values, not stopping on the first error.
//
// If there is any error during this operation then error will be set to the
// first error. Error on particular fields are flagged by setting the "status"
// field in the attribute value to G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING,
// which means you can also detect further errors.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - info: Info.
//   - flags: QueryInfoFlags.
func (file *File) setAttributesFromInfo(ctx context.Context, info *FileInfo, flags FileQueryInfoFlags) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.set_attributes_from_info

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GFileInfo          // out
	var _arg2 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg2 = C.GFileQueryInfoFlags(flags)

	C._gotk4_gio2_File_virtual_set_attributes_from_info(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setDisplayName renames file to the specified display name.
//
// The display name is converted from UTF-8 to the correct encoding for the
// target filesystem if possible and the file is renamed to this.
//
// If you want to implement a rename operation in the user interface the edit
// name (G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial
// value in the rename widget, and then the result after editing should be
// passed to g_file_set_display_name().
//
// On success the resulting converted filename is returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - displayName: string.
//
// The function returns the following values:
//
//   - ret specifying what file was renamed to, or NULL if there was an error.
//     Free the returned object with g_object_unref().
func (file *File) setDisplayName(ctx context.Context, displayName string) (*File, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.set_display_name

	var _arg0 *C.GFile        // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.char         // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_File_virtual_set_display_name(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(displayName)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// setDisplayNameAsync: asynchronously sets the display name for a given #GFile.
//
// For more details, see g_file_set_display_name() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_set_display_name_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - displayName: string.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) setDisplayNameAsync(ctx context.Context, displayName string, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.set_display_name_async

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_set_display_name_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// setDisplayNameFinish finishes setting a display name started with
// g_file_set_display_name_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - ret or NULL on error. Free the returned object with g_object_unref().
func (file *File) setDisplayNameFinish(res AsyncResulter) (*File, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.set_display_name_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_set_display_name_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// startMountable starts a file of type G_FILE_TYPE_MOUNTABLE. Using
// start_operation, you can request callbacks when, for instance, passwords are
// needed during authentication.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - startOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (file *File) startMountable(ctx context.Context, flags DriveStartFlags, startOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.start_mountable

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GDriveStartFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GDriveStartFlags(flags)
	if startOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(startOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_start_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startOperation)
	runtime.KeepAlive(callback)
}

// startMountableFinish finishes a start operation. See g_file_start_mountable()
// for details.
//
// Finish an asynchronous start operation that was started with
// g_file_start_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) startMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.start_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_start_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// stopMountable stops a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_stop_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional) to call when the request is satisfied, or NULL.
func (file *File) stopMountable(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.stop_mountable

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_stop_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// stopMountableFinish finishes a stop operation, see g_file_stop_mountable()
// for details.
//
// Finish an asynchronous stop operation that was started with
// g_file_stop_mountable().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) stopMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.stop_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_stop_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Trash sends file to the "Trashcan", if possible. This is similar to
// deleting it, but the user can recover it before emptying the trashcan.
// Not all file systems support trashing, so this call can return the
// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the x-gvfs-notrash unix
// mount option can be used to disable g_file_trash() support for certain
// mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (file *File) trash(ctx context.Context) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.trash

	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_File_virtual_trash(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// trashAsync: asynchronously sends file to the Trash location, if possible.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (file *File) trashAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.trash_async

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_trash_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// trashFinish finishes an asynchronous file trashing operation, started with
// g_file_trash_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) trashFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.trash_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_trash_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// unmountMountable unmounts a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_unmount_mountable_finish() to get the result of the operation.
//
// Deprecated: Use g_file_unmount_mountable_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) unmountMountable(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.unmount_mountable

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_unmount_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// unmountMountableFinish finishes an unmount operation, see
// g_file_unmount_mountable() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable().
//
// Deprecated: Use g_file_unmount_mountable_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) unmountMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.unmount_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_unmount_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// unmountMountableWithOperation unmounts a file of type G_FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_unmount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional): Operation, or NULL to avoid user interaction.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (file *File) unmountMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.unmount_mountable_with_operation

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_unmount_mountable_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// unmountMountableWithOperationFinish finishes an unmount operation, see
// g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable_with_operation().
//
// The function takes the following parameters:
//
//   - result: Result.
func (file *File) unmountMountableWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.unmount_mountable_with_operation_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_unmount_mountable_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// NewFileBuildFilenamev constructs a #GFile from a vector of elements using the
// correct separator for filenames.
//
// Using this function is equivalent to calling g_build_filenamev(), followed by
// g_file_new_for_path() on the result.
//
// The function takes the following parameters:
//
//   - args: NULL-terminated array of strings containing the path elements.
//
// The function returns the following values:
//
//   - file: new #GFile.
func NewFileBuildFilenamev(args []string) *File {
	var _arg1 **C.gchar // out
	var _cret *C.GFile  // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(args) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(args)+1)
			var zero *C.gchar
			out[len(args)] = zero
			for i := range args {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(args[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.g_file_new_build_filenamev(_arg1)
	runtime.KeepAlive(args)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// NewFileForCommandlineArg creates a #GFile with the given argument from
// the command line. The value of arg can be either a URI, an absolute path
// or a relative path resolved relative to the current working directory.
// This operation never fails, but the returned object might not support any I/O
// operation if arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in UTF-8 --
// not the system code page. This means that you should not use this function
// with string from argv as it is passed to main(). g_win32_get_command_line()
// will return a UTF-8 version of the commandline. #GApplication also uses UTF-8
// but g_application_command_line_create_file_for_arg() may be more useful for
// you there. It is also always possible to use this function with Context
// arguments of type G_OPTION_ARG_FILENAME.
//
// The function takes the following parameters:
//
//   - arg: command line string.
//
// The function returns the following values:
//
//   - file: new #GFile. Free the returned object with g_object_unref().
func NewFileForCommandlineArg(arg string) *File {
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_new_for_commandline_arg(_arg1)
	runtime.KeepAlive(arg)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// NewFileForCommandlineArgAndCwd creates a #GFile with the given argument from
// the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except that it
// allows for passing the current working directory as an argument instead of
// using the current working directory of the process.
//
// This is useful if the commandline argument was given in a context other than
// the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
//
// The function takes the following parameters:
//
//   - arg: command line string.
//   - cwd: current working directory of the commandline.
//
// The function returns the following values:
//
//   - file: new #GFile.
func NewFileForCommandlineArgAndCwd(arg, cwd string) *File {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.GFile // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(cwd)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_file_new_for_commandline_arg_and_cwd(_arg1, _arg2)
	runtime.KeepAlive(arg)
	runtime.KeepAlive(cwd)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// NewFileForPath constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O operation if path is
// malformed.
//
// The function takes the following parameters:
//
//   - path: string containing a relative or absolute path. The string must be
//     encoded in the glib filename encoding.
//
// The function returns the following values:
//
//   - file: new #GFile for the given path. Free the returned object with
//     g_object_unref().
func NewFileForPath(path string) *File {
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_new_for_path(_arg1)
	runtime.KeepAlive(path)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// NewFileForURI constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O operation if uri is
// malformed or if the uri type is not supported.
//
// The function takes the following parameters:
//
//   - uri: UTF-8 string containing a URI.
//
// The function returns the following values:
//
//   - file: new #GFile for the given uri. Free the returned object with
//     g_object_unref().
func NewFileForURI(uri string) *File {
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_new_for_uri(_arg1)
	runtime.KeepAlive(uri)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// NewFileTmp opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and IOStream pointing to
// it.
//
// tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is NULL,
// a default template is used.
//
// Unlike the other #GFile constructors, this will return NULL if a temporary
// file could not be created.
//
// The function takes the following parameters:
//
//   - tmpl (optional): template for the file name, as in g_file_open_tmp(),
//     or NULL for a default template.
//
// The function returns the following values:
//
//   - iostream: on return, a IOStream for the created file.
//   - file: new #GFile. Free the returned object with g_object_unref().
func NewFileTmp(tmpl string) (*FileIOStream, *File, error) {
	var _arg1 *C.char          // out
	var _arg2 *C.GFileIOStream // in
	var _cret *C.GFile         // in
	var _cerr *C.GError        // in

	if tmpl != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_file_new_tmp(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(tmpl)

	var _iostream *FileIOStream // out
	var _file *File             // out
	var _goerr error            // out

	_iostream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _iostream, _file, _goerr
}

// NewFileTmpAsync: asynchronously opens a file in the preferred directory for
// temporary files (as returned by g_get_tmp_dir()) as g_file_new_tmp().
//
// tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is NULL,
// a default template is used.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - tmpl (optional): template for the file name, as in g_file_open_tmp(),
//     or NULL for a default template.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is done.
func NewFileTmpAsync(ctx context.Context, tmpl string, ioPriority int, callback AsyncReadyCallback) {
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if tmpl != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_new_tmp_async(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// NewFileTmpDirAsync: asynchronously creates a directory in the preferred
// directory for temporary files (as returned by g_get_tmp_dir()) as
// g_dir_make_tmp().
//
// tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is NULL,
// a default template is used.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - tmpl (optional): template for the file name, as in g_dir_make_tmp(),
//     or NULL for a default template.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is done.
func NewFileTmpDirAsync(ctx context.Context, tmpl string, ioPriority int, callback AsyncReadyCallback) {
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if tmpl != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_new_tmp_dir_async(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// NewFileTmpDirFinish finishes a temporary directory creation started by
// g_file_new_tmp_dir_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - file: new #GFile. Free the returned object with g_object_unref().
func NewFileTmpDirFinish(result AsyncResulter) (*File, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GFile        // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_new_tmp_dir_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _file *File  // out
	var _goerr error // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _file, _goerr
}

// NewFileTmpFinish finishes a temporary file creation started by
// g_file_new_tmp_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - iostream: on return, a IOStream for the created file.
//   - file: new #GFile. Free the returned object with g_object_unref().
func NewFileTmpFinish(result AsyncResulter) (*FileIOStream, *File, error) {
	var _arg1 *C.GAsyncResult  // out
	var _arg2 *C.GFileIOStream // in
	var _cret *C.GFile         // in
	var _cerr *C.GError        // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_new_tmp_finish(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(result)

	var _iostream *FileIOStream // out
	var _file *File             // out
	var _goerr error            // out

	_iostream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _iostream, _file, _goerr
}

// FileParseName constructs a #GFile with the given parse_name (i.e.
// something given by g_file_get_parse_name()). This operation never fails,
// but the returned object might not support any I/O operation if the parse_name
// cannot be parsed.
//
// The function takes the following parameters:
//
//   - parseName: file name or path to be parsed.
//
// The function returns the following values:
//
//   - file: new #GFile.
func FileParseName(parseName string) *File {
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_parse_name(_arg1)
	runtime.KeepAlive(parseName)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// Icon: GIcon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
//
// GIcon does not provide the actual pixmap for the icon as this is out of GIO's
// scope, however implementations of GIcon may contain the name of an icon (see
// gio.ThemedIcon), or the path to an icon (see gio.LoadableIcon).
//
// To obtain a hash of a GIcon, see gio.Icon.Hash().
//
// To check if two GIcons are equal, see gio.Icon.Equal().
//
// For serializing a GIcon, use gio.Icon.Serialize() and gio.Icon().Deserialize.
//
// If you want to consume GIcon (for example, in a toolkit) you
// must be prepared to handle at least the three following cases:
// gio.LoadableIcon, gio.ThemedIcon and gio.EmblemedIcon. It may also
// make sense to have fast-paths for other cases (like handling GdkPixbuf
// (https://docs.gtk.org/gdk-pixbuf/class.Pixbuf.html) directly, for example)
// but all compliant GIcon implementations outside of GIO must implement
// gio.LoadableIcon.
//
// If your application or library provides one or more GIcon implementations you
// need to ensure that your new implementation also implements gio.LoadableIcon.
// Additionally, you must provide an implementation of gio.Icon.Serialize() that
// gives a result that is understood by gio.Icon().Deserialize, yielding one of
// the built-in icon types.
//
// Icon wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Icon struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Icon)(nil)
)

// Iconner describes Icon's interface methods.
type Iconner interface {
	coreglib.Objector

	// Equal checks if two icons are equal.
	Equal(icon2 Iconner) bool
	// Hash gets a hash for an icon.
	Hash() uint
	// Serialize serializes a #GIcon into a #GVariant.
	Serialize() *glib.Variant
	// String generates a textual representation of icon that can be used for
	// serialization such as when passing icon to a different process or saving
	// it to persistent storage.
	String() string
}

var _ Iconner = (*Icon)(nil)

func wrapIcon(obj *coreglib.Object) *Icon {
	return &Icon{
		Object: obj,
	}
}

func marshalIcon(p uintptr) (interface{}, error) {
	return wrapIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Equal checks if two icons are equal.
//
// The function takes the following parameters:
//
//   - icon2 (optional): pointer to the second #GIcon.
//
// The function returns the following values:
//
//   - ok: TRUE if icon1 is equal to icon2. FALSE otherwise.
func (icon1 *Icon) Equal(icon2 Iconner) bool {
	var _arg0 *C.GIcon   // out
	var _arg1 *C.GIcon   // out
	var _cret C.gboolean // in

	if icon1 != nil {
		_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon1).Native()))
	}
	if icon2 != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon2).Native()))
	}

	_cret = C.g_icon_equal(_arg0, _arg1)
	runtime.KeepAlive(icon1)
	runtime.KeepAlive(icon2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash gets a hash for an icon.
//
// The function returns the following values:
//
//   - guint containing a hash for the icon, suitable for use in a Table or
//     similar data structure.
func (icon *Icon) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_icon_hash(_arg0)
	runtime.KeepAlive(icon)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can
// be retrieved back by calling g_icon_deserialize() on the returned value.
// As serialization will avoid using raw icon data when possible, it only makes
// sense to transfer the #GVariant between processes on the same machine,
// (as opposed to over the network), and within the same file system namespace.
//
// The function returns the following values:
//
//   - variant (optional) or NULL when serialization fails. The #GVariant will
//     not be floating.
func (icon *Icon) Serialize() *glib.Variant {
	var _arg0 *C.GIcon    // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_icon_serialize(_arg0)
	runtime.KeepAlive(icon)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// String generates a textual representation of icon that can be used for
// serialization such as when passing icon to a different process or saving it
// to persistent storage. Use g_icon_new_for_string() to get icon back from the
// returned string.
//
// The encoding of the returned string is proprietary to #GIcon except in the
// following two cases
//
// - If icon is a Icon, the returned string is a native path (such as
// /path/to/my icon.png) without escaping if the #GFile for icon is a native
// file. If the file is not native, the returned string is the result of
// g_file_get_uri() (such as sftp://path/to/my20icon.png).
//
// - If icon is a Icon with exactly one name and no fallbacks, the encoding is
// simply the name (such as network-server).
//
// The function returns the following values:
//
//   - utf8 (optional): allocated NUL-terminated UTF8 string or NULL if icon
//     can't be serialized. Use g_free() to free.
func (icon *Icon) String() string {
	var _arg0 *C.GIcon // out
	var _cret *C.gchar // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_icon_to_string(_arg0)
	runtime.KeepAlive(icon)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Equal checks if two icons are equal.
//
// The function takes the following parameters:
//
//   - icon2 (optional): pointer to the second #GIcon.
//
// The function returns the following values:
//
//   - ok: TRUE if icon1 is equal to icon2. FALSE otherwise.
func (icon1 *Icon) equal(icon2 Iconner) bool {
	gclass := (*C.GIconIface)(coreglib.PeekParentClass(icon1))
	fnarg := gclass.equal

	var _arg0 *C.GIcon   // out
	var _arg1 *C.GIcon   // out
	var _cret C.gboolean // in

	if icon1 != nil {
		_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon1).Native()))
	}
	if icon2 != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon2).Native()))
	}

	_cret = C._gotk4_gio2_Icon_virtual_equal(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(icon1)
	runtime.KeepAlive(icon2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash gets a hash for an icon.
//
// The function returns the following values:
//
//   - guint containing a hash for the icon, suitable for use in a Table or
//     similar data structure.
func (icon *Icon) hash() uint {
	gclass := (*C.GIconIface)(coreglib.PeekParentClass(icon))
	fnarg := gclass.hash

	var _arg0 *C.GIcon // out
	var _cret C.guint  // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C._gotk4_gio2_Icon_virtual_hash(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(icon)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can
// be retrieved back by calling g_icon_deserialize() on the returned value.
// As serialization will avoid using raw icon data when possible, it only makes
// sense to transfer the #GVariant between processes on the same machine,
// (as opposed to over the network), and within the same file system namespace.
//
// The function returns the following values:
//
//   - variant (optional) or NULL when serialization fails. The #GVariant will
//     not be floating.
func (icon *Icon) serialize() *glib.Variant {
	gclass := (*C.GIconIface)(coreglib.PeekParentClass(icon))
	fnarg := gclass.serialize

	var _arg0 *C.GIcon    // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C._gotk4_gio2_Icon_virtual_serialize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(icon)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// IconDeserialize deserializes a #GIcon previously serialized using
// g_icon_serialize().
//
// The function takes the following parameters:
//
//   - value created with g_icon_serialize().
//
// The function returns the following values:
//
//   - icon (optional) or NULL when deserialization fails.
func IconDeserialize(value *glib.Variant) *Icon {
	var _arg1 *C.GVariant // out
	var _cret *C.GIcon    // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_icon_deserialize(_arg1)
	runtime.KeepAlive(value)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _icon
}

// NewIconForString: generate a #GIcon instance from str. This function can fail
// if str is not valid - see g_icon_to_string() for discussion.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that each #GType is registered with the type system prior
// to calling g_icon_new_for_string().
//
// The function takes the following parameters:
//
//   - str: string obtained via g_icon_to_string().
//
// The function returns the following values:
//
//   - icon: object implementing the #GIcon interface or NULL if error is set.
func NewIconForString(str string) (*Icon, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.GIcon  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_icon_new_for_string(_arg1, &_cerr)
	runtime.KeepAlive(str)

	var _icon *Icon  // out
	var _goerr error // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _icon, _goerr
}

// Initable: GInitable is implemented by objects that can fail during
// initialization. If an object implements this interface then it must
// be initialized as the first thing after construction, either via
// gio.Initable.Init() or gio.AsyncInitable.InitAsync() (the latter is only
// available if it also implements gio.AsyncInitable).
//
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. They will often
// fail with glib.Critical() or glib.Warning(), but this must not be relied on.
//
// Users of objects implementing this are not intended to use the interface
// method directly, instead it will be used automatically in various ways.
// For C applications you generally just call gio.Initable().New directly, or
// indirectly via a foo_thing_new() wrapper. This will call gio.Initable.Init()
// under the cover, returning NULL and setting a GError on failure (at which
// point the instance is unreferenced).
//
// For bindings in languages where the native constructor supports exceptions
// the binding could check for objects implementing GInitable during normal
// construction and automatically initialize them, throwing an exception on
// failure.
//
// Initable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Initable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Initable)(nil)
)

// Initabler describes Initable's interface methods.
type Initabler interface {
	coreglib.Objector

	// Init initializes the object implementing the interface.
	Init(ctx context.Context) error
}

var _ Initabler = (*Initable)(nil)

func wrapInitable(obj *coreglib.Object) *Initable {
	return &Initable{
		Object: obj,
	}
}

func marshalInitable(p uintptr) (interface{}, error) {
	return wrapInitable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Init initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If cancellable is not NULL,
// then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL
// and the object doesn't support cancellable initialization the error
// G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. See the
// [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class implementation of init() can assume (and
// assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes the
// object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a Class.constructor
// that sometimes returns an existing instance. In this pattern, a caller would
// expect to be able to call g_initable_init() on the result of g_object_new(),
// regardless of whether it is in fact a new instance.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (initable *Initable) Init(ctx context.Context) error {
	var _arg0 *C.GInitable    // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInitable)(unsafe.Pointer(coreglib.InternObject(initable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_initable_init(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Init initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If cancellable is not NULL,
// then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL
// and the object doesn't support cancellable initialization the error
// G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. See the
// [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class implementation of init() can assume (and
// assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes the
// object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a Class.constructor
// that sometimes returns an existing instance. In this pattern, a caller would
// expect to be able to call g_initable_init() on the result of g_object_new(),
// regardless of whether it is in fact a new instance.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (initable *Initable) init(ctx context.Context) error {
	gclass := (*C.GInitableIface)(coreglib.PeekParentClass(initable))
	fnarg := gclass.init

	var _arg0 *C.GInitable    // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInitable)(unsafe.Pointer(coreglib.InternObject(initable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_Initable_virtual_init(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListModel: GListModel is an interface that represents a mutable list of
// gobject.Object. Its main intention is as a model for various widgets in user
// interfaces, such as list views, but it can also be used as a convenient
// method of returning lists of data, with support for updates.
//
// Each object in the list may also report changes in itself via some mechanism
// (normally the gobject.Object::notify signal). Taken together with the
// gio.ListModel::items-changed signal, this provides for a list that can
// change its membership, and in which the members can change their individual
// properties.
//
// A good example would be the list of visible wireless network access points,
// where each access point can report dynamic properties such as signal
// strength.
//
// It is important to note that the GListModel itself does not report changes
// to the individual items. It only reports changes to the list membership.
// If you want to observe changes to the objects themselves then you need to
// connect signals to the objects that you are interested in.
//
// All items in a GListModel are of (or derived from) the same type.
// gio.ListModel.GetItemType() returns that type. The type may be an interface,
// in which case all objects in the list must implement it.
//
// The semantics are close to that of an array: gio.ListModel.GetNItems()
// returns the number of items in the list and gio.ListModel.GetItem() returns
// an item at a (0-based) position. In order to allow implementations to
// calculate the list length lazily, you can also iterate over items: starting
// from 0, repeatedly call gio.ListModel.GetItem() until it returns NULL.
//
// An implementation may create objects lazily, but must take care to return the
// same object for a given position until all references to it are gone.
//
// On the other side, a consumer is expected only to hold references on objects
// that are currently user visible, in order to facilitate the maximum level
// of laziness in the implementation of the list and to reduce the required
// number of signal connections at a given time.
//
// This interface is intended only to be used from a single thread.
// The thread in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns the
// thread-default main context (see glib.MainContext.PushThreadDefault()) in
// effect at the time that the model was created.
//
// Over time, it has established itself as good practice for list model
// implementations to provide properties item-type and n-items to ease
// working with them. While it is not required, it is recommended that
// implementations provide these two properties. They should return the values
// of gio.ListModel.GetItemType() and gio.ListModel.GetNItems() respectively and
// be defined as such:
//
//	properties[PROP_ITEM_TYPE] =
//	  g_param_spec_gtype ("item-type", NULL, NULL, G_TYPE_OBJECT,
//	                      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
//	properties[PROP_N_ITEMS] =
//	  g_param_spec_uint ("n-items", NULL, NULL, 0, G_MAXUINT, 0,
//	                     G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);.
//
// ListModel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ListModel)(nil)
)

// ListModeller describes ListModel's interface methods.
type ListModeller interface {
	coreglib.Objector

	// ItemType gets the type of the items in list.
	ItemType() coreglib.Type
	// NItems gets the number of items in list.
	NItems() uint
	// Item: get the item at position.
	Item(position uint) *coreglib.Object
	// ItemsChanged emits the Model::items-changed signal on list.
	ItemsChanged(position, removed, added uint)

	// Items-changed: this signal is emitted whenever items were added to or
	// removed from list.
	ConnectItemsChanged(func(position, removed, added uint)) coreglib.SignalHandle
}

var _ ListModeller = (*ListModel)(nil)

func wrapListModel(obj *coreglib.Object) *ListModel {
	return &ListModel{
		Object: obj,
	}
}

func marshalListModel(p uintptr) (interface{}, error) {
	return wrapListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectItemsChanged: this signal is emitted whenever items were added to or
// removed from list. At position, removed items were removed and added items
// were added in their place.
//
// Note: If removed != added, the positions of all later items in the model
// change.
func (list *ListModel) ConnectItemsChanged(f func(position, removed, added uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(list, "items-changed", false, unsafe.Pointer(C._gotk4_gio2_ListModel_ConnectItemsChanged), f)
}

// ItemType gets the type of the items in list.
//
// All items returned from g_list_model_get_item() are of the type returned
// by this function, or a subtype, or if the type is an interface, they are an
// implementation of that interface.
//
// The item type of a Model can not change during the life of the model.
//
// The function returns the following values:
//
//   - gType of the items contained in list.
func (list *ListModel) ItemType() coreglib.Type {
	var _arg0 *C.GListModel // out
	var _cret C.GType       // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(list).Native()))

	_cret = C.g_list_model_get_item_type(_arg0)
	runtime.KeepAlive(list)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// NItems gets the number of items in list.
//
// Depending on the model implementation, calling this function may be less
// efficient than iterating the list with increasing values for position until
// g_list_model_get_item() returns NULL.
//
// The function returns the following values:
//
//   - guint: number of items in list.
func (list *ListModel) NItems() uint {
	var _arg0 *C.GListModel // out
	var _cret C.guint       // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(list).Native()))

	_cret = C.g_list_model_get_n_items(_arg0)
	runtime.KeepAlive(list)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Item: get the item at position.
//
// If position is greater than the number of items in list, NULL is returned.
//
// NULL is never returned for an index that is smaller than the length of the
// list.
//
// This function is meant to be used by language bindings in place of
// g_list_model_get_item().
//
// See also: g_list_model_get_n_items().
//
// The function takes the following parameters:
//
//   - position of the item to fetch.
//
// The function returns the following values:
//
//   - object (optional) at position.
func (list *ListModel) Item(position uint) *coreglib.Object {
	var _arg0 *C.GListModel // out
	var _arg1 C.guint       // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(list).Native()))
	_arg1 = C.guint(position)

	_cret = C.g_list_model_get_object(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(position)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// ItemsChanged emits the Model::items-changed signal on list.
//
// This function should only be called by classes implementing Model. It has to
// be called after the internal representation of list has been updated, because
// handlers connected to this signal might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to its
// consumer) in places that will not cause problems for that consumer.
// For models that are driven directly by a write API (such as Store), changes
// can be reported in response to uses of that API. For models that represent
// remote data, changes should only be made from a fresh mainloop dispatch.
// It is particularly not permitted to make changes in response to a call to the
// Model consumer API.
//
// Stated another way: in general, it is assumed that code making a series
// of accesses to the model via the API, without returning to the mainloop,
// and without calling other code, will continue to view the same contents of
// the model.
//
// The function takes the following parameters:
//
//   - position at which list changed.
//   - removed: number of items removed.
//   - added: number of items added.
func (list *ListModel) ItemsChanged(position, removed, added uint) {
	var _arg0 *C.GListModel // out
	var _arg1 C.guint       // out
	var _arg2 C.guint       // out
	var _arg3 C.guint       // out

	_arg0 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(list).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(removed)
	_arg3 = C.guint(added)

	C.g_list_model_items_changed(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// Item: get the item at position. If position is greater than the number of
// items in list, NULL is returned.
//
// NULL is never returned for an index that is smaller than the length of the
// list. See g_list_model_get_n_items().
//
// The same #GObject instance may not appear more than once in a Model.
//
// The function takes the following parameters:
//
//   - position of the item to fetch.
//
// The function returns the following values:
//
//   - object (optional) at position.
func (list *ListModel) item(position uint) *coreglib.Object {
	gclass := (*C.GListModelInterface)(coreglib.PeekParentClass(list))
	fnarg := gclass.get_item

	var _arg0 *C.GListModel // out
	var _arg1 C.guint       // out
	var _cret C.gpointer    // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(list).Native()))
	_arg1 = C.guint(position)

	_cret = C._gotk4_gio2_ListModel_virtual_get_item(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(position)

	var _object *coreglib.Object // out

	_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))

	return _object
}

// itemType gets the type of the items in list.
//
// All items returned from g_list_model_get_item() are of the type returned
// by this function, or a subtype, or if the type is an interface, they are an
// implementation of that interface.
//
// The item type of a Model can not change during the life of the model.
//
// The function returns the following values:
//
//   - gType of the items contained in list.
func (list *ListModel) itemType() coreglib.Type {
	gclass := (*C.GListModelInterface)(coreglib.PeekParentClass(list))
	fnarg := gclass.get_item_type

	var _arg0 *C.GListModel // out
	var _cret C.GType       // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(list).Native()))

	_cret = C._gotk4_gio2_ListModel_virtual_get_item_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(list)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// nItems gets the number of items in list.
//
// Depending on the model implementation, calling this function may be less
// efficient than iterating the list with increasing values for position until
// g_list_model_get_item() returns NULL.
//
// The function returns the following values:
//
//   - guint: number of items in list.
func (list *ListModel) nItems() uint {
	gclass := (*C.GListModelInterface)(coreglib.PeekParentClass(list))
	fnarg := gclass.get_n_items

	var _arg0 *C.GListModel // out
	var _cret C.guint       // in

	_arg0 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(list).Native()))

	_cret = C._gotk4_gio2_ListModel_virtual_get_n_items(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(list)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// LoadableIcon: GLoadableIcon extends the gio.Icon interface and adds the
// ability to load icons from streams.
//
// LoadableIcon wraps an interface. This means the user can get the
// underlying type by calling Cast().
type LoadableIcon struct {
	_ [0]func() // equal guard
	Icon
}

var ()

// LoadableIconner describes LoadableIcon's interface methods.
type LoadableIconner interface {
	coreglib.Objector

	// Load loads a loadable icon.
	Load(ctx context.Context, size int) (string, InputStreamer, error)
	// LoadAsync loads an icon asynchronously.
	LoadAsync(ctx context.Context, size int, callback AsyncReadyCallback)
	// LoadFinish finishes an asynchronous icon load started in
	// g_loadable_icon_load_async().
	LoadFinish(res AsyncResulter) (string, InputStreamer, error)
}

var _ LoadableIconner = (*LoadableIcon)(nil)

func wrapLoadableIcon(obj *coreglib.Object) *LoadableIcon {
	return &LoadableIcon{
		Icon: Icon{
			Object: obj,
		},
	}
}

func marshalLoadableIcon(p uintptr) (interface{}, error) {
	return wrapLoadableIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Load loads a loadable icon. For the asynchronous version of this function,
// see g_loadable_icon_load_async().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - size: integer.
//
// The function returns the following values:
//
//   - typ (optional): location to store the type of the loaded icon, NULL to
//     ignore.
//   - inputStream to read the icon from.
func (icon *LoadableIcon) Load(ctx context.Context, size int) (string, InputStreamer, error) {
	var _arg0 *C.GLoadableIcon // out
	var _arg3 *C.GCancellable  // out
	var _arg1 C.int            // out
	var _arg2 *C.char          // in
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(size)

	_cret = C.g_loadable_icon_load(_arg0, _arg1, &_arg2, _arg3, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)

	var _typ string                // out
	var _inputStream InputStreamer // out
	var _goerr error               // out

	if _arg2 != nil {
		_typ = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _typ, _inputStream, _goerr
}

// LoadAsync loads an icon asynchronously. To finish this function, see
// g_loadable_icon_load_finish(). For the synchronous, blocking version of this
// function, see g_loadable_icon_load().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - size: integer.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (icon *LoadableIcon) LoadAsync(ctx context.Context, size int, callback AsyncReadyCallback) {
	var _arg0 *C.GLoadableIcon      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(size)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_loadable_icon_load_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)
	runtime.KeepAlive(callback)
}

// LoadFinish finishes an asynchronous icon load started in
// g_loadable_icon_load_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - typ (optional): location to store the type of the loaded icon, NULL to
//     ignore.
//   - inputStream to read the icon from.
func (icon *LoadableIcon) LoadFinish(res AsyncResulter) (string, InputStreamer, error) {
	var _arg0 *C.GLoadableIcon // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 *C.char          // in
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_loadable_icon_load_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(res)

	var _typ string                // out
	var _inputStream InputStreamer // out
	var _goerr error               // out

	if _arg2 != nil {
		_typ = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _typ, _inputStream, _goerr
}

// Load loads a loadable icon. For the asynchronous version of this function,
// see g_loadable_icon_load_async().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - size: integer.
//
// The function returns the following values:
//
//   - typ (optional): location to store the type of the loaded icon, NULL to
//     ignore.
//   - inputStream to read the icon from.
func (icon *LoadableIcon) load(ctx context.Context, size int) (string, InputStreamer, error) {
	gclass := (*C.GLoadableIconIface)(coreglib.PeekParentClass(icon))
	fnarg := gclass.load

	var _arg0 *C.GLoadableIcon // out
	var _arg3 *C.GCancellable  // out
	var _arg1 C.int            // out
	var _arg2 *C.char          // in
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(size)

	_cret = C._gotk4_gio2_LoadableIcon_virtual_load(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, _arg3, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)

	var _typ string                // out
	var _inputStream InputStreamer // out
	var _goerr error               // out

	if _arg2 != nil {
		_typ = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _typ, _inputStream, _goerr
}

// loadAsync loads an icon asynchronously. To finish this function, see
// g_loadable_icon_load_finish(). For the synchronous, blocking version of this
// function, see g_loadable_icon_load().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - size: integer.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (icon *LoadableIcon) loadAsync(ctx context.Context, size int, callback AsyncReadyCallback) {
	gclass := (*C.GLoadableIconIface)(coreglib.PeekParentClass(icon))
	fnarg := gclass.load_async

	var _arg0 *C.GLoadableIcon      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(size)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_LoadableIcon_virtual_load_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)
	runtime.KeepAlive(callback)
}

// loadFinish finishes an asynchronous icon load started in
// g_loadable_icon_load_async().
//
// The function takes the following parameters:
//
//   - res: Result.
//
// The function returns the following values:
//
//   - typ (optional): location to store the type of the loaded icon, NULL to
//     ignore.
//   - inputStream to read the icon from.
func (icon *LoadableIcon) loadFinish(res AsyncResulter) (string, InputStreamer, error) {
	gclass := (*C.GLoadableIconIface)(coreglib.PeekParentClass(icon))
	fnarg := gclass.load_finish

	var _arg0 *C.GLoadableIcon // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 *C.char          // in
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GLoadableIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_LoadableIcon_virtual_load_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(res)

	var _typ string                // out
	var _inputStream InputStreamer // out
	var _goerr error               // out

	if _arg2 != nil {
		_typ = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _typ, _inputStream, _goerr
}

// MemoryMonitor: GMemoryMonitor will monitor system memory and suggest
// to the application when to free memory so as to leave more room for
// other applications. It is implemented on Linux using the Low Memory
// Monitor (https://gitlab.freedesktop.org/hadess/low-memory-monitor/) (API
// documentation (https://hadess.pages.freedesktop.org/low-memory-monitor/)).
//
// There is also an implementation for use inside Flatpak sandboxes.
//
// Possible actions to take when the signal is received are:
//
//   - Free caches
//   - Save files that havent been looked at in a while to disk, ready to be
//     reopened when needed
//   - Run a garbage collection cycle
//   - Try and compress fragmented allocations
//   - Exit on idle if the process has no reason to stay around
//   - Call malloc_trim(3) (man:malloc_trim(3)) to return cached heap pages to
//     the kernel (if supported by your libc)
//
// Note that some actions may not always improve system performance,
// and so should be profiled for your application. malloc_trim(), for example,
// may make future heap allocations slower (due to releasing cached heap pages
// back to the kernel).
//
// See gio.MemoryMonitorWarningLevel for details on the various warning levels.
//
//	static void
//	warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
//	{
//	  g_debug ("Warning level: d", level);
//	  if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//	    drop_caches ();
//	}
//
//	static GMemoryMonitor *
//	monitor_low_memory (void)
//	{
//	  GMemoryMonitor *m;
//	  m = g_memory_monitor_dup_default ();
//	  g_signal_connect (G_OBJECT (m), "low-memory-warning",
//	                    G_CALLBACK (warning_cb), NULL);
//	  return m;
//	}
//
// Dont forget to disconnect the gio.MemoryMonitor::low-memory-warning signal,
// and unref the GMemoryMonitor itself when exiting.
//
// MemoryMonitor wraps an interface. This means the user can get the
// underlying type by calling Cast().
type MemoryMonitor struct {
	_ [0]func() // equal guard
	Initable
}

var ()

// MemoryMonitorrer describes MemoryMonitor's interface methods.
type MemoryMonitorrer interface {
	coreglib.Objector

	baseMemoryMonitor() *MemoryMonitor
}

var _ MemoryMonitorrer = (*MemoryMonitor)(nil)

func wrapMemoryMonitor(obj *coreglib.Object) *MemoryMonitor {
	return &MemoryMonitor{
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalMemoryMonitor(p uintptr) (interface{}, error) {
	return wrapMemoryMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *MemoryMonitor) baseMemoryMonitor() *MemoryMonitor {
	return v
}

// BaseMemoryMonitor returns the underlying base object.
func BaseMemoryMonitor(obj MemoryMonitorrer) *MemoryMonitor {
	return obj.baseMemoryMonitor()
}

// ConnectLowMemoryWarning is emitted when the system is running low on free
// memory. The signal handler should then take the appropriate action depending
// on the warning level. See the MonitorWarningLevel documentation for details.
func (v *MemoryMonitor) ConnectLowMemoryWarning(f func(level MemoryMonitorWarningLevel)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "low-memory-warning", false, unsafe.Pointer(C._gotk4_gio2_MemoryMonitor_ConnectLowMemoryWarning), f)
}

// lowMemoryWarning: virtual function pointer for the
// Monitor::low-memory-warning signal.
func (monitor *MemoryMonitor) lowMemoryWarning(level MemoryMonitorWarningLevel) {
	gclass := (*C.GMemoryMonitorInterface)(coreglib.PeekParentClass(monitor))
	fnarg := gclass.low_memory_warning

	var _arg0 *C.GMemoryMonitor            // out
	var _arg1 C.GMemoryMonitorWarningLevel // out

	_arg0 = (*C.GMemoryMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = C.GMemoryMonitorWarningLevel(level)

	C._gotk4_gio2_MemoryMonitor_virtual_low_memory_warning(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(level)
}

// MemoryMonitorDupDefault gets a reference to the default Monitor for the
// system.
//
// The function returns the following values:
//
//   - memoryMonitor: new reference to the default Monitor.
func MemoryMonitorDupDefault() *MemoryMonitor {
	var _cret *C.GMemoryMonitor // in

	_cret = C.g_memory_monitor_dup_default()

	var _memoryMonitor *MemoryMonitor // out

	_memoryMonitor = wrapMemoryMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _memoryMonitor
}

// Mount: GMount interface represents user-visible mounts. Note, when porting
// from GnomeVFS (migrating-gnome-vfs.html), GMount is the moral equivalent of
// GnomeVFSVolume.
//
// GMount is a mounted filesystem that you can access. Mounted is in quotes
// because its not the same as a UNIX mount, it might be a GVFS mount,
// but you can still access the files on it if you use GIO. Might or might not
// be related to a volume object.
//
// Unmounting a GMount instance is an asynchronous operation. For more
// information about asynchronous operations, see gio.AsyncResult and gio.Task.
// To unmount a GMount instance, first call gio.Mount.UnmountWithOperation()
// with (at least) the GMount instance and a gio.AsyncReadyCallback. The
// callback will be fired when the operation has resolved (either with success
// or failure), and a gio.AsyncResult structure will be passed to the callback.
// That callback should then call gio.Mount.UnmountWithOperationFinish()
// with the GMount and the gio.AsyncResult data to see if the
// operation was completed successfully. If an error is present when
// gio.Mount.UnmountWithOperationFinish() is called, then it will be filled with
// any error information.
//
// Mount wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Mount struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Mount)(nil)
)

// Mounter describes Mount's interface methods.
type Mounter interface {
	coreglib.Objector

	// CanEject checks if mount can be ejected.
	CanEject() bool
	// CanUnmount checks if mount can be unmounted.
	CanUnmount() bool
	// Eject ejects a mount.
	Eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback)
	// EjectFinish finishes ejecting a mount.
	EjectFinish(result AsyncResulter) error
	// EjectWithOperation ejects a mount.
	EjectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// EjectWithOperationFinish finishes ejecting a mount.
	EjectWithOperationFinish(result AsyncResulter) error
	// DefaultLocation gets the default location of mount.
	DefaultLocation() *File
	// Drive gets the drive for the mount.
	Drive() *Drive
	// Icon gets the icon for mount.
	Icon() *Icon
	// Name gets the name of mount.
	Name() string
	// Root gets the root directory on mount.
	Root() *File
	// SortKey gets the sort key for mount, if any.
	SortKey() string
	// SymbolicIcon gets the symbolic icon for mount.
	SymbolicIcon() *Icon
	// UUID gets the UUID for the mount.
	UUID() string
	// Volume gets the volume for the mount.
	Volume() *Volume
	// GuessContentType tries to guess the type of content stored on mount.
	GuessContentType(ctx context.Context, forceRescan bool, callback AsyncReadyCallback)
	// GuessContentTypeFinish finishes guessing content types of mount.
	GuessContentTypeFinish(result AsyncResulter) ([]string, error)
	// GuessContentTypeSync tries to guess the type of content stored on mount.
	GuessContentTypeSync(ctx context.Context, forceRescan bool) ([]string, error)
	// IsShadowed determines if mount is shadowed.
	IsShadowed() bool
	// Remount remounts a mount.
	Remount(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// RemountFinish finishes remounting a mount.
	RemountFinish(result AsyncResulter) error
	// Shadow increments the shadow count on mount.
	Shadow()
	// Unmount unmounts a mount.
	Unmount(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback)
	// UnmountFinish finishes unmounting a mount.
	UnmountFinish(result AsyncResulter) error
	// UnmountWithOperation unmounts a mount.
	UnmountWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// UnmountWithOperationFinish finishes unmounting a mount.
	UnmountWithOperationFinish(result AsyncResulter) error
	// Unshadow decrements the shadow count on mount.
	Unshadow()

	// Changed is emitted when the mount has been changed.
	ConnectChanged(func()) coreglib.SignalHandle
	// Pre-unmount: this signal may be emitted when the #GMount is about to be
	// unmounted.
	ConnectPreUnmount(func()) coreglib.SignalHandle
	// Unmounted: this signal is emitted when the #GMount have been unmounted.
	ConnectUnmounted(func()) coreglib.SignalHandle
}

var _ Mounter = (*Mount)(nil)

func wrapMount(obj *coreglib.Object) *Mount {
	return &Mount{
		Object: obj,
	}
}

func marshalMount(p uintptr) (interface{}, error) {
	return wrapMount(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the mount has been changed.
func (mount *Mount) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(mount, "changed", false, unsafe.Pointer(C._gotk4_gio2_Mount_ConnectChanged), f)
}

// ConnectPreUnmount: this signal may be emitted when the #GMount is about to be
// unmounted.
//
// This signal depends on the backend and is only emitted if GIO was used to
// unmount.
func (mount *Mount) ConnectPreUnmount(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(mount, "pre-unmount", false, unsafe.Pointer(C._gotk4_gio2_Mount_ConnectPreUnmount), f)
}

// ConnectUnmounted: this signal is emitted when the #GMount have been
// unmounted. If the recipient is holding references to the object they should
// release them so the object can be finalized.
func (mount *Mount) ConnectUnmounted(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(mount, "unmounted", false, unsafe.Pointer(C._gotk4_gio2_Mount_ConnectUnmounted), f)
}

// CanEject checks if mount can be ejected.
//
// The function returns the following values:
//
//   - ok: TRUE if the mount can be ejected.
func (mount *Mount) CanEject() bool {
	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_can_eject(_arg0)
	runtime.KeepAlive(mount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUnmount checks if mount can be unmounted.
//
// The function returns the following values:
//
//   - ok: TRUE if the mount can be unmounted.
func (mount *Mount) CanUnmount() bool {
	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_can_unmount(_arg0)
	runtime.KeepAlive(mount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Eject ejects a mount. This is an asynchronous operation, and is finished by
// calling g_mount_eject_finish() with the mount and Result data returned in the
// callback.
//
// Deprecated: Use g_mount_eject_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - callback (optional) or NULL.
func (mount *Mount) Eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GMount             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_mount_eject(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// EjectFinish finishes ejecting a mount. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// Deprecated: Use g_mount_eject_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) EjectFinish(result AsyncResulter) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_mount_eject_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EjectWithOperation ejects a mount. This is an asynchronous operation, and is
// finished by calling g_mount_eject_with_operation_finish() with the mount and
// Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (mount *Mount) EjectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GMount             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_mount_eject_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish finishes ejecting a mount. If any errors occurred
// during the operation, error will be set to contain the errors and FALSE will
// be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) EjectWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_mount_eject_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DefaultLocation gets the default location of mount. The default location of
// the given mount is a path that reflects the main entry point for the user
// (e.g. the home directory, or the root of the volume).
//
// The function returns the following values:
//
//   - file: #GFile. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) DefaultLocation() *File {
	var _arg0 *C.GMount // out
	var _cret *C.GFile  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_default_location(_arg0)
	runtime.KeepAlive(mount)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// Drive gets the drive for the mount.
//
// This is a convenience method for getting the #GVolume and then using that
// object to get the #GDrive.
//
// The function returns the following values:
//
//   - drive (optional) or NULL if mount is not associated with a volume or a
//     drive. The returned object should be unreffed with g_object_unref() when
//     no longer needed.
func (mount *Mount) Drive() *Drive {
	var _arg0 *C.GMount // out
	var _cret *C.GDrive // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_drive(_arg0)
	runtime.KeepAlive(mount)

	var _drive *Drive // out

	if _cret != nil {
		_drive = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _drive
}

// Icon gets the icon for mount.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) Icon() *Icon {
	var _arg0 *C.GMount // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_icon(_arg0)
	runtime.KeepAlive(mount)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Name gets the name of mount.
//
// The function returns the following values:
//
//   - utf8: name for the given mount. The returned string should be freed with
//     g_free() when no longer needed.
func (mount *Mount) Name() string {
	var _arg0 *C.GMount // out
	var _cret *C.char   // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_name(_arg0)
	runtime.KeepAlive(mount)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Root gets the root directory on mount.
//
// The function returns the following values:
//
//   - file: #GFile. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) Root() *File {
	var _arg0 *C.GMount // out
	var _cret *C.GFile  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_root(_arg0)
	runtime.KeepAlive(mount)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// SortKey gets the sort key for mount, if any.
//
// The function returns the following values:
//
//   - utf8 (optional): sorting key for mount or NULL if no such key is
//     available.
func (mount *Mount) SortKey() string {
	var _arg0 *C.GMount // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_sort_key(_arg0)
	runtime.KeepAlive(mount)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SymbolicIcon gets the symbolic icon for mount.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) SymbolicIcon() *Icon {
	var _arg0 *C.GMount // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_symbolic_icon(_arg0)
	runtime.KeepAlive(mount)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// UUID gets the UUID for the mount. The reference is typically based on the
// file system UUID for the mount in question and should be considered an opaque
// string. Returns NULL if there is no UUID available.
//
// The function returns the following values:
//
//   - utf8 (optional): UUID for mount or NULL if no UUID can be computed.
//     The returned string should be freed with g_free() when no longer needed.
func (mount *Mount) UUID() string {
	var _arg0 *C.GMount // out
	var _cret *C.char   // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_uuid(_arg0)
	runtime.KeepAlive(mount)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Volume gets the volume for the mount.
//
// The function returns the following values:
//
//   - volume (optional) or NULL if mount is not associated with a volume.
//     The returned object should be unreffed with g_object_unref() when no
//     longer needed.
func (mount *Mount) Volume() *Volume {
	var _arg0 *C.GMount  // out
	var _cret *C.GVolume // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_get_volume(_arg0)
	runtime.KeepAlive(mount)

	var _volume *Volume // out

	if _cret != nil {
		_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _volume
}

// GuessContentType tries to guess the type of content stored on
// mount. Returns one or more textual identifiers of well-known
// content types (typically prefixed with "x-content/"), e.g.
// x-content/image-dcf for camera memory cards. See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This is an asynchronous operation (see g_mount_guess_content_type_sync()
// for the synchronous version), and is finished by calling
// g_mount_guess_content_type_finish() with the mount and Result data returned
// in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - forceRescan: whether to force a rescan of the content. Otherwise a cached
//     result will be used if available.
//   - callback (optional): ReadyCallback.
func (mount *Mount) GuessContentType(ctx context.Context, forceRescan bool, callback AsyncReadyCallback) {
	var _arg0 *C.GMount             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.gboolean            // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if forceRescan {
		_arg1 = C.TRUE
	}
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_mount_guess_content_type(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(forceRescan)
	runtime.KeepAlive(callback)
}

// GuessContentTypeFinish finishes guessing content types of mount.
// If any errors occurred during the operation, error will be set to contain
// the errors and FALSE will be returned. In particular, you may get an
// G_IO_ERROR_NOT_SUPPORTED if the mount does not support content guessing.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of content types or NULL on error. Caller
//     should free this array with g_strfreev() when done with it.
func (mount *Mount) GuessContentTypeFinish(result AsyncResulter) ([]string, error) {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cret **C.gchar       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_mount_guess_content_type_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// GuessContentTypeSync tries to guess the type of content stored
// on mount. Returns one or more textual identifiers of well-known
// content types (typically prefixed with "x-content/"), e.g.
// x-content/image-dcf for camera memory cards. See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This is a synchronous operation and as such may block doing IO; see
// g_mount_guess_content_type() for the asynchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - forceRescan: whether to force a rescan of the content. Otherwise a cached
//     result will be used if available.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of content types or NULL on error. Caller
//     should free this array with g_strfreev() when done with it.
func (mount *Mount) GuessContentTypeSync(ctx context.Context, forceRescan bool) ([]string, error) {
	var _arg0 *C.GMount       // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.gboolean      // out
	var _cret **C.gchar       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if forceRescan {
		_arg1 = C.TRUE
	}

	_cret = C.g_mount_guess_content_type_sync(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(forceRescan)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// IsShadowed determines if mount is shadowed. Applications or libraries should
// avoid displaying mount in the user interface if it is shadowed.
//
// A mount is said to be shadowed if there exists one or more user visible
// objects (currently #GMount objects) with a root that is inside the root of
// mount.
//
// One application of shadow mounts is when exposing a single file system
// that is used to address several logical volumes. In this situation,
// a Monitor implementation would create two #GVolume objects (for example,
// one for the camera functionality of the device and one for a SD card reader
// on the device) with activation URIs gphoto2://[usb:001,002]/store1/ and
// gphoto2://[usb:001,002]/store2/. When the underlying mount (with root
// gphoto2://[usb:001,002]/) is mounted, said Monitor implementation would
// create two #GMount objects (each with their root matching the corresponding
// volume activation root) that would shadow the original mount.
//
// The proxy monitor in GVfs 2.26 and later, automatically creates and manage
// shadow mounts (and shadows the underlying mount) if the activation root on a
// #GVolume is set.
//
// The function returns the following values:
//
//   - ok: TRUE if mount is shadowed.
func (mount *Mount) IsShadowed() bool {
	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_mount_is_shadowed(_arg0)
	runtime.KeepAlive(mount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remount remounts a mount. This is an asynchronous operation, and is finished
// by calling g_mount_remount_finish() with the mount and Results data returned
// in the callback.
//
// Remounting is useful when some setting affecting the operation of the volume
// has been changed, as these may need a remount to take affect. While this is
// semantically equivalent with unmounting and then remounting not all backends
// might need to actually be unmounted.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (mount *Mount) Remount(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GMount             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_mount_remount(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// RemountFinish finishes remounting a mount. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) RemountFinish(result AsyncResulter) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_mount_remount_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Shadow increments the shadow count on mount. Usually used by
// Monitor implementations when creating a shadow mount for mount, see
// g_mount_is_shadowed() for more information. The caller will need to emit the
// #GMount::changed signal on mount manually.
func (mount *Mount) Shadow() {
	var _arg0 *C.GMount // out

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C.g_mount_shadow(_arg0)
	runtime.KeepAlive(mount)
}

// Unmount unmounts a mount. This is an asynchronous operation, and is finished
// by calling g_mount_unmount_finish() with the mount and Result data returned
// in the callback.
//
// Deprecated: Use g_mount_unmount_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - callback (optional) or NULL.
func (mount *Mount) Unmount(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GMount             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_mount_unmount(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// UnmountFinish finishes unmounting a mount. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// Deprecated: Use g_mount_unmount_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) UnmountFinish(result AsyncResulter) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_mount_unmount_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// UnmountWithOperation unmounts a mount. This is an asynchronous operation,
// and is finished by calling g_mount_unmount_with_operation_finish() with the
// mount and Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (mount *Mount) UnmountWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GMount             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_mount_unmount_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// UnmountWithOperationFinish finishes unmounting a mount. If any errors
// occurred during the operation, error will be set to contain the errors and
// FALSE will be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) UnmountWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_mount_unmount_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Unshadow decrements the shadow count on mount. Usually used by
// Monitor implementations when destroying a shadow mount for mount, see
// g_mount_is_shadowed() for more information. The caller will need to emit the
// #GMount::changed signal on mount manually.
func (mount *Mount) Unshadow() {
	var _arg0 *C.GMount // out

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C.g_mount_unshadow(_arg0)
	runtime.KeepAlive(mount)
}

// canEject checks if mount can be ejected.
//
// The function returns the following values:
//
//   - ok: TRUE if the mount can be ejected.
func (mount *Mount) canEject() bool {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.can_eject

	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_can_eject(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canUnmount checks if mount can be unmounted.
//
// The function returns the following values:
//
//   - ok: TRUE if the mount can be unmounted.
func (mount *Mount) canUnmount() bool {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.can_unmount

	var _arg0 *C.GMount  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_can_unmount(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Changed: changed signal that is emitted when the mount's state has changed.
func (mount *Mount) changed() {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.changed

	var _arg0 *C.GMount // out

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_Mount_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)
}

// Eject ejects a mount. This is an asynchronous operation, and is finished by
// calling g_mount_eject_finish() with the mount and Result data returned in the
// callback.
//
// Deprecated: Use g_mount_eject_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - callback (optional) or NULL.
func (mount *Mount) eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.eject

	var _arg0 *C.GMount             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Mount_virtual_eject(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ejectFinish finishes ejecting a mount. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// Deprecated: Use g_mount_eject_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) ejectFinish(result AsyncResulter) error {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.eject_finish

	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Mount_virtual_eject_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ejectWithOperation ejects a mount. This is an asynchronous operation, and is
// finished by calling g_mount_eject_with_operation_finish() with the mount and
// Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (mount *Mount) ejectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.eject_with_operation

	var _arg0 *C.GMount             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Mount_virtual_eject_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// ejectWithOperationFinish finishes ejecting a mount. If any errors occurred
// during the operation, error will be set to contain the errors and FALSE will
// be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) ejectWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.eject_with_operation_finish

	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Mount_virtual_eject_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// defaultLocation gets the default location of mount. The default location of
// the given mount is a path that reflects the main entry point for the user
// (e.g. the home directory, or the root of the volume).
//
// The function returns the following values:
//
//   - file: #GFile. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) defaultLocation() *File {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_default_location

	var _arg0 *C.GMount // out
	var _cret *C.GFile  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_default_location(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// Drive gets the drive for the mount.
//
// This is a convenience method for getting the #GVolume and then using that
// object to get the #GDrive.
//
// The function returns the following values:
//
//   - drive (optional) or NULL if mount is not associated with a volume or a
//     drive. The returned object should be unreffed with g_object_unref() when
//     no longer needed.
func (mount *Mount) drive() *Drive {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_drive

	var _arg0 *C.GMount // out
	var _cret *C.GDrive // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_drive(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _drive *Drive // out

	if _cret != nil {
		_drive = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _drive
}

// Icon gets the icon for mount.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) icon() *Icon {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_icon

	var _arg0 *C.GMount // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Name gets the name of mount.
//
// The function returns the following values:
//
//   - utf8: name for the given mount. The returned string should be freed with
//     g_free() when no longer needed.
func (mount *Mount) name() string {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_name

	var _arg0 *C.GMount // out
	var _cret *C.char   // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Root gets the root directory on mount.
//
// The function returns the following values:
//
//   - file: #GFile. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) root() *File {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_root

	var _arg0 *C.GMount // out
	var _cret *C.GFile  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_root(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// sortKey gets the sort key for mount, if any.
//
// The function returns the following values:
//
//   - utf8 (optional): sorting key for mount or NULL if no such key is
//     available.
func (mount *Mount) sortKey() string {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_sort_key

	var _arg0 *C.GMount // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_sort_key(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// symbolicIcon gets the symbolic icon for mount.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (mount *Mount) symbolicIcon() *Icon {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_symbolic_icon

	var _arg0 *C.GMount // out
	var _cret *C.GIcon  // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_symbolic_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// uuiD gets the UUID for the mount. The reference is typically based on the
// file system UUID for the mount in question and should be considered an opaque
// string. Returns NULL if there is no UUID available.
//
// The function returns the following values:
//
//   - utf8 (optional): UUID for mount or NULL if no UUID can be computed.
//     The returned string should be freed with g_free() when no longer needed.
func (mount *Mount) uuiD() string {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_uuid

	var _arg0 *C.GMount // out
	var _cret *C.char   // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_uuid(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Volume gets the volume for the mount.
//
// The function returns the following values:
//
//   - volume (optional) or NULL if mount is not associated with a volume.
//     The returned object should be unreffed with g_object_unref() when no
//     longer needed.
func (mount *Mount) volume() *Volume {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.get_volume

	var _arg0 *C.GMount  // out
	var _cret *C.GVolume // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_get_volume(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)

	var _volume *Volume // out

	if _cret != nil {
		_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _volume
}

// guessContentType tries to guess the type of content stored on
// mount. Returns one or more textual identifiers of well-known
// content types (typically prefixed with "x-content/"), e.g.
// x-content/image-dcf for camera memory cards. See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This is an asynchronous operation (see g_mount_guess_content_type_sync()
// for the synchronous version), and is finished by calling
// g_mount_guess_content_type_finish() with the mount and Result data returned
// in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - forceRescan: whether to force a rescan of the content. Otherwise a cached
//     result will be used if available.
//   - callback (optional): ReadyCallback.
func (mount *Mount) guessContentType(ctx context.Context, forceRescan bool, callback AsyncReadyCallback) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.guess_content_type

	var _arg0 *C.GMount             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.gboolean            // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if forceRescan {
		_arg1 = C.TRUE
	}
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Mount_virtual_guess_content_type(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(forceRescan)
	runtime.KeepAlive(callback)
}

// guessContentTypeFinish finishes guessing content types of mount.
// If any errors occurred during the operation, error will be set to contain
// the errors and FALSE will be returned. In particular, you may get an
// G_IO_ERROR_NOT_SUPPORTED if the mount does not support content guessing.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of content types or NULL on error. Caller
//     should free this array with g_strfreev() when done with it.
func (mount *Mount) guessContentTypeFinish(result AsyncResulter) ([]string, error) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.guess_content_type_finish

	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cret **C.gchar       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Mount_virtual_guess_content_type_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// guessContentTypeSync tries to guess the type of content stored
// on mount. Returns one or more textual identifiers of well-known
// content types (typically prefixed with "x-content/"), e.g.
// x-content/image-dcf for camera memory cards. See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This is a synchronous operation and as such may block doing IO; see
// g_mount_guess_content_type() for the asynchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - forceRescan: whether to force a rescan of the content. Otherwise a cached
//     result will be used if available.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of content types or NULL on error. Caller
//     should free this array with g_strfreev() when done with it.
func (mount *Mount) guessContentTypeSync(ctx context.Context, forceRescan bool) ([]string, error) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.guess_content_type_sync

	var _arg0 *C.GMount       // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.gboolean      // out
	var _cret **C.gchar       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if forceRescan {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gio2_Mount_virtual_guess_content_type_sync(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(forceRescan)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// preUnmount: ::pre-unmount signal that is emitted when the #GMount will soon
// be emitted. If the recipient is somehow holding the mount open by keeping an
// open file on it it should close the file.
func (mount *Mount) preUnmount() {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.pre_unmount

	var _arg0 *C.GMount // out

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_Mount_virtual_pre_unmount(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)
}

// Remount remounts a mount. This is an asynchronous operation, and is finished
// by calling g_mount_remount_finish() with the mount and Results data returned
// in the callback.
//
// Remounting is useful when some setting affecting the operation of the volume
// has been changed, as these may need a remount to take affect. While this is
// semantically equivalent with unmounting and then remounting not all backends
// might need to actually be unmounted.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (mount *Mount) remount(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.remount

	var _arg0 *C.GMount             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Mount_virtual_remount(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// remountFinish finishes remounting a mount. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) remountFinish(result AsyncResulter) error {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.remount_finish

	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Mount_virtual_remount_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Unmount unmounts a mount. This is an asynchronous operation, and is finished
// by calling g_mount_unmount_finish() with the mount and Result data returned
// in the callback.
//
// Deprecated: Use g_mount_unmount_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - callback (optional) or NULL.
func (mount *Mount) unmount(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.unmount

	var _arg0 *C.GMount             // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Mount_virtual_unmount(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// unmountFinish finishes unmounting a mount. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// Deprecated: Use g_mount_unmount_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) unmountFinish(result AsyncResulter) error {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.unmount_finish

	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Mount_virtual_unmount_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// unmountWithOperation unmounts a mount. This is an asynchronous operation,
// and is finished by calling g_mount_unmount_with_operation_finish() with the
// mount and Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (mount *Mount) unmountWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.unmount_with_operation

	var _arg0 *C.GMount             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Mount_virtual_unmount_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// unmountWithOperationFinish finishes unmounting a mount. If any errors
// occurred during the operation, error will be set to contain the errors and
// FALSE will be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (mount *Mount) unmountWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.unmount_with_operation_finish

	var _arg0 *C.GMount       // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Mount_virtual_unmount_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Unmounted signal that is emitted when the #GMount have been unmounted.
// If the recipient is holding references to the object they should release them
// so the object can be finalized.
func (mount *Mount) unmounted() {
	gclass := (*C.GMountIface)(coreglib.PeekParentClass(mount))
	fnarg := gclass.unmounted

	var _arg0 *C.GMount // out

	_arg0 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_Mount_virtual_unmounted(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mount)
}

// NetworkMonitor: GNetworkMonitor provides an easy-to-use cross-platform API
// for monitoring network connectivity. On Linux, the available implementations
// are based on the kernel's netlink interface and on NetworkManager.
//
// There is also an implementation for use inside Flatpak sandboxes.
//
// NetworkMonitor wraps an interface. This means the user can get the
// underlying type by calling Cast().
type NetworkMonitor struct {
	_ [0]func() // equal guard
	Initable
}

var ()

// NetworkMonitorrer describes NetworkMonitor's interface methods.
type NetworkMonitorrer interface {
	coreglib.Objector

	// CanReach attempts to determine whether or not the host pointed to by
	// connectable can be reached, without actually trying to connect to it.
	CanReach(ctx context.Context, connectable SocketConnectabler) error
	// CanReachAsync: asynchronously attempts to determine whether or not the
	// host pointed to by connectable can be reached, without actually trying to
	// connect to it.
	CanReachAsync(ctx context.Context, connectable SocketConnectabler, callback AsyncReadyCallback)
	// CanReachFinish finishes an async network connectivity test.
	CanReachFinish(result AsyncResulter) error
	// Connectivity gets a more detailed networking state than
	// g_network_monitor_get_network_available().
	Connectivity() NetworkConnectivity
	// NetworkAvailable checks if the network is available.
	NetworkAvailable() bool
	// NetworkMetered checks if the network is metered.
	NetworkMetered() bool

	// Network-changed is emitted when the network configuration changes.
	ConnectNetworkChanged(func(networkAvailable bool)) coreglib.SignalHandle
}

var _ NetworkMonitorrer = (*NetworkMonitor)(nil)

func wrapNetworkMonitor(obj *coreglib.Object) *NetworkMonitor {
	return &NetworkMonitor{
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalNetworkMonitor(p uintptr) (interface{}, error) {
	return wrapNetworkMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectNetworkChanged is emitted when the network configuration changes.
func (monitor *NetworkMonitor) ConnectNetworkChanged(f func(networkAvailable bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(monitor, "network-changed", false, unsafe.Pointer(C._gotk4_gio2_NetworkMonitor_ConnectNetworkChanged), f)
}

// CanReach attempts to determine whether or not the host pointed to by
// connectable can be reached, without actually trying to connect to it.
//
// This may return TRUE even when Monitor:network-available is FALSE, if,
// for example, monitor can determine that connectable refers to a host on a
// local network.
//
// If monitor believes that an attempt to connect to connectable will succeed,
// it will return TRUE. Otherwise, it will return FALSE and set error to an
// appropriate error (such as G_IO_ERROR_HOST_UNREACHABLE).
//
// Note that although this does not attempt to connect to connectable,
// it may still block for a brief period of time (eg, trying to do multicast
// DNS on the local network), so if you do not want to block, you should use
// g_network_monitor_can_reach_async().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connectable: Connectable.
func (monitor *NetworkMonitor) CanReach(ctx context.Context, connectable SocketConnectabler) error {
	var _arg0 *C.GNetworkMonitor    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GSocketConnectable // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	C.g_network_monitor_can_reach(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connectable)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CanReachAsync: asynchronously attempts to determine whether or not the host
// pointed to by connectable can be reached, without actually trying to connect
// to it.
//
// For more details, see g_network_monitor_can_reach().
//
// When the operation is finished, callback will be called. You can then call
// g_network_monitor_can_reach_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connectable: Connectable.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (monitor *NetworkMonitor) CanReachAsync(ctx context.Context, connectable SocketConnectabler, callback AsyncReadyCallback) {
	var _arg0 *C.GNetworkMonitor    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GSocketConnectable // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_network_monitor_can_reach_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(callback)
}

// CanReachFinish finishes an async network connectivity test. See
// g_network_monitor_can_reach_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (monitor *NetworkMonitor) CanReachFinish(result AsyncResulter) error {
	var _arg0 *C.GNetworkMonitor // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_network_monitor_can_reach_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Connectivity gets a more detailed networking state than
// g_network_monitor_get_network_available().
//
// If Monitor:network-available is FALSE, then the connectivity state will be
// G_NETWORK_CONNECTIVITY_LOCAL.
//
// If Monitor:network-available is TRUE, then the connectivity state will
// be G_NETWORK_CONNECTIVITY_FULL (if there is full Internet connectivity),
// G_NETWORK_CONNECTIVITY_LIMITED (if the host has a default route,
// but appears to be unable to actually reach the full Internet),
// or G_NETWORK_CONNECTIVITY_PORTAL (if the host is trapped behind a "captive
// portal" that requires some sort of login or acknowledgement before allowing
// full Internet access).
//
// Note that in the case of G_NETWORK_CONNECTIVITY_LIMITED and
// G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are reachable
// but others are not. In this case, applications can attempt to connect to
// remote servers, but should gracefully fall back to their "offline" behavior
// if the connection attempt fails.
//
// The function returns the following values:
//
//   - networkConnectivity: network connectivity state.
func (monitor *NetworkMonitor) Connectivity() NetworkConnectivity {
	var _arg0 *C.GNetworkMonitor     // out
	var _cret C.GNetworkConnectivity // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_network_monitor_get_connectivity(_arg0)
	runtime.KeepAlive(monitor)

	var _networkConnectivity NetworkConnectivity // out

	_networkConnectivity = NetworkConnectivity(_cret)

	return _networkConnectivity
}

// NetworkAvailable checks if the network is available. "Available" here means
// that the system has a default route available for at least one of IPv4 or
// IPv6. It does not necessarily imply that the public Internet is reachable.
// See Monitor:network-available for more details.
//
// The function returns the following values:
//
//   - ok: whether the network is available.
func (monitor *NetworkMonitor) NetworkAvailable() bool {
	var _arg0 *C.GNetworkMonitor // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_network_monitor_get_network_available(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NetworkMetered checks if the network is metered. See Monitor:network-metered
// for more details.
//
// The function returns the following values:
//
//   - ok: whether the connection is metered.
func (monitor *NetworkMonitor) NetworkMetered() bool {
	var _arg0 *C.GNetworkMonitor // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_network_monitor_get_network_metered(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canReach attempts to determine whether or not the host pointed to by
// connectable can be reached, without actually trying to connect to it.
//
// This may return TRUE even when Monitor:network-available is FALSE, if,
// for example, monitor can determine that connectable refers to a host on a
// local network.
//
// If monitor believes that an attempt to connect to connectable will succeed,
// it will return TRUE. Otherwise, it will return FALSE and set error to an
// appropriate error (such as G_IO_ERROR_HOST_UNREACHABLE).
//
// Note that although this does not attempt to connect to connectable,
// it may still block for a brief period of time (eg, trying to do multicast
// DNS on the local network), so if you do not want to block, you should use
// g_network_monitor_can_reach_async().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connectable: Connectable.
func (monitor *NetworkMonitor) canReach(ctx context.Context, connectable SocketConnectabler) error {
	gclass := (*C.GNetworkMonitorInterface)(coreglib.PeekParentClass(monitor))
	fnarg := gclass.can_reach

	var _arg0 *C.GNetworkMonitor    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GSocketConnectable // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	C._gotk4_gio2_NetworkMonitor_virtual_can_reach(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connectable)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// canReachAsync: asynchronously attempts to determine whether or not the host
// pointed to by connectable can be reached, without actually trying to connect
// to it.
//
// For more details, see g_network_monitor_can_reach().
//
// When the operation is finished, callback will be called. You can then call
// g_network_monitor_can_reach_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connectable: Connectable.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (monitor *NetworkMonitor) canReachAsync(ctx context.Context, connectable SocketConnectabler, callback AsyncReadyCallback) {
	gclass := (*C.GNetworkMonitorInterface)(coreglib.PeekParentClass(monitor))
	fnarg := gclass.can_reach_async

	var _arg0 *C.GNetworkMonitor    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GSocketConnectable // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_NetworkMonitor_virtual_can_reach_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(callback)
}

// canReachFinish finishes an async network connectivity test. See
// g_network_monitor_can_reach_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (monitor *NetworkMonitor) canReachFinish(result AsyncResulter) error {
	gclass := (*C.GNetworkMonitorInterface)(coreglib.PeekParentClass(monitor))
	fnarg := gclass.can_reach_finish

	var _arg0 *C.GNetworkMonitor // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_NetworkMonitor_virtual_can_reach_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// networkChanged: virtual function pointer for the
// GNetworkMonitor::network-changed signal.
func (monitor *NetworkMonitor) networkChanged(networkAvailable bool) {
	gclass := (*C.GNetworkMonitorInterface)(coreglib.PeekParentClass(monitor))
	fnarg := gclass.network_changed

	var _arg0 *C.GNetworkMonitor // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GNetworkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	if networkAvailable {
		_arg1 = C.TRUE
	}

	C._gotk4_gio2_NetworkMonitor_virtual_network_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(networkAvailable)
}

// NetworkMonitorGetDefault gets the default Monitor for the system.
//
// The function returns the following values:
//
//   - networkMonitor which will be a dummy object if no network monitor is
//     available.
func NetworkMonitorGetDefault() *NetworkMonitor {
	var _cret *C.GNetworkMonitor // in

	_cret = C.g_network_monitor_get_default()

	var _networkMonitor *NetworkMonitor // out

	_networkMonitor = wrapNetworkMonitor(coreglib.Take(unsafe.Pointer(_cret)))

	return _networkMonitor
}

// PollableInputStream: GPollableInputStream is implemented by gio.InputStreams
// that can be polled for readiness to read. This can be used when interfacing
// with a non-GIO API that expects UNIX-file-descriptor-style asynchronous I/O
// rather than GIO-style.
//
// Some classes may implement GPollableInputStream but have only certain
// instances of that class be pollable. If gio.PollableInputStream.CanPoll()
// returns false, then the behavior of other GPollableInputStream methods is
// undefined.
//
// PollableInputStream wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PollableInputStream struct {
	_ [0]func() // equal guard
	InputStream
}

var (
	_ InputStreamer = (*PollableInputStream)(nil)
)

// PollableInputStreamer describes PollableInputStream's interface methods.
type PollableInputStreamer interface {
	coreglib.Objector

	// CanPoll checks if stream is actually pollable.
	CanPoll() bool
	// CreateSource creates a #GSource that triggers when stream can be read,
	// or cancellable is triggered or an error occurs.
	CreateSource(ctx context.Context) *glib.Source
	// IsReadable checks if stream can be read.
	IsReadable() bool
	// ReadNonblocking attempts to read up to count bytes from stream into
	// buffer, as with g_input_stream_read().
	ReadNonblocking(ctx context.Context, buffer []byte) (int, error)
}

var _ PollableInputStreamer = (*PollableInputStream)(nil)

func wrapPollableInputStream(obj *coreglib.Object) *PollableInputStream {
	return &PollableInputStream{
		InputStream: InputStream{
			Object: obj,
		},
	}
}

func marshalPollableInputStream(p uintptr) (interface{}, error) {
	return wrapPollableInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CanPoll checks if stream is actually pollable. Some classes may implement
// InputStream but have only certain instances of that class be pollable.
// If this method returns FALSE, then the behavior of other InputStream methods
// is undefined.
//
// For any given stream, the value returned by this method is constant; a stream
// cannot switch from pollable to non-pollable or vice versa.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is pollable, FALSE if not.
func (stream *PollableInputStream) CanPoll() bool {
	var _arg0 *C.GPollableInputStream // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_pollable_input_stream_can_poll(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateSource creates a #GSource that triggers when stream can be read,
// or cancellable is triggered or an error occurs. The callback on the source is
// of the SourceFunc type.
//
// As with g_pollable_input_stream_is_readable(), it is possible that the
// stream may not actually be readable even after the source triggers,
// so you should use g_pollable_input_stream_read_nonblocking() rather than
// g_input_stream_read() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//
// The function returns the following values:
//
//   - source: new #GSource.
func (stream *PollableInputStream) CreateSource(ctx context.Context) *glib.Source {
	var _arg0 *C.GPollableInputStream // out
	var _arg1 *C.GCancellable         // out
	var _cret *C.GSource              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_pollable_input_stream_create_source(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// IsReadable checks if stream can be read.
//
// Note that some stream types may not be able to implement this 100% reliably,
// and it is possible that a call to g_input_stream_read() after this returns
// TRUE would still block. To guarantee non-blocking behavior, you should
// always use g_pollable_input_stream_read_nonblocking(), which will return a
// G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns FALSE for stream.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is readable, FALSE if not. If an error has occurred
//     on stream, this will result in g_pollable_input_stream_is_readable()
//     returning TRUE, and the next attempt to read will return the error.
func (stream *PollableInputStream) IsReadable() bool {
	var _arg0 *C.GPollableInputStream // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_pollable_input_stream_is_readable(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReadNonblocking attempts to read up to count bytes from stream into buffer,
// as with g_input_stream_read(). If stream is not currently readable,
// this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can use
// g_pollable_input_stream_create_source() to create a #GSource that will be
// triggered when stream is readable.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - buffer: a buffer to read data into (which should be at least count bytes
//     long).
//
// The function returns the following values:
//
//   - gssize: number of bytes read, or -1 on error (including
//     G_IO_ERROR_WOULD_BLOCK).
func (stream *PollableInputStream) ReadNonblocking(ctx context.Context, buffer []byte) (int, error) {
	var _arg0 *C.GPollableInputStream // out
	var _arg3 *C.GCancellable         // out
	var _arg1 *C.void                 // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C.g_pollable_input_stream_read_nonblocking(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// canPoll checks if stream is actually pollable. Some classes may implement
// InputStream but have only certain instances of that class be pollable.
// If this method returns FALSE, then the behavior of other InputStream methods
// is undefined.
//
// For any given stream, the value returned by this method is constant; a stream
// cannot switch from pollable to non-pollable or vice versa.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is pollable, FALSE if not.
func (stream *PollableInputStream) canPoll() bool {
	gclass := (*C.GPollableInputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.can_poll

	var _arg0 *C.GPollableInputStream // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_PollableInputStream_virtual_can_poll(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// createSource creates a #GSource that triggers when stream can be read,
// or cancellable is triggered or an error occurs. The callback on the source is
// of the SourceFunc type.
//
// As with g_pollable_input_stream_is_readable(), it is possible that the
// stream may not actually be readable even after the source triggers,
// so you should use g_pollable_input_stream_read_nonblocking() rather than
// g_input_stream_read() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//
// The function returns the following values:
//
//   - source: new #GSource.
func (stream *PollableInputStream) createSource(ctx context.Context) *glib.Source {
	gclass := (*C.GPollableInputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.create_source

	var _arg0 *C.GPollableInputStream // out
	var _arg1 *C.GCancellable         // out
	var _cret *C.GSource              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_PollableInputStream_virtual_create_source(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// isReadable checks if stream can be read.
//
// Note that some stream types may not be able to implement this 100% reliably,
// and it is possible that a call to g_input_stream_read() after this returns
// TRUE would still block. To guarantee non-blocking behavior, you should
// always use g_pollable_input_stream_read_nonblocking(), which will return a
// G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns FALSE for stream.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is readable, FALSE if not. If an error has occurred
//     on stream, this will result in g_pollable_input_stream_is_readable()
//     returning TRUE, and the next attempt to read will return the error.
func (stream *PollableInputStream) isReadable() bool {
	gclass := (*C.GPollableInputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.is_readable

	var _arg0 *C.GPollableInputStream // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_PollableInputStream_virtual_is_readable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// readNonblocking attempts to read up to count bytes from stream into buffer,
// as with g_input_stream_read(). If stream is not currently readable,
// this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can use
// g_pollable_input_stream_create_source() to create a #GSource that will be
// triggered when stream is readable.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - buffer (optional): a buffer to read data into (which should be at least
//     count bytes long).
//
// The function returns the following values:
//
//   - gssize: number of bytes read, or -1 on error (including
//     G_IO_ERROR_WOULD_BLOCK).
func (stream *PollableInputStream) readNonblocking(buffer []byte) (int, error) {
	gclass := (*C.GPollableInputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.read_nonblocking

	var _arg0 *C.GPollableInputStream // out
	var _arg1 *C.void                 // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GPollableInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C._gotk4_gio2_PollableInputStream_virtual_read_nonblocking(unsafe.Pointer(fnarg), _arg0, unsafe.Pointer(_arg1), _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// PollableOutputStream: GPollableOutputStream is implemented by
// gio.OutputStreams that can be polled for readiness to write. This can be used
// when interfacing with a non-GIO API that expects UNIX-file-descriptor-style
// asynchronous I/O rather than GIO-style.
//
// Some classes may implement GPollableOutputStream but have only certain
// instances of that class be pollable. If gio.PollableOutputStream.CanPoll()
// returns false, then the behavior of other GPollableOutputStream methods is
// undefined.
//
// PollableOutputStream wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PollableOutputStream struct {
	_ [0]func() // equal guard
	OutputStream
}

var (
	_ OutputStreamer = (*PollableOutputStream)(nil)
)

// PollableOutputStreamer describes PollableOutputStream's interface methods.
type PollableOutputStreamer interface {
	coreglib.Objector

	// CanPoll checks if stream is actually pollable.
	CanPoll() bool
	// CreateSource creates a #GSource that triggers when stream can be written,
	// or cancellable is triggered or an error occurs.
	CreateSource(ctx context.Context) *glib.Source
	// IsWritable checks if stream can be written.
	IsWritable() bool
	// WriteNonblocking attempts to write up to count bytes from buffer to
	// stream, as with g_output_stream_write().
	WriteNonblocking(ctx context.Context, buffer []byte) (int, error)
	// WritevNonblocking attempts to write the bytes contained in the n_vectors
	// vectors to stream, as with g_output_stream_writev().
	WritevNonblocking(ctx context.Context, vectors []OutputVector) (uint, PollableReturn, error)
}

var _ PollableOutputStreamer = (*PollableOutputStream)(nil)

func wrapPollableOutputStream(obj *coreglib.Object) *PollableOutputStream {
	return &PollableOutputStream{
		OutputStream: OutputStream{
			Object: obj,
		},
	}
}

func marshalPollableOutputStream(p uintptr) (interface{}, error) {
	return wrapPollableOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CanPoll checks if stream is actually pollable. Some classes may implement
// OutputStream but have only certain instances of that class be pollable.
// If this method returns FALSE, then the behavior of other OutputStream methods
// is undefined.
//
// For any given stream, the value returned by this method is constant; a stream
// cannot switch from pollable to non-pollable or vice versa.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is pollable, FALSE if not.
func (stream *PollableOutputStream) CanPoll() bool {
	var _arg0 *C.GPollableOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_pollable_output_stream_can_poll(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateSource creates a #GSource that triggers when stream can be written,
// or cancellable is triggered or an error occurs. The callback on the source is
// of the SourceFunc type.
//
// As with g_pollable_output_stream_is_writable(), it is possible that the
// stream may not actually be writable even after the source triggers,
// so you should use g_pollable_output_stream_write_nonblocking() rather than
// g_output_stream_write() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//
// The function returns the following values:
//
//   - source: new #GSource.
func (stream *PollableOutputStream) CreateSource(ctx context.Context) *glib.Source {
	var _arg0 *C.GPollableOutputStream // out
	var _arg1 *C.GCancellable          // out
	var _cret *C.GSource               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_pollable_output_stream_create_source(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// IsWritable checks if stream can be written.
//
// Note that some stream types may not be able to implement this 100% reliably,
// and it is possible that a call to g_output_stream_write() after this returns
// TRUE would still block. To guarantee non-blocking behavior, you should
// always use g_pollable_output_stream_write_nonblocking(), which will return a
// G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is writable, FALSE if not. If an error has occurred
//     on stream, this will result in g_pollable_output_stream_is_writable()
//     returning TRUE, and the next attempt to write will return the error.
func (stream *PollableOutputStream) IsWritable() bool {
	var _arg0 *C.GPollableOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_pollable_output_stream_is_writable(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WriteNonblocking attempts to write up to count bytes from buffer to stream,
// as with g_output_stream_write(). If stream is not currently writable,
// this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can use
// g_pollable_output_stream_create_source() to create a #GSource that will be
// triggered when stream is writable.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same buffer and count in
// the next write call.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - buffer to write data from.
//
// The function returns the following values:
//
//   - gssize: number of bytes written, or -1 on error (including
//     G_IO_ERROR_WOULD_BLOCK).
func (stream *PollableOutputStream) WriteNonblocking(ctx context.Context, buffer []byte) (int, error) {
	var _arg0 *C.GPollableOutputStream // out
	var _arg3 *C.GCancellable          // out
	var _arg1 *C.void                  // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C.g_pollable_output_stream_write_nonblocking(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// WritevNonblocking attempts to write the bytes contained in the
// n_vectors vectors to stream, as with g_output_stream_writev().
// If stream is not currently writable, this will immediately
// return G_POLLABLE_RETURN_WOULD_BLOCK, and you can use
// g_pollable_output_stream_create_source() to create a #GSource that will be
// triggered when stream is writable. error will *not* be set in that case.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// Also note that if G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same vectors and n_vectors
// in the next write call.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
//   - pollableReturn: G_POLLABLE_RETURN_OK on success,
//     G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable
//     (and error is *not* set), or G_POLLABLE_RETURN_FAILED if there was an
//     error in which case error will be set.
func (stream *PollableOutputStream) WritevNonblocking(ctx context.Context, vectors []OutputVector) (uint, PollableReturn, error) {
	var _arg0 *C.GPollableOutputStream // out
	var _arg4 *C.GCancellable          // out
	var _arg1 *C.GOutputVector         // out
	var _arg2 C.gsize
	var _arg3 C.gsize           // in
	var _cret C.GPollableReturn // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	_cret = C.g_pollable_output_stream_writev_nonblocking(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint             // out
	var _pollableReturn PollableReturn // out
	var _goerr error                   // out

	_bytesWritten = uint(_arg3)
	_pollableReturn = PollableReturn(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _pollableReturn, _goerr
}

// canPoll checks if stream is actually pollable. Some classes may implement
// OutputStream but have only certain instances of that class be pollable.
// If this method returns FALSE, then the behavior of other OutputStream methods
// is undefined.
//
// For any given stream, the value returned by this method is constant; a stream
// cannot switch from pollable to non-pollable or vice versa.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is pollable, FALSE if not.
func (stream *PollableOutputStream) canPoll() bool {
	gclass := (*C.GPollableOutputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.can_poll

	var _arg0 *C.GPollableOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_PollableOutputStream_virtual_can_poll(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// createSource creates a #GSource that triggers when stream can be written,
// or cancellable is triggered or an error occurs. The callback on the source is
// of the SourceFunc type.
//
// As with g_pollable_output_stream_is_writable(), it is possible that the
// stream may not actually be writable even after the source triggers,
// so you should use g_pollable_output_stream_write_nonblocking() rather than
// g_output_stream_write() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//
// The function returns the following values:
//
//   - source: new #GSource.
func (stream *PollableOutputStream) createSource(ctx context.Context) *glib.Source {
	gclass := (*C.GPollableOutputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.create_source

	var _arg0 *C.GPollableOutputStream // out
	var _arg1 *C.GCancellable          // out
	var _cret *C.GSource               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_PollableOutputStream_virtual_create_source(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// isWritable checks if stream can be written.
//
// Note that some stream types may not be able to implement this 100% reliably,
// and it is possible that a call to g_output_stream_write() after this returns
// TRUE would still block. To guarantee non-blocking behavior, you should
// always use g_pollable_output_stream_write_nonblocking(), which will return a
// G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is writable, FALSE if not. If an error has occurred
//     on stream, this will result in g_pollable_output_stream_is_writable()
//     returning TRUE, and the next attempt to write will return the error.
func (stream *PollableOutputStream) isWritable() bool {
	gclass := (*C.GPollableOutputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.is_writable

	var _arg0 *C.GPollableOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_PollableOutputStream_virtual_is_writable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// writeNonblocking attempts to write up to count bytes from buffer to stream,
// as with g_output_stream_write(). If stream is not currently writable,
// this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can use
// g_pollable_output_stream_create_source() to create a #GSource that will be
// triggered when stream is writable.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same buffer and count in
// the next write call.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - buffer (optional) to write data from.
//
// The function returns the following values:
//
//   - gssize: number of bytes written, or -1 on error (including
//     G_IO_ERROR_WOULD_BLOCK).
func (stream *PollableOutputStream) writeNonblocking(buffer []byte) (int, error) {
	gclass := (*C.GPollableOutputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.write_nonblocking

	var _arg0 *C.GPollableOutputStream // out
	var _arg1 *C.void                  // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C._gotk4_gio2_PollableOutputStream_virtual_write_nonblocking(unsafe.Pointer(fnarg), _arg0, unsafe.Pointer(_arg1), _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// writevNonblocking attempts to write the bytes contained in the
// n_vectors vectors to stream, as with g_output_stream_writev().
// If stream is not currently writable, this will immediately
// return G_POLLABLE_RETURN_WOULD_BLOCK, and you can use
// g_pollable_output_stream_create_source() to create a #GSource that will be
// triggered when stream is writable. error will *not* be set in that case.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// Also note that if G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same vectors and n_vectors
// in the next write call.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns FALSE for stream.
//
// The function takes the following parameters:
//
//   - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
//   - pollableReturn: G_POLLABLE_RETURN_OK on success,
//     G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable
//     (and error is *not* set), or G_POLLABLE_RETURN_FAILED if there was an
//     error in which case error will be set.
func (stream *PollableOutputStream) writevNonblocking(vectors []OutputVector) (uint, PollableReturn, error) {
	gclass := (*C.GPollableOutputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.writev_nonblocking

	var _arg0 *C.GPollableOutputStream // out
	var _arg1 *C.GOutputVector         // out
	var _arg2 C.gsize
	var _arg3 C.gsize           // in
	var _cret C.GPollableReturn // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	_cret = C._gotk4_gio2_PollableOutputStream_virtual_writev_nonblocking(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint             // out
	var _pollableReturn PollableReturn // out
	var _goerr error                   // out

	_bytesWritten = uint(_arg3)
	_pollableReturn = PollableReturn(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _pollableReturn, _goerr
}

// PowerProfileMonitorOverrider contains methods that are overridable.
type PowerProfileMonitorOverrider interface {
}

// PowerProfileMonitor: GPowerProfileMonitor makes it possible for applications
// as well as OS components to monitor system power profiles and act upon them.
// It currently only exports whether the system is in Power Saver mode (known
// as Low Power mode on some systems).
//
// When in Low Power mode, it is recommended that applications:
//
// - disable automatic downloads;
//
// - reduce the rate of refresh from online sources such as calendar or email
// synchronisation;
//
// - reduce the use of expensive visual effects.
//
// It is also likely that OS components providing services to applications will
// lower their own background activity, for the sake of the system.
//
// There are a variety of tools that exist for power consumption analysis,
// but those usually depend on the OS and hardware used. On Linux, one could
// use upower to monitor the battery discharge rate, powertop to check on the
// background activity or activity at all), sysprof to inspect CPU usage,
// and intel_gpu_time to profile GPU usage.
//
// Dont forget to disconnect the gobject.Object::notify signal
// for gio.PowerProfileMonitor:power-saver-enabled, and unref the
// GPowerProfileMonitor itself when exiting.
//
// PowerProfileMonitor wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PowerProfileMonitor struct {
	_ [0]func() // equal guard
	Initable
}

var ()

// PowerProfileMonitorrer describes PowerProfileMonitor's interface methods.
type PowerProfileMonitorrer interface {
	coreglib.Objector

	// PowerSaverEnabled gets whether the system is in Power Saver mode.
	PowerSaverEnabled() bool
}

var _ PowerProfileMonitorrer = (*PowerProfileMonitor)(nil)

func ifaceInitPowerProfileMonitorrer(gifacePtr, data C.gpointer) {
}

func wrapPowerProfileMonitor(obj *coreglib.Object) *PowerProfileMonitor {
	return &PowerProfileMonitor{
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalPowerProfileMonitor(p uintptr) (interface{}, error) {
	return wrapPowerProfileMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// PowerSaverEnabled gets whether the system is in Power Saver mode.
//
// You are expected to listen to the ProfileMonitor::notify::power-saver-enabled
// signal to know when the profile has changed.
//
// The function returns the following values:
//
//   - ok: whether the system is in Power Saver mode.
func (monitor *PowerProfileMonitor) PowerSaverEnabled() bool {
	var _arg0 *C.GPowerProfileMonitor // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GPowerProfileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_power_profile_monitor_get_power_saver_enabled(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PowerProfileMonitorDupDefault gets a reference to the default ProfileMonitor
// for the system.
//
// The function returns the following values:
//
//   - powerProfileMonitor: new reference to the default ProfileMonitor.
func PowerProfileMonitorDupDefault() *PowerProfileMonitor {
	var _cret *C.GPowerProfileMonitor // in

	_cret = C.g_power_profile_monitor_dup_default()

	var _powerProfileMonitor *PowerProfileMonitor // out

	_powerProfileMonitor = wrapPowerProfileMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _powerProfileMonitor
}

// Proxy: GProxy handles connecting to a remote host via a given type of proxy
// server. It is implemented by the gio-proxy extension point. The extensions
// are named after their proxy protocol name. As an example, a SOCKS5 proxy
// implementation can be retrieved with the name socks5 using the function
// gio.IOExtensionPoint.GetExtensionByName().
//
// Proxy wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Proxy struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Proxy)(nil)
)

// Proxier describes Proxy's interface methods.
type Proxier interface {
	coreglib.Objector

	// ConnectProxy: given connection to communicate with a proxy (eg,
	// a Connection that is connected to the proxy server), this does the
	// necessary handshake to connect to proxy_address, and if required,
	// wraps the OStream to handle proxy payload.
	ConnectProxy(ctx context.Context, connection IOStreamer, proxyAddress *ProxyAddress) (IOStreamer, error)
	// ConnectAsync asynchronous version of g_proxy_connect().
	ConnectAsync(ctx context.Context, connection IOStreamer, proxyAddress *ProxyAddress, callback AsyncReadyCallback)
	// ConnectFinish: see g_proxy_connect().
	ConnectFinish(result AsyncResulter) (IOStreamer, error)
	// SupportsHostname: some proxy protocols expect to be passed a hostname,
	// which they will resolve to an IP address themselves.
	SupportsHostname() bool
}

var _ Proxier = (*Proxy)(nil)

func wrapProxy(obj *coreglib.Object) *Proxy {
	return &Proxy{
		Object: obj,
	}
}

func marshalProxy(p uintptr) (interface{}, error) {
	return wrapProxy(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectProxy: given connection to communicate with a proxy (eg, a Connection
// that is connected to the proxy server), this does the necessary handshake to
// connect to proxy_address, and if required, wraps the OStream to handle proxy
// payload.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - connection: OStream.
//   - proxyAddress: Address.
//
// The function returns the following values:
//
//   - ioStream that will replace connection. This might be the same as
//     connection, in which case a reference will be added.
func (proxy *Proxy) ConnectProxy(ctx context.Context, connection IOStreamer, proxyAddress *ProxyAddress) (IOStreamer, error) {
	var _arg0 *C.GProxy        // out
	var _arg3 *C.GCancellable  // out
	var _arg1 *C.GIOStream     // out
	var _arg2 *C.GProxyAddress // out
	var _cret *C.GIOStream     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxyAddress).Native()))

	_cret = C.g_proxy_connect(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)

	var _ioStream IOStreamer // out
	var _goerr error         // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStream, _goerr
}

// ConnectAsync asynchronous version of g_proxy_connect().
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - connection: OStream.
//   - proxyAddress: Address.
//   - callback (optional): ReadyCallback.
func (proxy *Proxy) ConnectAsync(ctx context.Context, connection IOStreamer, proxyAddress *ProxyAddress, callback AsyncReadyCallback) {
	var _arg0 *C.GProxy             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GIOStream          // out
	var _arg2 *C.GProxyAddress      // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxyAddress).Native()))
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_proxy_connect_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)
	runtime.KeepAlive(callback)
}

// ConnectFinish: see g_proxy_connect().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - ioStream: OStream.
func (proxy *Proxy) ConnectFinish(result AsyncResulter) (IOStreamer, error) {
	var _arg0 *C.GProxy       // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_proxy_connect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(result)

	var _ioStream IOStreamer // out
	var _goerr error         // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStream, _goerr
}

// SupportsHostname: some proxy protocols expect to be passed a hostname,
// which they will resolve to an IP address themselves. Others, like SOCKS4, do
// not allow this. This function will return FALSE if proxy is implementing such
// a protocol. When FALSE is returned, the caller should resolve the destination
// hostname first, and then pass a Address containing the stringified IP address
// to g_proxy_connect() or g_proxy_connect_async().
//
// The function returns the following values:
//
//   - ok: TRUE if hostname resolution is supported.
func (proxy *Proxy) SupportsHostname() bool {
	var _arg0 *C.GProxy  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_supports_hostname(_arg0)
	runtime.KeepAlive(proxy)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// connectProxy: given connection to communicate with a proxy (eg, a Connection
// that is connected to the proxy server), this does the necessary handshake to
// connect to proxy_address, and if required, wraps the OStream to handle proxy
// payload.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - connection: OStream.
//   - proxyAddress: Address.
//
// The function returns the following values:
//
//   - ioStream that will replace connection. This might be the same as
//     connection, in which case a reference will be added.
func (proxy *Proxy) connectProxy(ctx context.Context, connection IOStreamer, proxyAddress *ProxyAddress) (IOStreamer, error) {
	gclass := (*C.GProxyInterface)(coreglib.PeekParentClass(proxy))
	fnarg := gclass.connect

	var _arg0 *C.GProxy        // out
	var _arg3 *C.GCancellable  // out
	var _arg1 *C.GIOStream     // out
	var _arg2 *C.GProxyAddress // out
	var _cret *C.GIOStream     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxyAddress).Native()))

	_cret = C._gotk4_gio2_Proxy_virtual_connect(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)

	var _ioStream IOStreamer // out
	var _goerr error         // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStream, _goerr
}

// connectAsync asynchronous version of g_proxy_connect().
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - connection: OStream.
//   - proxyAddress: Address.
//   - callback (optional): ReadyCallback.
func (proxy *Proxy) connectAsync(ctx context.Context, connection IOStreamer, proxyAddress *ProxyAddress, callback AsyncReadyCallback) {
	gclass := (*C.GProxyInterface)(coreglib.PeekParentClass(proxy))
	fnarg := gclass.connect_async

	var _arg0 *C.GProxy             // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GIOStream          // out
	var _arg2 *C.GProxyAddress      // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxyAddress).Native()))
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Proxy_virtual_connect_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)
	runtime.KeepAlive(callback)
}

// connectFinish: see g_proxy_connect().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - ioStream: OStream.
func (proxy *Proxy) connectFinish(result AsyncResulter) (IOStreamer, error) {
	gclass := (*C.GProxyInterface)(coreglib.PeekParentClass(proxy))
	fnarg := gclass.connect_finish

	var _arg0 *C.GProxy       // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Proxy_virtual_connect_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(result)

	var _ioStream IOStreamer // out
	var _goerr error         // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStream, _goerr
}

// supportsHostname: some proxy protocols expect to be passed a hostname,
// which they will resolve to an IP address themselves. Others, like SOCKS4, do
// not allow this. This function will return FALSE if proxy is implementing such
// a protocol. When FALSE is returned, the caller should resolve the destination
// hostname first, and then pass a Address containing the stringified IP address
// to g_proxy_connect() or g_proxy_connect_async().
//
// The function returns the following values:
//
//   - ok: TRUE if hostname resolution is supported.
func (proxy *Proxy) supportsHostname() bool {
	gclass := (*C.GProxyInterface)(coreglib.PeekParentClass(proxy))
	fnarg := gclass.supports_hostname

	var _arg0 *C.GProxy  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C._gotk4_gio2_Proxy_virtual_supports_hostname(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(proxy)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyGetDefaultForProtocol: find the gio-proxy extension point for a proxy
// implementation that supports the specified protocol.
//
// The function takes the following parameters:
//
//   - protocol: proxy protocol name (e.g. http, socks, etc).
//
// The function returns the following values:
//
//   - proxy (optional): return a #GProxy or NULL if protocol is not supported.
func ProxyGetDefaultForProtocol(protocol string) *Proxy {
	var _arg1 *C.gchar  // out
	var _cret *C.GProxy // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_proxy_get_default_for_protocol(_arg1)
	runtime.KeepAlive(protocol)

	var _proxy *Proxy // out

	if _cret != nil {
		_proxy = wrapProxy(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _proxy
}

// ProxyResolver: GProxyResolver provides synchronous and asynchronous network
// proxy resolution. GProxyResolver is used within gio.SocketClient through the
// method gio.SocketConnectable.ProxyEnumerate().
//
// Implementations of GProxyResolver based on libproxy
// (https://github.com/libproxy/libproxy) and GNOME settings can be found in
// glib-networking (https://gitlab.gnome.org/GNOME/glib-networking). GIO comes
// with an implementation for use inside Flatpak portals.
//
// ProxyResolver wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ProxyResolver struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ProxyResolver)(nil)
)

// ProxyResolverer describes ProxyResolver's interface methods.
type ProxyResolverer interface {
	coreglib.Objector

	// IsSupported checks if resolver can be used on this system.
	IsSupported() bool
	// Lookup looks into the system proxy configuration to determine what proxy,
	// if any, to use to connect to uri.
	Lookup(ctx context.Context, uri string) ([]string, error)
	// LookupAsync asynchronous lookup of proxy.
	LookupAsync(ctx context.Context, uri string, callback AsyncReadyCallback)
	// LookupFinish: call this function to obtain the array of proxy URIs when
	// g_proxy_resolver_lookup_async() is complete.
	LookupFinish(result AsyncResulter) ([]string, error)
}

var _ ProxyResolverer = (*ProxyResolver)(nil)

func wrapProxyResolver(obj *coreglib.Object) *ProxyResolver {
	return &ProxyResolver{
		Object: obj,
	}
}

func marshalProxyResolver(p uintptr) (interface{}, error) {
	return wrapProxyResolver(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// IsSupported checks if resolver can be used on this system. (This is used
// internally; g_proxy_resolver_get_default() will only return a proxy resolver
// that returns TRUE for this method.).
//
// The function returns the following values:
//
//   - ok: TRUE if resolver is supported.
func (resolver *ProxyResolver) IsSupported() bool {
	var _arg0 *C.GProxyResolver // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))

	_cret = C.g_proxy_resolver_is_supported(_arg0)
	runtime.KeepAlive(resolver)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lookup looks into the system proxy configuration to determine what proxy,
// if any, to use to connect to uri. The returned proxy URIs are of the form
// <protocol>://[user[:password]@]host[:port] or direct://, where <protocol>
// could be http, rtsp, socks or other proxying protocol.
//
// If you don't know what network protocol is being used on the socket,
// you should use none as the URI protocol. In this case, the resolver might
// still return a generic proxy type (such as SOCKS), but would not return
// protocol-specific proxy types (such as http).
//
// direct:// is used when no proxy is needed. Direct connection should not be
// attempted unless it is part of the returned array of proxies.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - uri: URI representing the destination to connect to.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated array of proxy URIs. Must be freed with
//     g_strfreev().
func (resolver *ProxyResolver) Lookup(ctx context.Context, uri string) ([]string, error) {
	var _arg0 *C.GProxyResolver // out
	var _arg2 *C.GCancellable   // out
	var _arg1 *C.gchar          // out
	var _cret **C.gchar         // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_proxy_resolver_lookup(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// LookupAsync asynchronous lookup of proxy. See g_proxy_resolver_lookup() for
// more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - uri: URI representing the destination to connect to.
//   - callback (optional) to call after resolution completes.
func (resolver *ProxyResolver) LookupAsync(ctx context.Context, uri string, callback AsyncReadyCallback) {
	var _arg0 *C.GProxyResolver     // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_proxy_resolver_lookup_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(callback)
}

// LookupFinish: call this function to obtain the array of proxy URIs when
// g_proxy_resolver_lookup_async() is complete. See g_proxy_resolver_lookup()
// for more details.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated array of proxy URIs. Must be freed with
//     g_strfreev().
func (resolver *ProxyResolver) LookupFinish(result AsyncResulter) ([]string, error) {
	var _arg0 *C.GProxyResolver // out
	var _arg1 *C.GAsyncResult   // out
	var _cret **C.gchar         // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_proxy_resolver_lookup_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// isSupported checks if resolver can be used on this system. (This is used
// internally; g_proxy_resolver_get_default() will only return a proxy resolver
// that returns TRUE for this method.).
//
// The function returns the following values:
//
//   - ok: TRUE if resolver is supported.
func (resolver *ProxyResolver) isSupported() bool {
	gclass := (*C.GProxyResolverInterface)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.is_supported

	var _arg0 *C.GProxyResolver // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))

	_cret = C._gotk4_gio2_ProxyResolver_virtual_is_supported(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(resolver)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lookup looks into the system proxy configuration to determine what proxy,
// if any, to use to connect to uri. The returned proxy URIs are of the form
// <protocol>://[user[:password]@]host[:port] or direct://, where <protocol>
// could be http, rtsp, socks or other proxying protocol.
//
// If you don't know what network protocol is being used on the socket,
// you should use none as the URI protocol. In this case, the resolver might
// still return a generic proxy type (such as SOCKS), but would not return
// protocol-specific proxy types (such as http).
//
// direct:// is used when no proxy is needed. Direct connection should not be
// attempted unless it is part of the returned array of proxies.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - uri: URI representing the destination to connect to.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated array of proxy URIs. Must be freed with
//     g_strfreev().
func (resolver *ProxyResolver) lookup(ctx context.Context, uri string) ([]string, error) {
	gclass := (*C.GProxyResolverInterface)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup

	var _arg0 *C.GProxyResolver // out
	var _arg2 *C.GCancellable   // out
	var _arg1 *C.gchar          // out
	var _cret **C.gchar         // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_ProxyResolver_virtual_lookup(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// lookupAsync asynchronous lookup of proxy. See g_proxy_resolver_lookup() for
// more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - uri: URI representing the destination to connect to.
//   - callback (optional) to call after resolution completes.
func (resolver *ProxyResolver) lookupAsync(ctx context.Context, uri string, callback AsyncReadyCallback) {
	gclass := (*C.GProxyResolverInterface)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_async

	var _arg0 *C.GProxyResolver     // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_ProxyResolver_virtual_lookup_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(callback)
}

// lookupFinish: call this function to obtain the array of proxy URIs when
// g_proxy_resolver_lookup_async() is complete. See g_proxy_resolver_lookup()
// for more details.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated array of proxy URIs. Must be freed with
//     g_strfreev().
func (resolver *ProxyResolver) lookupFinish(result AsyncResulter) ([]string, error) {
	gclass := (*C.GProxyResolverInterface)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_finish

	var _arg0 *C.GProxyResolver // out
	var _arg1 *C.GAsyncResult   // out
	var _cret **C.gchar         // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_ProxyResolver_virtual_lookup_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// ProxyResolverGetDefault gets the default Resolver for the system.
//
// The function returns the following values:
//
//   - proxyResolver: default Resolver, which will be a dummy object if no proxy
//     resolver is available.
func ProxyResolverGetDefault() *ProxyResolver {
	var _cret *C.GProxyResolver // in

	_cret = C.g_proxy_resolver_get_default()

	var _proxyResolver *ProxyResolver // out

	_proxyResolver = wrapProxyResolver(coreglib.Take(unsafe.Pointer(_cret)))

	return _proxyResolver
}

// RemoteActionGroup: GRemoteActionGroup interface is implemented by
// gio.ActionGroup instances that either transmit action invocations to other
// processes or receive action invocations in the local process from other
// processes.
//
// The interface has _full variants of the two methods on gio.ActionGroup
// used to activate actions: gio.ActionGroup.ActivateAction() and
// gio.ActionGroup.ChangeActionState(). These variants allow a platform data
// glib.Variant to be specified: a dictionary providing context for the action
// invocation (for example: timestamps, startup notification IDs, etc).
//
// gio.DBusActionGroup implements GRemoteActionGroup. This provides a mechanism
// to send platform data for action invocations over D-Bus.
//
// Additionally, gio.DBusConnection.ExportActionGroup() will check if the
// exported gio.ActionGroup implements GRemoteActionGroup and use the _full
// variants of the calls if available. This provides a mechanism by which to
// receive platform data for action invocations that arrive by way of D-Bus.
//
// RemoteActionGroup wraps an interface. This means the user can get the
// underlying type by calling Cast().
type RemoteActionGroup struct {
	_ [0]func() // equal guard
	ActionGroup
}

var ()

// RemoteActionGrouper describes RemoteActionGroup's interface methods.
type RemoteActionGrouper interface {
	coreglib.Objector

	// ActivateActionFull activates the remote action.
	ActivateActionFull(actionName string, parameter, platformData *glib.Variant)
	// ChangeActionStateFull changes the state of a remote action.
	ChangeActionStateFull(actionName string, value, platformData *glib.Variant)
}

var _ RemoteActionGrouper = (*RemoteActionGroup)(nil)

func wrapRemoteActionGroup(obj *coreglib.Object) *RemoteActionGroup {
	return &RemoteActionGroup{
		ActionGroup: ActionGroup{
			Object: obj,
		},
	}
}

func marshalRemoteActionGroup(p uintptr) (interface{}, error) {
	return wrapRemoteActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ActivateActionFull activates the remote action.
//
// This is the same as g_action_group_activate_action() except that it allows
// for provision of "platform data" to be sent along with the activation
// request. This typically contains details such as the user interaction
// timestamp or startup notification information.
//
// platform_data must be non-NULL and must have the type G_VARIANT_TYPE_VARDICT.
// If it is floating, it will be consumed.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to activate.
//   - parameter (optional): optional parameter to the activation.
//   - platformData: platform data to send.
func (remote *RemoteActionGroup) ActivateActionFull(actionName string, parameter, platformData *glib.Variant) {
	var _arg0 *C.GRemoteActionGroup // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 *C.GVariant           // out

	_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(coreglib.InternObject(remote).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameter != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C.g_remote_action_group_activate_action_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(remote)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(parameter)
	runtime.KeepAlive(platformData)
}

// ChangeActionStateFull changes the state of a remote action.
//
// This is the same as g_action_group_change_action_state() except that it
// allows for provision of "platform data" to be sent along with the state
// change request. This typically contains details such as the user interaction
// timestamp or startup notification information.
//
// platform_data must be non-NULL and must have the type G_VARIANT_TYPE_VARDICT.
// If it is floating, it will be consumed.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to change the state of.
//   - value: new requested value for the state.
//   - platformData: platform data to send.
func (remote *RemoteActionGroup) ChangeActionStateFull(actionName string, value, platformData *glib.Variant) {
	var _arg0 *C.GRemoteActionGroup // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 *C.GVariant           // out

	_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(coreglib.InternObject(remote).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C.g_remote_action_group_change_action_state_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(remote)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(value)
	runtime.KeepAlive(platformData)
}

// activateActionFull activates the remote action.
//
// This is the same as g_action_group_activate_action() except that it allows
// for provision of "platform data" to be sent along with the activation
// request. This typically contains details such as the user interaction
// timestamp or startup notification information.
//
// platform_data must be non-NULL and must have the type G_VARIANT_TYPE_VARDICT.
// If it is floating, it will be consumed.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to activate.
//   - parameter (optional): optional parameter to the activation.
//   - platformData: platform data to send.
func (remote *RemoteActionGroup) activateActionFull(actionName string, parameter, platformData *glib.Variant) {
	gclass := (*C.GRemoteActionGroupInterface)(coreglib.PeekParentClass(remote))
	fnarg := gclass.activate_action_full

	var _arg0 *C.GRemoteActionGroup // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 *C.GVariant           // out

	_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(coreglib.InternObject(remote).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameter != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_RemoteActionGroup_virtual_activate_action_full(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(remote)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(parameter)
	runtime.KeepAlive(platformData)
}

// changeActionStateFull changes the state of a remote action.
//
// This is the same as g_action_group_change_action_state() except that it
// allows for provision of "platform data" to be sent along with the state
// change request. This typically contains details such as the user interaction
// timestamp or startup notification information.
//
// platform_data must be non-NULL and must have the type G_VARIANT_TYPE_VARDICT.
// If it is floating, it will be consumed.
//
// The function takes the following parameters:
//
//   - actionName: name of the action to change the state of.
//   - value: new requested value for the state.
//   - platformData: platform data to send.
func (remote *RemoteActionGroup) changeActionStateFull(actionName string, value, platformData *glib.Variant) {
	gclass := (*C.GRemoteActionGroupInterface)(coreglib.PeekParentClass(remote))
	fnarg := gclass.change_action_state_full

	var _arg0 *C.GRemoteActionGroup // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 *C.GVariant           // out

	_arg0 = (*C.GRemoteActionGroup)(unsafe.Pointer(coreglib.InternObject(remote).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_RemoteActionGroup_virtual_change_action_state_full(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(remote)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(value)
	runtime.KeepAlive(platformData)
}

// Seekable: GSeekable is implemented by streams (implementations of
// gio.InputStream or gio.OutputStream) that support seeking.
//
// Seekable streams largely fall into two categories: resizable and fixed-size.
//
// GSeekable on fixed-sized streams is approximately the same as POSIX lseek()
// (man:lseek(2)) on a block device (for example: attempting to seek past the
// end of the device is an error). Fixed streams typically cannot be truncated.
//
// GSeekable on resizable streams is approximately the same as POSIX lseek()
// (man:lseek(2)) on a normal file. Seeking past the end and writing data will
// usually cause the stream to resize by introducing zero bytes.
//
// Seekable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Seekable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Seekable)(nil)
)

// Seekabler describes Seekable's interface methods.
type Seekabler interface {
	coreglib.Objector

	// CanSeek tests if the stream supports the Iface.
	CanSeek() bool
	// CanTruncate tests if the length of the stream can be adjusted with
	// g_seekable_truncate().
	CanTruncate() bool
	// Seek seeks in the stream by the given offset, modified by type.
	Seek(ctx context.Context, offset int64, typ glib.SeekType) error
	// Tell tells the current position within the stream.
	Tell() int64
	// Truncate sets the length of the stream to offset.
	Truncate(ctx context.Context, offset int64) error
}

var _ Seekabler = (*Seekable)(nil)

func wrapSeekable(obj *coreglib.Object) *Seekable {
	return &Seekable{
		Object: obj,
	}
}

func marshalSeekable(p uintptr) (interface{}, error) {
	return wrapSeekable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CanSeek tests if the stream supports the Iface.
//
// The function returns the following values:
//
//   - ok: TRUE if seekable can be seeked. FALSE otherwise.
func (seekable *Seekable) CanSeek() bool {
	var _arg0 *C.GSeekable // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))

	_cret = C.g_seekable_can_seek(_arg0)
	runtime.KeepAlive(seekable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanTruncate tests if the length of the stream can be adjusted with
// g_seekable_truncate().
//
// The function returns the following values:
//
//   - ok: TRUE if the stream can be truncated, FALSE otherwise.
func (seekable *Seekable) CanTruncate() bool {
	var _arg0 *C.GSeekable // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))

	_cret = C.g_seekable_can_truncate(_arg0)
	runtime.KeepAlive(seekable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Seek seeks in the stream by the given offset, modified by type.
//
// Attempting to seek past the end of the stream will have different results
// depending on if the stream is fixed-sized or resizable. If the stream is
// resizable then seeking past the end and then writing will result in zeros
// filling the empty space. Seeking past the end of a resizable stream and
// reading will result in EOF. Seeking past the end of a fixed-sized stream will
// fail.
//
// Any operation that would result in a negative offset will fail.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - offset: #goffset.
//   - typ: Type.
func (seekable *Seekable) Seek(ctx context.Context, offset int64, typ glib.SeekType) error {
	var _arg0 *C.GSeekable    // out
	var _arg3 *C.GCancellable // out
	var _arg1 C.goffset       // out
	var _arg2 C.GSeekType     // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(offset)
	_arg2 = C.GSeekType(typ)

	C.g_seekable_seek(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Tell tells the current position within the stream.
//
// The function returns the following values:
//
//   - gint64: (positive or zero) offset from the beginning of the buffer,
//     zero if the target is not seekable.
func (seekable *Seekable) Tell() int64 {
	var _arg0 *C.GSeekable // out
	var _cret C.goffset    // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))

	_cret = C.g_seekable_tell(_arg0)
	runtime.KeepAlive(seekable)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Truncate sets the length of the stream to offset. If the stream was
// previously larger than offset, the extra data is discarded. If the stream was
// previously shorter than offset, it is extended with NUL ('\0') bytes.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - offset: new length for seekable, in bytes.
func (seekable *Seekable) Truncate(ctx context.Context, offset int64) error {
	var _arg0 *C.GSeekable    // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.goffset       // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(offset)

	C.g_seekable_truncate(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(offset)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// canSeek tests if the stream supports the Iface.
//
// The function returns the following values:
//
//   - ok: TRUE if seekable can be seeked. FALSE otherwise.
func (seekable *Seekable) canSeek() bool {
	gclass := (*C.GSeekableIface)(coreglib.PeekParentClass(seekable))
	fnarg := gclass.can_seek

	var _arg0 *C.GSeekable // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))

	_cret = C._gotk4_gio2_Seekable_virtual_can_seek(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(seekable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canTruncate tests if the length of the stream can be adjusted with
// g_seekable_truncate().
//
// The function returns the following values:
//
//   - ok: TRUE if the stream can be truncated, FALSE otherwise.
func (seekable *Seekable) canTruncate() bool {
	gclass := (*C.GSeekableIface)(coreglib.PeekParentClass(seekable))
	fnarg := gclass.can_truncate

	var _arg0 *C.GSeekable // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))

	_cret = C._gotk4_gio2_Seekable_virtual_can_truncate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(seekable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Seek seeks in the stream by the given offset, modified by type.
//
// Attempting to seek past the end of the stream will have different results
// depending on if the stream is fixed-sized or resizable. If the stream is
// resizable then seeking past the end and then writing will result in zeros
// filling the empty space. Seeking past the end of a resizable stream and
// reading will result in EOF. Seeking past the end of a fixed-sized stream will
// fail.
//
// Any operation that would result in a negative offset will fail.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - offset: #goffset.
//   - typ: Type.
func (seekable *Seekable) seek(ctx context.Context, offset int64, typ glib.SeekType) error {
	gclass := (*C.GSeekableIface)(coreglib.PeekParentClass(seekable))
	fnarg := gclass.seek

	var _arg0 *C.GSeekable    // out
	var _arg3 *C.GCancellable // out
	var _arg1 C.goffset       // out
	var _arg2 C.GSeekType     // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(offset)
	_arg2 = C.GSeekType(typ)

	C._gotk4_gio2_Seekable_virtual_seek(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Tell tells the current position within the stream.
//
// The function returns the following values:
//
//   - gint64: (positive or zero) offset from the beginning of the buffer,
//     zero if the target is not seekable.
func (seekable *Seekable) tell() int64 {
	gclass := (*C.GSeekableIface)(coreglib.PeekParentClass(seekable))
	fnarg := gclass.tell

	var _arg0 *C.GSeekable // out
	var _cret C.goffset    // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))

	_cret = C._gotk4_gio2_Seekable_virtual_tell(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(seekable)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// truncateFn sets the length of the stream to offset. If the stream was
// previously larger than offset, the extra data is discarded. If the stream was
// previously shorter than offset, it is extended with NUL ('\0') bytes.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - offset: new length for seekable, in bytes.
func (seekable *Seekable) truncateFn(ctx context.Context, offset int64) error {
	gclass := (*C.GSeekableIface)(coreglib.PeekParentClass(seekable))
	fnarg := gclass.truncate_fn

	var _arg0 *C.GSeekable    // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.goffset       // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSeekable)(unsafe.Pointer(coreglib.InternObject(seekable).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(offset)

	C._gotk4_gio2_Seekable_virtual_truncate_fn(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(offset)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SocketConnectable objects that describe one or more potential
// socket endpoints implement GSocketConnectable. Callers can then use
// gio.SocketConnectable.Enumerate() to get a gio.SocketAddressEnumerator to try
// out each socket address in turn until one succeeds, as shown in the sample
// code below.
//
//	MyConnectionType *
//	connect_to_host (const char    *hostname,
//	                 guint16        port,
//	                 GCancellable  *cancellable,
//	                 GError       **error)
//	{
//	  MyConnection *conn = NULL;
//	  GSocketConnectable *addr;
//	  GSocketAddressEnumerator *enumerator;
//	  GSocketAddress *sockaddr;
//	  GError *conn_error = NULL;
//
//	  addr = g_network_address_new (hostname, port);
//	  enumerator = g_socket_connectable_enumerate (addr);
//	  g_object_unref (addr);
//
//	  // Try each sockaddr until we succeed. Record the first connection error,
//	  // but not any further ones (since they'll probably be basically the same
//	  // as the first).
//	  while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
//	    {
//	      conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
//	      g_object_unref (sockaddr);
//	    }
//	  g_object_unref (enumerator);
//
//	  if (conn)
//	    {
//	      if (conn_error)
//	        {
//	          // We couldn't connect to the first address, but we succeeded
//	          // in connecting to a later address.
//	          g_error_free (conn_error);
//	        }
//	      return conn;
//	    }
//	  else if (error)
//	    {
//	      /// Either initial lookup failed, or else the caller cancelled us.
//	      if (conn_error)
//	        g_error_free (conn_error);
//	      return NULL;
//	    }
//	  else
//	    {
//	      g_error_propagate (error, conn_error);
//	      return NULL;
//	    }
//	}.
//
// SocketConnectable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type SocketConnectable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketConnectable)(nil)
)

// SocketConnectabler describes SocketConnectable's interface methods.
type SocketConnectabler interface {
	coreglib.Objector

	// Enumerate creates a AddressEnumerator for connectable.
	Enumerate() SocketAddressEnumeratorrer
	// ProxyEnumerate creates a AddressEnumerator for connectable that will
	// return a Address for each of its addresses that you must connect to via a
	// proxy.
	ProxyEnumerate() SocketAddressEnumeratorrer
	// String: format a Connectable as a string.
	String() string
}

var _ SocketConnectabler = (*SocketConnectable)(nil)

func wrapSocketConnectable(obj *coreglib.Object) *SocketConnectable {
	return &SocketConnectable{
		Object: obj,
	}
}

func marshalSocketConnectable(p uintptr) (interface{}, error) {
	return wrapSocketConnectable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Enumerate creates a AddressEnumerator for connectable.
//
// The function returns the following values:
//
//   - socketAddressEnumerator: new AddressEnumerator.
func (connectable *SocketConnectable) Enumerate() SocketAddressEnumeratorrer {
	var _arg0 *C.GSocketConnectable       // out
	var _cret *C.GSocketAddressEnumerator // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	_cret = C.g_socket_connectable_enumerate(_arg0)
	runtime.KeepAlive(connectable)

	var _socketAddressEnumerator SocketAddressEnumeratorrer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddressEnumeratorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddressEnumeratorrer)
			return ok
		})
		rv, ok := casted.(SocketAddressEnumeratorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddressEnumeratorrer")
		}
		_socketAddressEnumerator = rv
	}

	return _socketAddressEnumerator
}

// ProxyEnumerate creates a AddressEnumerator for connectable that will return a
// Address for each of its addresses that you must connect to via a proxy.
//
// If connectable does not implement g_socket_connectable_proxy_enumerate(),
// this will fall back to calling g_socket_connectable_enumerate().
//
// The function returns the following values:
//
//   - socketAddressEnumerator: new AddressEnumerator.
func (connectable *SocketConnectable) ProxyEnumerate() SocketAddressEnumeratorrer {
	var _arg0 *C.GSocketConnectable       // out
	var _cret *C.GSocketAddressEnumerator // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	_cret = C.g_socket_connectable_proxy_enumerate(_arg0)
	runtime.KeepAlive(connectable)

	var _socketAddressEnumerator SocketAddressEnumeratorrer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddressEnumeratorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddressEnumeratorrer)
			return ok
		})
		rv, ok := casted.(SocketAddressEnumeratorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddressEnumeratorrer")
		}
		_socketAddressEnumerator = rv
	}

	return _socketAddressEnumerator
}

// String: format a Connectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
//
// If the Connectable implementation does not support string formatting,
// the implementations type name will be returned as a fallback.
//
// The function returns the following values:
//
//   - utf8: formatted string.
func (connectable *SocketConnectable) String() string {
	var _arg0 *C.GSocketConnectable // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	_cret = C.g_socket_connectable_to_string(_arg0)
	runtime.KeepAlive(connectable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Enumerate creates a AddressEnumerator for connectable.
//
// The function returns the following values:
//
//   - socketAddressEnumerator: new AddressEnumerator.
func (connectable *SocketConnectable) enumerate() SocketAddressEnumeratorrer {
	gclass := (*C.GSocketConnectableIface)(coreglib.PeekParentClass(connectable))
	fnarg := gclass.enumerate

	var _arg0 *C.GSocketConnectable       // out
	var _cret *C.GSocketAddressEnumerator // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	_cret = C._gotk4_gio2_SocketConnectable_virtual_enumerate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(connectable)

	var _socketAddressEnumerator SocketAddressEnumeratorrer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddressEnumeratorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddressEnumeratorrer)
			return ok
		})
		rv, ok := casted.(SocketAddressEnumeratorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddressEnumeratorrer")
		}
		_socketAddressEnumerator = rv
	}

	return _socketAddressEnumerator
}

// proXYEnumerate creates a AddressEnumerator for connectable that will return a
// Address for each of its addresses that you must connect to via a proxy.
//
// If connectable does not implement g_socket_connectable_proxy_enumerate(),
// this will fall back to calling g_socket_connectable_enumerate().
//
// The function returns the following values:
//
//   - socketAddressEnumerator: new AddressEnumerator.
func (connectable *SocketConnectable) proxyEnumerate() SocketAddressEnumeratorrer {
	gclass := (*C.GSocketConnectableIface)(coreglib.PeekParentClass(connectable))
	fnarg := gclass.proxy_enumerate

	var _arg0 *C.GSocketConnectable       // out
	var _cret *C.GSocketAddressEnumerator // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	_cret = C._gotk4_gio2_SocketConnectable_virtual_proxy_enumerate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(connectable)

	var _socketAddressEnumerator SocketAddressEnumeratorrer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddressEnumeratorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddressEnumeratorrer)
			return ok
		})
		rv, ok := casted.(SocketAddressEnumeratorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddressEnumeratorrer")
		}
		_socketAddressEnumerator = rv
	}

	return _socketAddressEnumerator
}

// Str: format a Connectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
//
// If the Connectable implementation does not support string formatting,
// the implementations type name will be returned as a fallback.
//
// The function returns the following values:
//
//   - utf8: formatted string.
func (connectable *SocketConnectable) str() string {
	gclass := (*C.GSocketConnectableIface)(coreglib.PeekParentClass(connectable))
	fnarg := gclass.to_string

	var _arg0 *C.GSocketConnectable // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	_cret = C._gotk4_gio2_SocketConnectable_virtual_to_string(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(connectable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TLSBackend: TLS (Transport Layer Security, aka SSL) and DTLS backend.
// This is an internal type used to coordinate the different classes implemented
// by a TLS backend.
//
// TLSBackend wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TLSBackend struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TLSBackend)(nil)
)

// TLSBackender describes TLSBackend's interface methods.
type TLSBackender interface {
	coreglib.Objector

	// CertificateType gets the #GType of backend's Certificate implementation.
	CertificateType() coreglib.Type
	// ClientConnectionType gets the #GType of backend's ClientConnection
	// implementation.
	ClientConnectionType() coreglib.Type
	// DefaultDatabase gets the default Database used to verify TLS connections.
	DefaultDatabase() TLSDatabaser
	// DTLSClientConnectionType gets the #GType of backends ClientConnection
	// implementation.
	DTLSClientConnectionType() coreglib.Type
	// DTLSServerConnectionType gets the #GType of backends ServerConnection
	// implementation.
	DTLSServerConnectionType() coreglib.Type
	// FileDatabaseType gets the #GType of backend's FileDatabase
	// implementation.
	FileDatabaseType() coreglib.Type
	// ServerConnectionType gets the #GType of backend's ServerConnection
	// implementation.
	ServerConnectionType() coreglib.Type
	// SetDefaultDatabase: set the default Database used to verify TLS
	// connections.
	SetDefaultDatabase(database TLSDatabaser)
	// SupportsDTLS checks if DTLS is supported.
	SupportsDTLS() bool
	// SupportsTLS checks if TLS is supported; if this returns FALSE for the
	// default Backend, it means no "real" TLS backend is available.
	SupportsTLS() bool
}

var _ TLSBackender = (*TLSBackend)(nil)

func wrapTLSBackend(obj *coreglib.Object) *TLSBackend {
	return &TLSBackend{
		Object: obj,
	}
}

func marshalTLSBackend(p uintptr) (interface{}, error) {
	return wrapTLSBackend(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CertificateType gets the #GType of backend's Certificate implementation.
//
// The function returns the following values:
//
//   - gType of backend's Certificate implementation.
func (backend *TLSBackend) CertificateType() coreglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_get_certificate_type(_arg0)
	runtime.KeepAlive(backend)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// ClientConnectionType gets the #GType of backend's ClientConnection
// implementation.
//
// The function returns the following values:
//
//   - gType of backend's ClientConnection implementation.
func (backend *TLSBackend) ClientConnectionType() coreglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_get_client_connection_type(_arg0)
	runtime.KeepAlive(backend)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// DefaultDatabase gets the default Database used to verify TLS connections.
//
// The function returns the following values:
//
//   - tlsDatabase: default database, which should be unreffed when done.
func (backend *TLSBackend) DefaultDatabase() TLSDatabaser {
	var _arg0 *C.GTlsBackend  // out
	var _cret *C.GTlsDatabase // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_get_default_database(_arg0)
	runtime.KeepAlive(backend)

	var _tlsDatabase TLSDatabaser // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSDatabaser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSDatabaser)
			return ok
		})
		rv, ok := casted.(TLSDatabaser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
		}
		_tlsDatabase = rv
	}

	return _tlsDatabase
}

// DTLSClientConnectionType gets the #GType of backends ClientConnection
// implementation.
//
// The function returns the following values:
//
//   - gType of backends ClientConnection implementation, or G_TYPE_INVALID if
//     this backend doesnt support DTLS.
func (backend *TLSBackend) DTLSClientConnectionType() coreglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_get_dtls_client_connection_type(_arg0)
	runtime.KeepAlive(backend)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// DTLSServerConnectionType gets the #GType of backends ServerConnection
// implementation.
//
// The function returns the following values:
//
//   - gType of backends ServerConnection implementation, or G_TYPE_INVALID if
//     this backend doesnt support DTLS.
func (backend *TLSBackend) DTLSServerConnectionType() coreglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_get_dtls_server_connection_type(_arg0)
	runtime.KeepAlive(backend)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// FileDatabaseType gets the #GType of backend's FileDatabase implementation.
//
// The function returns the following values:
//
//   - gType of backend's FileDatabase implementation.
func (backend *TLSBackend) FileDatabaseType() coreglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_get_file_database_type(_arg0)
	runtime.KeepAlive(backend)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// ServerConnectionType gets the #GType of backend's ServerConnection
// implementation.
//
// The function returns the following values:
//
//   - gType of backend's ServerConnection implementation.
func (backend *TLSBackend) ServerConnectionType() coreglib.Type {
	var _arg0 *C.GTlsBackend // out
	var _cret C.GType        // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_get_server_connection_type(_arg0)
	runtime.KeepAlive(backend)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// SetDefaultDatabase: set the default Database used to verify TLS connections
//
// Any subsequent call to g_tls_backend_get_default_database() will return
// the database set in this call. Existing databases and connections are not
// modified.
//
// Setting a NULL default database will reset to using the system default
// database as if g_tls_backend_set_default_database() had never been called.
//
// The function takes the following parameters:
//
//   - database (optional): Database.
func (backend *TLSBackend) SetDefaultDatabase(database TLSDatabaser) {
	var _arg0 *C.GTlsBackend  // out
	var _arg1 *C.GTlsDatabase // out

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))
	if database != nil {
		_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(database).Native()))
	}

	C.g_tls_backend_set_default_database(_arg0, _arg1)
	runtime.KeepAlive(backend)
	runtime.KeepAlive(database)
}

// SupportsDTLS checks if DTLS is supported. DTLS support may not be available
// even if TLS support is available, and vice-versa.
//
// The function returns the following values:
//
//   - ok: whether DTLS is supported.
func (backend *TLSBackend) SupportsDTLS() bool {
	var _arg0 *C.GTlsBackend // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_supports_dtls(_arg0)
	runtime.KeepAlive(backend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsTLS checks if TLS is supported; if this returns FALSE for the default
// Backend, it means no "real" TLS backend is available.
//
// The function returns the following values:
//
//   - ok: whether or not TLS is supported.
func (backend *TLSBackend) SupportsTLS() bool {
	var _arg0 *C.GTlsBackend // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C.g_tls_backend_supports_tls(_arg0)
	runtime.KeepAlive(backend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// defaultDatabase gets the default Database used to verify TLS connections.
//
// The function returns the following values:
//
//   - tlsDatabase: default database, which should be unreffed when done.
func (backend *TLSBackend) defaultDatabase() TLSDatabaser {
	gclass := (*C.GTlsBackendInterface)(coreglib.PeekParentClass(backend))
	fnarg := gclass.get_default_database

	var _arg0 *C.GTlsBackend  // out
	var _cret *C.GTlsDatabase // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C._gotk4_gio2_TLSBackend_virtual_get_default_database(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(backend)

	var _tlsDatabase TLSDatabaser // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSDatabaser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSDatabaser)
			return ok
		})
		rv, ok := casted.(TLSDatabaser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
		}
		_tlsDatabase = rv
	}

	return _tlsDatabase
}

// supportsDTLS checks if DTLS is supported. DTLS support may not be available
// even if TLS support is available, and vice-versa.
//
// The function returns the following values:
//
//   - ok: whether DTLS is supported.
func (backend *TLSBackend) supportsDTLS() bool {
	gclass := (*C.GTlsBackendInterface)(coreglib.PeekParentClass(backend))
	fnarg := gclass.supports_dtls

	var _arg0 *C.GTlsBackend // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C._gotk4_gio2_TLSBackend_virtual_supports_dtls(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(backend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// supportsTLS checks if TLS is supported; if this returns FALSE for the default
// Backend, it means no "real" TLS backend is available.
//
// The function returns the following values:
//
//   - ok: whether or not TLS is supported.
func (backend *TLSBackend) supportsTLS() bool {
	gclass := (*C.GTlsBackendInterface)(coreglib.PeekParentClass(backend))
	fnarg := gclass.supports_tls

	var _arg0 *C.GTlsBackend // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GTlsBackend)(unsafe.Pointer(coreglib.InternObject(backend).Native()))

	_cret = C._gotk4_gio2_TLSBackend_virtual_supports_tls(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(backend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TLSBackendGetDefault gets the default Backend for the system.
//
// The function returns the following values:
//
//   - tlsBackend which will be a dummy object if no TLS backend is available.
func TLSBackendGetDefault() *TLSBackend {
	var _cret *C.GTlsBackend // in

	_cret = C.g_tls_backend_get_default()

	var _tlsBackend *TLSBackend // out

	_tlsBackend = wrapTLSBackend(coreglib.Take(unsafe.Pointer(_cret)))

	return _tlsBackend
}

// TLSClientConnection: GTlsClientConnection is the client-side subclass of
// gio.TLSConnection, representing a client-side TLS connection.
//
// TLSClientConnection wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TLSClientConnection struct {
	_ [0]func() // equal guard
	TLSConnection
}

var (
	_ TLSConnectioner = (*TLSClientConnection)(nil)
)

// TLSClientConnectioner describes TLSClientConnection's interface methods.
type TLSClientConnectioner interface {
	coreglib.Objector

	// CopySessionState: possibly copies session state from one connection to
	// another, for use in TLS session resumption.
	CopySessionState(source TLSClientConnectioner)
	// ServerIdentity gets conn's expected server identity.
	ServerIdentity() *SocketConnectable
	// UseSSL3: SSL 3.0 is no longer supported.
	UseSSL3() bool
	// ValidationFlags gets conn's validation flags.
	ValidationFlags() TLSCertificateFlags
	// SetServerIdentity sets conn's expected server identity, which is used
	// both to tell servers on virtual hosts which certificate to present,
	// and also to let conn know what name to look for in the certificate when
	// performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	SetServerIdentity(identity SocketConnectabler)
	// SetUseSSL3: since GLib 2.42.1, SSL 3.0 is no longer supported.
	SetUseSSL3(useSsl3 bool)
	// SetValidationFlags sets conn's validation flags, to override the default
	// set of checks performed when validating a server certificate.
	SetValidationFlags(flags TLSCertificateFlags)
}

var _ TLSClientConnectioner = (*TLSClientConnection)(nil)

func wrapTLSClientConnection(obj *coreglib.Object) *TLSClientConnection {
	return &TLSClientConnection{
		TLSConnection: TLSConnection{
			IOStream: IOStream{
				Object: obj,
			},
		},
	}
}

func marshalTLSClientConnection(p uintptr) (interface{}, error) {
	return wrapTLSClientConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CopySessionState: possibly copies session state from one connection to
// another, for use in TLS session resumption. This is not normally needed,
// but may be used when the same session needs to be used between different
// endpoints, as is required by some protocols, such as FTP over TLS. source
// should have already completed a handshake and, since TLS 1.3, it should
// have been used to read data at least once. conn should not have completed a
// handshake.
//
// It is not possible to know whether a call to this function will actually do
// anything. Because session resumption is normally used only for performance
// benefit, the TLS backend might not implement this function. Even if
// implemented, it may not actually succeed in allowing conn to resume source's
// TLS session, because the server may not have sent a session resumption token
// to source, or it may refuse to accept the token from conn. There is no way to
// know whether a call to this function is actually successful.
//
// Using this function is not required to benefit from session resumption.
// If the TLS backend supports session resumption, the session will be resumed
// automatically if it is possible to do so without weakening the privacy
// guarantees normally provided by TLS, without need to call this function.
// For example, with TLS 1.3, a session ticket will be automatically copied from
// any ClientConnection that has previously received session tickets from the
// server, provided a ticket is available that has not previously been used for
// session resumption, since session ticket reuse would be a privacy weakness.
// Using this function causes the ticket to be copied without regard for privacy
// considerations.
//
// The function takes the following parameters:
//
//   - source: ClientConnection.
func (conn *TLSClientConnection) CopySessionState(source TLSClientConnectioner) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 *C.GTlsClientConnection // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	C.g_tls_client_connection_copy_session_state(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(source)
}

// ServerIdentity gets conn's expected server identity.
//
// The function returns the following values:
//
//   - socketConnectable (optional) describing the expected server identity,
//     or NULL if the expected identity is not known.
func (conn *TLSClientConnection) ServerIdentity() *SocketConnectable {
	var _arg0 *C.GTlsClientConnection // out
	var _cret *C.GSocketConnectable   // in

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_client_connection_get_server_identity(_arg0)
	runtime.KeepAlive(conn)

	var _socketConnectable *SocketConnectable // out

	if _cret != nil {
		_socketConnectable = wrapSocketConnectable(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _socketConnectable
}

// UseSSL3: SSL 3.0 is no longer supported. See
// g_tls_client_connection_set_use_ssl3() for details.
//
// Deprecated: SSL 3.0 is insecure.
//
// The function returns the following values:
//
//   - ok: FALSE.
func (conn *TLSClientConnection) UseSSL3() bool {
	var _arg0 *C.GTlsClientConnection // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_client_connection_get_use_ssl3(_arg0)
	runtime.KeepAlive(conn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValidationFlags gets conn's validation flags
//
// This function does not work as originally designed and is impossible to use
// correctly. See ClientConnection:validation-flags for more information.
//
// Deprecated: Do not attempt to ignore validation errors.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: validation flags.
func (conn *TLSClientConnection) ValidationFlags() TLSCertificateFlags {
	var _arg0 *C.GTlsClientConnection // out
	var _cret C.GTlsCertificateFlags  // in

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_client_connection_get_validation_flags(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// SetServerIdentity sets conn's expected server identity, which is used both
// to tell servers on virtual hosts which certificate to present, and also
// to let conn know what name to look for in the certificate when performing
// G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
//
// The function takes the following parameters:
//
//   - identity describing the expected server identity.
func (conn *TLSClientConnection) SetServerIdentity(identity SocketConnectabler) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 *C.GSocketConnectable   // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))

	C.g_tls_client_connection_set_server_identity(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(identity)
}

// SetUseSSL3: since GLib 2.42.1, SSL 3.0 is no longer supported.
//
// From GLib 2.42.1 through GLib 2.62, this function could be used to force
// use of TLS 1.0, the lowest-supported TLS protocol version at the time.
// In the past, this was needed to connect to broken TLS servers that exhibited
// protocol version intolerance. Such servers are no longer common, and using
// TLS 1.0 is no longer considered acceptable.
//
// Since GLib 2.64, this function does nothing.
//
// Deprecated: SSL 3.0 is insecure.
//
// The function takes the following parameters:
//
//   - useSsl3: #gboolean, ignored.
func (conn *TLSClientConnection) SetUseSSL3(useSsl3 bool) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if useSsl3 {
		_arg1 = C.TRUE
	}

	C.g_tls_client_connection_set_use_ssl3(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(useSsl3)
}

// SetValidationFlags sets conn's validation flags, to override the default
// set of checks performed when validating a server certificate. By default,
// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
//
// This function does not work as originally designed and is impossible to use
// correctly. See ClientConnection:validation-flags for more information.
//
// Deprecated: Do not attempt to ignore validation errors.
//
// The function takes the following parameters:
//
//   - flags to use.
func (conn *TLSClientConnection) SetValidationFlags(flags TLSCertificateFlags) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 C.GTlsCertificateFlags  // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsCertificateFlags(flags)

	C.g_tls_client_connection_set_validation_flags(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(flags)
}

// copySessionState: possibly copies session state from one connection to
// another, for use in TLS session resumption. This is not normally needed,
// but may be used when the same session needs to be used between different
// endpoints, as is required by some protocols, such as FTP over TLS. source
// should have already completed a handshake and, since TLS 1.3, it should
// have been used to read data at least once. conn should not have completed a
// handshake.
//
// It is not possible to know whether a call to this function will actually do
// anything. Because session resumption is normally used only for performance
// benefit, the TLS backend might not implement this function. Even if
// implemented, it may not actually succeed in allowing conn to resume source's
// TLS session, because the server may not have sent a session resumption token
// to source, or it may refuse to accept the token from conn. There is no way to
// know whether a call to this function is actually successful.
//
// Using this function is not required to benefit from session resumption.
// If the TLS backend supports session resumption, the session will be resumed
// automatically if it is possible to do so without weakening the privacy
// guarantees normally provided by TLS, without need to call this function.
// For example, with TLS 1.3, a session ticket will be automatically copied from
// any ClientConnection that has previously received session tickets from the
// server, provided a ticket is available that has not previously been used for
// session resumption, since session ticket reuse would be a privacy weakness.
// Using this function causes the ticket to be copied without regard for privacy
// considerations.
//
// The function takes the following parameters:
//
//   - source: ClientConnection.
func (conn *TLSClientConnection) copySessionState(source TLSClientConnectioner) {
	gclass := (*C.GTlsClientConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.copy_session_state

	var _arg0 *C.GTlsClientConnection // out
	var _arg1 *C.GTlsClientConnection // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	C._gotk4_gio2_TLSClientConnection_virtual_copy_session_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(source)
}

// NewTLSClientConnection creates a new ClientConnection wrapping base_io_stream
// (which must have pollable input and output streams) which is assumed to
// communicate with the server identified by server_identity.
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the base_io_stream after this function
// has returned.
//
// The function takes the following parameters:
//
//   - baseIoStream to wrap.
//   - serverIdentity (optional): expected identity of the server.
//
// The function returns the following values:
//
//   - tlsClientConnection: new ClientConnection, or NULL on error.
func NewTLSClientConnection(baseIoStream IOStreamer, serverIdentity SocketConnectabler) (*TLSClientConnection, error) {
	var _arg1 *C.GIOStream          // out
	var _arg2 *C.GSocketConnectable // out
	var _cret *C.GIOStream          // in
	var _cerr *C.GError             // in

	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(baseIoStream).Native()))
	if serverIdentity != nil {
		_arg2 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(serverIdentity).Native()))
	}

	_cret = C.g_tls_client_connection_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(serverIdentity)

	var _tlsClientConnection *TLSClientConnection // out
	var _goerr error                              // out

	_tlsClientConnection = wrapTLSClientConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsClientConnection, _goerr
}

// TLSFileDatabaseOverrider contains methods that are overridable.
type TLSFileDatabaseOverrider interface {
}

// TLSFileDatabase: GTlsFileDatabase is implemented by gio.TLSDatabase objects
// which load their certificate information from a file. It is an interface
// which TLS library specific subtypes implement.
//
// TLSFileDatabase wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TLSFileDatabase struct {
	_ [0]func() // equal guard
	TLSDatabase
}

var (
	_ TLSDatabaser = (*TLSFileDatabase)(nil)
)

// TLSFileDatabaser describes TLSFileDatabase's interface methods.
type TLSFileDatabaser interface {
	coreglib.Objector

	baseTLSFileDatabase() *TLSFileDatabase
}

var _ TLSFileDatabaser = (*TLSFileDatabase)(nil)

func ifaceInitTLSFileDatabaser(gifacePtr, data C.gpointer) {
}

func wrapTLSFileDatabase(obj *coreglib.Object) *TLSFileDatabase {
	return &TLSFileDatabase{
		TLSDatabase: TLSDatabase{
			Object: obj,
		},
	}
}

func marshalTLSFileDatabase(p uintptr) (interface{}, error) {
	return wrapTLSFileDatabase(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *TLSFileDatabase) baseTLSFileDatabase() *TLSFileDatabase {
	return v
}

// BaseTLSFileDatabase returns the underlying base object.
func BaseTLSFileDatabase(obj TLSFileDatabaser) *TLSFileDatabase {
	return obj.baseTLSFileDatabase()
}

// NewTLSFileDatabase creates a new FileDatabase which uses anchor certificate
// authorities in anchors to verify certificate chains.
//
// The certificates in anchors must be PEM encoded.
//
// The function takes the following parameters:
//
//   - anchors: filename of anchor certificate authorities.
//
// The function returns the following values:
//
//   - tlsFileDatabase: new FileDatabase, or NULL on error.
func NewTLSFileDatabase(anchors string) (*TLSFileDatabase, error) {
	var _arg1 *C.gchar        // out
	var _cret *C.GTlsDatabase // in
	var _cerr *C.GError       // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(anchors)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_tls_file_database_new(_arg1, &_cerr)
	runtime.KeepAlive(anchors)

	var _tlsFileDatabase *TLSFileDatabase // out
	var _goerr error                      // out

	_tlsFileDatabase = wrapTLSFileDatabase(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsFileDatabase, _goerr
}

// TLSServerConnectionOverrider contains methods that are overridable.
type TLSServerConnectionOverrider interface {
}

// TLSServerConnection: GTlsServerConnection is the server-side subclass of
// gio.TLSConnection, representing a server-side TLS connection.
//
// TLSServerConnection wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TLSServerConnection struct {
	_ [0]func() // equal guard
	TLSConnection
}

var (
	_ TLSConnectioner = (*TLSServerConnection)(nil)
)

// TLSServerConnectioner describes TLSServerConnection's interface methods.
type TLSServerConnectioner interface {
	coreglib.Objector

	baseTLSServerConnection() *TLSServerConnection
}

var _ TLSServerConnectioner = (*TLSServerConnection)(nil)

func ifaceInitTLSServerConnectioner(gifacePtr, data C.gpointer) {
}

func wrapTLSServerConnection(obj *coreglib.Object) *TLSServerConnection {
	return &TLSServerConnection{
		TLSConnection: TLSConnection{
			IOStream: IOStream{
				Object: obj,
			},
		},
	}
}

func marshalTLSServerConnection(p uintptr) (interface{}, error) {
	return wrapTLSServerConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *TLSServerConnection) baseTLSServerConnection() *TLSServerConnection {
	return v
}

// BaseTLSServerConnection returns the underlying base object.
func BaseTLSServerConnection(obj TLSServerConnectioner) *TLSServerConnection {
	return obj.baseTLSServerConnection()
}

// NewTLSServerConnection creates a new ServerConnection wrapping base_io_stream
// (which must have pollable input and output streams).
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the base_io_stream after this function
// has returned.
//
// The function takes the following parameters:
//
//   - baseIoStream to wrap.
//   - certificate (optional): default server certificate, or NULL.
//
// The function returns the following values:
//
//   - tlsServerConnection: new ServerConnection, or NULL on error.
func NewTLSServerConnection(baseIoStream IOStreamer, certificate TLSCertificater) (*TLSServerConnection, error) {
	var _arg1 *C.GIOStream       // out
	var _arg2 *C.GTlsCertificate // out
	var _cret *C.GIOStream       // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(baseIoStream).Native()))
	if certificate != nil {
		_arg2 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	}

	_cret = C.g_tls_server_connection_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(certificate)

	var _tlsServerConnection *TLSServerConnection // out
	var _goerr error                              // out

	_tlsServerConnection = wrapTLSServerConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsServerConnection, _goerr
}

// Volume: GVolume interface represents user-visible objects that can be
// mounted. Note, when porting from GnomeVFS (migrating-gnome-vfs.html), GVolume
// is the moral equivalent of GnomeVFSDrive.
//
// Mounting a GVolume instance is an asynchronous operation. For more
// information about asynchronous operations, see gio.AsyncResult and gio.Task.
// To mount a GVolume, first call gio.Volume.Mount() with (at least)
// the GVolume instance, optionally a gio.MountOperation object and a
// gio.AsyncReadyCallback.
//
// Typically, one will only want to pass NULL for the gio.MountOperation
// if automounting all volumes when a desktop session starts since its not
// desirable to put up a lot of dialogs asking for credentials.
//
// The callback will be fired when the operation has resolved (either with
// success or failure), and a gio.AsyncResult instance will be passed to
// the callback. That callback should then call gio.Volume.MountFinish()
// with the GVolume instance and the gio.AsyncResult data to see if the
// operation was completed successfully. If a glib.Error is present when
// gio.Volume.MountFinish() is called, then it will be filled with any error
// information.
//
// # Volume Identifiers
//
// It is sometimes necessary to directly access the underlying operating system
// object behind a volume (e.g. for passing a volume to an application via the
// command line). For this purpose, GIO allows to obtain an identifier for
// the volume. There can be different kinds of identifiers, such as Hal UDIs,
// filesystem labels, traditional Unix devices (e.g. /dev/sda2), UUIDs.
// GIO uses predefined strings as names for the different kinds of identifiers:
// G_VOLUME_IDENTIFIER_KIND_UUID, G_VOLUME_IDENTIFIER_KIND_LABEL, etc. Use
// gio.Volume.GetIdentifier() to obtain an identifier for a volume.
//
// Note that G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available
// when the GVFS hal volume monitor is in use. Other volume monitors will
// generally be able to provide the G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
// identifier, which can be used to obtain a hal device by means of
// libhal_manager_find_device_string_match().
//
// Volume wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Volume struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Volume)(nil)
)

// Volumer describes Volume's interface methods.
type Volumer interface {
	coreglib.Objector

	// CanEject checks if a volume can be ejected.
	CanEject() bool
	// CanMount checks if a volume can be mounted.
	CanMount() bool
	// Eject ejects a volume.
	Eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback)
	// EjectFinish finishes ejecting a volume.
	EjectFinish(result AsyncResulter) error
	// EjectWithOperation ejects a volume.
	EjectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// EjectWithOperationFinish finishes ejecting a volume.
	EjectWithOperationFinish(result AsyncResulter) error
	// EnumerateIdentifiers gets the kinds of identifiers (#volume-identifiers)
	// that volume has.
	EnumerateIdentifiers() []string
	// ActivationRoot gets the activation root for a #GVolume if it is known
	// ahead of mount time.
	ActivationRoot() *File
	// Drive gets the drive for the volume.
	Drive() *Drive
	// Icon gets the icon for volume.
	Icon() *Icon
	// Identifier gets the identifier of the given kind for volume.
	Identifier(kind string) string
	// GetMount gets the mount for the volume.
	GetMount() *Mount
	// Name gets the name of volume.
	Name() string
	// SortKey gets the sort key for volume, if any.
	SortKey() string
	// SymbolicIcon gets the symbolic icon for volume.
	SymbolicIcon() *Icon
	// UUID gets the UUID for the volume.
	UUID() string
	// Mount mounts a volume.
	Mount(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback)
	// MountFinish finishes mounting a volume.
	MountFinish(result AsyncResulter) error
	// ShouldAutomount returns whether the volume should be automatically
	// mounted.
	ShouldAutomount() bool

	// Changed is emitted when the volume has been changed.
	ConnectChanged(func()) coreglib.SignalHandle
	// Removed: this signal is emitted when the #GVolume have been removed.
	ConnectRemoved(func()) coreglib.SignalHandle
}

var _ Volumer = (*Volume)(nil)

func wrapVolume(obj *coreglib.Object) *Volume {
	return &Volume{
		Object: obj,
	}
}

func marshalVolume(p uintptr) (interface{}, error) {
	return wrapVolume(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the volume has been changed.
func (volume *Volume) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volume, "changed", false, unsafe.Pointer(C._gotk4_gio2_Volume_ConnectChanged), f)
}

// ConnectRemoved: this signal is emitted when the #GVolume have been removed.
// If the recipient is holding references to the object they should release them
// so the object can be finalized.
func (volume *Volume) ConnectRemoved(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volume, "removed", false, unsafe.Pointer(C._gotk4_gio2_Volume_ConnectRemoved), f)
}

// CanEject checks if a volume can be ejected.
//
// The function returns the following values:
//
//   - ok: TRUE if the volume can be ejected. FALSE otherwise.
func (volume *Volume) CanEject() bool {
	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_can_eject(_arg0)
	runtime.KeepAlive(volume)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanMount checks if a volume can be mounted.
//
// The function returns the following values:
//
//   - ok: TRUE if the volume can be mounted. FALSE otherwise.
func (volume *Volume) CanMount() bool {
	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_can_mount(_arg0)
	runtime.KeepAlive(volume)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Eject ejects a volume. This is an asynchronous operation, and is finished by
// calling g_volume_eject_finish() with the volume and Result returned in the
// callback.
//
// Deprecated: Use g_volume_eject_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - callback (optional) or NULL.
func (volume *Volume) Eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GVolume            // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_volume_eject(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// EjectFinish finishes ejecting a volume. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// Deprecated: Use g_volume_eject_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (volume *Volume) EjectFinish(result AsyncResulter) error {
	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_volume_eject_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EjectWithOperation ejects a volume. This is an asynchronous operation,
// and is finished by calling g_volume_eject_with_operation_finish() with the
// volume and Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (volume *Volume) EjectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GVolume            // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_volume_eject_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish finishes ejecting a volume. If any errors occurred
// during the operation, error will be set to contain the errors and FALSE will
// be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (volume *Volume) EjectWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_volume_eject_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EnumerateIdentifiers gets the kinds of identifiers (#volume-identifiers)
// that volume has. Use g_volume_get_identifier() to obtain the identifiers
// themselves.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings containing kinds of identifiers.
//     Use g_strfreev() to free.
func (volume *Volume) EnumerateIdentifiers() []string {
	var _arg0 *C.GVolume // out
	var _cret **C.char   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_enumerate_identifiers(_arg0)
	runtime.KeepAlive(volume)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ActivationRoot gets the activation root for a #GVolume if it is known ahead
// of mount time. Returns NULL otherwise. If not NULL and if volume is mounted,
// then the result of g_mount_get_root() on the #GMount object obtained from
// g_volume_get_mount() will always either be equal or a prefix of what this
// function returns. In other words, in code
//
//	(g_file_has_prefix (volume_activation_root, mount_root) ||
//	 g_file_equal (volume_activation_root, mount_root))
//
// will always be TRUE.
//
// Activation roots are typically used in Monitor implementations to find the
// underlying mount to shadow, see g_mount_is_shadowed() for more details.
//
// The function returns the following values:
//
//   - file (optional): activation root of volume or NULL. Use g_object_unref()
//     to free.
func (volume *Volume) ActivationRoot() *File {
	var _arg0 *C.GVolume // out
	var _cret *C.GFile   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_activation_root(_arg0)
	runtime.KeepAlive(volume)

	var _file *File // out

	if _cret != nil {
		_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _file
}

// Drive gets the drive for the volume.
//
// The function returns the following values:
//
//   - drive (optional) or NULL if volume is not associated with a drive.
//     The returned object should be unreffed with g_object_unref() when no
//     longer needed.
func (volume *Volume) Drive() *Drive {
	var _arg0 *C.GVolume // out
	var _cret *C.GDrive  // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_drive(_arg0)
	runtime.KeepAlive(volume)

	var _drive *Drive // out

	if _cret != nil {
		_drive = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _drive
}

// Icon gets the icon for volume.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (volume *Volume) Icon() *Icon {
	var _arg0 *C.GVolume // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_icon(_arg0)
	runtime.KeepAlive(volume)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Identifier gets the identifier of the given kind for volume. See the
// introduction (#volume-identifiers) for more information about volume
// identifiers.
//
// The function takes the following parameters:
//
//   - kind of identifier to return.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing the requested
//     identifier, or NULL if the #GVolume doesn't have this kind of identifier.
func (volume *Volume) Identifier(kind string) string {
	var _arg0 *C.GVolume // out
	var _arg1 *C.char    // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_get_identifier(_arg0, _arg1)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(kind)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// GetMount gets the mount for the volume.
//
// The function returns the following values:
//
//   - mount (optional) or NULL if volume isn't mounted. The returned object
//     should be unreffed with g_object_unref() when no longer needed.
func (volume *Volume) GetMount() *Mount {
	var _arg0 *C.GVolume // out
	var _cret *C.GMount  // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_mount(_arg0)
	runtime.KeepAlive(volume)

	var _mount *Mount // out

	if _cret != nil {
		_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _mount
}

// Name gets the name of volume.
//
// The function returns the following values:
//
//   - utf8: name for the given volume. The returned string should be freed with
//     g_free() when no longer needed.
func (volume *Volume) Name() string {
	var _arg0 *C.GVolume // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_name(_arg0)
	runtime.KeepAlive(volume)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SortKey gets the sort key for volume, if any.
//
// The function returns the following values:
//
//   - utf8 (optional): sorting key for volume or NULL if no such key is
//     available.
func (volume *Volume) SortKey() string {
	var _arg0 *C.GVolume // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_sort_key(_arg0)
	runtime.KeepAlive(volume)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SymbolicIcon gets the symbolic icon for volume.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (volume *Volume) SymbolicIcon() *Icon {
	var _arg0 *C.GVolume // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_symbolic_icon(_arg0)
	runtime.KeepAlive(volume)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// UUID gets the UUID for the volume. The reference is typically based on the
// file system UUID for the volume in question and should be considered an
// opaque string. Returns NULL if there is no UUID available.
//
// The function returns the following values:
//
//   - utf8 (optional): UUID for volume or NULL if no UUID can be computed.
//     The returned string should be freed with g_free() when no longer needed.
func (volume *Volume) UUID() string {
	var _arg0 *C.GVolume // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_get_uuid(_arg0)
	runtime.KeepAlive(volume)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Mount mounts a volume. This is an asynchronous operation, and is finished by
// calling g_volume_mount_finish() with the volume and Result returned in the
// callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (volume *Volume) Mount(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GVolume            // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_volume_mount(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// MountFinish finishes mounting a volume. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// If the mount operation succeeded, g_volume_get_mount() on volume is
// guaranteed to return the mount right after calling this function; there's no
// need to listen for the 'mount-added' signal on Monitor.
//
// The function takes the following parameters:
//
//   - result: Result.
func (volume *Volume) MountFinish(result AsyncResulter) error {
	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_volume_mount_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ShouldAutomount returns whether the volume should be automatically mounted.
//
// The function returns the following values:
//
//   - ok: TRUE if the volume should be automatically mounted.
func (volume *Volume) ShouldAutomount() bool {
	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C.g_volume_should_automount(_arg0)
	runtime.KeepAlive(volume)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canEject checks if a volume can be ejected.
//
// The function returns the following values:
//
//   - ok: TRUE if the volume can be ejected. FALSE otherwise.
func (volume *Volume) canEject() bool {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.can_eject

	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_can_eject(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// canMount checks if a volume can be mounted.
//
// The function returns the following values:
//
//   - ok: TRUE if the volume can be mounted. FALSE otherwise.
func (volume *Volume) canMount() bool {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.can_mount

	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_can_mount(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Changed: changed signal that is emitted when the volume's state has changed.
func (volume *Volume) changed() {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.changed

	var _arg0 *C.GVolume // out

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_Volume_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)
}

// Eject ejects a volume. This is an asynchronous operation, and is finished by
// calling g_volume_eject_finish() with the volume and Result returned in the
// callback.
//
// Deprecated: Use g_volume_eject_with_operation() instead.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - callback (optional) or NULL.
func (volume *Volume) eject(ctx context.Context, flags MountUnmountFlags, callback AsyncReadyCallback) {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.eject

	var _arg0 *C.GVolume            // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Volume_virtual_eject(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ejectFinish finishes ejecting a volume. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// Deprecated: Use g_volume_eject_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//   - result: Result.
func (volume *Volume) ejectFinish(result AsyncResulter) error {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.eject_finish

	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Volume_virtual_eject_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ejectWithOperation ejects a volume. This is an asynchronous operation,
// and is finished by calling g_volume_eject_with_operation_finish() with the
// volume and Result data returned in the callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the unmount if required for eject.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (volume *Volume) ejectWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.eject_with_operation

	var _arg0 *C.GVolume            // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Volume_virtual_eject_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// ejectWithOperationFinish finishes ejecting a volume. If any errors occurred
// during the operation, error will be set to contain the errors and FALSE will
// be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (volume *Volume) ejectWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.eject_with_operation_finish

	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Volume_virtual_eject_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// enumerateIdentifiers gets the kinds of identifiers (#volume-identifiers)
// that volume has. Use g_volume_get_identifier() to obtain the identifiers
// themselves.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings containing kinds of identifiers.
//     Use g_strfreev() to free.
func (volume *Volume) enumerateIdentifiers() []string {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.enumerate_identifiers

	var _arg0 *C.GVolume // out
	var _cret **C.char   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_enumerate_identifiers(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// activationRoot gets the activation root for a #GVolume if it is known ahead
// of mount time. Returns NULL otherwise. If not NULL and if volume is mounted,
// then the result of g_mount_get_root() on the #GMount object obtained from
// g_volume_get_mount() will always either be equal or a prefix of what this
// function returns. In other words, in code
//
//	(g_file_has_prefix (volume_activation_root, mount_root) ||
//	 g_file_equal (volume_activation_root, mount_root))
//
// will always be TRUE.
//
// Activation roots are typically used in Monitor implementations to find the
// underlying mount to shadow, see g_mount_is_shadowed() for more details.
//
// The function returns the following values:
//
//   - file (optional): activation root of volume or NULL. Use g_object_unref()
//     to free.
func (volume *Volume) activationRoot() *File {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_activation_root

	var _arg0 *C.GVolume // out
	var _cret *C.GFile   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_activation_root(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _file *File // out

	if _cret != nil {
		_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _file
}

// Drive gets the drive for the volume.
//
// The function returns the following values:
//
//   - drive (optional) or NULL if volume is not associated with a drive.
//     The returned object should be unreffed with g_object_unref() when no
//     longer needed.
func (volume *Volume) drive() *Drive {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_drive

	var _arg0 *C.GVolume // out
	var _cret *C.GDrive  // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_drive(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _drive *Drive // out

	if _cret != nil {
		_drive = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _drive
}

// Icon gets the icon for volume.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (volume *Volume) icon() *Icon {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_icon

	var _arg0 *C.GVolume // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// Identifier gets the identifier of the given kind for volume. See the
// introduction (#volume-identifiers) for more information about volume
// identifiers.
//
// The function takes the following parameters:
//
//   - kind of identifier to return.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing the requested
//     identifier, or NULL if the #GVolume doesn't have this kind of identifier.
func (volume *Volume) identifier(kind string) string {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_identifier

	var _arg0 *C.GVolume // out
	var _arg1 *C.char    // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_Volume_virtual_get_identifier(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(kind)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Mount gets the mount for the volume.
//
// The function returns the following values:
//
//   - mount (optional) or NULL if volume isn't mounted. The returned object
//     should be unreffed with g_object_unref() when no longer needed.
func (volume *Volume) mount() *Mount {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_mount

	var _arg0 *C.GVolume // out
	var _cret *C.GMount  // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_mount(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _mount *Mount // out

	if _cret != nil {
		_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _mount
}

// Name gets the name of volume.
//
// The function returns the following values:
//
//   - utf8: name for the given volume. The returned string should be freed with
//     g_free() when no longer needed.
func (volume *Volume) name() string {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_name

	var _arg0 *C.GVolume // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// sortKey gets the sort key for volume, if any.
//
// The function returns the following values:
//
//   - utf8 (optional): sorting key for volume or NULL if no such key is
//     available.
func (volume *Volume) sortKey() string {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_sort_key

	var _arg0 *C.GVolume // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_sort_key(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// symbolicIcon gets the symbolic icon for volume.
//
// The function returns the following values:
//
//   - icon: #GIcon. The returned object should be unreffed with
//     g_object_unref() when no longer needed.
func (volume *Volume) symbolicIcon() *Icon {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_symbolic_icon

	var _arg0 *C.GVolume // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_symbolic_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _icon
}

// uuiD gets the UUID for the volume. The reference is typically based on the
// file system UUID for the volume in question and should be considered an
// opaque string. Returns NULL if there is no UUID available.
//
// The function returns the following values:
//
//   - utf8 (optional): UUID for volume or NULL if no UUID can be computed.
//     The returned string should be freed with g_free() when no longer needed.
func (volume *Volume) uuiD() string {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.get_uuid

	var _arg0 *C.GVolume // out
	var _cret *C.char    // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_get_uuid(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// mountFinish finishes mounting a volume. If any errors occurred during
// the operation, error will be set to contain the errors and FALSE will be
// returned.
//
// If the mount operation succeeded, g_volume_get_mount() on volume is
// guaranteed to return the mount right after calling this function; there's no
// need to listen for the 'mount-added' signal on Monitor.
//
// The function takes the following parameters:
//
//   - result: Result.
func (volume *Volume) mountFinish(result AsyncResulter) error {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.mount_finish

	var _arg0 *C.GVolume      // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Volume_virtual_mount_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// mountFn mounts a volume. This is an asynchronous operation, and is finished
// by calling g_volume_mount_finish() with the volume and Result returned in the
// callback.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - flags affecting the operation.
//   - mountOperation (optional) or NULL to avoid user interaction.
//   - callback (optional) or NULL.
func (volume *Volume) mountFn(ctx context.Context, flags MountMountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.mount_fn

	var _arg0 *C.GVolume            // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountMountFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Volume_virtual_mount_fn(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// Removed signal that is emitted when the #GVolume have been removed. If the
// recipient is holding references to the object they should release them so the
// object can be finalized.
func (volume *Volume) removed() {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.removed

	var _arg0 *C.GVolume // out

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_Volume_virtual_removed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)
}

// shouldAutomount returns whether the volume should be automatically mounted.
//
// The function returns the following values:
//
//   - ok: TRUE if the volume should be automatically mounted.
func (volume *Volume) shouldAutomount() bool {
	gclass := (*C.GVolumeIface)(coreglib.PeekParentClass(volume))
	fnarg := gclass.should_automount

	var _arg0 *C.GVolume // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	_cret = C._gotk4_gio2_Volume_virtual_should_automount(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volume)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppInfoMonitor: GAppInfoMonitor monitors application information for changes.
//
// GAppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (newly installed or removed applications).
//
// Call gio.AppInfoMonitor().Get to get a GAppInfoMonitor and connect to the
// gio.AppInfoMonitor::changed signal. The signal will be emitted once when
// the app info database changes, and will not be emitted again until after
// the next call to gio.AppInfo().GetAll or another g_app_info_*() function.
// This is because monitoring the app info database for changes is expensive.
//
// The following functions will re-arm the gio.AppInfoMonitor::changed signal so
// it can be emitted again:
//
//   - gio.AppInfo().GetAll
//   - gio.AppInfo().GetAllForType
//   - gio.AppInfo().GetDefaultForType
//   - gio.AppInfo().GetFallbackForType
//   - gio.AppInfo().GetRecommendedForType
//   - g_desktop_app_info_get_implementations()
//     (../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
//   - g_desktop_app_info_new() (../gio-unix/ctor.DesktopAppInfo.new.html)
//   - g_desktop_app_info_new_from_filename()
//     (../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
//   - g_desktop_app_info_new_from_keyfile()
//     (../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
//   - g_desktop_app_info_search()
//     (../gio-unix/type_func.DesktopAppInfo.search.html)
//
// The latter functions are available if using GDesktopAppInfo
// (../gio-unix/class.DesktopAppInfo.html) from gio-unix-2.0.pc (GIR namespace
// GioUnix-2.0).
//
// In the usual case, applications should try to make note of the change
// (doing things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to GAppInfo APIs in response to
// the change signal, deferring these until the time that the updated data is
// actually required. The exception to this case is when application information
// is actually being displayed on the screen (for example, during a search or
// when the list of all applications is shown). The reason for this is that
// changes to the list of installed applications often come in groups (like
// during system updates) and rescanning the list on every change is pointless
// and expensive.
type AppInfoMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppInfoMonitor)(nil)
)

func wrapAppInfoMonitor(obj *coreglib.Object) *AppInfoMonitor {
	return &AppInfoMonitor{
		Object: obj,
	}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	return wrapAppInfoMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged: signal emitted when the app info database changes, when
// applications are installed or removed.
func (v *AppInfoMonitor) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "changed", false, unsafe.Pointer(C._gotk4_gio2_AppInfoMonitor_ConnectChanged), f)
}

// AppInfoMonitorGet gets the InfoMonitor for the current thread-default main
// context.
//
// The InfoMonitor will emit a "changed" signal in the thread-default main
// context whenever the list of installed applications (as reported by
// g_app_info_get_all()) may have changed.
//
// The InfoMonitor::changed signal will only be emitted once until
// g_app_info_get_all() (or another g_app_info_*() function) is called. Doing so
// will re-arm the signal ready to notify about the next change.
//
// You must only call g_object_unref() on the return value from under the same
// main context as you created it.
//
// The function returns the following values:
//
//   - appInfoMonitor: reference to a InfoMonitor.
func AppInfoMonitorGet() *AppInfoMonitor {
	var _cret *C.GAppInfoMonitor // in

	_cret = C.g_app_info_monitor_get()

	var _appInfoMonitor *AppInfoMonitor // out

	_appInfoMonitor = wrapAppInfoMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appInfoMonitor
}

// AppLaunchContextOverrides contains methods that are overridable.
type AppLaunchContextOverrides struct {
	// Display gets the display string for the context. This is used to ensure
	// new applications are started on the same display as the launching
	// application, by setting the DISPLAY environment variable.
	//
	// The function takes the following parameters:
	//
	//   - info: Info.
	//   - files of #GFile objects.
	//
	// The function returns the following values:
	//
	//   - utf8 (optional): display string for the display.
	Display func(info AppInfor, files []Filer) string
	// StartupNotifyID initiates startup notification for the application and
	// returns the XDG_ACTIVATION_TOKEN or DESKTOP_STARTUP_ID for the launched
	// operation, if supported.
	//
	// The returned token may be referred to equivalently as an
	// activation token (using Wayland terminology) or a startup
	// sequence ID (using X11 terminology). The two are interoperable
	// (https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
	//
	// Activation tokens are defined in the XDG Activation
	// Protocol (https://wayland.app/protocols/xdg-activation-v1),
	// and startup notification IDs are defined in the
	// freedesktop.org Startup Notification Protocol
	// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
	//
	// Support for the XDG Activation Protocol was added in GLib 2.76.
	//
	// The function takes the following parameters:
	//
	//   - info: Info.
	//   - files of #GFile objects.
	//
	// The function returns the following values:
	//
	//   - utf8 (optional): startup notification ID for the application, or NULL
	//     if not supported.
	StartupNotifyID func(info AppInfor, files []Filer) string
	// LaunchFailed: called when an application has failed to launch,
	// so that it can cancel the application startup notification started in
	// g_app_launch_context_get_startup_notify_id().
	//
	// The function takes the following parameters:
	//
	//   - startupNotifyId: startup notification id that was returned by
	//     g_app_launch_context_get_startup_notify_id().
	LaunchFailed func(startupNotifyId string)
	// The function takes the following parameters:
	//
	//   - info
	//   - platformData
	LaunchStarted func(info AppInfor, platformData *glib.Variant)
	// The function takes the following parameters:
	//
	//   - info
	//   - platformData
	Launched func(info AppInfor, platformData *glib.Variant)
}

func defaultAppLaunchContextOverrides(v *AppLaunchContext) AppLaunchContextOverrides {
	return AppLaunchContextOverrides{
		Display:         v.display,
		StartupNotifyID: v.startupNotifyID,
		LaunchFailed:    v.launchFailed,
		LaunchStarted:   v.launchStarted,
		Launched:        v.launched,
	}
}

// AppLaunchContext: integrating the launch with the launching application.
// This is used to handle for instance startup notification and launching the
// new application on the same screen as the launching window.
type AppLaunchContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppLaunchContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AppLaunchContext, *AppLaunchContextClass, AppLaunchContextOverrides](
		GTypeAppLaunchContext,
		initAppLaunchContextClass,
		wrapAppLaunchContext,
		defaultAppLaunchContextOverrides,
	)
}

func initAppLaunchContextClass(gclass unsafe.Pointer, overrides AppLaunchContextOverrides, classInitFunc func(*AppLaunchContextClass)) {
	pclass := (*C.GAppLaunchContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAppLaunchContext))))

	if overrides.Display != nil {
		pclass.get_display = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_get_display)
	}

	if overrides.StartupNotifyID != nil {
		pclass.get_startup_notify_id = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_get_startup_notify_id)
	}

	if overrides.LaunchFailed != nil {
		pclass.launch_failed = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_launch_failed)
	}

	if overrides.LaunchStarted != nil {
		pclass.launch_started = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_launch_started)
	}

	if overrides.Launched != nil {
		pclass.launched = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_launched)
	}

	if classInitFunc != nil {
		class := (*AppLaunchContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAppLaunchContext(obj *coreglib.Object) *AppLaunchContext {
	return &AppLaunchContext{
		Object: obj,
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	return wrapAppLaunchContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectLaunchFailed signal is emitted when a Info launch fails. The startup
// notification id is provided, so that the launcher can cancel the startup
// notification.
//
// Because a launch operation may involve spawning multiple instances of the
// target application, you should expect this signal to be emitted multiple
// times, one for each spawned instance.
func (context *AppLaunchContext) ConnectLaunchFailed(f func(startupNotifyId string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "launch-failed", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunchFailed), f)
}

// ConnectLaunchStarted signal is emitted when a Info is about to be launched.
// If non-null the platform_data is an GVariant dictionary mapping strings to
// variants (ie a{sv}), which contains additional, platform-specific data about
// this launch. On UNIX, at least the startup-notification-id keys will be
// present.
//
// The value of the startup-notification-id key (type s) is a startup
// notification ID corresponding to the format from the [startup-notification
// specification](https://specifications.freedesktop.org/startup-notification-spec/startup-notification-0.1.txt).
// It allows tracking the progress of the launchee through startup.
//
// It is guaranteed that this signal is followed by either a
// LaunchContext::launched or LaunchContext::launch-failed signal.
//
// Because a launch operation may involve spawning multiple instances of the
// target application, you should expect this signal to be emitted multiple
// times, one for each spawned instance.
func (context *AppLaunchContext) ConnectLaunchStarted(f func(info AppInfor, platformData *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "launch-started", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunchStarted), f)
}

// ConnectLaunched signal is emitted when a Info is successfully launched.
//
// Because a launch operation may involve spawning multiple instances of the
// target application, you should expect this signal to be emitted multiple
// times, one time for each spawned instance.
//
// The platform_data is an GVariant dictionary mapping strings to variants (ie
// a{sv}), which contains additional, platform-specific data about this launch.
// On UNIX, at least the pid and startup-notification-id keys will be present.
//
// Since 2.72 the pid may be 0 if the process id wasn't known (for example
// if the process was launched via D-Bus). The pid may not be set at all in
// subsequent releases.
//
// On Windows, pid is guaranteed to be valid only for the duration of the
// LaunchContext::launched signal emission; after the signal is emitted,
// GLib will call g_spawn_close_pid(). If you need to keep the #GPid after the
// signal has been emitted, then you can duplicate pid using DuplicateHandle().
func (context *AppLaunchContext) ConnectLaunched(f func(info AppInfor, platformData *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "launched", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunched), f)
}

// NewAppLaunchContext creates a new application launch context. This is
// not normally used, instead you instantiate a subclass of this, such as
// AppLaunchContext.
//
// The function returns the following values:
//
//   - appLaunchContext: LaunchContext.
func NewAppLaunchContext() *AppLaunchContext {
	var _cret *C.GAppLaunchContext // in

	_cret = C.g_app_launch_context_new()

	var _appLaunchContext *AppLaunchContext // out

	_appLaunchContext = wrapAppLaunchContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appLaunchContext
}

// Display gets the display string for the context. This is used to ensure new
// applications are started on the same display as the launching application,
// by setting the DISPLAY environment variable.
//
// The function takes the following parameters:
//
//   - info: Info.
//   - files of #GFile objects.
//
// The function returns the following values:
//
//   - utf8 (optional): display string for the display.
func (context *AppLaunchContext) Display(info AppInfor, files []Filer) string {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C.g_app_launch_context_get_display(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Environment gets the complete environment variable list to be passed to
// the child process when context is used to launch an application. This is a
// NULL-terminated array of strings, where each string has the form KEY=VALUE.
//
// The function returns the following values:
//
//   - filenames: the child's environment.
func (context *AppLaunchContext) Environment() []string {
	var _arg0 *C.GAppLaunchContext // out
	var _cret **C.char             // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.g_app_launch_context_get_environment(_arg0)
	runtime.KeepAlive(context)

	var _filenames []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// StartupNotifyID initiates startup notification for the application and
// returns the XDG_ACTIVATION_TOKEN or DESKTOP_STARTUP_ID for the launched
// operation, if supported.
//
// The returned token may be referred to equivalently as an
// activation token (using Wayland terminology) or a startup
// sequence ID (using X11 terminology). The two are interoperable
// (https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
//
// Activation tokens are defined in the XDG Activation Protocol
// (https://wayland.app/protocols/xdg-activation-v1), and startup notification
// IDs are defined in the freedesktop.org Startup Notification Protocol
// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
//
// Support for the XDG Activation Protocol was added in GLib 2.76.
//
// The function takes the following parameters:
//
//   - info: Info.
//   - files of #GFile objects.
//
// The function returns the following values:
//
//   - utf8 (optional): startup notification ID for the application, or NULL if
//     not supported.
func (context *AppLaunchContext) StartupNotifyID(info AppInfor, files []Filer) string {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C.g_app_launch_context_get_startup_notify_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// LaunchFailed: called when an application has failed to launch,
// so that it can cancel the application startup notification started in
// g_app_launch_context_get_startup_notify_id().
//
// The function takes the following parameters:
//
//   - startupNotifyId: startup notification id that was returned by
//     g_app_launch_context_get_startup_notify_id().
func (context *AppLaunchContext) LaunchFailed(startupNotifyId string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_launch_failed(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(startupNotifyId)
}

// Setenv arranges for variable to be set to value in the child's environment
// when context is used to launch an application.
//
// The function takes the following parameters:
//
//   - variable: environment variable to set.
//   - value for to set the variable to.
func (context *AppLaunchContext) Setenv(variable, value string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out
	var _arg2 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_app_launch_context_setenv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
}

// Unsetenv arranges for variable to be unset in the child's environment when
// context is used to launch an application.
//
// The function takes the following parameters:
//
//   - variable: environment variable to remove.
func (context *AppLaunchContext) Unsetenv(variable string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_unsetenv(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(variable)
}

// Display gets the display string for the context. This is used to ensure new
// applications are started on the same display as the launching application,
// by setting the DISPLAY environment variable.
//
// The function takes the following parameters:
//
//   - info: Info.
//   - files of #GFile objects.
//
// The function returns the following values:
//
//   - utf8 (optional): display string for the display.
func (context *AppLaunchContext) display(info AppInfor, files []Filer) string {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_display

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C._gotk4_gio2_AppLaunchContext_virtual_get_display(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// startupNotifyID initiates startup notification for the application and
// returns the XDG_ACTIVATION_TOKEN or DESKTOP_STARTUP_ID for the launched
// operation, if supported.
//
// The returned token may be referred to equivalently as an
// activation token (using Wayland terminology) or a startup
// sequence ID (using X11 terminology). The two are interoperable
// (https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
//
// Activation tokens are defined in the XDG Activation Protocol
// (https://wayland.app/protocols/xdg-activation-v1), and startup notification
// IDs are defined in the freedesktop.org Startup Notification Protocol
// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
//
// Support for the XDG Activation Protocol was added in GLib 2.76.
//
// The function takes the following parameters:
//
//   - info: Info.
//   - files of #GFile objects.
//
// The function returns the following values:
//
//   - utf8 (optional): startup notification ID for the application, or NULL if
//     not supported.
func (context *AppLaunchContext) startupNotifyID(info AppInfor, files []Filer) string {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_startup_notify_id

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C._gotk4_gio2_AppLaunchContext_virtual_get_startup_notify_id(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// launchFailed: called when an application has failed to launch,
// so that it can cancel the application startup notification started in
// g_app_launch_context_get_startup_notify_id().
//
// The function takes the following parameters:
//
//   - startupNotifyId: startup notification id that was returned by
//     g_app_launch_context_get_startup_notify_id().
func (context *AppLaunchContext) launchFailed(startupNotifyId string) {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.launch_failed

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppLaunchContext_virtual_launch_failed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(startupNotifyId)
}

// The function takes the following parameters:
//
//   - info
//   - platformData
func (context *AppLaunchContext) launchStarted(info AppInfor, platformData *glib.Variant) {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.launch_started

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GVariant          // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_AppLaunchContext_virtual_launch_started(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(platformData)
}

// The function takes the following parameters:
//
//   - info
//   - platformData
func (context *AppLaunchContext) launched(info AppInfor, platformData *glib.Variant) {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.launched

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GVariant          // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_AppLaunchContext_virtual_launched(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(platformData)
}

// ApplicationOverrides contains methods that are overridable.
type ApplicationOverrides struct {
	// Activate activates the application.
	//
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	//
	// The application must be registered before calling this function.
	Activate func()
	// AddPlatformData: invoked (locally) to add 'platform data' to be sent to
	// the primary instance when activating, opening or invoking actions.
	AddPlatformData func(builder *glib.VariantBuilder)
	// AfterEmit: invoked on the primary instance after 'activate', 'open',
	// 'command-line' or any action invocation, gets the 'platform data' from
	// the calling instance.
	AfterEmit func(platformData *glib.Variant)
	// BeforeEmit: invoked on the primary instance before 'activate', 'open',
	// 'command-line' or any action invocation, gets the 'platform data' from
	// the calling instance.
	BeforeEmit func(platformData *glib.Variant)
	// CommandLine: invoked on the primary instance when a command-line is not
	// handled locally.
	CommandLine func(commandLine *ApplicationCommandLine) int
	// DBusRegister: invoked locally during registration, if the application
	// is using its D-Bus backend. You can use this to export extra objects
	// on the bus, that need to exist before the application tries to own the
	// bus name. The function is passed the BusConnection to to session bus,
	// and the object path that #GApplication will use to export its D-Bus API.
	// If this function returns TRUE, registration will proceed; otherwise
	// registration will abort. Since: 2.34.
	//
	// The function takes the following parameters:
	//
	//   - connection
	//   - objectPath
	DBusRegister func(connection *DBusConnection, objectPath string) error
	// DBusUnregister: invoked locally during unregistration, if the application
	// is using its D-Bus backend. Use this to undo anything done by the
	// dbus_register vfunc. Since: 2.34.
	//
	// The function takes the following parameters:
	//
	//   - connection
	//   - objectPath
	DBusUnregister func(connection *DBusConnection, objectPath string)
	// HandleLocalOptions: invoked locally after the parsing of the commandline
	// options has occurred. Since: 2.40.
	HandleLocalOptions func(options *glib.VariantDict) int
	// NameLost: invoked when another instance is taking over the name. Since:
	// 2.60.
	NameLost func() bool
	// Open opens the given files.
	//
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	//
	// n_files must be greater than zero.
	//
	// hint is simply passed through to the ::open signal. It is intended to
	// be used by applications that have multiple modes for opening files (eg:
	// "view" vs "edit", etc). Unless you have a need for this functionality,
	// you should use "".
	//
	// The application must be registered before calling this function and it
	// must have the G_APPLICATION_HANDLES_OPEN flag set.
	//
	// The function takes the following parameters:
	//
	//   - files: array of #GFiles to open.
	//   - hint (or ""), but never NULL.
	Open func(files []Filer, hint string)
	// QuitMainloop: used to be invoked on the primary instance when the use
	// count of the application drops to zero (and after any inactivity timeout,
	// if requested). Not used anymore since 2.32.
	QuitMainloop func()
	// RunMainloop: used to be invoked on the primary instance from
	// g_application_run() if the use-count is non-zero. Since 2.32,
	// GApplication is iterating the main context directly and is not using
	// run_mainloop anymore.
	RunMainloop func()
	// Shutdown: invoked only on the registered primary instance immediately
	// after the main loop terminates.
	Shutdown func()
	// Startup: invoked on the primary instance immediately after registration.
	Startup func()
}

func defaultApplicationOverrides(v *Application) ApplicationOverrides {
	return ApplicationOverrides{
		Activate:           v.activate,
		AddPlatformData:    v.addPlatformData,
		AfterEmit:          v.afterEmit,
		BeforeEmit:         v.beforeEmit,
		CommandLine:        v.commandLine,
		DBusRegister:       v.dBusRegister,
		DBusUnregister:     v.dBusUnregister,
		HandleLocalOptions: v.handleLocalOptions,
		NameLost:           v.nameLost,
		Open:               v.open,
		QuitMainloop:       v.quitMainloop,
		RunMainloop:        v.runMainloop,
		Shutdown:           v.shutdown,
		Startup:            v.startup,
	}
}

// Application: GApplication is the core class for application support.
//
// A GApplication is the foundation of an application. It wraps some low-level
// platform-specific services and is intended to act as the foundation for
// higher-level application classes such as GtkApplication or MxApplication. In
// general, you should not use this class outside of a higher level framework.
//
// GApplication provides convenient life-cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using gio.Application.Hold() and gio.Application.Release(). If it drops to
// zero, the application exits. Higher-level classes such as GtkApplication
// employ the use count to ensure that the application stays alive as long as it
// has any opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent,
// but corresponds roughly to a graphical desktop login. When your application
// is launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling gio.Application.Run(). All checks for uniqueness
// are done internally. If the application is the primary instance then the
// startup signal is emitted and the mainloop runs. If the application is
// not the primary instance then a signal is sent to the primary instance and
// gio.Application.Run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier
// is the same as that of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: com.example.MyApp, org.example.internal_apps.Calculator,
// org._7_zip.Archiver. For details on valid application identifiers, see
// gio.Application().IDIsValid.
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application
// is scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with
// the shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is
// not running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in gio.Application.Register()).
// Unfortunately, this means that you cannot use gio.Application:is-remote to
// decide if you want to register object paths.
//
// GApplication also implements the gio.ActionGroup and gio.ActionMap
// interfaces and lets you easily export actions by adding them with
// gio.ActionMap.AddAction(). When invoking an action by calling
// gio.ActionGroup.ActivateAction() on the application, it is always invoked
// in the primary instance. The actions are also exported on the session bus,
// and GIO provides the gio.DBusActionGroup wrapper to conveniently access
// them remotely. GIO provides a gio.DBusMenuModel wrapper for remote access to
// exported gio.MenuModels.
//
// Note: Due to the fact that actions are exported on the session bus, using
// maybe parameters is not supported, since D-Bus does not support maybe types.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The gio.Application::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some platform data from the launching instance
// to the primary instance, in the form of a glib.Variant dictionary
// mapping strings to variants. To use platform data, override the
// gio.Application.BeforeEmit() or gio.Application.AfterEmit() virtual functions
// in your GApplication subclass. When dealing with gio.ApplicationCommandLine
// objects, the platform data is directly available via
// gio.ApplicationCommandLine.GetCwd(), gio.ApplicationCommandLine.GetEnviron()
// and gio.ApplicationCommandLine.GetPlatformData().
//
// As the name indicates, the platform data may vary depending on the
// operating system, but it always includes the current directory (key cwd),
// and optionally the environment (ie the set of environment variables and
// their values) of the calling process (key environ). The environment is only
// added to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// GApplication subclasses can add their own platform data by overriding
// the gio.Application.AddPlatformData() virtual function. For instance,
// GtkApplication adds startup notification data in this way.
//
// To parse commandline arguments you may handle the
// gio.Application::command-line signal or override the
// gio.Application.LocalCommandLine() virtual funcion, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a
// GApplication, see gapplication-example-open.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication,
// see gapplication-example-actions.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with
// GApplication, see gapplication-example-dbushooks.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
type Application struct {
	_ [0]func() // equal guard
	*coreglib.Object

	ActionGroup
	ActionMap
}

var (
	_ coreglib.Objector = (*Application)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Application, *ApplicationClass, ApplicationOverrides](
		GTypeApplication,
		initApplicationClass,
		wrapApplication,
		defaultApplicationOverrides,
	)
}

func initApplicationClass(gclass unsafe.Pointer, overrides ApplicationOverrides, classInitFunc func(*ApplicationClass)) {
	pclass := (*C.GApplicationClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeApplication))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gio2_ApplicationClass_activate)
	}

	if overrides.AddPlatformData != nil {
		pclass.add_platform_data = (*[0]byte)(C._gotk4_gio2_ApplicationClass_add_platform_data)
	}

	if overrides.AfterEmit != nil {
		pclass.after_emit = (*[0]byte)(C._gotk4_gio2_ApplicationClass_after_emit)
	}

	if overrides.BeforeEmit != nil {
		pclass.before_emit = (*[0]byte)(C._gotk4_gio2_ApplicationClass_before_emit)
	}

	if overrides.CommandLine != nil {
		pclass.command_line = (*[0]byte)(C._gotk4_gio2_ApplicationClass_command_line)
	}

	if overrides.DBusRegister != nil {
		pclass.dbus_register = (*[0]byte)(C._gotk4_gio2_ApplicationClass_dbus_register)
	}

	if overrides.DBusUnregister != nil {
		pclass.dbus_unregister = (*[0]byte)(C._gotk4_gio2_ApplicationClass_dbus_unregister)
	}

	if overrides.HandleLocalOptions != nil {
		pclass.handle_local_options = (*[0]byte)(C._gotk4_gio2_ApplicationClass_handle_local_options)
	}

	if overrides.NameLost != nil {
		pclass.name_lost = (*[0]byte)(C._gotk4_gio2_ApplicationClass_name_lost)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gio2_ApplicationClass_open)
	}

	if overrides.QuitMainloop != nil {
		pclass.quit_mainloop = (*[0]byte)(C._gotk4_gio2_ApplicationClass_quit_mainloop)
	}

	if overrides.RunMainloop != nil {
		pclass.run_mainloop = (*[0]byte)(C._gotk4_gio2_ApplicationClass_run_mainloop)
	}

	if overrides.Shutdown != nil {
		pclass.shutdown = (*[0]byte)(C._gotk4_gio2_ApplicationClass_shutdown)
	}

	if overrides.Startup != nil {
		pclass.startup = (*[0]byte)(C._gotk4_gio2_ApplicationClass_startup)
	}

	if classInitFunc != nil {
		class := (*ApplicationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplication(obj *coreglib.Object) *Application {
	return &Application{
		Object: obj,
		ActionGroup: ActionGroup{
			Object: obj,
		},
		ActionMap: ActionMap{
			Object: obj,
		},
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	return wrapApplication(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate signal is emitted on the primary instance when an activation
// occurs. See g_application_activate().
func (application *Application) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "activate", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectActivate), f)
}

// ConnectCommandLine signal is emitted on the primary instance when a
// commandline is not handled locally. See g_application_run() and the
// CommandLine documentation for more information.
func (application *Application) ConnectCommandLine(f func(commandLine *ApplicationCommandLine) (gint int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "command-line", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectCommandLine), f)
}

// ConnectHandleLocalOptions signal is emitted on the local instance after the
// parsing of the commandline options has occurred.
//
// You can add options to be recognised during commandline option parsing using
// g_application_add_main_option_entries() and g_application_add_option_group().
//
// Signal handlers can inspect options (along with values pointed to from
// the arg_data of an installed Entrys) in order to decide to perform certain
// actions, including direct local handling (which may be useful for options
// like --version).
//
// In the event that the application is marked
// G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will send
// the options dictionary to the primary instance where it can be read with
// g_application_command_line_get_options_dict(). The signal handler can modify
// the dictionary before returning, and the modified dictionary will be sent.
//
// In the event that G_APPLICATION_HANDLES_COMMAND_LINE is not set, "normal
// processing" will treat the remaining uncollected command line arguments as
// filenames or URIs. If there are no arguments, the application is activated
// by g_application_activate(). One or more arguments results in a call to
// g_application_open().
//
// If you want to handle the local commandline arguments for
// yourself by converting them to calls to g_application_open() or
// g_action_group_activate_action() then you must be sure to register the
// application first. You should probably not call g_application_activate() for
// yourself, however: just return -1 and allow the default handler to do it for
// you. This will ensure that the --gapplication-service switch works properly
// (i.e. no activation in that case).
//
// Note that this signal is emitted from the default implementation of
// local_command_line(). If you override that function and don't chain up then
// this signal will never be emitted.
//
// You can override local_command_line() if you need more powerful capabilities
// than what is provided here, but this should not normally be required.
func (application *Application) ConnectHandleLocalOptions(f func(options *glib.VariantDict) (gint int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "handle-local-options", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectHandleLocalOptions), f)
}

// ConnectNameLost signal is emitted only on the registered primary instance
// when a new instance has taken over. This can only happen if the application
// is using the G_APPLICATION_ALLOW_REPLACEMENT flag.
//
// The default handler for this signal calls g_application_quit().
func (application *Application) ConnectNameLost(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "name-lost", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectNameLost), f)
}

// ConnectOpen signal is emitted on the primary instance when there are files to
// open. See g_application_open() for more information.
func (application *Application) ConnectOpen(f func(files []Filer, hint string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "open", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectOpen), f)
}

// ConnectShutdown signal is emitted only on the registered primary instance
// immediately after the main loop terminates.
func (application *Application) ConnectShutdown(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "shutdown", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectShutdown), f)
}

// ConnectStartup signal is emitted on the primary instance immediately after
// registration. See g_application_register().
func (application *Application) ConnectStartup(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "startup", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectStartup), f)
}

// NewApplication creates a new #GApplication instance.
//
// If non-NULL, the application id must be valid. See
// g_application_id_is_valid().
//
// If no application ID is given then some features of #GApplication (most
// notably application uniqueness) will be disabled.
//
// The function takes the following parameters:
//
//   - applicationId (optional): application id.
//   - flags: application flags.
//
// The function returns the following values:
//
//   - application: new #GApplication instance.
func NewApplication(applicationId string, flags ApplicationFlags) *Application {
	var _arg1 *C.gchar            // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GApplication     // in

	if applicationId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GApplicationFlags(flags)

	_cret = C.g_application_new(_arg1, _arg2)
	runtime.KeepAlive(applicationId)
	runtime.KeepAlive(flags)

	var _application *Application // out

	_application = wrapApplication(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

// Activate activates the application.
//
// In essence, this results in the #GApplication::activate signal being emitted
// in the primary instance.
//
// The application must be registered before calling this function.
func (application *Application) Activate() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_activate(_arg0)
	runtime.KeepAlive(application)
}

// AddMainOption: add an option to be handled by application.
//
// Calling this function is the equivalent of calling
// g_application_add_main_option_entries() with a single Entry that has its
// arg_data member set to NULL.
//
// The parsed arguments will be packed into a Dict which is passed to
// #GApplication::handle-local-options. If G_APPLICATION_HANDLES_COMMAND_LINE
// is set, then it will also be sent to the primary instance. See
// g_application_add_main_option_entries() for more details.
//
// See Entry for more documentation of the arguments.
//
// The function takes the following parameters:
//
//   - longName: long name of an option used to specify it in a commandline.
//   - shortName: short name of an option.
//   - flags from Flags.
//   - arg: type of the option, as a Arg.
//   - description for the option in --help output.
//   - argDescription (optional): placeholder to use for the extra argument
//     parsed by the option in --help output.
func (application *Application) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description, argDescription string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.char         // out
	var _arg2 C.char          // out
	var _arg3 C.GOptionFlags  // out
	var _arg4 C.GOptionArg    // out
	var _arg5 *C.char         // out
	var _arg6 *C.char         // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(longName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.char(shortName)
	_arg3 = C.GOptionFlags(flags)
	_arg4 = C.GOptionArg(arg)
	_arg5 = (*C.char)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg5))
	if argDescription != "" {
		_arg6 = (*C.char)(unsafe.Pointer(C.CString(argDescription)))
		defer C.free(unsafe.Pointer(_arg6))
	}

	C.g_application_add_main_option(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(application)
	runtime.KeepAlive(longName)
	runtime.KeepAlive(shortName)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(arg)
	runtime.KeepAlive(description)
	runtime.KeepAlive(argDescription)
}

// AddMainOptionEntries adds main option entries to be handled by application.
//
// This function is comparable to g_option_context_add_main_entries().
//
// After the commandline arguments are parsed, the
// #GApplication::handle-local-options signal will be emitted. At this point,
// the application can inspect the values pointed to by arg_data in the given
// Entrys.
//
// Unlike Context, #GApplication supports giving a NULL arg_data for a
// non-callback Entry. This results in the argument in question being packed
// into a Dict which is also passed to #GApplication::handle-local-options,
// where it can be inspected and modified. If G_APPLICATION_HANDLES_COMMAND_LINE
// is set, then the resulting dictionary is sent to the primary instance,
// where g_application_command_line_get_options_dict() will return it.
// As it has been passed outside the process at this point, the types of all
// values in the options dict must be checked before being used. This "packing"
// is done according to the type of the argument -- booleans for normal flags,
// strings for strings, bytestrings for filenames, etc. The packing only occurs
// if the flag is given (ie: we do not pack a "false" #GVariant in the case that
// a flag is missing).
//
// In general, it is recommended that all commandline arguments are parsed
// locally. The options dictionary should then be used to transmit the result
// of the parsing to the primary instance, where g_variant_dict_lookup() can
// be used. For local options, it is possible to either use arg_data in the
// usual way, or to consult (and potentially remove) the option from the options
// dictionary.
//
// This function is new in GLib 2.40. Before then, the only real choice
// was to send all of the commandline arguments (options and all) to the
// primary instance for handling. #GApplication ignored them completely on
// the local side. Calling this function "opts in" to the new behaviour,
// and in particular, means that unrecognised options will be treated
// as errors. Unrecognised options have never been ignored when
// G_APPLICATION_HANDLES_COMMAND_LINE is unset.
//
// If #GApplication::handle-local-options needs to see the list of filenames,
// then the use of G_OPTION_REMAINING is recommended. If arg_data is NULL
// then G_OPTION_REMAINING can be used as a key into the options dictionary.
// If you do use G_OPTION_REMAINING then you need to handle these arguments for
// yourself because once they are consumed, they will no longer be visible to
// the default handling (which treats them as filenames to be opened).
//
// It is important to use the proper GVariant format when retrieving the options
// with g_variant_dict_lookup():
//
// - for G_OPTION_ARG_NONE, use b
//
// - for G_OPTION_ARG_STRING, use &s
//
// - for G_OPTION_ARG_INT, use i
//
// - for G_OPTION_ARG_INT64, use x
//
// - for G_OPTION_ARG_DOUBLE, use d
//
// - for G_OPTION_ARG_FILENAME, use ^&ay
//
// - for G_OPTION_ARG_STRING_ARRAY, use ^a&s
//
// - for G_OPTION_ARG_FILENAME_ARRAY, use ^a&ay.
//
// The function takes the following parameters:
//
//   - entries: the main options for the application.
func (application *Application) AddMainOptionEntries(entries []glib.OptionEntry) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionEntry // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	{
		_arg1 = (*C.GOptionEntry)(C.calloc(C.size_t((len(entries) + 1)), C.size_t(C.sizeof_GOptionEntry)))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(entries)+1)
			var zero C.GOptionEntry
			out[len(entries)] = zero
			for i := range entries {
				out[i] = *(*C.GOptionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
			}
		}
	}

	C.g_application_add_main_option_entries(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(entries)
}

// AddOptionGroup adds a Group to the commandline handling of application.
//
// This function is comparable to g_option_context_add_group().
//
// Unlike g_application_add_main_option_entries(), this function does not deal
// with NULL arg_data and never transmits options to the primary instance.
//
// The reason for that is because, by the time the options arrive at the primary
// instance, it is typically too late to do anything with them. Taking the GTK
// option group as an example: GTK will already have been initialised by the
// time the #GApplication::command-line handler runs. In the case that this is
// not the first-running instance of the application, the existing instance may
// already have been running for a very long time.
//
// This means that the options from Group are only really usable in the case
// that the instance of the application being run is the first instance. Passing
// options like --display= or --gdk-debug= on future runs will have no effect on
// the existing primary instance.
//
// Calling this function will cause the options in the supplied option
// group to be parsed, but it does not cause you to be "opted in" to the
// new functionality whereby unrecognised options are rejected even if
// G_APPLICATION_HANDLES_COMMAND_LINE was given.
//
// The function takes the following parameters:
//
//   - group: Group.
func (application *Application) AddOptionGroup(group *glib.OptionGroup) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionGroup // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GOptionGroup)(gextras.StructNative(unsafe.Pointer(group)))

	C.g_application_add_option_group(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(group)
}

// BindBusyProperty marks application as busy (see g_application_mark_busy())
// while property on object is TRUE.
//
// The binding holds a reference to application while it is active, but not to
// object. Instead, the binding is destroyed when object is finalized.
//
// The function takes the following parameters:
//
//   - object: #GObject.
//   - property: name of a boolean property of object.
func (application *Application) BindBusyProperty(object *coreglib.Object, property string) {
	var _arg0 *C.GApplication // out
	var _arg1 C.gpointer      // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_application_bind_busy_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(object)
	runtime.KeepAlive(property)
}

// ApplicationID gets the unique identifier for application.
//
// The function returns the following values:
//
//   - utf8 (optional): identifier for application, owned by application.
func (application *Application) ApplicationID() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_application_id(_arg0)
	runtime.KeepAlive(application)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DBusConnection gets the BusConnection being used by the application, or NULL.
//
// If #GApplication is using its D-Bus backend then this function will return
// the BusConnection being used for uniqueness and communication with the
// desktop environment and other instances of the application.
//
// If #GApplication is not using D-Bus then this function will return NULL.
// This includes the situation where the D-Bus backend would normally be in use
// but we were unable to connect to the bus.
//
// This function must not be called before the application has been registered.
// See g_application_get_is_registered().
//
// The function returns the following values:
//
//   - dBusConnection (optional) or NULL.
func (application *Application) DBusConnection() *DBusConnection {
	var _arg0 *C.GApplication    // out
	var _cret *C.GDBusConnection // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_dbus_connection(_arg0)
	runtime.KeepAlive(application)

	var _dBusConnection *DBusConnection // out

	if _cret != nil {
		_dBusConnection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _dBusConnection
}

// DBusObjectPath gets the D-Bus object path being used by the application,
// or NULL.
//
// If #GApplication is using its D-Bus backend then this function will return
// the D-Bus object path that #GApplication is using. If the application is
// the primary instance then there is an object published at this path. If the
// application is not the primary instance then the result of this function is
// undefined.
//
// If #GApplication is not using D-Bus then this function will return NULL.
// This includes the situation where the D-Bus backend would normally be in use
// but we were unable to connect to the bus.
//
// This function must not be called before the application has been registered.
// See g_application_get_is_registered().
//
// The function returns the following values:
//
//   - utf8 (optional): object path, or NULL.
func (application *Application) DBusObjectPath() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_dbus_object_path(_arg0)
	runtime.KeepAlive(application)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Flags gets the flags for application.
//
// See Flags.
//
// The function returns the following values:
//
//   - applicationFlags flags for application.
func (application *Application) Flags() ApplicationFlags {
	var _arg0 *C.GApplication     // out
	var _cret C.GApplicationFlags // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_flags(_arg0)
	runtime.KeepAlive(application)

	var _applicationFlags ApplicationFlags // out

	_applicationFlags = ApplicationFlags(_cret)

	return _applicationFlags
}

// InactivityTimeout gets the current inactivity timeout for the application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
//
// The function returns the following values:
//
//   - guint: timeout, in milliseconds.
func (application *Application) InactivityTimeout() uint {
	var _arg0 *C.GApplication // out
	var _cret C.guint         // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_inactivity_timeout(_arg0)
	runtime.KeepAlive(application)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsBusy gets the application's current busy state, as set through
// g_application_mark_busy() or g_application_bind_busy_property().
//
// The function returns the following values:
//
//   - ok: TRUE if application is currently marked as busy.
func (application *Application) IsBusy() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_is_busy(_arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRegistered checks if application is registered.
//
// An application is registered if g_application_register() has been
// successfully called.
//
// The function returns the following values:
//
//   - ok: TRUE if application is registered.
func (application *Application) IsRegistered() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_is_registered(_arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRemote checks if application is remote.
//
// If application is remote then it means that another instance of application
// already exists (the 'primary' instance). Calls to perform actions on
// application will result in the actions being performed by the primary
// instance.
//
// The value of this property cannot be accessed before g_application_register()
// has been called. See g_application_get_is_registered().
//
// The function returns the following values:
//
//   - ok: TRUE if application is remote.
func (application *Application) IsRemote() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_is_remote(_arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResourceBasePath gets the resource base path of application.
//
// See g_application_set_resource_base_path() for more information.
//
// The function returns the following values:
//
//   - utf8 (optional): base resource path, if one is set.
func (application *Application) ResourceBasePath() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_resource_base_path(_arg0)
	runtime.KeepAlive(application)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Version gets the version of application.
//
// The function returns the following values:
//
//   - utf8 (optional): version of application.
func (application *Application) Version() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_version(_arg0)
	runtime.KeepAlive(application)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Hold increases the use count of application.
//
// Use this function to indicate that the application has a reason to continue
// to run. For example, g_application_hold() is called by GTK when a toplevel
// window is on the screen.
//
// To cancel the hold, call g_application_release().
func (application *Application) Hold() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_hold(_arg0)
	runtime.KeepAlive(application)
}

// MarkBusy increases the busy count of application.
//
// Use this function to indicate that the application is busy, for instance
// while a long running operation is pending.
//
// The busy state will be exposed to other processes, so a session shell will
// use that information to indicate the state to the user (e.g. with a spinner).
//
// To cancel the busy indication, use g_application_unmark_busy().
//
// The application must be registered before calling this function.
func (application *Application) MarkBusy() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_mark_busy(_arg0)
	runtime.KeepAlive(application)
}

// Open opens the given files.
//
// In essence, this results in the #GApplication::open signal being emitted in
// the primary instance.
//
// n_files must be greater than zero.
//
// hint is simply passed through to the ::open signal. It is intended to be used
// by applications that have multiple modes for opening files (eg: "view" vs
// "edit", etc). Unless you have a need for this functionality, you should use
// "".
//
// The application must be registered before calling this function and it must
// have the G_APPLICATION_HANDLES_OPEN flag set.
//
// The function takes the following parameters:
//
//   - files: array of #GFiles to open.
//   - hint (or ""), but never NULL.
func (application *Application) Open(files []Filer, hint string) {
	var _arg0 *C.GApplication // out
	var _arg1 **C.GFile       // out
	var _arg2 C.gint
	var _arg3 *C.gchar // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg2 = (C.gint)(len(files))
	_arg1 = (**C.GFile)(C.calloc(C.size_t(len(files)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GFile)(_arg1), len(files))
		for i := range files {
			out[i] = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(files[i]).Native()))
		}
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(hint)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_application_open(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(files)
	runtime.KeepAlive(hint)
}

// Quit: immediately quits the application.
//
// Upon return to the mainloop, g_application_run() will return, calling only
// the 'shutdown' function before doing so.
//
// The hold count is ignored. Take care if your code has called
// g_application_hold() on the application and is therefore still expecting it
// to exist. (Note that you may have called g_application_hold() indirectly,
// for example through gtk_application_add_window().)
//
// The result of calling g_application_run() again after it returns is
// unspecified.
func (application *Application) Quit() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_quit(_arg0)
	runtime.KeepAlive(application)
}

// Register attempts registration of the application.
//
// This is the point at which the application discovers if it is the primary
// instance or merely acting as a remote for an already-existing primary
// instance. This is implemented by attempting to acquire the application
// identifier as a unique bus name on the session bus using GDBus.
//
// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given,
// then this process will always become the primary instance.
//
// Due to the internal architecture of GDBus, method calls can be dispatched
// at any time (even if a main loop is not running). For this reason, you must
// ensure that any object paths that you wish to register are registered before
// calling this function.
//
// If the application has already been registered then TRUE is returned with no
// work performed.
//
// The #GApplication::startup signal is emitted if registration succeeds and
// application is the primary instance (including the non-unique case).
//
// In the event of an error (such as cancellable being cancelled, or a
// failure to connect to the session bus), FALSE is returned and error is set
// appropriately.
//
// Note: the return value of this function is not an indicator that this
// instance is or is not the primary instance of the application. See
// g_application_get_is_remote() for that.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (application *Application) Register(ctx context.Context) error {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_application_register(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(application)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Release: decrease the use count of application.
//
// When the use count reaches zero, the application will stop running.
//
// Never call this function except to cancel the effect of a previous call to
// g_application_hold().
func (application *Application) Release() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_release(_arg0)
	runtime.KeepAlive(application)
}

// Run runs the application.
//
// This function is intended to be run from main() and its return value is
// intended to be returned by main(). Although you are expected to pass the
// argc, argv parameters from main() to this function, it is possible to pass
// NULL if argv is not available or commandline handling is not required. Note
// that on Windows, argc and argv are ignored, and g_win32_get_command_line() is
// called internally (for proper support of Unicode commandline arguments).
//
// #GApplication will attempt to parse the commandline arguments.
// You can add commandline flags to the list of recognised options
// by way of g_application_add_main_option_entries(). After this,
// the #GApplication::handle-local-options signal is emitted, from which the
// application can inspect the values of its Entrys.
//
// #GApplication::handle-local-options is a good place to handle options
// such as --version, where an immediate reply from the local process is
// desired (instead of communicating with an already-running instance).
// A #GApplication::handle-local-options handler can stop further processing
// by returning a non-negative value, which then becomes the exit status of the
// process.
//
// What happens next depends on the flags: if G_APPLICATION_HANDLES_COMMAND_LINE
// was specified then the remaining commandline arguments are sent to the
// primary instance, where a #GApplication::command-line signal is emitted.
// Otherwise, the remaining commandline arguments are assumed to be a list
// of files. If there are no files listed, the application is activated
// via the #GApplication::activate signal. If there are one or more files,
// and G_APPLICATION_HANDLES_OPEN was specified then the files are opened via
// the #GApplication::open signal.
//
// If you are interested in doing more complicated local handling of
// the commandline then you should implement your own #GApplication
// subclass and override local_command_line(). In this case,
// you most likely want to return TRUE from your local_command_line()
// implementation to suppress the default handling. See
// [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
// for an example.
//
// If, after the above is done, the use count of the application is zero then
// the exit status is returned immediately. If the use count is non-zero then
// the default main context is iterated until the use count falls to zero,
// at which point 0 is returned.
//
// If the G_APPLICATION_IS_SERVICE flag is set, then the service will run
// for as much as 10 seconds with a use count of zero while waiting for the
// message that caused the activation to arrive. After that, if the use count
// falls to zero the application will exit immediately, except in the case that
// g_application_set_inactivity_timeout() is in use.
//
// This function sets the prgname (g_set_prgname()), if not already set,
// to the basename of argv[0].
//
// Much like g_main_loop_run(), this function will acquire the main context for
// the duration that the application is running.
//
// Since 2.40, applications that are not explicitly flagged as services or
// launchers (ie: neither G_APPLICATION_IS_SERVICE or G_APPLICATION_IS_LAUNCHER
// are given as flags) will check (from the default handler for
// local_command_line) if "--gapplication-service" was given in the command
// line. If this flag is present then normal commandline processing is
// interrupted and the G_APPLICATION_IS_SERVICE flag is set. This provides
// a "compromise" solution whereby running an application directly from the
// commandline will invoke it in the normal way (which can be useful for
// debugging) while still allowing applications to be D-Bus activated in
// service mode. The D-Bus service file should invoke the executable with
// "--gapplication-service" as the sole commandline argument. This approach
// is suitable for use by most graphical applications but should not be used
// from applications like editors that need precise control over when processes
// invoked via the commandline will exit and what their exit status will be.
//
// The function takes the following parameters:
//
//   - argv (optional): the argv from main(), or NULL.
//
// The function returns the following values:
//
//   - gint: exit status.
func (application *Application) Run(argv []string) int {
	var _arg0 *C.GApplication // out
	var _arg2 **C.char        // out
	var _arg1 C.int
	var _cret C.int // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (C.int)(len(argv))
	_arg2 = (**C.char)(C.calloc(C.size_t(len(argv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((**C.char)(_arg2), len(argv))
		for i := range argv {
			out[i] = (*C.char)(unsafe.Pointer(C.CString(argv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_application_run(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(argv)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SendNotification sends a notification on behalf of application to the desktop
// shell. There is no guarantee that the notification is displayed immediately,
// or even at all.
//
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is activated.
//
// Modifying notification after this call has no effect. However, the object can
// be reused for a later call to this function.
//
// id may be any string that uniquely identifies the event for the application.
// It does not need to be in any special format. For example, "new-message"
// might be appropriate for a notification about new messages.
//
// If a previous notification was sent with the same id, it will be replaced
// with notification and shown again as if it was a new notification. This works
// even for notifications sent from a previous execution of the application,
// as long as id is the same string.
//
// id may be NULL, but it is impossible to replace or withdraw notifications
// without an id.
//
// If notification is no longer relevant, it can be withdrawn with
// g_application_withdraw_notification().
//
// It is an error to call this function if application has no application ID.
//
// The function takes the following parameters:
//
//   - id (optional) of the notification, or NULL.
//   - notification to send.
func (application *Application) SendNotification(id string, notification *Notification) {
	var _arg0 *C.GApplication  // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GNotification // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if id != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))

	C.g_application_send_notification(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
	runtime.KeepAlive(notification)
}

// SetActionGroup: this used to be how actions were associated with a
// #GApplication. Now there is Map for that.
//
// Deprecated: Use the Map interface instead. Never ever mix use of this API
// with use of Map on the same application or things will go very badly wrong.
// This function is known to introduce buggy behaviour (ie: signals not emitted
// on changes to the action group), so you should really use Map instead.
//
// The function takes the following parameters:
//
//   - actionGroup (optional) or NULL.
func (application *Application) SetActionGroup(actionGroup ActionGrouper) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GActionGroup // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if actionGroup != nil {
		_arg1 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	}

	C.g_application_set_action_group(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(actionGroup)
}

// SetApplicationID sets the unique identifier for application.
//
// The application id can only be modified if application has not yet been
// registered.
//
// If non-NULL, the application id must be valid. See
// g_application_id_is_valid().
//
// The function takes the following parameters:
//
//   - applicationId (optional): identifier for application.
func (application *Application) SetApplicationID(applicationId string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if applicationId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_application_id(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(applicationId)
}

// SetDefault sets or unsets the default application for the process,
// as returned by g_application_get_default().
//
// This function does not take its own reference on application. If application
// is destroyed then the default application will revert back to NULL.
func (application *Application) SetDefault() {
	var _arg0 *C.GApplication // out

	if application != nil {
		_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	}

	C.g_application_set_default(_arg0)
	runtime.KeepAlive(application)
}

// SetFlags sets the flags for application.
//
// The flags can only be modified if application has not yet been registered.
//
// See Flags.
//
// The function takes the following parameters:
//
//   - flags for application.
func (application *Application) SetFlags(flags ApplicationFlags) {
	var _arg0 *C.GApplication     // out
	var _arg1 C.GApplicationFlags // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.GApplicationFlags(flags)

	C.g_application_set_flags(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(flags)
}

// SetInactivityTimeout sets the current inactivity timeout for the application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
//
// This call has no side effects of its own. The value set here is only used for
// next time g_application_release() drops the use count to zero. Any timeouts
// currently in progress are not impacted.
//
// The function takes the following parameters:
//
//   - inactivityTimeout: timeout, in milliseconds.
func (application *Application) SetInactivityTimeout(inactivityTimeout uint) {
	var _arg0 *C.GApplication // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.guint(inactivityTimeout)

	C.g_application_set_inactivity_timeout(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(inactivityTimeout)
}

// SetOptionContextDescription adds a description to the application option
// context.
//
// See g_option_context_set_description() for more information.
//
// The function takes the following parameters:
//
//   - description (optional): string to be shown in --help output after the
//     list of options, or NULL.
func (application *Application) SetOptionContextDescription(description string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if description != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_option_context_description(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(description)
}

// SetOptionContextParameterString sets the parameter string to be used by the
// commandline handling of application.
//
// This function registers the argument to be passed to g_option_context_new()
// when the internal Context of application is created.
//
// See g_option_context_new() for more information about parameter_string.
//
// The function takes the following parameters:
//
//   - parameterString (optional): string which is displayed in the first line
//     of --help output, after the usage summary programname [OPTION...].
func (application *Application) SetOptionContextParameterString(parameterString string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if parameterString != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(parameterString)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_option_context_parameter_string(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(parameterString)
}

// SetOptionContextSummary adds a summary to the application option context.
//
// See g_option_context_set_summary() for more information.
//
// The function takes the following parameters:
//
//   - summary (optional): string to be shown in --help output before the list
//     of options, or NULL.
func (application *Application) SetOptionContextSummary(summary string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if summary != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(summary)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_option_context_summary(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(summary)
}

// SetResourceBasePath sets (or unsets) the base resource path of application.
//
// The path is used to automatically load various [application
// resources][gresource] such as menu layouts and action descriptions. The
// various types of resources will be found at fixed names relative to the given
// base path.
//
// By default, the resource base path is determined from the application ID by
// prefixing '/' and replacing each '.' with '/'. This is done at the time that
// the #GApplication object is constructed. Changes to the application ID after
// that point will not have an impact on the resource base path.
//
// As an example, if the application has an ID of "org.example.app" then
// the default resource base path will be "/org/example/app". If this is a
// Application (and you have not manually changed the path) then Gtk will then
// search for the menus of the application at "/org/example/app/gtk/menus.ui".
//
// See #GResource for more information about adding resources to your
// application.
//
// You can disable automatic resource loading functionality by setting the path
// to NULL.
//
// Changing the resource base path once the application is running is not
// recommended. The point at which the resource path is consulted for forming
// paths for various purposes is unspecified. When writing a sub-class of
// #GApplication you should either set the #GApplication:resource-base-path
// property at construction time, or call this function during the
// instance initialization. Alternatively, you can call this function in
// the Class.startup virtual function, before chaining up to the parent
// implementation.
//
// The function takes the following parameters:
//
//   - resourcePath (optional): resource path to use.
func (application *Application) SetResourceBasePath(resourcePath string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if resourcePath != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_resource_base_path(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(resourcePath)
}

// SetVersion sets the version number of application. This will be used to
// implement a --version command line argument
//
// The application version can only be modified if application has not yet been
// registered.
//
// The function takes the following parameters:
//
//   - version of application.
func (application *Application) SetVersion(version string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(version)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_set_version(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(version)
}

// UnbindBusyProperty destroys a binding between property and
// the busy state of application that was previously created with
// g_application_bind_busy_property().
//
// The function takes the following parameters:
//
//   - object: #GObject.
//   - property: name of a boolean property of object.
func (application *Application) UnbindBusyProperty(object *coreglib.Object, property string) {
	var _arg0 *C.GApplication // out
	var _arg1 C.gpointer      // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_application_unbind_busy_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(object)
	runtime.KeepAlive(property)
}

// UnmarkBusy decreases the busy count of application.
//
// When the busy count reaches zero, the new state will be propagated to other
// processes.
//
// This function must only be called to cancel the effect of a previous call to
// g_application_mark_busy().
func (application *Application) UnmarkBusy() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_unmark_busy(_arg0)
	runtime.KeepAlive(application)
}

// WithdrawNotification withdraws a notification that was sent with
// g_application_send_notification().
//
// This call does nothing if a notification with id doesn't exist or the
// notification was never sent.
//
// This function works even for notifications sent in previous executions of
// this application, as long id is the same as it was for the sent notification.
//
// Note that notifications are dismissed when the user clicks on one of the
// buttons in a notification or triggers its default action, so there is no need
// to explicitly withdraw the notification in that case.
//
// The function takes the following parameters:
//
//   - id of a previously sent notification.
func (application *Application) WithdrawNotification(id string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_withdraw_notification(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
}

// Activate activates the application.
//
// In essence, this results in the #GApplication::activate signal being emitted
// in the primary instance.
//
// The application must be registered before calling this function.
func (application *Application) activate() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.activate

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

// addPlatformData: invoked (locally) to add 'platform data' to be sent to the
// primary instance when activating, opening or invoking actions.
func (application *Application) addPlatformData(builder *glib.VariantBuilder) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.add_platform_data

	var _arg0 *C.GApplication    // out
	var _arg1 *C.GVariantBuilder // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	C._gotk4_gio2_Application_virtual_add_platform_data(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(builder)
}

// afterEmit: invoked on the primary instance after 'activate', 'open',
// 'command-line' or any action invocation, gets the 'platform data' from the
// calling instance.
func (application *Application) afterEmit(platformData *glib.Variant) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.after_emit

	var _arg0 *C.GApplication // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_Application_virtual_after_emit(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(platformData)
}

// beforeEmit: invoked on the primary instance before 'activate', 'open',
// 'command-line' or any action invocation, gets the 'platform data' from the
// calling instance.
func (application *Application) beforeEmit(platformData *glib.Variant) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.before_emit

	var _arg0 *C.GApplication // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_Application_virtual_before_emit(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(platformData)
}

// commandLine: invoked on the primary instance when a command-line is not
// handled locally.
func (application *Application) commandLine(commandLine *ApplicationCommandLine) int {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.command_line

	var _arg0 *C.GApplication            // out
	var _arg1 *C.GApplicationCommandLine // out
	var _cret C.int                      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(commandLine).Native()))

	_cret = C._gotk4_gio2_Application_virtual_command_line(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(commandLine)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// dBusRegister: invoked locally during registration, if the application is
// using its D-Bus backend. You can use this to export extra objects on the bus,
// that need to exist before the application tries to own the bus name. The
// function is passed the BusConnection to to session bus, and the object path
// that #GApplication will use to export its D-Bus API. If this function returns
// TRUE, registration will proceed; otherwise registration will abort. Since:
// 2.34.
//
// The function takes the following parameters:
//
//   - connection
//   - objectPath
func (application *Application) dBusRegister(connection *DBusConnection, objectPath string) error {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.dbus_register

	var _arg0 *C.GApplication    // out
	var _arg1 *C.GDBusConnection // out
	var _arg2 *C.gchar           // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gio2_Application_virtual_dbus_register(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(application)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// dBusUnregister: invoked locally during unregistration, if the application is
// using its D-Bus backend. Use this to undo anything done by the dbus_register
// vfunc. Since: 2.34.
//
// The function takes the following parameters:
//
//   - connection
//   - objectPath
func (application *Application) dBusUnregister(connection *DBusConnection, objectPath string) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.dbus_unregister

	var _arg0 *C.GApplication    // out
	var _arg1 *C.GDBusConnection // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gio2_Application_virtual_dbus_unregister(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)
}

// handleLocalOptions: invoked locally after the parsing of the commandline
// options has occurred. Since: 2.40.
func (application *Application) handleLocalOptions(options *glib.VariantDict) int {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.handle_local_options

	var _arg0 *C.GApplication // out
	var _arg1 *C.GVariantDict // out
	var _cret C.gint          // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(options)))

	_cret = C._gotk4_gio2_Application_virtual_handle_local_options(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(options)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// nameLost: invoked when another instance is taking over the name. Since: 2.60.
func (application *Application) nameLost() bool {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.name_lost

	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C._gotk4_gio2_Application_virtual_name_lost(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Open opens the given files.
//
// In essence, this results in the #GApplication::open signal being emitted in
// the primary instance.
//
// n_files must be greater than zero.
//
// hint is simply passed through to the ::open signal. It is intended to be used
// by applications that have multiple modes for opening files (eg: "view" vs
// "edit", etc). Unless you have a need for this functionality, you should use
// "".
//
// The application must be registered before calling this function and it must
// have the G_APPLICATION_HANDLES_OPEN flag set.
//
// The function takes the following parameters:
//
//   - files: array of #GFiles to open.
//   - hint (or ""), but never NULL.
func (application *Application) open(files []Filer, hint string) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.open

	var _arg0 *C.GApplication // out
	var _arg1 **C.GFile       // out
	var _arg2 C.gint
	var _arg3 *C.gchar // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg2 = (C.gint)(len(files))
	_arg1 = (**C.GFile)(C.calloc(C.size_t(len(files)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GFile)(_arg1), len(files))
		for i := range files {
			out[i] = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(files[i]).Native()))
		}
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(hint)))
	defer C.free(unsafe.Pointer(_arg3))

	C._gotk4_gio2_Application_virtual_open(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(files)
	runtime.KeepAlive(hint)
}

// quitMainloop: used to be invoked on the primary instance when the use
// count of the application drops to zero (and after any inactivity timeout,
// if requested). Not used anymore since 2.32.
func (application *Application) quitMainloop() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.quit_mainloop

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_quit_mainloop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

// runMainloop: used to be invoked on the primary instance from
// g_application_run() if the use-count is non-zero. Since 2.32, GApplication is
// iterating the main context directly and is not using run_mainloop anymore.
func (application *Application) runMainloop() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.run_mainloop

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_run_mainloop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

// Shutdown: invoked only on the registered primary instance immediately after
// the main loop terminates.
func (application *Application) shutdown() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.shutdown

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_shutdown(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

// Startup: invoked on the primary instance immediately after registration.
func (application *Application) startup() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.startup

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_startup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

// ApplicationGetDefault returns the default #GApplication instance for this
// process.
//
// Normally there is only one #GApplication per process and it becomes the
// default when it is created. You can exercise more control over this by using
// g_application_set_default().
//
// If there is no default application then NULL is returned.
//
// The function returns the following values:
//
//   - application (optional): default application for this process, or NULL.
func ApplicationGetDefault() *Application {
	var _cret *C.GApplication // in

	_cret = C.g_application_get_default()

	var _application *Application // out

	if _cret != nil {
		_application = wrapApplication(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _application
}

// ApplicationIDIsValid checks if application_id is a valid application
// identifier.
//
// A valid ID is required for calls to g_application_new() and
// g_application_set_application_id().
//
// Application identifiers follow the same format as D-Bus well-known bus names
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// For convenience, the restrictions on application identifiers are reproduced
// here:
//
// - Application identifiers are composed of 1 or more elements separated by a
// period (.) character. All elements must contain at least one character.
//
// - Each element must only contain the ASCII characters [A-Z][a-z][0-9]_-,
// with - discouraged in new application identifiers. Each element must not
// begin with a digit.
//
// - Application identifiers must contain at least one . (period) character (and
// thus at least two elements).
//
// - Application identifiers must not begin with a . (period) character.
//
// - Application identifiers must not exceed 255 characters.
//
// Note that the hyphen (-) character is allowed in application identifiers,
// but is problematic or not allowed in various specifications
// and APIs that refer to D-Bus, such as Flatpak application IDs
// (http://docs.flatpak.org/en/latest/introduction.html#identifiers),
// the DBusActivatable interface in the Desktop Entry Specification
// (https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
// and the convention that an application's "main" interface and object path
// resemble its application identifier and bus name. To avoid situations that
// require special-case handling, it is recommended that new application
// identifiers consistently replace hyphens with underscores.
//
// Like D-Bus interface names, application identifiers should start with the
// reversed DNS domain name of the author of the interface (in lower-case),
// and it is conventional for the rest of the application identifier to consist
// of words run together, with initial capital letters.
//
// As with D-Bus interface names, if the author's DNS domain name contains
// hyphen/minus characters they should be replaced by underscores, and if it
// contains leading digits they should be escaped by prepending an underscore.
// For example, if the owner of 7-zip.org used an application identifier for an
// archiving application, it might be named org._7_zip.Archiver.
//
// The function takes the following parameters:
//
//   - applicationId: potential application identifier.
//
// The function returns the following values:
//
//   - ok: TRUE if application_id is valid.
func ApplicationIDIsValid(applicationId string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_application_id_is_valid(_arg1)
	runtime.KeepAlive(applicationId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ApplicationCommandLineOverrides contains methods that are overridable.
type ApplicationCommandLineOverrides struct {
	// Done signals that command line processing is completed.
	//
	// For remote invocation, it causes the invoking process to terminate.
	//
	// For local invocation, it does nothing.
	//
	// This method should be called in the gio.Application::command-line
	// handler, after the exit status is set and all messages are printed.
	//
	// After this call, g_application_command_line_set_exit_status() has no
	// effect. Subsequent calls to this method are no-ops.
	//
	// This method is automatically called when the CommandLine object is
	// disposed  so you can omit the call in non-garbage collected languages.
	Done func()
	// Stdin gets the stdin of the invoking process.
	//
	// The Stream can be used to read data passed to the standard input of
	// the invoking process. This doesn't work on all platforms. Presently,
	// it is only available on UNIX when using a D-Bus daemon capable of passing
	// file descriptors. If stdin is not available then NULL will be returned.
	// In the future, support may be expanded to other platforms.
	//
	// You must only call this function once per commandline invocation.
	//
	// The function returns the following values:
	//
	//   - inputStream (optional) for stdin.
	Stdin func() InputStreamer
	// PrintLiteral prints a message using the stdout print handler in the
	// invoking process.
	//
	// Unlike g_application_command_line_print(), message is not a
	// printf()-style format string. Use this function if message contains
	// text you don't have control over, that could include printf() escape
	// sequences.
	//
	// The function takes the following parameters:
	//
	//   - message: message.
	PrintLiteral func(message string)
	// PrinterrLiteral prints a message using the stderr print handler in the
	// invoking process.
	//
	// Unlike g_application_command_line_printerr(), message is not a
	// printf()-style format string. Use this function if message contains
	// text you don't have control over, that could include printf() escape
	// sequences.
	//
	// The function takes the following parameters:
	//
	//   - message: message.
	PrinterrLiteral func(message string)
}

func defaultApplicationCommandLineOverrides(v *ApplicationCommandLine) ApplicationCommandLineOverrides {
	return ApplicationCommandLineOverrides{
		Done:            v.done,
		Stdin:           v.stdin,
		PrintLiteral:    v.printLiteral,
		PrinterrLiteral: v.printerrLiteral,
	}
}

// ApplicationCommandLine: GApplicationCommandLine represents a command-line
// invocation of an application.
//
// It is created by gio.Application and emitted in the
// gio.Application::command-line signal and virtual function.
//
// The class contains the list of arguments that the program was invoked with.
// It is also possible to query if the commandline invocation was local (ie:
// the current process is running in direct response to the invocation) or
// remote (ie: some other process forwarded the commandline to this process).
//
// The GApplicationCommandLine object can provide the argc and argv
// parameters for use with the glib.OptionContext command-line parsing API,
// with the gio.ApplicationCommandLine.GetArguments() function. See
// [gapplication-example-cmdline3.c][gapplication-example-cmdline3] for an
// example.
//
// The exit status of the originally-invoked process may be set and messages can
// be printed to stdout or stderr of that process.
//
// For remote invocation, the originally-invoked process exits when
// gio.ApplicationCommandLine.Done() method is called. This method is also
// automatically called when the object is disposed.
//
// The main use for GApplicationCommandLine (and the
// gio.Application::command-line signal) is 'Emacs server' like use cases: You
// can set the EDITOR environment variable to have e.g. git use your favourite
// editor to edit commit messages, and if you already have an instance of the
// editor running, the editing will happen in the running instance, instead of
// opening a new one. An important aspect of this use case is that the process
// that gets started by git does not return until the editing is done.
//
// Normally, the commandline is completely handled in the
// gio.Application::command-line handler. The launching instance exits once the
// signal handler in the primary instance has returned, and the return value of
// the signal handler becomes the exit status of the launching instance.
//
//	static int
//	command_line (GApplication            *application,
//	              GApplicationCommandLine *cmdline)
//	{
//	  gchar **argv;
//	  gint argc;
//	  gint i;
//
//	  argv = g_application_command_line_get_arguments (cmdline, &argc);
//
//	  g_application_command_line_print (cmdline,
//	                                    "This text is written back\n"
//	                                    "to stdout of the caller\n");
//
//	  for (i = 0; i < argc; i++)
//	    g_print ("argument d: s\n", i, argv[i]);
//
//	  g_strfreev (argv);
//
//	  return 0;
//	}
//
// The complete example can be found here: gapplication-example-cmdline.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)
//
// In more complicated cases, the handling of the commandline can be split
// between the launcher and the primary instance.
//
//	static gboolean
//	 test_local_cmdline (GApplication   *application,
//	                     gchar        ***arguments,
//	                     gint           *exit_status)
//	{
//	  gint i, j;
//	  gchar **argv;
//
//	  argv = *arguments;
//
//	  if (argv[0] == NULL)
//	    {
//	      *exit_status = 0;
//	      return FALSE;
//	    }
//
//	  i = 1;
//	  while (argv[i])
//	    {
//	      if (g_str_has_prefix (argv[i], "--local-"))
//	        {
//	          g_print ("handling argument s locally\n", argv[i]);
//	          g_free (argv[i]);
//	          for (j = i; argv[j]; j++)
//	            argv[j] = argv[j + 1];
//	        }
//	      else
//	        {
//	          g_print ("not handling argument s locally\n", argv[i]);
//	          i++;
//	        }
//	    }
//
//	  *exit_status = 0;
//
//	  return FALSE;
//	}
//
//	static void
//	test_application_class_init (TestApplicationClass *class)
//	{
//	  G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
//
//	  ...
//	}
//
// In this example of split commandline handling, options that start
// with --local- are handled locally, all other options are passed to the
// gio.Application::command-line handler which runs in the primary instance.
//
// The complete example can be found here: gapplication-example-cmdline2.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)
//
// If handling the commandline requires a lot of work, it may be better to defer
// it.
//
//	static gboolean
//	my_cmdline_handler (gpointer data)
//	{
//	  GApplicationCommandLine *cmdline = data;
//
//	  // do the heavy lifting in an idle
//
//	  g_application_command_line_set_exit_status (cmdline, 0);
//	  g_object_unref (cmdline); // this releases the application
//
//	  return G_SOURCE_REMOVE;
//	}
//
//	static int
//	command_line (GApplication            *application,
//	              GApplicationCommandLine *cmdline)
//	{
//	  // keep the application running until we are done with this commandline
//	  g_application_hold (application);
//
//	  g_object_set_data_full (G_OBJECT (cmdline),
//	                          "application", application,
//	                          (GDestroyNotify)g_application_release);
//
//	  g_object_ref (cmdline);
//	  g_idle_add (my_cmdline_handler, cmdline);
//
//	  return 0;
//	}
//
// In this example the commandline is not completely handled before the
// gio.Application::command-line handler returns. Instead, we keep a reference
// to the GApplicationCommandLine object and handle it later (in this example,
// in an idle). Note that it is necessary to hold the application until you are
// done with the commandline.
//
// The complete example can be found here: gapplication-example-cmdline3.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c).
type ApplicationCommandLine struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ApplicationCommandLine)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ApplicationCommandLine, *ApplicationCommandLineClass, ApplicationCommandLineOverrides](
		GTypeApplicationCommandLine,
		initApplicationCommandLineClass,
		wrapApplicationCommandLine,
		defaultApplicationCommandLineOverrides,
	)
}

func initApplicationCommandLineClass(gclass unsafe.Pointer, overrides ApplicationCommandLineOverrides, classInitFunc func(*ApplicationCommandLineClass)) {
	pclass := (*C.GApplicationCommandLineClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeApplicationCommandLine))))

	if overrides.Done != nil {
		pclass.done = (*[0]byte)(C._gotk4_gio2_ApplicationCommandLineClass_done)
	}

	if overrides.Stdin != nil {
		pclass.get_stdin = (*[0]byte)(C._gotk4_gio2_ApplicationCommandLineClass_get_stdin)
	}

	if overrides.PrintLiteral != nil {
		pclass.print_literal = (*[0]byte)(C._gotk4_gio2_ApplicationCommandLineClass_print_literal)
	}

	if overrides.PrinterrLiteral != nil {
		pclass.printerr_literal = (*[0]byte)(C._gotk4_gio2_ApplicationCommandLineClass_printerr_literal)
	}

	if classInitFunc != nil {
		class := (*ApplicationCommandLineClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplicationCommandLine(obj *coreglib.Object) *ApplicationCommandLine {
	return &ApplicationCommandLine{
		Object: obj,
	}
}

func marshalApplicationCommandLine(p uintptr) (interface{}, error) {
	return wrapApplicationCommandLine(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CreateFileForArg creates a #GFile corresponding to a filename that was given
// as part of the invocation of cmdline.
//
// This differs from g_file_new_for_commandline_arg() in that it resolves
// relative pathnames using the current working directory of the invoking
// process rather than the local process.
//
// The function takes the following parameters:
//
//   - arg: argument from cmdline.
//
// The function returns the following values:
//
//   - file: new #GFile.
func (cmdline *ApplicationCommandLine) CreateFileForArg(arg string) *File {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out
	var _cret *C.GFile                   // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_application_command_line_create_file_for_arg(_arg0, _arg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(arg)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// Done signals that command line processing is completed.
//
// For remote invocation, it causes the invoking process to terminate.
//
// For local invocation, it does nothing.
//
// This method should be called in the gio.Application::command-line handler,
// after the exit status is set and all messages are printed.
//
// After this call, g_application_command_line_set_exit_status() has no effect.
// Subsequent calls to this method are no-ops.
//
// This method is automatically called when the CommandLine object is disposed 
// so you can omit the call in non-garbage collected languages.
func (cmdline *ApplicationCommandLine) Done() {
	var _arg0 *C.GApplicationCommandLine // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	C.g_application_command_line_done(_arg0)
	runtime.KeepAlive(cmdline)
}

// Arguments gets the list of arguments that was passed on the command line.
//
// The strings in the array may contain non-UTF-8 data on UNIX (such as
// filenames or arguments given in the system locale) but are always in UTF-8 on
// Windows.
//
// If you wish to use the return value with Context, you must use
// g_option_context_parse_strv().
//
// The return value is NULL-terminated and should be freed using g_strfreev().
//
// The function returns the following values:
//
//   - filenames: the string array containing the arguments (the argv).
func (cmdline *ApplicationCommandLine) Arguments() []string {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret **C.gchar                  // in
	var _arg1 C.int                      // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_arguments(_arg0, &_arg1)
	runtime.KeepAlive(cmdline)

	var _filenames []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_filenames = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// Cwd gets the working directory of the command line invocation. The string may
// contain non-utf8 data.
//
// It is possible that the remote application did not send a working directory,
// so this may be NULL.
//
// The return value should not be modified or freed and is valid for as long as
// cmdline exists.
//
// The function returns the following values:
//
//   - filename (optional): current directory, or NULL.
func (cmdline *ApplicationCommandLine) Cwd() string {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.gchar                   // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_cwd(_arg0)
	runtime.KeepAlive(cmdline)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// Environ gets the contents of the 'environ' variable of the command line
// invocation, as would be returned by g_get_environ(), ie as a NULL-terminated
// list of strings in the form 'NAME=VALUE'. The strings may contain non-utf8
// data.
//
// The remote application usually does not send an environment. Use
// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
// is possible that the environment is still not available (due to invocation
// messages from other applications).
//
// The return value should not be modified or freed and is valid for as long as
// cmdline exists.
//
// See g_application_command_line_getenv() if you are only interested in the
// value of a single environment variable.
//
// The function returns the following values:
//
//   - filenames: the environment strings, or NULL if they were not sent.
func (cmdline *ApplicationCommandLine) Environ() []string {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret **C.gchar                  // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_environ(_arg0)
	runtime.KeepAlive(cmdline)

	var _filenames []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _filenames
}

// ExitStatus gets the exit status of cmdline. See
// g_application_command_line_set_exit_status() for more information.
//
// The function returns the following values:
//
//   - gint: exit status.
func (cmdline *ApplicationCommandLine) ExitStatus() int {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret C.int                      // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_exit_status(_arg0)
	runtime.KeepAlive(cmdline)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsRemote determines if cmdline represents a remote invocation.
//
// The function returns the following values:
//
//   - ok: TRUE if the invocation was remote.
func (cmdline *ApplicationCommandLine) IsRemote() bool {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_is_remote(_arg0)
	runtime.KeepAlive(cmdline)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OptionsDict gets the options that were passed to
// g_application_command_line().
//
// If you did not override local_command_line() then these are the same options
// that were parsed according to the Entrys added to the application with
// g_application_add_main_option_entries() and possibly modified from your
// GApplication::handle-local-options handler.
//
// If no options were sent then an empty dictionary is returned so that you
// don't need to check for NULL.
//
// The data has been passed via an untrusted external process, so the types of
// all values must be checked before being used.
//
// The function returns the following values:
//
//   - variantDict with the options.
func (cmdline *ApplicationCommandLine) OptionsDict() *glib.VariantDict {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.GVariantDict            // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_options_dict(_arg0)
	runtime.KeepAlive(cmdline)

	var _variantDict *glib.VariantDict // out

	_variantDict = (*glib.VariantDict)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_dict_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantDict)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_dict_unref((*C.GVariantDict)(intern.C))
		},
	)

	return _variantDict
}

// PlatformData gets the platform data associated with the invocation of
// cmdline.
//
// This is a #GVariant dictionary containing information about the context in
// which the invocation occurred. It typically contains information like the
// current working directory and the startup notification ID.
//
// It comes from an untrusted external process and hence the types of all values
// must be validated before being used.
//
// For local invocation, it will be NULL.
//
// The function returns the following values:
//
//   - variant (optional): platform data, or NULL.
func (cmdline *ApplicationCommandLine) PlatformData() *glib.Variant {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.GVariant                // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_platform_data(_arg0)
	runtime.KeepAlive(cmdline)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Stdin gets the stdin of the invoking process.
//
// The Stream can be used to read data passed to the standard input of
// the invoking process. This doesn't work on all platforms. Presently,
// it is only available on UNIX when using a D-Bus daemon capable of passing
// file descriptors. If stdin is not available then NULL will be returned.
// In the future, support may be expanded to other platforms.
//
// You must only call this function once per commandline invocation.
//
// The function returns the following values:
//
//   - inputStream (optional) for stdin.
func (cmdline *ApplicationCommandLine) Stdin() InputStreamer {
	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.GInputStream            // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C.g_application_command_line_get_stdin(_arg0)
	runtime.KeepAlive(cmdline)

	var _inputStream InputStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(InputStreamer)
				return ok
			})
			rv, ok := casted.(InputStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
			}
			_inputStream = rv
		}
	}

	return _inputStream
}

// Env gets the value of a particular environment variable of the command line
// invocation, as would be returned by g_getenv(). The strings may contain
// non-utf8 data.
//
// The remote application usually does not send an environment. Use
// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
// is possible that the environment is still not available (due to invocation
// messages from other applications).
//
// The return value should not be modified or freed and is valid for as long as
// cmdline exists.
//
// The function takes the following parameters:
//
//   - name: environment variable to get.
//
// The function returns the following values:
//
//   - utf8 (optional): value of the variable, or NULL if unset or unsent.
func (cmdline *ApplicationCommandLine) env(name string) string {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out
	var _cret *C.gchar                   // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_application_command_line_getenv(_arg0, _arg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(name)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PrintLiteral prints a message using the stdout print handler in the invoking
// process.
//
// Unlike g_application_command_line_print(), message is not a printf()-style
// format string. Use this function if message contains text you don't have
// control over, that could include printf() escape sequences.
//
// The function takes the following parameters:
//
//   - message: message.
func (cmdline *ApplicationCommandLine) PrintLiteral(message string) {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_command_line_print_literal(_arg0, _arg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// PrinterrLiteral prints a message using the stderr print handler in the
// invoking process.
//
// Unlike g_application_command_line_printerr(), message is not a printf()-style
// format string. Use this function if message contains text you don't have
// control over, that could include printf() escape sequences.
//
// The function takes the following parameters:
//
//   - message: message.
func (cmdline *ApplicationCommandLine) PrinterrLiteral(message string) {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_command_line_printerr_literal(_arg0, _arg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// SetExitStatus sets the exit status that will be used when the invoking
// process exits.
//
// The return value of the #GApplication::command-line signal is passed to this
// function when the handler returns. This is the usual way of setting the exit
// status.
//
// In the event that you want the remote invocation to continue running and
// want to decide on the exit status in the future, you can use this call.
// For the case of a remote invocation, the remote process will typically exit
// when the last reference is dropped on cmdline. The exit status of the remote
// process will be equal to the last value that was set with this function.
//
// In the case that the commandline invocation is local, the situation is
// slightly more complicated. If the commandline invocation results in the
// mainloop running (ie: because the use-count of the application increased to a
// non-zero value) then the application is considered to have been 'successful'
// in a certain sense, and the exit status is always zero. If the application
// use count is zero, though, the exit status of the local CommandLine is used.
//
// This method is a no-op if g_application_command_line_done() has been called.
//
// The function takes the following parameters:
//
//   - exitStatus: exit status.
func (cmdline *ApplicationCommandLine) SetExitStatus(exitStatus int) {
	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 C.int                      // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))
	_arg1 = C.int(exitStatus)

	C.g_application_command_line_set_exit_status(_arg0, _arg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(exitStatus)
}

// Done signals that command line processing is completed.
//
// For remote invocation, it causes the invoking process to terminate.
//
// For local invocation, it does nothing.
//
// This method should be called in the gio.Application::command-line handler,
// after the exit status is set and all messages are printed.
//
// After this call, g_application_command_line_set_exit_status() has no effect.
// Subsequent calls to this method are no-ops.
//
// This method is automatically called when the CommandLine object is disposed 
// so you can omit the call in non-garbage collected languages.
func (cmdline *ApplicationCommandLine) done() {
	gclass := (*C.GApplicationCommandLineClass)(coreglib.PeekParentClass(cmdline))
	fnarg := gclass.done

	var _arg0 *C.GApplicationCommandLine // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	C._gotk4_gio2_ApplicationCommandLine_virtual_done(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cmdline)
}

// Stdin gets the stdin of the invoking process.
//
// The Stream can be used to read data passed to the standard input of
// the invoking process. This doesn't work on all platforms. Presently,
// it is only available on UNIX when using a D-Bus daemon capable of passing
// file descriptors. If stdin is not available then NULL will be returned.
// In the future, support may be expanded to other platforms.
//
// You must only call this function once per commandline invocation.
//
// The function returns the following values:
//
//   - inputStream (optional) for stdin.
func (cmdline *ApplicationCommandLine) stdin() InputStreamer {
	gclass := (*C.GApplicationCommandLineClass)(coreglib.PeekParentClass(cmdline))
	fnarg := gclass.get_stdin

	var _arg0 *C.GApplicationCommandLine // out
	var _cret *C.GInputStream            // in

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))

	_cret = C._gotk4_gio2_ApplicationCommandLine_virtual_get_stdin(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cmdline)

	var _inputStream InputStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(InputStreamer)
				return ok
			})
			rv, ok := casted.(InputStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
			}
			_inputStream = rv
		}
	}

	return _inputStream
}

// printLiteral prints a message using the stdout print handler in the invoking
// process.
//
// Unlike g_application_command_line_print(), message is not a printf()-style
// format string. Use this function if message contains text you don't have
// control over, that could include printf() escape sequences.
//
// The function takes the following parameters:
//
//   - message: message.
func (cmdline *ApplicationCommandLine) printLiteral(message string) {
	gclass := (*C.GApplicationCommandLineClass)(coreglib.PeekParentClass(cmdline))
	fnarg := gclass.print_literal

	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_ApplicationCommandLine_virtual_print_literal(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// printerrLiteral prints a message using the stderr print handler in the
// invoking process.
//
// Unlike g_application_command_line_printerr(), message is not a printf()-style
// format string. Use this function if message contains text you don't have
// control over, that could include printf() escape sequences.
//
// The function takes the following parameters:
//
//   - message: message.
func (cmdline *ApplicationCommandLine) printerrLiteral(message string) {
	gclass := (*C.GApplicationCommandLineClass)(coreglib.PeekParentClass(cmdline))
	fnarg := gclass.printerr_literal

	var _arg0 *C.GApplicationCommandLine // out
	var _arg1 *C.gchar                   // out

	_arg0 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(cmdline).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_ApplicationCommandLine_virtual_printerr_literal(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// BufferedInputStreamOverrides contains methods that are overridable.
type BufferedInputStreamOverrides struct {
	// Fill tries to read count bytes from the stream into the buffer. Will
	// block during this read.
	//
	// If count is zero, returns zero and does nothing. A value of count larger
	// than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer is returned.
	// It is not an error if this is not the same as the requested size,
	// as it can happen e.g. near the end of a file. Zero is returned on end of
	// file (or if count is zero), but never otherwise.
	//
	// If count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	//
	// If cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and error is set accordingly.
	//
	// For the asynchronous, non-blocking, version of this function, see
	// g_buffered_input_stream_fill_async().
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//   - count: number of bytes that will be read from the stream.
	//
	// The function returns the following values:
	//
	//   - gssize: number of bytes read into stream's buffer, up to count,
	//     or -1 on error.
	Fill func(ctx context.Context, count int) (int, error)
	// FillFinish finishes an asynchronous read.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - gssize of the read stream, or -1 on an error.
	FillFinish func(result AsyncResulter) (int, error)
}

func defaultBufferedInputStreamOverrides(v *BufferedInputStream) BufferedInputStreamOverrides {
	return BufferedInputStreamOverrides{
		Fill:       v.fill,
		FillFinish: v.fillFinish,
	}
}

// BufferedInputStream: buffered input stream implements InputStream and
// provides for buffered reads.
//
// By default, GBufferedInputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered input stream, use gio.BufferedInputStream.New,
// or gio.BufferedInputStream.NewSized to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// gio.BufferedInputStream.GetBufferSize(). To change the size of a buffered
// input stream's buffer, use gio.BufferedInputStream.SetBufferSize(). Note that
// the buffer's size cannot be reduced below the size of the data within the
// buffer.
type BufferedInputStream struct {
	_ [0]func() // equal guard
	FilterInputStream

	Seekable
}

var (
	_ FilterInputStreamer = (*BufferedInputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BufferedInputStream, *BufferedInputStreamClass, BufferedInputStreamOverrides](
		GTypeBufferedInputStream,
		initBufferedInputStreamClass,
		wrapBufferedInputStream,
		defaultBufferedInputStreamOverrides,
	)
}

func initBufferedInputStreamClass(gclass unsafe.Pointer, overrides BufferedInputStreamOverrides, classInitFunc func(*BufferedInputStreamClass)) {
	pclass := (*C.GBufferedInputStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBufferedInputStream))))

	if overrides.Fill != nil {
		pclass.fill = (*[0]byte)(C._gotk4_gio2_BufferedInputStreamClass_fill)
	}

	if overrides.FillFinish != nil {
		pclass.fill_finish = (*[0]byte)(C._gotk4_gio2_BufferedInputStreamClass_fill_finish)
	}

	if classInitFunc != nil {
		class := (*BufferedInputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBufferedInputStream(obj *coreglib.Object) *BufferedInputStream {
	return &BufferedInputStream{
		FilterInputStream: FilterInputStream{
			InputStream: InputStream{
				Object: obj,
			},
		},
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalBufferedInputStream(p uintptr) (interface{}, error) {
	return wrapBufferedInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBufferedInputStream creates a new Stream from the given base_stream,
// with a buffer set to the default size (4 kilobytes).
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//
// The function returns the following values:
//
//   - bufferedInputStream for the given base_stream.
func NewBufferedInputStream(baseStream InputStreamer) *BufferedInputStream {
	var _arg1 *C.GInputStream // out
	var _cret *C.GInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))

	_cret = C.g_buffered_input_stream_new(_arg1)
	runtime.KeepAlive(baseStream)

	var _bufferedInputStream *BufferedInputStream // out

	_bufferedInputStream = wrapBufferedInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedInputStream
}

// NewBufferedInputStreamSized creates a new InputStream from the given
// base_stream, with a buffer set to size.
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//   - size: #gsize.
//
// The function returns the following values:
//
//   - bufferedInputStream: Stream.
func NewBufferedInputStreamSized(baseStream InputStreamer, size uint) *BufferedInputStream {
	var _arg1 *C.GInputStream // out
	var _arg2 C.gsize         // out
	var _cret *C.GInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))
	_arg2 = C.gsize(size)

	_cret = C.g_buffered_input_stream_new_sized(_arg1, _arg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(size)

	var _bufferedInputStream *BufferedInputStream // out

	_bufferedInputStream = wrapBufferedInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedInputStream
}

// Fill tries to read count bytes from the stream into the buffer. Will block
// during this read.
//
// If count is zero, returns zero and does nothing. A value of count larger than
// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// near the end of a file. Zero is returned on end of file (or if count is
// zero), but never otherwise.
//
// If count is -1 then the attempted read size is equal to the number of bytes
// that are required to fill the buffer.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// On error -1 is returned and error is set accordingly.
//
// For the asynchronous, non-blocking, version of this function, see
// g_buffered_input_stream_fill_async().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: number of bytes that will be read from the stream.
//
// The function returns the following values:
//
//   - gssize: number of bytes read into stream's buffer, up to count, or -1 on
//     error.
func (stream *BufferedInputStream) Fill(ctx context.Context, count int) (int, error) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg2 *C.GCancellable         // out
	var _arg1 C.gssize                // out
	var _cret C.gssize                // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gssize(count)

	_cret = C.g_buffered_input_stream_fill(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// FillAsync reads data into stream's buffer asynchronously, up to count size.
// io_priority can be used to prioritize reads. For the synchronous version of
// this function, see g_buffered_input_stream_fill().
//
// If count is -1 then the attempted read size is equal to the number of bytes
// that are required to fill the buffer.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object.
//   - count: number of bytes that will be read from the stream.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback.
func (stream *BufferedInputStream) FillAsync(ctx context.Context, count, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg3 *C.GCancellable         // out
	var _arg1 C.gssize                // out
	var _arg2 C.int                   // out
	var _arg4 C.GAsyncReadyCallback   // out
	var _arg5 C.gpointer

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gssize(count)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_buffered_input_stream_fill_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// FillFinish finishes an asynchronous read.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize of the read stream, or -1 on an error.
func (stream *BufferedInputStream) FillFinish(result AsyncResulter) (int, error) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.gssize                // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_buffered_input_stream_fill_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// Available gets the size of the available data within the stream.
//
// The function returns the following values:
//
//   - gsize: size of the available stream.
func (stream *BufferedInputStream) Available() uint {
	var _arg0 *C.GBufferedInputStream // out
	var _cret C.gsize                 // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_buffered_input_stream_get_available(_arg0)
	runtime.KeepAlive(stream)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// BufferSize gets the size of the input buffer.
//
// The function returns the following values:
//
//   - gsize: current buffer size.
func (stream *BufferedInputStream) BufferSize() uint {
	var _arg0 *C.GBufferedInputStream // out
	var _cret C.gsize                 // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_buffered_input_stream_get_buffer_size(_arg0)
	runtime.KeepAlive(stream)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Peek peeks in the buffer, copying data of size count into buffer, offset
// offset bytes.
//
// The function takes the following parameters:
//
//   - buffer: pointer to an allocated chunk of memory.
//   - offset: #gsize.
//
// The function returns the following values:
//
//   - gsize of the number of bytes peeked, or -1 on error.
func (stream *BufferedInputStream) Peek(buffer []byte, offset uint) uint {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 *C.void                 // out
	var _arg3 C.gsize
	var _arg2 C.gsize // out
	var _cret C.gsize // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg3 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	_arg2 = C.gsize(offset)

	_cret = C.g_buffered_input_stream_peek(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// PeekBuffer returns the buffer with the currently available bytes.
// The returned buffer must not be modified and will become invalid when reading
// from the stream or filling the buffer.
//
// The function returns the following values:
//
//   - guint8s: read-only buffer.
func (stream *BufferedInputStream) PeekBuffer() []byte {
	var _arg0 *C.GBufferedInputStream // out
	var _cret unsafe.Pointer          // in
	var _arg1 C.gsize                 // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_buffered_input_stream_peek_buffer(_arg0, &_arg1)
	runtime.KeepAlive(stream)

	var _guint8s []byte // out

	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// ReadByte tries to read a single byte from the stream or the buffer. Will
// block during this read.
//
// On success, the byte read from the stream is returned. On end of stream -1 is
// returned but it's not an exceptional error and error is not set.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - gint: byte read from the stream, or -1 on end of stream or error.
func (stream *BufferedInputStream) ReadByte(ctx context.Context) (int, error) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 *C.GCancellable         // out
	var _cret C.int                   // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_buffered_input_stream_read_byte(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// SetBufferSize sets the size of the internal buffer of stream to size,
// or to the size of the contents of the buffer. The buffer can never be resized
// smaller than its current contents.
//
// The function takes the following parameters:
//
//   - size: #gsize.
func (stream *BufferedInputStream) SetBufferSize(size uint) {
	var _arg0 *C.GBufferedInputStream // out
	var _arg1 C.gsize                 // out

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.gsize(size)

	C.g_buffered_input_stream_set_buffer_size(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
}

// Fill tries to read count bytes from the stream into the buffer. Will block
// during this read.
//
// If count is zero, returns zero and does nothing. A value of count larger than
// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// near the end of a file. Zero is returned on end of file (or if count is
// zero), but never otherwise.
//
// If count is -1 then the attempted read size is equal to the number of bytes
// that are required to fill the buffer.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// On error -1 is returned and error is set accordingly.
//
// For the asynchronous, non-blocking, version of this function, see
// g_buffered_input_stream_fill_async().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: number of bytes that will be read from the stream.
//
// The function returns the following values:
//
//   - gssize: number of bytes read into stream's buffer, up to count, or -1 on
//     error.
func (stream *BufferedInputStream) fill(ctx context.Context, count int) (int, error) {
	gclass := (*C.GBufferedInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.fill

	var _arg0 *C.GBufferedInputStream // out
	var _arg2 *C.GCancellable         // out
	var _arg1 C.gssize                // out
	var _cret C.gssize                // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gssize(count)

	_cret = C._gotk4_gio2_BufferedInputStream_virtual_fill(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// fillAsync reads data into stream's buffer asynchronously, up to count size.
// io_priority can be used to prioritize reads. For the synchronous version of
// this function, see g_buffered_input_stream_fill().
//
// If count is -1 then the attempted read size is equal to the number of bytes
// that are required to fill the buffer.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object.
//   - count: number of bytes that will be read from the stream.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback.
func (stream *BufferedInputStream) fillAsync(ctx context.Context, count, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GBufferedInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.fill_async

	var _arg0 *C.GBufferedInputStream // out
	var _arg3 *C.GCancellable         // out
	var _arg1 C.gssize                // out
	var _arg2 C.int                   // out
	var _arg4 C.GAsyncReadyCallback   // out
	var _arg5 C.gpointer

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gssize(count)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_BufferedInputStream_virtual_fill_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// fillFinish finishes an asynchronous read.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize of the read stream, or -1 on an error.
func (stream *BufferedInputStream) fillFinish(result AsyncResulter) (int, error) {
	gclass := (*C.GBufferedInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.fill_finish

	var _arg0 *C.GBufferedInputStream // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.gssize                // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GBufferedInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_BufferedInputStream_virtual_fill_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// BufferedOutputStreamOverrides contains methods that are overridable.
type BufferedOutputStreamOverrides struct {
}

func defaultBufferedOutputStreamOverrides(v *BufferedOutputStream) BufferedOutputStreamOverrides {
	return BufferedOutputStreamOverrides{}
}

// BufferedOutputStream: buffered output stream implements
// gio.FilterOutputStream and provides for buffered writes.
//
// By default, GBufferedOutputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered output stream, use gio.BufferedOutputStream.New,
// or gio.BufferedOutputStream.NewSized to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// gio.BufferedOutputStream.GetBufferSize(). To change the size of a buffered
// output stream's buffer, use gio.BufferedOutputStream.SetBufferSize(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedOutputStream struct {
	_ [0]func() // equal guard
	FilterOutputStream

	Seekable
}

var (
	_ FilterOutputStreamer = (*BufferedOutputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BufferedOutputStream, *BufferedOutputStreamClass, BufferedOutputStreamOverrides](
		GTypeBufferedOutputStream,
		initBufferedOutputStreamClass,
		wrapBufferedOutputStream,
		defaultBufferedOutputStreamOverrides,
	)
}

func initBufferedOutputStreamClass(gclass unsafe.Pointer, overrides BufferedOutputStreamOverrides, classInitFunc func(*BufferedOutputStreamClass)) {
	if classInitFunc != nil {
		class := (*BufferedOutputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBufferedOutputStream(obj *coreglib.Object) *BufferedOutputStream {
	return &BufferedOutputStream{
		FilterOutputStream: FilterOutputStream{
			OutputStream: OutputStream{
				Object: obj,
			},
		},
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalBufferedOutputStream(p uintptr) (interface{}, error) {
	return wrapBufferedOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBufferedOutputStream creates a new buffered output stream for a base
// stream.
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//
// The function returns the following values:
//
//   - bufferedOutputStream for the given base_stream.
func NewBufferedOutputStream(baseStream OutputStreamer) *BufferedOutputStream {
	var _arg1 *C.GOutputStream // out
	var _cret *C.GOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))

	_cret = C.g_buffered_output_stream_new(_arg1)
	runtime.KeepAlive(baseStream)

	var _bufferedOutputStream *BufferedOutputStream // out

	_bufferedOutputStream = wrapBufferedOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedOutputStream
}

// NewBufferedOutputStreamSized creates a new buffered output stream with a
// given buffer size.
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//   - size: #gsize.
//
// The function returns the following values:
//
//   - bufferedOutputStream with an internal buffer set to size.
func NewBufferedOutputStreamSized(baseStream OutputStreamer, size uint) *BufferedOutputStream {
	var _arg1 *C.GOutputStream // out
	var _arg2 C.gsize          // out
	var _cret *C.GOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))
	_arg2 = C.gsize(size)

	_cret = C.g_buffered_output_stream_new_sized(_arg1, _arg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(size)

	var _bufferedOutputStream *BufferedOutputStream // out

	_bufferedOutputStream = wrapBufferedOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferedOutputStream
}

// AutoGrow checks if the buffer automatically grows as data is added.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream's buffer automatically grows, FALSE otherwise.
func (stream *BufferedOutputStream) AutoGrow() bool {
	var _arg0 *C.GBufferedOutputStream // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_buffered_output_stream_get_auto_grow(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferSize gets the size of the buffer in the stream.
//
// The function returns the following values:
//
//   - gsize: current size of the buffer.
func (stream *BufferedOutputStream) BufferSize() uint {
	var _arg0 *C.GBufferedOutputStream // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_buffered_output_stream_get_buffer_size(_arg0)
	runtime.KeepAlive(stream)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// SetAutoGrow sets whether or not the stream's buffer should automatically
// grow. If auto_grow is true, then each write will just make the buffer larger,
// and you must manually flush the buffer to actually write out the data to the
// underlying stream.
//
// The function takes the following parameters:
//
//   - autoGrow: #gboolean.
func (stream *BufferedOutputStream) SetAutoGrow(autoGrow bool) {
	var _arg0 *C.GBufferedOutputStream // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if autoGrow {
		_arg1 = C.TRUE
	}

	C.g_buffered_output_stream_set_auto_grow(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(autoGrow)
}

// SetBufferSize sets the size of the internal buffer to size.
//
// The function takes the following parameters:
//
//   - size: #gsize.
func (stream *BufferedOutputStream) SetBufferSize(size uint) {
	var _arg0 *C.GBufferedOutputStream // out
	var _arg1 C.gsize                  // out

	_arg0 = (*C.GBufferedOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.gsize(size)

	C.g_buffered_output_stream_set_buffer_size(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
}

// BytesIcon: GBytesIcon specifies an image held in memory in a common format
// (usually PNG) to be used as icon.
type BytesIcon struct {
	_ [0]func() // equal guard
	*coreglib.Object

	LoadableIcon
}

var (
	_ coreglib.Objector = (*BytesIcon)(nil)
)

func wrapBytesIcon(obj *coreglib.Object) *BytesIcon {
	return &BytesIcon{
		Object: obj,
		LoadableIcon: LoadableIcon{
			Icon: Icon{
				Object: obj,
			},
		},
	}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	return wrapBytesIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBytesIcon creates a new icon for a bytes.
//
// This cannot fail, but loading and interpreting the bytes may fail later on
// (for example, if g_loadable_icon_load() is called) if the image is invalid.
//
// The function takes the following parameters:
//
//   - bytes: #GBytes.
//
// The function returns the following values:
//
//   - bytesIcon for the given bytes.
func NewBytesIcon(bytes *glib.Bytes) *BytesIcon {
	var _arg1 *C.GBytes // out
	var _cret *C.GIcon  // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.g_bytes_icon_new(_arg1)
	runtime.KeepAlive(bytes)

	var _bytesIcon *BytesIcon // out

	_bytesIcon = wrapBytesIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bytesIcon
}

// Bytes gets the #GBytes associated with the given icon.
//
// The function returns the following values:
//
//   - bytes: #GBytes.
func (icon *BytesIcon) Bytes() *glib.Bytes {
	var _arg0 *C.GBytesIcon // out
	var _cret *C.GBytes     // in

	_arg0 = (*C.GBytesIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_bytes_icon_get_bytes(_arg0)
	runtime.KeepAlive(icon)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_bytes_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// CancellableOverrides contains methods that are overridable.
type CancellableOverrides struct {
	Cancelled func()
}

func defaultCancellableOverrides(v *Cancellable) CancellableOverrides {
	return CancellableOverrides{
		Cancelled: v.cancelled,
	}
}

// Cancellable: GCancellable allows operations to be cancelled.
//
// GCancellable is a thread-safe operation cancellation stack used throughout
// GIO to allow for cancellation of synchronous and asynchronous operations.
type Cancellable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Cancellable)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Cancellable, *CancellableClass, CancellableOverrides](
		GTypeCancellable,
		initCancellableClass,
		wrapCancellable,
		defaultCancellableOverrides,
	)
}

func initCancellableClass(gclass unsafe.Pointer, overrides CancellableOverrides, classInitFunc func(*CancellableClass)) {
	pclass := (*C.GCancellableClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCancellable))))

	if overrides.Cancelled != nil {
		pclass.cancelled = (*[0]byte)(C._gotk4_gio2_CancellableClass_cancelled)
	}

	if classInitFunc != nil {
		class := (*CancellableClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCancellable(obj *coreglib.Object) *Cancellable {
	return &Cancellable{
		Object: obj,
	}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	return wrapCancellable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCancelled is emitted when the operation has been cancelled.
//
// Can be used by implementations of cancellable operations. If the operation is
// cancelled from another thread, the signal will be emitted in the thread that
// cancelled the operation, not the thread that is running the operation.
//
// Note that disconnecting from this signal (or any signal) in a
// multi-threaded program is prone to race conditions. For instance it
// is possible that a signal handler may be invoked even after a call to
// g_signal_handler_disconnect() for that handler has already returned.
//
// There is also a problem when cancellation happens right before connecting
// to the signal. If this happens the signal will unexpectedly not be emitted,
// and checking before connecting to the signal leaves a race condition where
// this is still happening.
//
// In order to make it safe and easy to connect handlers there are two helper
// functions: g_cancellable_connect() and g_cancellable_disconnect() which
// protect against problems like this.
//
// An example of how to us this:
//
//	// Make sure we don't do unnecessary work if already cancelled
//	if (g_cancellable_set_error_if_cancelled (cancellable, error))
//	  return;
//
//	// Set up all the data needed to be able to handle cancellation
//	// of the operation
//	my_data = my_data_new (...);
//
//	id = 0;
//	if (cancellable)
//	  id = g_cancellable_connect (cancellable,
//				      G_CALLBACK (cancelled_handler)
//				      data, NULL);
//
//	// cancellable operation here...
//
//	g_cancellable_disconnect (cancellable, id);
//
//	// cancelled_handler is never called after this, it is now safe
//	// to free the data
//	my_data_free (my_data);
//
// Note that the cancelled signal is emitted in the thread that the user
// cancelled from, which may be the main thread. So, the cancellable signal
// should not do something that can block.
func (cancellable *Cancellable) ConnectCancelled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cancellable, "cancelled", false, unsafe.Pointer(C._gotk4_gio2_Cancellable_ConnectCancelled), f)
}

// NewCancellable creates a new #GCancellable object.
//
// Applications that want to start one or more operations that should be
// cancellable should create a #GCancellable and pass it to the operations.
//
// One #GCancellable can be used in multiple consecutive operations or in
// multiple concurrent operations.
//
// The function returns the following values:
//
//   - cancellable: #GCancellable.
func NewCancellable() *Cancellable {
	var _cret *C.GCancellable // in

	_cret = C.g_cancellable_new()

	var _cancellable *Cancellable // out

	_cancellable = wrapCancellable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cancellable
}

// Cancel will set cancellable to cancelled, and will emit the
// #GCancellable::cancelled signal. (However, see the warning about race
// conditions in the documentation for that signal if you are planning to
// connect to it.)
//
// This function is thread-safe. In other words, you can safely call it from
// a thread other than the one running the operation that was passed the
// cancellable.
//
// If cancellable is NULL, this function returns immediately for convenience.
//
// The convention within GIO is that cancelling an asynchronous operation causes
// it to complete asynchronously. That is, if you cancel the operation from the
// same thread in which it is running, then the operation's ReadyCallback will
// not be invoked until the application returns to the main loop.
func (cancellable *Cancellable) Cancel() {
	var _arg0 *C.GCancellable // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C.g_cancellable_cancel(_arg0)
	runtime.KeepAlive(cancellable)
}

// Disconnect disconnects a handler from a cancellable instance similar to
// g_signal_handler_disconnect(). Additionally, in the event that a signal
// handler is currently running, this call will block until the handler has
// finished. Calling this function from a #GCancellable::cancelled signal
// handler will therefore result in a deadlock.
//
// This avoids a race condition where a thread cancels at the same time as
// the cancellable operation is finished and the signal handler is removed.
// See #GCancellable::cancelled for details on how to use this.
//
// If cancellable is NULL or handler_id is 0 this function does nothing.
//
// The function takes the following parameters:
//
//   - handlerId: handler id of the handler to be disconnected, or 0.
func (cancellable *Cancellable) Disconnect(handlerId uint32) {
	var _arg0 *C.GCancellable // out
	var _arg1 C.gulong        // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}
	_arg1 = C.gulong(handlerId)

	C.g_cancellable_disconnect(_arg0, _arg1)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(handlerId)
}

// Fd gets the file descriptor for a cancellable job. This can be used to
// implement cancellable operations on Unix systems. The returned fd will turn
// readable when cancellable is cancelled.
//
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done with
// g_cancellable_reset().
//
// After a successful return from this function, you should use
// g_cancellable_release_fd() to free up resources allocated for the returned
// file descriptor.
//
// See also g_cancellable_make_pollfd().
//
// The function returns the following values:
//
//   - gint: valid file descriptor. -1 if the file descriptor is not supported,
//     or on errors.
func (cancellable *Cancellable) Fd() int {
	var _arg0 *C.GCancellable // out
	var _cret C.int           // in

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	_cret = C.g_cancellable_get_fd(_arg0)
	runtime.KeepAlive(cancellable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsCancelled checks if a cancellable job has been cancelled.
//
// The function returns the following values:
//
//   - ok: TRUE if cancellable is cancelled, FALSE if called with NULL or if
//     item is not cancelled.
func (cancellable *Cancellable) IsCancelled() bool {
	var _arg0 *C.GCancellable // out
	var _cret C.gboolean      // in

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	_cret = C.g_cancellable_is_cancelled(_arg0)
	runtime.KeepAlive(cancellable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopCurrent pops cancellable off the cancellable stack (verifying that
// cancellable is on the top of the stack).
func (cancellable *Cancellable) PopCurrent() {
	var _arg0 *C.GCancellable // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C.g_cancellable_pop_current(_arg0)
	runtime.KeepAlive(cancellable)
}

// PushCurrent pushes cancellable onto the cancellable stack. The current
// cancellable can then be received using g_cancellable_get_current().
//
// This is useful when implementing cancellable operations in code that does not
// allow you to pass down the cancellable object.
//
// This is typically called automatically by e.g. #GFile operations, so you
// rarely have to call this yourself.
func (cancellable *Cancellable) PushCurrent() {
	var _arg0 *C.GCancellable // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C.g_cancellable_push_current(_arg0)
	runtime.KeepAlive(cancellable)
}

// ReleaseFd releases a resources previously allocated by g_cancellable_get_fd()
// or g_cancellable_make_pollfd().
//
// For compatibility reasons with older releases, calling this function is
// not strictly required, the resources will be automatically freed when the
// cancellable is finalized. However, the cancellable will block scarce file
// descriptors until it is finalized if this function is not called. This can
// cause the application to run out of file descriptors when many #GCancellables
// are used at the same time.
func (cancellable *Cancellable) ReleaseFd() {
	var _arg0 *C.GCancellable // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C.g_cancellable_release_fd(_arg0)
	runtime.KeepAlive(cancellable)
}

// Reset resets cancellable to its uncancelled state.
//
// If cancellable is currently in use by any cancellable operation then the
// behavior of this function is undefined.
//
// Note that it is generally not a good idea to reuse an existing cancellable
// for more operations after it has been cancelled once, as this function
// might tempt you to do. The recommended practice is to drop the reference
// to a cancellable after cancelling it, and let it die with the outstanding
// async operations. You should create a fresh cancellable for further async
// operations.
func (cancellable *Cancellable) Reset() {
	var _arg0 *C.GCancellable // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C.g_cancellable_reset(_arg0)
	runtime.KeepAlive(cancellable)
}

// SetErrorIfCancelled: if the cancellable is cancelled, sets the error to
// notify that the operation was cancelled.
func (cancellable *Cancellable) SetErrorIfCancelled() error {
	var _arg0 *C.GCancellable // out
	var _cerr *C.GError       // in

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C.g_cancellable_set_error_if_cancelled(_arg0, &_cerr)
	runtime.KeepAlive(cancellable)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// NewSource creates a source that triggers if cancellable is cancelled and
// calls its callback of type SourceFunc. This is primarily useful for attaching
// to another (non-cancellable) source with g_source_add_child_source() to add
// cancellability to it.
//
// For convenience, you can call this with a NULL #GCancellable, in which case
// the source will never trigger.
//
// The new #GSource will hold a reference to the #GCancellable.
//
// The function returns the following values:
//
//   - source: new #GSource.
func (cancellable *Cancellable) NewSource() *glib.Source {
	var _arg0 *C.GCancellable // out
	var _cret *C.GSource      // in

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	_cret = C.g_cancellable_source_new(_arg0)
	runtime.KeepAlive(cancellable)

	var _source *glib.Source // out

	_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

func (cancellable *Cancellable) cancelled() {
	gclass := (*C.GCancellableClass)(coreglib.PeekParentClass(cancellable))
	fnarg := gclass.cancelled

	var _arg0 *C.GCancellable // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C._gotk4_gio2_Cancellable_virtual_cancelled(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cancellable)
}

// CancellableGetCurrent gets the top cancellable from the stack.
//
// The function returns the following values:
//
//   - cancellable (optional) from the top of the stack, or NULL if the stack is
//     empty.
func CancellableGetCurrent() *Cancellable {
	var _cret *C.GCancellable // in

	_cret = C.g_cancellable_get_current()

	var _cancellable *Cancellable // out

	if _cret != nil {
		_cancellable = wrapCancellable(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _cancellable
}

// CharsetConverterOverrides contains methods that are overridable.
type CharsetConverterOverrides struct {
}

func defaultCharsetConverterOverrides(v *CharsetConverter) CharsetConverterOverrides {
	return CharsetConverterOverrides{}
}

// CharsetConverter: GCharsetConverter is an implementation of gio.Converter
// based on glib.IConv.
type CharsetConverter struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Converter
	Initable
}

var (
	_ coreglib.Objector = (*CharsetConverter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CharsetConverter, *CharsetConverterClass, CharsetConverterOverrides](
		GTypeCharsetConverter,
		initCharsetConverterClass,
		wrapCharsetConverter,
		defaultCharsetConverterOverrides,
	)
}

func initCharsetConverterClass(gclass unsafe.Pointer, overrides CharsetConverterOverrides, classInitFunc func(*CharsetConverterClass)) {
	if classInitFunc != nil {
		class := (*CharsetConverterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCharsetConverter(obj *coreglib.Object) *CharsetConverter {
	return &CharsetConverter{
		Object: obj,
		Converter: Converter{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalCharsetConverter(p uintptr) (interface{}, error) {
	return wrapCharsetConverter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCharsetConverter creates a new Converter.
//
// The function takes the following parameters:
//
//   - toCharset: destination charset.
//   - fromCharset: source charset.
//
// The function returns the following values:
//
//   - charsetConverter: new Converter or NULL on error.
func NewCharsetConverter(toCharset, fromCharset string) (*CharsetConverter, error) {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _cret *C.GCharsetConverter // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(toCharset)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(fromCharset)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_charset_converter_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(toCharset)
	runtime.KeepAlive(fromCharset)

	var _charsetConverter *CharsetConverter // out
	var _goerr error                        // out

	_charsetConverter = wrapCharsetConverter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _charsetConverter, _goerr
}

// NumFallbacks gets the number of fallbacks that converter has applied so far.
//
// The function returns the following values:
//
//   - guint: number of fallbacks that converter has applied.
func (converter *CharsetConverter) NumFallbacks() uint {
	var _arg0 *C.GCharsetConverter // out
	var _cret C.guint              // in

	_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))

	_cret = C.g_charset_converter_get_num_fallbacks(_arg0)
	runtime.KeepAlive(converter)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UseFallback gets the Converter:use-fallback property.
//
// The function returns the following values:
//
//   - ok: TRUE if fallbacks are used by converter.
func (converter *CharsetConverter) UseFallback() bool {
	var _arg0 *C.GCharsetConverter // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))

	_cret = C.g_charset_converter_get_use_fallback(_arg0)
	runtime.KeepAlive(converter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUseFallback sets the Converter:use-fallback property.
//
// The function takes the following parameters:
//
//   - useFallback: TRUE to use fallbacks.
func (converter *CharsetConverter) SetUseFallback(useFallback bool) {
	var _arg0 *C.GCharsetConverter // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GCharsetConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))
	if useFallback {
		_arg1 = C.TRUE
	}

	C.g_charset_converter_set_use_fallback(_arg0, _arg1)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(useFallback)
}

// ConverterInputStreamOverrides contains methods that are overridable.
type ConverterInputStreamOverrides struct {
}

func defaultConverterInputStreamOverrides(v *ConverterInputStream) ConverterInputStreamOverrides {
	return ConverterInputStreamOverrides{}
}

// ConverterInputStream: converter input stream implements gio.InputStream and
// allows conversion of data of various types during reading.
//
// As of GLib 2.34, GConverterInputStream implements gio.PollableInputStream.
type ConverterInputStream struct {
	_ [0]func() // equal guard
	FilterInputStream

	*coreglib.Object
	InputStream
	PollableInputStream
}

var (
	_ FilterInputStreamer = (*ConverterInputStream)(nil)
	_ coreglib.Objector   = (*ConverterInputStream)(nil)
	_ InputStreamer       = (*ConverterInputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ConverterInputStream, *ConverterInputStreamClass, ConverterInputStreamOverrides](
		GTypeConverterInputStream,
		initConverterInputStreamClass,
		wrapConverterInputStream,
		defaultConverterInputStreamOverrides,
	)
}

func initConverterInputStreamClass(gclass unsafe.Pointer, overrides ConverterInputStreamOverrides, classInitFunc func(*ConverterInputStreamClass)) {
	if classInitFunc != nil {
		class := (*ConverterInputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConverterInputStream(obj *coreglib.Object) *ConverterInputStream {
	return &ConverterInputStream{
		FilterInputStream: FilterInputStream{
			InputStream: InputStream{
				Object: obj,
			},
		},
		Object: obj,
		InputStream: InputStream{
			Object: obj,
		},
		PollableInputStream: PollableInputStream{
			InputStream: InputStream{
				Object: obj,
			},
		},
	}
}

func marshalConverterInputStream(p uintptr) (interface{}, error) {
	return wrapConverterInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewConverterInputStream creates a new converter input stream for the
// base_stream.
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//   - converter: #GConverter.
//
// The function returns the following values:
//
//   - converterInputStream: new Stream.
func NewConverterInputStream(baseStream InputStreamer, converter Converterer) *ConverterInputStream {
	var _arg1 *C.GInputStream // out
	var _arg2 *C.GConverter   // out
	var _cret *C.GInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))
	_arg2 = (*C.GConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))

	_cret = C.g_converter_input_stream_new(_arg1, _arg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(converter)

	var _converterInputStream *ConverterInputStream // out

	_converterInputStream = wrapConverterInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _converterInputStream
}

// Converter gets the #GConverter that is used by converter_stream.
//
// The function returns the following values:
//
//   - converter of the converter input stream.
func (converterStream *ConverterInputStream) Converter() *Converter {
	var _arg0 *C.GConverterInputStream // out
	var _cret *C.GConverter            // in

	_arg0 = (*C.GConverterInputStream)(unsafe.Pointer(coreglib.InternObject(converterStream).Native()))

	_cret = C.g_converter_input_stream_get_converter(_arg0)
	runtime.KeepAlive(converterStream)

	var _converter *Converter // out

	_converter = wrapConverter(coreglib.Take(unsafe.Pointer(_cret)))

	return _converter
}

// ConverterOutputStreamOverrides contains methods that are overridable.
type ConverterOutputStreamOverrides struct {
}

func defaultConverterOutputStreamOverrides(v *ConverterOutputStream) ConverterOutputStreamOverrides {
	return ConverterOutputStreamOverrides{}
}

// ConverterOutputStream: converter output stream implements gio.OutputStream
// and allows conversion of data of various types during reading.
//
// As of GLib 2.34, GConverterOutputStream implements gio.PollableOutputStream.
type ConverterOutputStream struct {
	_ [0]func() // equal guard
	FilterOutputStream

	*coreglib.Object
	OutputStream
	PollableOutputStream
}

var (
	_ FilterOutputStreamer = (*ConverterOutputStream)(nil)
	_ coreglib.Objector    = (*ConverterOutputStream)(nil)
	_ OutputStreamer       = (*ConverterOutputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ConverterOutputStream, *ConverterOutputStreamClass, ConverterOutputStreamOverrides](
		GTypeConverterOutputStream,
		initConverterOutputStreamClass,
		wrapConverterOutputStream,
		defaultConverterOutputStreamOverrides,
	)
}

func initConverterOutputStreamClass(gclass unsafe.Pointer, overrides ConverterOutputStreamOverrides, classInitFunc func(*ConverterOutputStreamClass)) {
	if classInitFunc != nil {
		class := (*ConverterOutputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConverterOutputStream(obj *coreglib.Object) *ConverterOutputStream {
	return &ConverterOutputStream{
		FilterOutputStream: FilterOutputStream{
			OutputStream: OutputStream{
				Object: obj,
			},
		},
		Object: obj,
		OutputStream: OutputStream{
			Object: obj,
		},
		PollableOutputStream: PollableOutputStream{
			OutputStream: OutputStream{
				Object: obj,
			},
		},
	}
}

func marshalConverterOutputStream(p uintptr) (interface{}, error) {
	return wrapConverterOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewConverterOutputStream creates a new converter output stream for the
// base_stream.
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//   - converter: #GConverter.
//
// The function returns the following values:
//
//   - converterOutputStream: new Stream.
func NewConverterOutputStream(baseStream OutputStreamer, converter Converterer) *ConverterOutputStream {
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.GConverter    // out
	var _cret *C.GOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))
	_arg2 = (*C.GConverter)(unsafe.Pointer(coreglib.InternObject(converter).Native()))

	_cret = C.g_converter_output_stream_new(_arg1, _arg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(converter)

	var _converterOutputStream *ConverterOutputStream // out

	_converterOutputStream = wrapConverterOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _converterOutputStream
}

// Converter gets the #GConverter that is used by converter_stream.
//
// The function returns the following values:
//
//   - converter of the converter output stream.
func (converterStream *ConverterOutputStream) Converter() *Converter {
	var _arg0 *C.GConverterOutputStream // out
	var _cret *C.GConverter             // in

	_arg0 = (*C.GConverterOutputStream)(unsafe.Pointer(coreglib.InternObject(converterStream).Native()))

	_cret = C.g_converter_output_stream_get_converter(_arg0)
	runtime.KeepAlive(converterStream)

	var _converter *Converter // out

	_converter = wrapConverter(coreglib.Take(unsafe.Pointer(_cret)))

	return _converter
}

// Credentials: GCredentials type is a reference-counted wrapper for native
// credentials.
//
// The information in GCredentials is typically used for identifying,
// authenticating and authorizing other processes.
//
// Some operating systems supports looking up the credentials of the remote peer
// of a communication endpoint - see e.g. gio.Socket.GetCredentials().
//
// Some operating systems supports securely sending and
// receiving credentials over a Unix Domain Socket, see
// gio.UnixCredentialsMessage, gio.UnixConnection.SendCredentials() and
// gio.UnixConnection.ReceiveCredentials() for details.
//
// On Linux, the native credential type is a struct ucred - see the
// unix(7) man page (man:unix(7)) for details. This corresponds to
// G_CREDENTIALS_TYPE_LINUX_UCRED.
//
// On Apple operating systems (including iOS, tvOS, and macOS),
// the native credential type is a struct xucred. This corresponds to
// G_CREDENTIALS_TYPE_APPLE_XUCRED.
//
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is
// a struct cmsgcred. This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
//
// On NetBSD, the native credential type is a struct unpcbid. This corresponds
// to G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
//
// On OpenBSD, the native credential type is a struct sockpeercred. This
// corresponds to G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
//
// On Solaris (including OpenSolaris and its derivatives), the native credential
// type is a ucred_t. This corresponds to G_CREDENTIALS_TYPE_SOLARIS_UCRED.
//
// Since GLib 2.72, on Windows, the native credentials may contain the PID of a
// process. This corresponds to G_CREDENTIALS_TYPE_WIN32_PID.
type Credentials struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Credentials)(nil)
)

func wrapCredentials(obj *coreglib.Object) *Credentials {
	return &Credentials{
		Object: obj,
	}
}

func marshalCredentials(p uintptr) (interface{}, error) {
	return wrapCredentials(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCredentials creates a new #GCredentials object with credentials matching
// the the current process.
//
// The function returns the following values:
//
//   - credentials Free with g_object_unref().
func NewCredentials() *Credentials {
	var _cret *C.GCredentials // in

	_cret = C.g_credentials_new()

	var _credentials *Credentials // out

	_credentials = wrapCredentials(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _credentials
}

// IsSameUser checks if credentials and other_credentials is the same user.
//
// This operation can fail if #GCredentials is not supported on the the OS.
//
// The function takes the following parameters:
//
//   - otherCredentials: #GCredentials.
func (credentials *Credentials) IsSameUser(otherCredentials *Credentials) error {
	var _arg0 *C.GCredentials // out
	var _arg1 *C.GCredentials // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GCredentials)(unsafe.Pointer(coreglib.InternObject(credentials).Native()))
	_arg1 = (*C.GCredentials)(unsafe.Pointer(coreglib.InternObject(otherCredentials).Native()))

	C.g_credentials_is_same_user(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(credentials)
	runtime.KeepAlive(otherCredentials)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetNative copies the native credentials of type native_type from native into
// credentials.
//
// It is a programming error (which will cause a warning to be logged) to use
// this method if there is no #GCredentials support for the OS or if native_type
// isn't supported by the OS.
//
// The function takes the following parameters:
//
//   - nativeType: type of native credentials to set.
//   - native: pointer to native credentials.
func (credentials *Credentials) SetNative(nativeType CredentialsType, native unsafe.Pointer) {
	var _arg0 *C.GCredentials    // out
	var _arg1 C.GCredentialsType // out
	var _arg2 C.gpointer         // out

	_arg0 = (*C.GCredentials)(unsafe.Pointer(coreglib.InternObject(credentials).Native()))
	_arg1 = C.GCredentialsType(nativeType)
	_arg2 = (C.gpointer)(unsafe.Pointer(native))

	C.g_credentials_set_native(_arg0, _arg1, _arg2)
	runtime.KeepAlive(credentials)
	runtime.KeepAlive(nativeType)
	runtime.KeepAlive(native)
}

// String creates a human-readable textual representation of credentials that
// can be used in logging and debug messages. The format of the returned string
// may change in future GLib release.
//
// The function returns the following values:
//
//   - utf8: string that should be freed with g_free().
func (credentials *Credentials) String() string {
	var _arg0 *C.GCredentials // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GCredentials)(unsafe.Pointer(coreglib.InternObject(credentials).Native()))

	_cret = C.g_credentials_to_string(_arg0)
	runtime.KeepAlive(credentials)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusActionGroup: GDBusActionGroup is an implementation of the gio.ActionGroup
// interface.
//
// GDBusActionGroup can be used as a proxy for an action group that is exported
// over D-Bus with gio.DBusConnection.ExportActionGroup().
type DBusActionGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object

	RemoteActionGroup
}

var (
	_ coreglib.Objector = (*DBusActionGroup)(nil)
)

func wrapDBusActionGroup(obj *coreglib.Object) *DBusActionGroup {
	return &DBusActionGroup{
		Object: obj,
		RemoteActionGroup: RemoteActionGroup{
			ActionGroup: ActionGroup{
				Object: obj,
			},
		},
	}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	return wrapDBusActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DBusActionGroupGet obtains a BusActionGroup for the action group which is
// exported at the given bus_name and object_path.
//
// The thread default main context is taken at the time of this call. All
// signals on the menu model (and any linked models) are reported with respect
// to this context. All calls on the returned menu model (and linked models)
// must also originate from this same context, with the thread default main
// context unchanged.
//
// This call is non-blocking. The returned action group may or may not already
// be filled in. The correct thing to do is connect the signals for the action
// group to monitor for changes and then to call g_action_group_list_actions()
// to get the initial list.
//
// The function takes the following parameters:
//
//   - connection: BusConnection.
//   - busName (optional) bus name which exports the action group or NULL if
//     connection is not a message bus connection.
//   - objectPath: object path at which the action group is exported.
//
// The function returns the following values:
//
//   - dBusActionGroup: BusActionGroup.
func DBusActionGroupGet(connection *DBusConnection, busName, objectPath string) *DBusActionGroup {
	var _arg1 *C.GDBusConnection  // out
	var _arg2 *C.gchar            // out
	var _arg3 *C.gchar            // out
	var _cret *C.GDBusActionGroup // in

	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	if busName != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_action_group_get(_arg1, _arg2, _arg3)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(busName)
	runtime.KeepAlive(objectPath)

	var _dBusActionGroup *DBusActionGroup // out

	_dBusActionGroup = wrapDBusActionGroup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusActionGroup
}

// DBusAuthObserver: GDBusAuthObserver provides a mechanism for participating in
// how a gio.DBusServer (or a gio.DBusConnection) authenticates remote peers.
//
// Simply instantiate a GDBusAuthObserver and connect to the signals you are
// interested in. Note that new signals may be added in the future.
//
// # Controlling Authentication Mechanisms
//
// By default, a GDBusServer or server-side GDBusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the EXTERNAL mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//	static gboolean
//	on_allow_mechanism (GDBusAuthObserver *observer,
//	                    const gchar       *mechanism,
//	                    gpointer           user_data)
//	{
//	  if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
//	    {
//	      return TRUE;
//	    }
//
//	  return FALSE;
//	}
//
// # Controlling Authorization
//
// By default, a GDBusServer or server-side GDBusConnection will accept
// connections from any successfully authenticated user (but not from anonymous
// connections using the ANONYMOUS mechanism). If you only want to allow D-Bus
// connections from processes owned by the same uid as the server, since GLib
// 2.68, you should use the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER
// flag. Its equivalent to the following signal handler:
//
//	static gboolean
//	on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//	                                 GIOStream         *stream,
//	                                 GCredentials      *credentials,
//	                                 gpointer           user_data)
//	{
//	  gboolean authorized;
//
//	  authorized = FALSE;
//	  if (credentials != NULL)
//	    {
//	      GCredentials *own_credentials;
//	      own_credentials = g_credentials_new ();
//	      if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//	        authorized = TRUE;
//	      g_object_unref (own_credentials);
//	    }
//
//	  return authorized;
//	}.
type DBusAuthObserver struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DBusAuthObserver)(nil)
)

func wrapDBusAuthObserver(obj *coreglib.Object) *DBusAuthObserver {
	return &DBusAuthObserver{
		Object: obj,
	}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	return wrapDBusAuthObserver(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAllowMechanism is emitted to check if mechanism is allowed to be used.
func (observer *DBusAuthObserver) ConnectAllowMechanism(f func(mechanism string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(observer, "allow-mechanism", false, unsafe.Pointer(C._gotk4_gio2_DBusAuthObserver_ConnectAllowMechanism), f)
}

// ConnectAuthorizeAuthenticatedPeer is emitted to check if a peer that is
// successfully authenticated is authorized.
func (observer *DBusAuthObserver) ConnectAuthorizeAuthenticatedPeer(f func(stream IOStreamer, credentials *Credentials) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(observer, "authorize-authenticated-peer", false, unsafe.Pointer(C._gotk4_gio2_DBusAuthObserver_ConnectAuthorizeAuthenticatedPeer), f)
}

// NewDBusAuthObserver creates a new BusAuthObserver object.
//
// The function returns the following values:
//
//   - dBusAuthObserver Free with g_object_unref().
func NewDBusAuthObserver() *DBusAuthObserver {
	var _cret *C.GDBusAuthObserver // in

	_cret = C.g_dbus_auth_observer_new()

	var _dBusAuthObserver *DBusAuthObserver // out

	_dBusAuthObserver = wrapDBusAuthObserver(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusAuthObserver
}

// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on observer.
//
// The function takes the following parameters:
//
//   - mechanism: name of the mechanism, e.g. DBUS_COOKIE_SHA1.
//
// The function returns the following values:
//
//   - ok: TRUE if mechanism can be used to authenticate the other peer,
//     FALSE if not.
func (observer *DBusAuthObserver) AllowMechanism(mechanism string) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(coreglib.InternObject(observer).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(mechanism)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)
	runtime.KeepAlive(observer)
	runtime.KeepAlive(mechanism)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AuthorizeAuthenticatedPeer emits the
// BusAuthObserver::authorize-authenticated-peer signal on observer.
//
// The function takes the following parameters:
//
//   - stream for the BusConnection.
//   - credentials (optional) credentials received from the peer or NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if the peer is authorized, FALSE if not.
func (observer *DBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStreamer, credentials *Credentials) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GCredentials      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(coreglib.InternObject(observer).Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if credentials != nil {
		_arg2 = (*C.GCredentials)(unsafe.Pointer(coreglib.InternObject(credentials).Native()))
	}

	_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)
	runtime.KeepAlive(observer)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(credentials)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusConnection: GDBusConnection type is used for D-Bus connections to remote
// peers such as a message buses.
//
// It is a low-level API that offers a lot of flexibility. For instance,
// it lets you establish a connection over any transport that can by represented
// as a gio.IOStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing
// a D-Bus client, it is often easier to use the gio.BusOwnName(),
// gio.BusWatchName() or gio.DBusProxy().NewForBus APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, GDBusConnections methods may be called
// from any thread. This is so that gio.BusGet() and gio.BusGetSync() can safely
// return the same GDBusConnection when called from any thread.
//
// Most of the ways to obtain a GDBusConnection automatically initialize
// it (i.e. connect to D-Bus): for instance, gio.DBusConnection().New
// and gio.BusGet(), and the synchronous versions of those methods,
// give you an initialized connection. Language bindings for GIO should use
// gio.Initable().New or gio.AsyncInitable().NewAsync, which also initialize the
// connection.
//
// If you construct an uninitialized GDBusConnection, such as via
// gobject.Object.New, you must initialize it via gio.Initable.Init() or
// gio.AsyncInitable.InitAsync() before using its methods or properties.
// Calling methods or accessing properties on a GDBusConnection that has not
// completed initialization successfully is considered to be invalid, and leads
// to undefined behaviour. In particular, if initialization fails with a GError,
// the only valid thing you can do with that GDBusConnection is to free it with
// gobject.Object.Unref().
//
// # An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
//
// # An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
//
// # An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
//
// # An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c).
type DBusConnection struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncInitable
	Initable
}

var (
	_ coreglib.Objector = (*DBusConnection)(nil)
)

func wrapDBusConnection(obj *coreglib.Object) *DBusConnection {
	return &DBusConnection{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	return wrapDBusConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClosed is emitted when the connection is closed.
//
// # The cause of this event can be
//
// - If g_dbus_connection_close() is called. In this case remote_peer_vanished
// is set to FALSE and error is NULL.
//
// - If the remote peer closes the connection. In this case remote_peer_vanished
// is set to TRUE and error is set.
//
// - If the remote peer sends invalid or malformed data. In this case
// remote_peer_vanished is set to FALSE and error is set.
//
// Upon receiving this signal, you should give up your reference to connection.
// You are guaranteed that this signal is emitted only once.
func (connection *DBusConnection) ConnectClosed(f func(remotePeerVanished bool, err error)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(connection, "closed", false, unsafe.Pointer(C._gotk4_gio2_DBusConnection_ConnectClosed), f)
}

// NewDBusConnectionFinish finishes an operation started with
// g_dbus_connection_new().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to g_dbus_connection_new().
//
// The function returns the following values:
//
//   - dBusConnection or NULL if error is set. Free with g_object_unref().
func NewDBusConnectionFinish(res AsyncResulter) (*DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressFinish finishes an operation started with
// g_dbus_connection_new_for_address().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to g_dbus_connection_new().
//
// The function returns the following values:
//
//   - dBusConnection or NULL if error is set. Free with g_object_unref().
func NewDBusConnectionForAddressFinish(res AsyncResulter) (*DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressSync: synchronously connects and sets
// up a D-Bus client connection for exchanging D-Bus messages with an
// endpoint specified by address which must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side connections - use
// g_dbus_connection_new_sync() if you need to act as the server. In particular,
// flags cannot contain the G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new_for_address() for the asynchronous version.
//
// If observer is not NULL it may be used to control the authentication process.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address d-Bus address.
//   - flags describing how to make the connection.
//   - observer (optional) or NULL.
//
// The function returns the following values:
//
//   - dBusConnection or NULL if error is set. Free with g_object_unref().
func NewDBusConnectionForAddressSync(ctx context.Context, address string, flags DBusConnectionFlags, observer *DBusAuthObserver) (*DBusConnection, error) {
	var _arg4 *C.GCancellable        // out
	var _arg1 *C.gchar               // out
	var _arg2 C.GDBusConnectionFlags // out
	var _arg3 *C.GDBusAuthObserver   // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusConnectionFlags(flags)
	if observer != nil {
		_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(coreglib.InternObject(observer).Native()))
	}

	_cret = C.g_dbus_connection_new_for_address_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(observer)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// NewDBusConnectionSync: synchronously sets up a D-Bus connection for
// exchanging D-Bus messages with the end represented by stream.
//
// If stream is a Connection, then the corresponding #GSocket will be put into
// non-blocking mode.
//
// The D-Bus connection will interact with stream from a worker thread. As a
// result, the caller should not interact with stream after this method has been
// called, except by calling g_object_unref() on it.
//
// If observer is not NULL it may be used to control the authentication process.
//
// This is a synchronous failable constructor. See g_dbus_connection_new() for
// the asynchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - stream: OStream.
//   - guid (optional): GUID to use if authenticating as a server or NULL.
//   - flags describing how to make the connection.
//   - observer (optional) or NULL.
//
// The function returns the following values:
//
//   - dBusConnection or NULL if error is set. Free with g_object_unref().
func NewDBusConnectionSync(ctx context.Context, stream IOStreamer, guid string, flags DBusConnectionFlags, observer *DBusAuthObserver) (*DBusConnection, error) {
	var _arg5 *C.GCancellable        // out
	var _arg1 *C.GIOStream           // out
	var _arg2 *C.gchar               // out
	var _arg3 C.GDBusConnectionFlags // out
	var _arg4 *C.GDBusAuthObserver   // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if guid != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(guid)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.GDBusConnectionFlags(flags)
	if observer != nil {
		_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(coreglib.InternObject(observer).Native()))
	}

	_cret = C.g_dbus_connection_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(guid)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(observer)

	var _dBusConnection *DBusConnection // out
	var _goerr error                    // out

	_dBusConnection = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusConnection, _goerr
}

// AddFilter adds a message filter. Filters are handlers that are run on all
// incoming and outgoing messages, prior to standard dispatch. Filters are
// run in the order that they were added. The same handler can be added as a
// filter more than once, in which case it will be run more than once. Filters
// added during a filter callback won't be run on the message being processed.
// Filter functions are allowed to modify and even drop messages.
//
// Note that filters are run in a dedicated message handling thread
// so they can't block and, generally, can't do anything but signal
// a worker thread. Also note that filters are rarely needed -
// use API such as g_dbus_connection_send_message_with_reply(),
// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
//
// If a filter consumes an incoming message the message is not
// dispatched anywhere else - not even the standard dispatch machinery
// (that API such as g_dbus_connection_signal_subscribe() and
// g_dbus_connection_send_message_with_reply() relies on) will see the message.
// Similarly, if a filter consumes an outgoing message, the message will not be
// sent to the other peer.
//
// If user_data_free_func is non-NULL, it will be called (in the thread-default
// main context of the thread you are calling this method from) at some point
// after user_data is no longer needed. (It is not guaranteed to be called
// synchronously when the filter is removed, and may be called after connection
// has been destroyed.).
//
// The function takes the following parameters:
//
//   - filterFunction: filter function.
//
// The function returns the following values:
//
//   - guint: filter identifier that can be used with
//     g_dbus_connection_remove_filter().
func (connection *DBusConnection) AddFilter(filterFunction DBusMessageFilterFunction) uint {
	var _arg0 *C.GDBusConnection           // out
	var _arg1 C.GDBusMessageFilterFunction // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gio2_DBusMessageFilterFunction)
	_arg2 = C.gpointer(gbox.Assign(filterFunction))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.g_dbus_connection_add_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(filterFunction)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Call: asynchronously invokes the method_name method on the interface_name
// D-Bus interface on the remote object at object_path owned by bus_name.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If parameters contains a value not compatible with the
// D-Bus protocol, the operation fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// If reply_type is non-NULL then the reply will be checked for having this
// type and an error will be raised if it does not match. Said another way,
// if you give a reply_type then any non-NULL return value will be of this type.
// Unless its G_VARIANT_TYPE_UNIT, the reply_type will be a tuple containing
// one or more values.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//	g_dbus_connection_call (connection,
//	                        "org.freedesktop.StringThings",
//	                        "/org/freedesktop/StringThings",
//	                        "org.freedesktop.StringThings",
//	                        "TwoStrings",
//	                        g_variant_new ("(ss)",
//	                                       "Thing One",
//	                                       "Thing Two"),
//	                        NULL,
//	                        G_DBUS_CALL_FLAGS_NONE,
//	                        -1,
//	                        NULL,
//	                        (GAsyncReadyCallback) two_strings_done,
//	                        NULL);
//
// This is an asynchronous method. When the operation is finished,
// callback will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_call_finish() to
// get the result of the operation. See g_dbus_connection_call_sync() for the
// synchronous version of this function.
//
// If callback is NULL then the D-Bus method call message will be sent with the
// G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - busName (optional): unique or well-known bus name or NULL if connection
//     is not a message bus connection.
//   - objectPath: path of remote object.
//   - interfaceName d-Bus interface to invoke method on.
//   - methodName: name of the method to invoke.
//   - parameters (optional) tuple with parameters for the method or NULL if not
//     passing parameters.
//   - replyType (optional): expected type of the reply (which will be a tuple),
//     or NULL.
//   - flags from the BusCallFlags enumeration.
//   - timeoutMsec: timeout in milliseconds, -1 to use the default timeout or
//     G_MAXINT for no timeout.
//   - callback (optional) to call when the request is satisfied or NULL if you
//     don't care about the result of the method invocation.
func (connection *DBusConnection) Call(ctx context.Context, busName, objectPath, interfaceName, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection     // out
	var _arg9 *C.GCancellable        // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 *C.GVariant            // out
	var _arg6 *C.GVariantType        // out
	var _arg7 C.GDBusCallFlags       // out
	var _arg8 C.gint                 // out
	var _arg10 C.GAsyncReadyCallback // out
	var _arg11 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if busName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg4))
	if parameters != nil {
		_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}
	if replyType != nil {
		_arg6 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(replyType)))
	}
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	if callback != nil {
		_arg10 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg11 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_connection_call(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busName)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(methodName)
	runtime.KeepAlive(parameters)
	runtime.KeepAlive(replyType)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)
	runtime.KeepAlive(callback)
}

// CallFinish finishes an operation started with g_dbus_connection_call().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to g_dbus_connection_call().
//
// The function returns the following values:
//
//   - variant: NULL if error is set. Otherwise a non-floating #GVariant tuple
//     with return values. Free with g_variant_unref().
func (connection *DBusConnection) CallFinish(res AsyncResulter) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(res)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// CallSync: synchronously invokes the method_name method on the interface_name
// D-Bus interface on the remote object at object_path owned by bus_name.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If parameters contains a value not compatible with the
// D-Bus protocol, the operation fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// If reply_type is non-NULL then the reply will be checked for having this
// type and an error will be raised if it does not match. Said another way,
// if you give a reply_type then any non-NULL return value will be of this type.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//	g_dbus_connection_call_sync (connection,
//	                             "org.freedesktop.StringThings",
//	                             "/org/freedesktop/StringThings",
//	                             "org.freedesktop.StringThings",
//	                             "TwoStrings",
//	                             g_variant_new ("(ss)",
//	                                            "Thing One",
//	                                            "Thing Two"),
//	                             NULL,
//	                             G_DBUS_CALL_FLAGS_NONE,
//	                             -1,
//	                             NULL,
//	                             &error);
//
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of this method.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - busName (optional): unique or well-known bus name or NULL if connection
//     is not a message bus connection.
//   - objectPath: path of remote object.
//   - interfaceName d-Bus interface to invoke method on.
//   - methodName: name of the method to invoke.
//   - parameters (optional) tuple with parameters for the method or NULL if not
//     passing parameters.
//   - replyType (optional): expected type of the reply, or NULL.
//   - flags from the BusCallFlags enumeration.
//   - timeoutMsec: timeout in milliseconds, -1 to use the default timeout or
//     G_MAXINT for no timeout.
//
// The function returns the following values:
//
//   - variant: NULL if error is set. Otherwise a non-floating #GVariant tuple
//     with return values. Free with g_variant_unref().
func (connection *DBusConnection) CallSync(ctx context.Context, busName, objectPath, interfaceName, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg9 *C.GCancellable    // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if busName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg4))
	if parameters != nil {
		_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}
	if replyType != nil {
		_arg6 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(replyType)))
	}
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)

	_cret = C.g_dbus_connection_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busName)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(methodName)
	runtime.KeepAlive(parameters)
	runtime.KeepAlive(replyType)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// Close closes connection. Note that this never causes the process to exit
// (this might only happen if the other end of a shared message bus connection
// disconnects, see BusConnection:exit-on-close).
//
// Once the connection is closed, operations such as sending a message
// will return with the error G_IO_ERROR_CLOSED. Closing a connection will
// not automatically flush the connection so queued messages may be lost.
// Use g_dbus_connection_flush() if you need such guarantees.
//
// If connection is already closed, this method fails with G_IO_ERROR_CLOSED.
//
// When connection has been closed, the BusConnection::closed signal is emitted
// in the [thread-default main context][g-main-context-push-thread-default] of
// the thread that connection was constructed in.
//
// This is an asynchronous method. When the operation is finished,
// callback will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_close_finish() to
// get the result of the operation. See g_dbus_connection_close_sync() for the
// synchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional) to call when the request is satisfied or NULL if you
//     don't care about the result.
func (connection *DBusConnection) Close(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_connection_close(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// CloseFinish finishes an operation started with g_dbus_connection_close().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to g_dbus_connection_close().
func (connection *DBusConnection) CloseFinish(res AsyncResulter) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(res)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CloseSync: synchronously closes connection. The calling thread is blocked
// until this is done. See g_dbus_connection_close() for the asynchronous
// version of this method and more details about what it does.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (connection *DBusConnection) CloseSync(ctx context.Context) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EmitSignal emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if parameters is not compatible with the D-Bus
// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if connection has been closed
// (G_IO_ERROR_CLOSED).
//
// The function takes the following parameters:
//
//   - destinationBusName (optional): unique bus name for the destination for
//     the signal or NULL to emit to all listeners.
//   - objectPath: path of remote object.
//   - interfaceName d-Bus interface to emit a signal on.
//   - signalName: name of the signal to emit.
//   - parameters (optional) tuple with parameters for the signal or NULL if not
//     passing parameters.
func (connection *DBusConnection) EmitSignal(destinationBusName, objectPath, interfaceName, signalName string, parameters *glib.Variant) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	if destinationBusName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(destinationBusName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(signalName)))
	defer C.free(unsafe.Pointer(_arg4))
	if parameters != nil {
		_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}

	C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(destinationBusName)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(signalName)
	runtime.KeepAlive(parameters)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ExportActionGroup exports action_group on connection at object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// A given object path can only have one action group exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// error set accordingly).
//
// You can unexport the action group using
// g_dbus_connection_unexport_action_group() with the return value of this
// function.
//
// The thread default main context is taken at the time of this call.
// All incoming action activations and state change requests are reported from
// this context. Any changes on the action group that cause it to emit signals
// must also come from this same context. Since incoming action activations and
// state change requests are rather likely to cause changes on the action group,
// this effectively limits a given action group to being exported from only one
// main context.
//
// The function takes the following parameters:
//
//   - objectPath d-Bus object path.
//   - actionGroup: Group.
//
// The function returns the following values:
//
//   - guint: ID of the export (never zero), or 0 in case of failure.
func (connection *DBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGrouper) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GActionGroup    // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))

	_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(actionGroup)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// ExportMenuModel exports menu on connection at object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// error set accordingly).
//
// Exporting menus with sections containing more than
// G_MENU_EXPORTER_MAX_SECTION_SIZE items is not supported and results in
// undefined behavior.
//
// You can unexport the menu model using g_dbus_connection_unexport_menu_model()
// with the return value of this function.
//
// The function takes the following parameters:
//
//   - objectPath d-Bus object path.
//   - menu: Model.
//
// The function returns the following values:
//
//   - guint: ID of the export (never zero), or 0 in case of failure.
func (connection *DBusConnection) ExportMenuModel(objectPath string, menu MenuModeller) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GMenuModel      // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(menu).Native()))

	_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(menu)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// Flush: asynchronously flushes connection, that is, writes all queued
// outgoing message to the transport and then flushes the transport (using
// g_output_stream_flush_async()). This is useful in programs that wants to emit
// a D-Bus signal and then exit immediately. Without flushing the connection,
// there is no guaranteed that the message has been sent to the networking
// buffers in the OS kernel.
//
// This is an asynchronous method. When the operation is finished,
// callback will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_connection_flush_finish() to
// get the result of the operation. See g_dbus_connection_flush_sync() for the
// synchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional) to call when the request is satisfied or NULL if you
//     don't care about the result.
func (connection *DBusConnection) Flush(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_connection_flush(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// FlushFinish finishes an operation started with g_dbus_connection_flush().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to g_dbus_connection_flush().
func (connection *DBusConnection) FlushFinish(res AsyncResulter) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(res)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FlushSync: synchronously flushes connection. The calling thread is blocked
// until this is done. See g_dbus_connection_flush() for the asynchronous
// version of this method and more details about what it does.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (connection *DBusConnection) FlushSync(ctx context.Context) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Capabilities gets the capabilities negotiated with the remote peer.
//
// The function returns the following values:
//
//   - dBusCapabilityFlags: zero or more flags from the BusCapabilityFlags
//     enumeration.
func (connection *DBusConnection) Capabilities() DBusCapabilityFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusCapabilityFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_capabilities(_arg0)
	runtime.KeepAlive(connection)

	var _dBusCapabilityFlags DBusCapabilityFlags // out

	_dBusCapabilityFlags = DBusCapabilityFlags(_cret)

	return _dBusCapabilityFlags
}

// ExitOnClose gets whether the process is terminated when connection is closed
// by the remote peer. See BusConnection:exit-on-close for more details.
//
// The function returns the following values:
//
//   - ok: whether the process is terminated when connection is closed by the
//     remote peer.
func (connection *DBusConnection) ExitOnClose() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_exit_on_close(_arg0)
	runtime.KeepAlive(connection)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Flags gets the flags used to construct this connection.
//
// The function returns the following values:
//
//   - dBusConnectionFlags: zero or more flags from the BusConnectionFlags
//     enumeration.
func (connection *DBusConnection) Flags() DBusConnectionFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusConnectionFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_flags(_arg0)
	runtime.KeepAlive(connection)

	var _dBusConnectionFlags DBusConnectionFlags // out

	_dBusConnectionFlags = DBusConnectionFlags(_cret)

	return _dBusConnectionFlags
}

// GUID of the peer performing the role of server when authenticating. See
// BusConnection:guid for more details.
//
// The function returns the following values:
//
//   - utf8: GUID. Do not free this string, it is owned by connection.
func (connection *DBusConnection) GUID() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_guid(_arg0)
	runtime.KeepAlive(connection)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// LastSerial retrieves the last serial number assigned to a BusMessage
// on the current thread. This includes messages sent via both low-level
// API such as g_dbus_connection_send_message() as well as high-level API
// such as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
// g_dbus_proxy_call().
//
// The function returns the following values:
//
//   - guint32: last used serial or zero when no message has been sent within
//     the current thread.
func (connection *DBusConnection) LastSerial() uint32 {
	var _arg0 *C.GDBusConnection // out
	var _cret C.guint32          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_last_serial(_arg0)
	runtime.KeepAlive(connection)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// PeerCredentials gets the credentials of the authenticated peer.
// This will always return NULL unless connection acted as a server (e.g.
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and the
// client passed credentials as part of the authentication process.
//
// In a message bus setup, the message bus is always the server and each
// application is a client. So this method will always return NULL for message
// bus clients.
//
// The function returns the following values:
//
//   - credentials (optional) or NULL if not available. Do not free this object,
//     it is owned by connection.
func (connection *DBusConnection) PeerCredentials() *Credentials {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GCredentials    // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_peer_credentials(_arg0)
	runtime.KeepAlive(connection)

	var _credentials *Credentials // out

	if _cret != nil {
		_credentials = wrapCredentials(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _credentials
}

// Stream gets the underlying stream used for IO.
//
// While the BusConnection is active, it will interact with this stream from a
// worker thread, so it is not safe to interact with the stream directly.
//
// The function returns the following values:
//
//   - ioStream: stream used for IO.
func (connection *DBusConnection) Stream() IOStreamer {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GIOStream       // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_stream(_arg0)
	runtime.KeepAlive(connection)

	var _ioStream IOStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}

	return _ioStream
}

// UniqueName gets the unique name of connection as assigned by the message bus.
// This can also be used to figure out if connection is a message bus
// connection.
//
// The function returns the following values:
//
//   - utf8 (optional): unique name or NULL if connection is not a message bus
//     connection. Do not free this string, it is owned by connection.
func (connection *DBusConnection) UniqueName() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_get_unique_name(_arg0)
	runtime.KeepAlive(connection)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IsClosed gets whether connection is closed.
//
// The function returns the following values:
//
//   - ok: TRUE if the connection is closed, FALSE otherwise.
func (connection *DBusConnection) IsClosed() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_connection_is_closed(_arg0)
	runtime.KeepAlive(connection)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegisterObject: version of g_dbus_connection_register_object() using closures
// instead of a BusInterfaceVTable for easier binding in other languages.
//
// The function takes the following parameters:
//
//   - objectPath: object path to register at.
//   - interfaceInfo: introspection data for the interface.
//   - methodCallClosure (optional) for handling incoming method calls.
//   - getPropertyClosure (optional) for getting a property.
//   - setPropertyClosure (optional) for setting a property.
//
// The function returns the following values:
//
//   - guint: 0 if error is set, otherwise a registration ID (never 0) that can
//     be used with g_dbus_connection_unregister_object() .
func (connection *DBusConnection) RegisterObject(objectPath string, interfaceInfo *DBusInterfaceInfo, methodCallClosure, getPropertyClosure, setPropertyClosure coreglib.AnyClosure) (uint, error) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GDBusInterfaceInfo // out
	var _arg3 *C.GClosure           // out
	var _arg4 *C.GClosure           // out
	var _arg5 *C.GClosure           // out
	var _cret C.guint               // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(interfaceInfo)))
	_arg3 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(connection), methodCallClosure))
	_arg4 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(connection), getPropertyClosure))
	_arg5 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(connection), setPropertyClosure))

	_cret = C.g_dbus_connection_register_object_with_closures(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceInfo)
	runtime.KeepAlive(methodCallClosure)
	runtime.KeepAlive(getPropertyClosure)
	runtime.KeepAlive(setPropertyClosure)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// RemoveFilter removes a filter.
//
// Note that since filters run in a different thread, there is a race
// condition where it is possible that the filter will be running even after
// calling g_dbus_connection_remove_filter(), so you cannot just free data
// that the filter might be using. Instead, you should pass a Notify to
// g_dbus_connection_add_filter(), which will be called when it is guaranteed
// that the data is no longer needed.
//
// The function takes the following parameters:
//
//   - filterId: identifier obtained from g_dbus_connection_add_filter().
func (connection *DBusConnection) RemoveFilter(filterId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = C.guint(filterId)

	C.g_dbus_connection_remove_filter(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(filterId)
}

// SendMessage: asynchronously sends message to the peer represented by
// connection.
//
// Unless flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by connection and set on message via
// g_dbus_message_set_serial(). If out_serial is not NULL, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a volatile qualifier, this is a
// historical artifact and the argument passed to it should not be volatile.
//
// If connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If message is not well-formed, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for
// an example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that message must be unlocked, unless flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// The function takes the following parameters:
//
//   - message: BusMessage.
//   - flags affecting how the message is sent.
//
// The function returns the following values:
//
//   - outSerial (optional): return location for serial number assigned to
//     message when sending it or NULL.
func (connection *DBusConnection) SendMessage(message *DBusMessage, flags DBusSendMessageFlags) (uint32, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.guint32               // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)

	C.g_dbus_connection_send_message(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(message)
	runtime.KeepAlive(flags)

	var _outSerial uint32 // out
	var _goerr error      // out

	_outSerial = uint32(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outSerial, _goerr
}

// SendMessageWithReply: asynchronously sends message to the peer represented by
// connection.
//
// Unless flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by connection and set on message via
// g_dbus_message_set_serial(). If out_serial is not NULL, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a volatile qualifier, this is a
// historical artifact and the argument passed to it should not be volatile.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If message is not well-formed, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// This is an asynchronous method. When the operation is
// finished, callback will be invoked in the [thread-default
// main context][g-main-context-push-thread-default] of the
// thread you are calling this method from. You can then call
// g_dbus_connection_send_message_with_reply_finish() to get the result of
// the operation. See g_dbus_connection_send_message_with_reply_sync() for the
// synchronous version.
//
// Note that message must be unlocked, unless flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for
// an example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - message: BusMessage.
//   - flags affecting how the message is sent.
//   - timeoutMsec: timeout in milliseconds, -1 to use the default timeout or
//     G_MAXINT for no timeout.
//   - callback (optional) to call when the request is satisfied or NULL if you
//     don't care about the result.
//
// The function returns the following values:
//
//   - outSerial (optional): return location for serial number assigned to
//     message when sending it or NULL.
func (connection *DBusConnection) SendMessageWithReply(ctx context.Context, message *DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, callback AsyncReadyCallback) uint32 {
	var _arg0 *C.GDBusConnection      // out
	var _arg5 *C.GCancellable         // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _arg6 C.GAsyncReadyCallback   // out
	var _arg7 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_connection_send_message_with_reply(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(message)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)
	runtime.KeepAlive(callback)

	var _outSerial uint32 // out

	_outSerial = uint32(_arg4)

	return _outSerial
}

// SendMessageWithReplyFinish finishes an operation started with
// g_dbus_connection_send_message_with_reply().
//
// Note that error is only set if a local in-process error occurred.
// That is to say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this
// to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for
// an example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to
//     g_dbus_connection_send_message_with_reply().
//
// The function returns the following values:
//
//   - dBusMessage: locked BusMessage or NULL if error is set.
func (connection *DBusConnection) SendMessageWithReplyFinish(res AsyncResulter) (*DBusMessage, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusMessage    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(res)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusMessage, _goerr
}

// SendMessageWithReplySync: synchronously sends message to the peer represented
// by connection and blocks the calling thread until a reply is received or the
// timeout is reached. See g_dbus_connection_send_message_with_reply() for the
// asynchronous version of this method.
//
// Unless flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by connection and set on message via
// g_dbus_message_set_serial(). If out_serial is not NULL, then the serial
// number used will be written to this location prior to submitting the message
// to the underlying transport. While it has a volatile qualifier, this is a
// historical artifact and the argument passed to it should not be volatile.
//
// If connection is closed then the operation will fail with G_IO_ERROR_CLOSED.
// If cancellable is canceled, the operation will fail with
// G_IO_ERROR_CANCELLED. If message is not well-formed, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// Note that error is only set if a local in-process error occurred.
// That is to say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode this
// to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for
// an example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that message must be unlocked, unless flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - message: BusMessage.
//   - flags affecting how the message is sent.
//   - timeoutMsec: timeout in milliseconds, -1 to use the default timeout or
//     G_MAXINT for no timeout.
//
// The function returns the following values:
//
//   - outSerial (optional): return location for serial number assigned to
//     message when sending it or NULL.
//   - dBusMessage: locked BusMessage that is the reply to message or NULL if
//     error is set.
func (connection *DBusConnection) SendMessageWithReplySync(ctx context.Context, message *DBusMessage, flags DBusSendMessageFlags, timeoutMsec int) (uint32, *DBusMessage, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg5 *C.GCancellable         // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _cret *C.GDBusMessage         // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)

	_cret = C.g_dbus_connection_send_message_with_reply_sync(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(message)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)

	var _outSerial uint32         // out
	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_outSerial = uint32(_arg4)
	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outSerial, _dBusMessage, _goerr
}

// SetExitOnClose sets whether the process should be terminated when connection
// is closed by the remote peer. See BusConnection:exit-on-close for more
// details.
//
// Note that this function should be used with care. Most modern UNIX desktops
// tie the notion of a user session with the session bus, and expect all of
// a user's applications to quit when their bus connection goes away. If you
// are setting exit_on_close to FALSE for the shared session bus connection,
// you should make sure that your application exits when the user session ends.
//
// The function takes the following parameters:
//
//   - exitOnClose: whether the process should be terminated when connection is
//     closed by the remote peer.
func (connection *DBusConnection) SetExitOnClose(exitOnClose bool) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	if exitOnClose {
		_arg1 = C.TRUE
	}

	C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(exitOnClose)
}

// SignalSubscribe subscribes to signals on connection and invokes callback
// whenever the signal is received. Note that callback will be invoked in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread you are calling this method from.
//
// If connection is not a message bus connection, sender must be NULL.
//
// If sender is a well-known name note that callback is invoked with the unique
// name for the owner of sender, not the well-known name as one would expect.
// This is because the message bus rewrites the name. As such, to avoid certain
// race conditions, users should be tracking the name owner of the well-known
// name and use that when processing the received signal.
//
// If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
// G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, arg0 is interpreted as part of
// a namespace or path. The first argument of a signal is matched against that
// part as specified by D-Bus.
//
// If user_data_free_func is non-NULL, it will be called (in the thread-default
// main context of the thread you are calling this method from) at some point
// after user_data is no longer needed. (It is not guaranteed to be called
// synchronously when the signal is unsubscribed from, and may be called after
// connection has been destroyed.)
//
// As callback is potentially invoked in a different thread from
// where its emitted, its possible for this to happen after
// g_dbus_connection_signal_unsubscribe() has been called in another thread.
// Due to this, user_data should have a strong reference which is freed with
// user_data_free_func, rather than pointing to data whose lifecycle is tied
// to the signal subscription. For example, if a #GObject is used to store the
// subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
// to that #GObject must be passed to user_data, and g_object_unref() passed to
// user_data_free_func. You are responsible for breaking the resulting reference
// count cycle by explicitly unsubscribing from the signal when dropping the
// last external reference to the #GObject. Alternatively, a weak reference may
// be used.
//
// It is guaranteed that if you unsubscribe from a signal using
// g_dbus_connection_signal_unsubscribe() from the same thread which made the
// corresponding g_dbus_connection_signal_subscribe() call, callback will not be
// invoked after g_dbus_connection_signal_unsubscribe() returns.
//
// The returned subscription identifier is an opaque value which is guaranteed
// to never be zero.
//
// This function can never fail.
//
// The function takes the following parameters:
//
//   - sender (optional) name to match on (unique or well-known name) or NULL to
//     listen from all senders.
//   - interfaceName (optional) d-Bus interface name to match on or NULL to
//     match on all interfaces.
//   - member (optional) d-Bus signal name to match on or NULL to match on all
//     signals.
//   - objectPath (optional): object path to match on or NULL to match on all
//     object paths.
//   - arg0 (optional) contents of first string argument to match on or NULL to
//     match on all kinds of arguments.
//   - flags describing how arg0 is used in subscribing to the signal.
//   - callback to invoke when there is a signal matching the requested data.
//
// The function returns the following values:
//
//   - guint: subscription identifier that can be used with
//     g_dbus_connection_signal_unsubscribe().
func (connection *DBusConnection) SignalSubscribe(sender, interfaceName, member, objectPath, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 C.GDBusSignalFlags    // out
	var _arg7 C.GDBusSignalCallback // out
	var _arg8 C.gpointer
	var _arg9 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	if sender != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(sender)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if interfaceName != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if member != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(member)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if objectPath != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if arg0 != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(arg0)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	_arg6 = C.GDBusSignalFlags(flags)
	_arg7 = (*[0]byte)(C._gotk4_gio2_DBusSignalCallback)
	_arg8 = C.gpointer(gbox.Assign(callback))
	_arg9 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.g_dbus_connection_signal_subscribe(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(sender)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(member)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(arg0)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SignalUnsubscribe unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_dbus_connection_signal_subscribe() is called,
// in order to avoid memory leaks through callbacks queued on the Context after
// its stopped being iterated. Alternatively, any idle source with a priority
// lower than G_PRIORITY_DEFAULT that was scheduled after unsubscription,
// also indicates that all resources of this subscription are released.
//
// The function takes the following parameters:
//
//   - subscriptionId: subscription id obtained from
//     g_dbus_connection_signal_subscribe().
func (connection *DBusConnection) SignalUnsubscribe(subscriptionId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = C.guint(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(subscriptionId)
}

// StartMessageProcessing: if connection was created with
// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
// processing messages. Does nothing on if connection wasn't created with this
// flag or if the method has already been called.
func (connection *DBusConnection) StartMessageProcessing() {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	C.g_dbus_connection_start_message_processing(_arg0)
	runtime.KeepAlive(connection)
}

// UnexportActionGroup reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_action_group() or to call it with the same ID more
// than once.
//
// The function takes the following parameters:
//
//   - exportId: ID from g_dbus_connection_export_action_group().
func (connection *DBusConnection) UnexportActionGroup(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(exportId)
}

// UnexportMenuModel reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_menu_model() or to call it with the same ID more
// than once.
//
// The function takes the following parameters:
//
//   - exportId: ID from g_dbus_connection_export_menu_model().
func (connection *DBusConnection) UnexportMenuModel(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(exportId)
}

// UnregisterObject unregisters an object.
//
// The function takes the following parameters:
//
//   - registrationId: registration id obtained from
//     g_dbus_connection_register_object().
//
// The function returns the following values:
//
//   - ok: TRUE if the object was unregistered, FALSE otherwise.
func (connection *DBusConnection) UnregisterObject(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(registrationId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnregisterSubtree unregisters a subtree.
//
// The function takes the following parameters:
//
//   - registrationId: subtree registration id obtained from
//     g_dbus_connection_register_subtree().
//
// The function returns the following values:
//
//   - ok: TRUE if the subtree was unregistered, FALSE otherwise.
func (connection *DBusConnection) UnregisterSubtree(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(registrationId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewDBusConnection: asynchronously sets up a D-Bus connection for exchanging
// D-Bus messages with the end represented by stream.
//
// If stream is a Connection, then the corresponding #GSocket will be put into
// non-blocking mode.
//
// The D-Bus connection will interact with stream from a worker thread. As a
// result, the caller should not interact with stream after this method has been
// called, except by calling g_object_unref() on it.
//
// If observer is not NULL it may be used to control the authentication process.
//
// When the operation is finished, callback will be invoked. You can then call
// g_dbus_connection_new_finish() to get the result of the operation.
//
// This is an asynchronous failable constructor. See
// g_dbus_connection_new_sync() for the synchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - stream: OStream.
//   - guid (optional): GUID to use if authenticating as a server or NULL.
//   - flags describing how to make the connection.
//   - observer (optional) or NULL.
//   - callback (optional) to call when the request is satisfied.
func NewDBusConnection(ctx context.Context, stream IOStreamer, guid string, flags DBusConnectionFlags, observer *DBusAuthObserver, callback AsyncReadyCallback) {
	var _arg5 *C.GCancellable        // out
	var _arg1 *C.GIOStream           // out
	var _arg2 *C.gchar               // out
	var _arg3 C.GDBusConnectionFlags // out
	var _arg4 *C.GDBusAuthObserver   // out
	var _arg6 C.GAsyncReadyCallback  // out
	var _arg7 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if guid != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(guid)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.GDBusConnectionFlags(flags)
	if observer != nil {
		_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(coreglib.InternObject(observer).Native()))
	}
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_connection_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(guid)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(observer)
	runtime.KeepAlive(callback)
}

// NewDBusConnectionForAddress: asynchronously connects and sets up a
// D-Bus client connection for exchanging D-Bus messages with an endpoint
// specified by address which must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side connections - use
// g_dbus_connection_new() if you need to act as the server. In particular,
// flags cannot contain the G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// When the operation is finished, callback will be invoked. You can then
// call g_dbus_connection_new_for_address_finish() to get the result of the
// operation.
//
// If observer is not NULL it may be used to control the authentication process.
//
// This is an asynchronous failable constructor. See
// g_dbus_connection_new_for_address_sync() for the synchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address d-Bus address.
//   - flags describing how to make the connection.
//   - observer (optional) or NULL.
//   - callback (optional) to call when the request is satisfied.
func NewDBusConnectionForAddress(ctx context.Context, address string, flags DBusConnectionFlags, observer *DBusAuthObserver, callback AsyncReadyCallback) {
	var _arg4 *C.GCancellable        // out
	var _arg1 *C.gchar               // out
	var _arg2 C.GDBusConnectionFlags // out
	var _arg3 *C.GDBusAuthObserver   // out
	var _arg5 C.GAsyncReadyCallback  // out
	var _arg6 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusConnectionFlags(flags)
	if observer != nil {
		_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(coreglib.InternObject(observer).Native()))
	}
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_connection_new_for_address(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(observer)
	runtime.KeepAlive(callback)
}

// DBusInterfaceSkeletonOverrides contains methods that are overridable.
type DBusInterfaceSkeletonOverrides struct {
	// Flush: if interface_ has outstanding changes, request for these changes
	// to be emitted immediately.
	//
	// For example, an exported D-Bus interface may queue up property changes
	// and emit the org.freedesktop.DBus.Properties.PropertiesChanged signal
	// later (e.g. in an idle handler). This technique is useful for collapsing
	// multiple property changes into one.
	Flush func()
	// GAuthorizeMethod: signal class handler for the
	// BusInterfaceSkeleton::g-authorize-method signal.
	GAuthorizeMethod func(invocation *DBusMethodInvocation) bool
	// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by interface_.
	//
	// The function returns the following values:
	//
	//   - dBusInterfaceInfo (never NULL). Do not free.
	Info func() *DBusInterfaceInfo
	// Properties gets all D-Bus properties for interface_.
	//
	// The function returns the following values:
	//
	//   - variant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with
	//     g_variant_unref().
	Properties func() *glib.Variant
	// Vtable gets the interface vtable for the D-Bus interface implemented
	// by interface_. The returned function pointers should expect interface_
	// itself to be passed as user_data.
	//
	// The function returns the following values:
	//
	//   - dBusInterfaceVTable: vtable of the D-Bus interface implemented by the
	//     skeleton.
	Vtable func() *DBusInterfaceVTable
}

func defaultDBusInterfaceSkeletonOverrides(v *DBusInterfaceSkeleton) DBusInterfaceSkeletonOverrides {
	return DBusInterfaceSkeletonOverrides{
		Flush:            v.flush,
		GAuthorizeMethod: v.gAuthorizeMethod,
		Info:             v.info,
		Properties:       v.properties,
		Vtable:           v.vtable,
	}
}

// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
type DBusInterfaceSkeleton struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DBusInterface
}

var (
	_ coreglib.Objector = (*DBusInterfaceSkeleton)(nil)
)

// DBusInterfaceSkeletonner describes types inherited from class DBusInterfaceSkeleton.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type DBusInterfaceSkeletonner interface {
	coreglib.Objector
	baseDBusInterfaceSkeleton() *DBusInterfaceSkeleton
}

var _ DBusInterfaceSkeletonner = (*DBusInterfaceSkeleton)(nil)

func init() {
	coreglib.RegisterClassInfo[*DBusInterfaceSkeleton, *DBusInterfaceSkeletonClass, DBusInterfaceSkeletonOverrides](
		GTypeDBusInterfaceSkeleton,
		initDBusInterfaceSkeletonClass,
		wrapDBusInterfaceSkeleton,
		defaultDBusInterfaceSkeletonOverrides,
	)
}

func initDBusInterfaceSkeletonClass(gclass unsafe.Pointer, overrides DBusInterfaceSkeletonOverrides, classInitFunc func(*DBusInterfaceSkeletonClass)) {
	pclass := (*C.GDBusInterfaceSkeletonClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDBusInterfaceSkeleton))))

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._gotk4_gio2_DBusInterfaceSkeletonClass_flush)
	}

	if overrides.GAuthorizeMethod != nil {
		pclass.g_authorize_method = (*[0]byte)(C._gotk4_gio2_DBusInterfaceSkeletonClass_g_authorize_method)
	}

	if overrides.Info != nil {
		pclass.get_info = (*[0]byte)(C._gotk4_gio2_DBusInterfaceSkeletonClass_get_info)
	}

	if overrides.Properties != nil {
		pclass.get_properties = (*[0]byte)(C._gotk4_gio2_DBusInterfaceSkeletonClass_get_properties)
	}

	if overrides.Vtable != nil {
		pclass.get_vtable = (*[0]byte)(C._gotk4_gio2_DBusInterfaceSkeletonClass_get_vtable)
	}

	if classInitFunc != nil {
		class := (*DBusInterfaceSkeletonClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusInterfaceSkeleton(obj *coreglib.Object) *DBusInterfaceSkeleton {
	return &DBusInterfaceSkeleton{
		Object: obj,
		DBusInterface: DBusInterface{
			Object: obj,
		},
	}
}

func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
	return wrapDBusInterfaceSkeleton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (interface_ *DBusInterfaceSkeleton) baseDBusInterfaceSkeleton() *DBusInterfaceSkeleton {
	return interface_
}

// BaseDBusInterfaceSkeleton returns the underlying base object.
func BaseDBusInterfaceSkeleton(obj DBusInterfaceSkeletonner) *DBusInterfaceSkeleton {
	return obj.baseDBusInterfaceSkeleton()
}

// ConnectGAuthorizeMethod is emitted when a method is invoked by a remote
// caller and used to determine if the method call is authorized.
//
// Note that this signal is emitted in a thread dedicated to handling the
// method call so handlers are allowed to perform blocking IO. This means that
// it is appropriate to call e.g. polkit_authority_check_authorization_sync()
// (http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html#polkit-authority-check-authorization-sync)
// with the POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION
// (http://hal.freedesktop.org/docs/polkit/PolkitAuthority.htmlLKIT-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS)
// flag set.
//
// If FALSE is returned then no further handlers are run and the signal handler
// must take a reference to invocation and finish handling the call (e.g.
// return an error via g_dbus_method_invocation_return_error()).
//
// Otherwise, if TRUE is returned, signal emission continues. If no handlers
// return FALSE, then the method is dispatched. If interface has an enclosing
// BusObjectSkeleton, then the BusObjectSkeleton::authorize-method signal
// handlers run before the handlers for this signal.
//
// The default class handler just returns TRUE.
//
// Please note that the common case is optimized: if no signals
// handlers are connected and the default class handler isn't
// overridden (for both interface and the enclosing BusObjectSkeleton,
// if any) and BusInterfaceSkeleton:g-flags does not have the
// G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD flags
// set, no dedicated thread is ever used and the call will be handled in the
// same thread as the object that interface belongs to was exported in.
func (interface_ *DBusInterfaceSkeleton) ConnectGAuthorizeMethod(f func(invocation *DBusMethodInvocation) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(interface_, "g-authorize-method", false, unsafe.Pointer(C._gotk4_gio2_DBusInterfaceSkeleton_ConnectGAuthorizeMethod), f)
}

// Export exports interface_ at object_path on connection.
//
// This can be called multiple times to export the same interface_ onto multiple
// connections however the object_path provided must be the same for all
// connections.
//
// Use g_dbus_interface_skeleton_unexport() to unexport the object.
//
// The function takes the following parameters:
//
//   - connection to export interface_ on.
//   - objectPath: path to export the interface at.
func (interface_ *DBusInterfaceSkeleton) Export(connection *DBusConnection, objectPath string) error {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out
	var _arg2 *C.gchar                  // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_interface_skeleton_export(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Flush: if interface_ has outstanding changes, request for these changes to be
// emitted immediately.
//
// For example, an exported D-Bus interface may queue up property changes and
// emit the org.freedesktop.DBus.Properties.PropertiesChanged signal later (e.g.
// in an idle handler). This technique is useful for collapsing multiple
// property changes into one.
func (interface_ *DBusInterfaceSkeleton) Flush() {
	var _arg0 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C.g_dbus_interface_skeleton_flush(_arg0)
	runtime.KeepAlive(interface_)
}

// Connection gets the first connection that interface_ is exported on, if any.
//
// The function returns the following values:
//
//   - dBusConnection (optional) or NULL if interface_ is not exported anywhere.
//     Do not free, the object belongs to interface_.
func (interface_ *DBusInterfaceSkeleton) Connection() *DBusConnection {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GDBusConnection        // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_connection(_arg0)
	runtime.KeepAlive(interface_)

	var _dBusConnection *DBusConnection // out

	if _cret != nil {
		_dBusConnection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _dBusConnection
}

// Connections gets a list of the connections that interface_ is exported on.
//
// The function returns the following values:
//
//   - list of all the connections that interface_ is exported on. The returned
//     list should be freed with g_list_free() after each element has been freed
//     with g_object_unref().
func (interface_ *DBusInterfaceSkeleton) Connections() []*DBusConnection {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GList                  // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_connections(_arg0)
	runtime.KeepAlive(interface_)

	var _list []*DBusConnection // out

	_list = make([]*DBusConnection, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDBusConnection)(v)
		var dst *DBusConnection // out
		dst = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Flags gets the BusInterfaceSkeletonFlags that describes what the behavior of
// interface_.
//
// The function returns the following values:
//
//   - dBusInterfaceSkeletonFlags: one or more flags from the
//     BusInterfaceSkeletonFlags enumeration.
func (interface_ *DBusInterfaceSkeleton) Flags() DBusInterfaceSkeletonFlags {
	var _arg0 *C.GDBusInterfaceSkeleton     // out
	var _cret C.GDBusInterfaceSkeletonFlags // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_flags(_arg0)
	runtime.KeepAlive(interface_)

	var _dBusInterfaceSkeletonFlags DBusInterfaceSkeletonFlags // out

	_dBusInterfaceSkeletonFlags = DBusInterfaceSkeletonFlags(_cret)

	return _dBusInterfaceSkeletonFlags
}

// Info gets D-Bus introspection information for the D-Bus interface implemented
// by interface_.
//
// The function returns the following values:
//
//   - dBusInterfaceInfo (never NULL). Do not free.
func (interface_ *DBusInterfaceSkeleton) Info() *DBusInterfaceInfo {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GDBusInterfaceInfo     // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_info(_arg0)
	runtime.KeepAlive(interface_)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_dbus_interface_info_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
		},
	)

	return _dBusInterfaceInfo
}

// ObjectPath gets the object path that interface_ is exported on, if any.
//
// The function returns the following values:
//
//   - utf8 (optional): string owned by interface_ or NULL if interface_ is not
//     exported anywhere. Do not free, the string belongs to interface_.
func (interface_ *DBusInterfaceSkeleton) ObjectPath() string {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.gchar                  // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_object_path(_arg0)
	runtime.KeepAlive(interface_)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Properties gets all D-Bus properties for interface_.
//
// The function returns the following values:
//
//   - variant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with
//     g_variant_unref().
func (interface_ *DBusInterfaceSkeleton) Properties() *glib.Variant {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_properties(_arg0)
	runtime.KeepAlive(interface_)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Vtable gets the interface vtable for the D-Bus interface implemented by
// interface_. The returned function pointers should expect interface_ itself to
// be passed as user_data.
//
// The function returns the following values:
//
//   - dBusInterfaceVTable: vtable of the D-Bus interface implemented by the
//     skeleton.
func (interface_ *DBusInterfaceSkeleton) Vtable() *DBusInterfaceVTable {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GDBusInterfaceVTable   // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_vtable(_arg0)
	runtime.KeepAlive(interface_)

	var _dBusInterfaceVTable *DBusInterfaceVTable // out

	_dBusInterfaceVTable = (*DBusInterfaceVTable)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _dBusInterfaceVTable
}

// HasConnection checks if interface_ is exported on connection.
//
// The function takes the following parameters:
//
//   - connection: BusConnection.
//
// The function returns the following values:
//
//   - ok: TRUE if interface_ is exported on connection, FALSE otherwise.
func (interface_ *DBusInterfaceSkeleton) HasConnection(connection *DBusConnection) bool {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_interface_skeleton_has_connection(_arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(connection)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlags sets flags describing what the behavior of skeleton should be.
//
// The function takes the following parameters:
//
//   - flags flags from the BusInterfaceSkeletonFlags enumeration.
func (interface_ *DBusInterfaceSkeleton) SetFlags(flags DBusInterfaceSkeletonFlags) {
	var _arg0 *C.GDBusInterfaceSkeleton     // out
	var _arg1 C.GDBusInterfaceSkeletonFlags // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg1 = C.GDBusInterfaceSkeletonFlags(flags)

	C.g_dbus_interface_skeleton_set_flags(_arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(flags)
}

// Unexport stops exporting interface_ on all connections it is exported on.
//
// To unexport interface_ from only a single connection, use
// g_dbus_interface_skeleton_unexport_from_connection().
func (interface_ *DBusInterfaceSkeleton) Unexport() {
	var _arg0 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C.g_dbus_interface_skeleton_unexport(_arg0)
	runtime.KeepAlive(interface_)
}

// UnexportFromConnection stops exporting interface_ on connection.
//
// To stop exporting on all connections the interface is exported on, use
// g_dbus_interface_skeleton_unexport().
//
// The function takes the following parameters:
//
//   - connection: BusConnection.
func (interface_ *DBusInterfaceSkeleton) UnexportFromConnection(connection *DBusConnection) {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	C.g_dbus_interface_skeleton_unexport_from_connection(_arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(connection)
}

// Flush: if interface_ has outstanding changes, request for these changes to be
// emitted immediately.
//
// For example, an exported D-Bus interface may queue up property changes and
// emit the org.freedesktop.DBus.Properties.PropertiesChanged signal later (e.g.
// in an idle handler). This technique is useful for collapsing multiple
// property changes into one.
func (interface_ *DBusInterfaceSkeleton) flush() {
	gclass := (*C.GDBusInterfaceSkeletonClass)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.flush

	var _arg0 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C._gotk4_gio2_DBusInterfaceSkeleton_virtual_flush(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(interface_)
}

// gAuthorizeMethod: signal class handler for the
// BusInterfaceSkeleton::g-authorize-method signal.
func (interface_ *DBusInterfaceSkeleton) gAuthorizeMethod(invocation *DBusMethodInvocation) bool {
	gclass := (*C.GDBusInterfaceSkeletonClass)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.g_authorize_method

	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusMethodInvocation  // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg1 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C._gotk4_gio2_DBusInterfaceSkeleton_virtual_g_authorize_method(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(invocation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Info gets D-Bus introspection information for the D-Bus interface implemented
// by interface_.
//
// The function returns the following values:
//
//   - dBusInterfaceInfo (never NULL). Do not free.
func (interface_ *DBusInterfaceSkeleton) info() *DBusInterfaceInfo {
	gclass := (*C.GDBusInterfaceSkeletonClass)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.get_info

	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GDBusInterfaceInfo     // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C._gotk4_gio2_DBusInterfaceSkeleton_virtual_get_info(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(interface_)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_dbus_interface_info_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
		},
	)

	return _dBusInterfaceInfo
}

// Properties gets all D-Bus properties for interface_.
//
// The function returns the following values:
//
//   - variant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with
//     g_variant_unref().
func (interface_ *DBusInterfaceSkeleton) properties() *glib.Variant {
	gclass := (*C.GDBusInterfaceSkeletonClass)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.get_properties

	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C._gotk4_gio2_DBusInterfaceSkeleton_virtual_get_properties(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(interface_)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Vtable gets the interface vtable for the D-Bus interface implemented by
// interface_. The returned function pointers should expect interface_ itself to
// be passed as user_data.
//
// The function returns the following values:
//
//   - dBusInterfaceVTable: vtable of the D-Bus interface implemented by the
//     skeleton.
func (interface_ *DBusInterfaceSkeleton) vtable() *DBusInterfaceVTable {
	gclass := (*C.GDBusInterfaceSkeletonClass)(coreglib.PeekParentClass(interface_))
	fnarg := gclass.get_vtable

	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GDBusInterfaceVTable   // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C._gotk4_gio2_DBusInterfaceSkeleton_virtual_get_vtable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(interface_)

	var _dBusInterfaceVTable *DBusInterfaceVTable // out

	_dBusInterfaceVTable = (*DBusInterfaceVTable)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _dBusInterfaceVTable
}

// DBusMenuModel: GDBusMenuModel is an implementation of gio.MenuModel that
// can be used as a proxy for a menu model that is exported over D-Bus with
// gio.DBusConnection.ExportMenuModel().
type DBusMenuModel struct {
	_ [0]func() // equal guard
	MenuModel
}

var (
	_ MenuModeller = (*DBusMenuModel)(nil)
)

func wrapDBusMenuModel(obj *coreglib.Object) *DBusMenuModel {
	return &DBusMenuModel{
		MenuModel: MenuModel{
			Object: obj,
		},
	}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	return wrapDBusMenuModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DBusMenuModelGet obtains a BusMenuModel for the menu model which is exported
// at the given bus_name and object_path.
//
// The thread default main context is taken at the time of this call. All
// signals on the menu model (and any linked models) are reported with respect
// to this context. All calls on the returned menu model (and linked models)
// must also originate from this same context, with the thread default main
// context unchanged.
//
// The function takes the following parameters:
//
//   - connection: BusConnection.
//   - busName (optional) bus name which exports the menu model or NULL if
//     connection is not a message bus connection.
//   - objectPath: object path at which the menu model is exported.
//
// The function returns the following values:
//
//   - dBusMenuModel object. Free with g_object_unref().
func DBusMenuModelGet(connection *DBusConnection, busName, objectPath string) *DBusMenuModel {
	var _arg1 *C.GDBusConnection // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _cret *C.GDBusMenuModel  // in

	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	if busName != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(busName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_menu_model_get(_arg1, _arg2, _arg3)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(busName)
	runtime.KeepAlive(objectPath)

	var _dBusMenuModel *DBusMenuModel // out

	_dBusMenuModel = wrapDBusMenuModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMenuModel
}

// DBusMessage: type for representing D-Bus messages that can be sent or
// received on a gio.DBusConnection.
type DBusMessage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DBusMessage)(nil)
)

func wrapDBusMessage(obj *coreglib.Object) *DBusMessage {
	return &DBusMessage{
		Object: obj,
	}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	return wrapDBusMessage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDBusMessage creates a new empty BusMessage.
//
// The function returns the following values:
//
//   - dBusMessage Free with g_object_unref().
func NewDBusMessage() *DBusMessage {
	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new()

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewDBusMessageFromBlob creates a new BusMessage from the data stored
// at blob. The byte order that the message was in can be retrieved using
// g_dbus_message_get_byte_order().
//
// If the blob cannot be parsed, contains invalid fields, or contains invalid
// headers, G_IO_ERROR_INVALID_ARGUMENT will be returned.
//
// The function takes the following parameters:
//
//   - blob representing a binary D-Bus message.
//   - capabilities describing what protocol features are supported.
//
// The function returns the following values:
//
//   - dBusMessage: new BusMessage or NULL if error is set. Free with
//     g_object_unref().
func NewDBusMessageFromBlob(blob []byte, capabilities DBusCapabilityFlags) (*DBusMessage, error) {
	var _arg1 *C.guchar // out
	var _arg2 C.gsize
	var _arg3 C.GDBusCapabilityFlags // out
	var _cret *C.GDBusMessage        // in
	var _cerr *C.GError              // in

	_arg2 = (C.gsize)(len(blob))
	if len(blob) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
	}
	_arg3 = C.GDBusCapabilityFlags(capabilities)

	_cret = C.g_dbus_message_new_from_blob(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(blob)
	runtime.KeepAlive(capabilities)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusMessage, _goerr
}

// NewDBusMessageMethodCall creates a new BusMessage for a method call.
//
// The function takes the following parameters:
//
//   - name (optional): valid D-Bus name or NULL.
//   - path: valid object path.
//   - interface_ (optional): valid D-Bus interface name or NULL.
//   - method: valid method name.
//
// The function returns the following values:
//
//   - dBusMessage Free with g_object_unref().
func NewDBusMessageMethodCall(name, path, interface_, method string) *DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg2))
	if interface_ != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(interface_)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(path)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(method)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewDBusMessageSignal creates a new BusMessage for a signal emission.
//
// The function takes the following parameters:
//
//   - path: valid object path.
//   - interface_: valid D-Bus interface name.
//   - signal: valid signal name.
//
// The function returns the following values:
//
//   - dBusMessage Free with g_object_unref().
func NewDBusMessageSignal(path, interface_, signal string) *DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(interface_)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(signal)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)
	runtime.KeepAlive(path)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(signal)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// Copy copies message. The copy is a deep copy and the returned BusMessage is
// completely identical except that it is guaranteed to not be locked.
//
// This operation can fail if e.g. message contains file descriptors and the
// per-process or system-wide open files limit is reached.
//
// The function returns the following values:
//
//   - dBusMessage: new BusMessage or NULL if error is set. Free with
//     g_object_unref().
func (message *DBusMessage) Copy() (*DBusMessage, error) {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_copy(_arg0, &_cerr)
	runtime.KeepAlive(message)

	var _dBusMessage *DBusMessage // out
	var _goerr error              // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusMessage, _goerr
}

// Arg0: convenience to get the first item in the body of message.
//
// See gio.DBusMessage.GetArg0Path() for returning object-path-typed arg0
// values.
//
// The function returns the following values:
//
//   - utf8 (optional): string item or NULL if the first item in the body of
//     message is not a string.
func (message *DBusMessage) Arg0() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_arg0(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Arg0Path: convenience to get the first item in the body of message.
//
// See gio.DBusMessage.GetArg0() for returning string-typed arg0 values.
//
// The function returns the following values:
//
//   - utf8 (optional): object path item or NULL if the first item in the body
//     of message is not an object path.
func (message *DBusMessage) Arg0Path() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_arg0_path(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Body gets the body of a message.
//
// The function returns the following values:
//
//   - variant (optional) or NULL if the body is empty. Do not free, it is owned
//     by message.
func (message *DBusMessage) Body() *glib.Variant {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_body(_arg0)
	runtime.KeepAlive(message)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_variant_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// ByteOrder gets the byte order of message.
//
// The function returns the following values:
//
//   - dBusMessageByteOrder: byte order.
func (message *DBusMessage) ByteOrder() DBusMessageByteOrder {
	var _arg0 *C.GDBusMessage         // out
	var _cret C.GDBusMessageByteOrder // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_byte_order(_arg0)
	runtime.KeepAlive(message)

	var _dBusMessageByteOrder DBusMessageByteOrder // out

	_dBusMessageByteOrder = DBusMessageByteOrder(_cret)

	return _dBusMessageByteOrder
}

// Destination: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
//
// The function returns the following values:
//
//   - utf8 (optional): value.
func (message *DBusMessage) Destination() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_destination(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ErrorName: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME
// header field.
//
// The function returns the following values:
//
//   - utf8 (optional): value.
func (message *DBusMessage) ErrorName() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_error_name(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Flags gets the flags for message.
//
// The function returns the following values:
//
//   - dBusMessageFlags flags that are set (typically values from the
//     BusMessageFlags enumeration bitwise ORed together).
func (message *DBusMessage) Flags() DBusMessageFlags {
	var _arg0 *C.GDBusMessage     // out
	var _cret C.GDBusMessageFlags // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_flags(_arg0)
	runtime.KeepAlive(message)

	var _dBusMessageFlags DBusMessageFlags // out

	_dBusMessageFlags = DBusMessageFlags(_cret)

	return _dBusMessageFlags
}

// Header gets a header field on message.
//
// The caller is responsible for checking the type of the returned #GVariant
// matches what is expected.
//
// The function takes the following parameters:
//
//   - headerField: 8-bit unsigned integer (typically a value from the
//     BusMessageHeaderField enumeration).
//
// The function returns the following values:
//
//   - variant (optional) with the value if the header was found, NULL
//     otherwise. Do not free, it is owned by message.
func (message *DBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)

	_cret = C.g_dbus_message_get_header(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(headerField)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_variant_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// HeaderFields gets an array of all header fields on message that are set.
//
// The function returns the following values:
//
//   - guint8s: array of header fields terminated by
//     G_DBUS_MESSAGE_HEADER_FIELD_INVALID. Each element is a #guchar. Free with
//     g_free().
func (message *DBusMessage) HeaderFields() []byte {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.guchar       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_header_fields(_arg0)
	runtime.KeepAlive(message)

	var _guint8s []byte // out

	{
		var i int
		var z C.guchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

// Interface: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE
// header field.
//
// The function returns the following values:
//
//   - utf8 (optional): value.
func (message *DBusMessage) Interface() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_interface(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Locked checks whether message is locked. To monitor changes to this value,
// conncet to the #GObject::notify signal to listen for changes on the
// BusMessage:locked property.
//
// The function returns the following values:
//
//   - ok: TRUE if message is locked, FALSE otherwise.
func (message *DBusMessage) Locked() bool {
	var _arg0 *C.GDBusMessage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_locked(_arg0)
	runtime.KeepAlive(message)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header
// field.
//
// The function returns the following values:
//
//   - utf8 (optional): value.
func (message *DBusMessage) Member() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_member(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MessageType gets the type of message.
//
// The function returns the following values:
//
//   - dBusMessageType: 8-bit unsigned integer (typically a value from the
//     BusMessageType enumeration).
func (message *DBusMessage) MessageType() DBusMessageType {
	var _arg0 *C.GDBusMessage    // out
	var _cret C.GDBusMessageType // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_message_type(_arg0)
	runtime.KeepAlive(message)

	var _dBusMessageType DBusMessageType // out

	_dBusMessageType = DBusMessageType(_cret)

	return _dBusMessageType
}

// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
//
// The function returns the following values:
//
//   - utf8 (optional): value.
func (message *DBusMessage) Path() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_path(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ReplySerial: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
//
// The function returns the following values:
//
//   - guint32: value.
func (message *DBusMessage) ReplySerial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_reply_serial(_arg0)
	runtime.KeepAlive(message)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header
// field.
//
// The function returns the following values:
//
//   - utf8 (optional): value.
func (message *DBusMessage) Sender() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_sender(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Serial gets the serial for message.
//
// The function returns the following values:
//
//   - guint32: #guint32.
func (message *DBusMessage) Serial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_serial(_arg0)
	runtime.KeepAlive(message)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Signature: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE
// header field.
//
// This will always be non-NULL, but may be an empty string.
//
// The function returns the following values:
//
//   - utf8: value.
func (message *DBusMessage) Signature() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_dbus_message_get_signature(_arg0)
	runtime.KeepAlive(message)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Lock: if message is locked, does nothing. Otherwise locks the message.
func (message *DBusMessage) Lock() {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	C.g_dbus_message_lock(_arg0)
	runtime.KeepAlive(message)
}

// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
// method_call_message.
//
// The function takes the following parameters:
//
//   - errorName: valid D-Bus error name.
//   - errorMessage d-Bus error message.
//
// The function returns the following values:
//
//   - dBusMessage Free with g_object_unref().
func (methodCallMessage *DBusMessage) NewMethodErrorLiteral(errorName, errorMessage string) *DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(methodCallMessage).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(errorName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)
	runtime.KeepAlive(methodCallMessage)
	runtime.KeepAlive(errorName)
	runtime.KeepAlive(errorMessage)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// NewMethodReply creates a new BusMessage that is a reply to
// method_call_message.
//
// The function returns the following values:
//
//   - dBusMessage Free with g_object_unref().
func (methodCallMessage *DBusMessage) NewMethodReply() *DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(methodCallMessage).Native()))

	_cret = C.g_dbus_message_new_method_reply(_arg0)
	runtime.KeepAlive(methodCallMessage)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// Print produces a human-readable multi-line description of message.
//
// The contents of the description has no ABI guarantees, the contents and
// formatting is subject to change at any time. Typical output looks something
// like this:
//
//	Flags:   none
//	Version: 0
//	Serial:  4
//	Headers:
//	  path -> objectpath '/org/gtk/GDBus/TestObject'
//	  interface -> 'org.gtk.GDBus.TestInterface'
//	  member -> 'GimmeStdout'
//	  destination -> ':1.146'
//	Body: ()
//	UNIX File Descriptors:
//	  (none)
//
// or
//
//	Flags:   no-reply-expected
//	Version: 0
//	Serial:  477
//	Headers:
//	  reply-serial -> uint32 4
//	  destination -> ':1.159'
//	  sender -> ':1.146'
//	  num-unix-fds -> uint32 1
//	Body: ()
//	UNIX File Descriptors:
//	  fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635.
//
// The function takes the following parameters:
//
//   - indent: indentation level.
//
// The function returns the following values:
//
//   - utf8: string that should be freed with glib.Free().
func (message *DBusMessage) Print(indent uint) string {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.guint(indent)

	_cret = C.g_dbus_message_print(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(indent)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetBody sets the body message. As a side-effect the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type string
// of body (or cleared if body is NULL).
//
// If body is floating, message assumes ownership of body.
//
// The function takes the following parameters:
//
//   - body: either NULL or a #GVariant that is a tuple.
func (message *DBusMessage) SetBody(body *glib.Variant) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(body)))

	C.g_dbus_message_set_body(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(body)
}

// SetByteOrder sets the byte order of message.
//
// The function takes the following parameters:
//
//   - byteOrder: byte order.
func (message *DBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	var _arg0 *C.GDBusMessage         // out
	var _arg1 C.GDBusMessageByteOrder // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.GDBusMessageByteOrder(byteOrder)

	C.g_dbus_message_set_byte_order(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(byteOrder)
}

// SetDestination: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
//
// The function takes the following parameters:
//
//   - value (optional) to set.
func (message *DBusMessage) SetDestination(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_destination(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// SetErrorName: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
//
// The function takes the following parameters:
//
//   - value to set.
func (message *DBusMessage) SetErrorName(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	if message != nil {
		_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_error_name(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// SetFlags sets the flags to set on message.
//
// The function takes the following parameters:
//
//   - flags flags for message that are set (typically values from the
//     BusMessageFlags enumeration bitwise ORed together).
func (message *DBusMessage) SetFlags(flags DBusMessageFlags) {
	var _arg0 *C.GDBusMessage     // out
	var _arg1 C.GDBusMessageFlags // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.GDBusMessageFlags(flags)

	C.g_dbus_message_set_flags(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(flags)
}

// SetHeader sets a header field on message.
//
// If value is floating, message assumes ownership of value.
//
// The function takes the following parameters:
//
//   - headerField: 8-bit unsigned integer (typically a value from the
//     BusMessageHeaderField enumeration).
//   - value (optional) to set the header field or NULL to clear the header
//     field.
func (message *DBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _arg2 *C.GVariant               // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)
	if value != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	}

	C.g_dbus_message_set_header(_arg0, _arg1, _arg2)
	runtime.KeepAlive(message)
	runtime.KeepAlive(headerField)
	runtime.KeepAlive(value)
}

// SetInterface: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
//
// The function takes the following parameters:
//
//   - value (optional) to set.
func (message *DBusMessage) SetInterface(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_interface(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
//
// The function takes the following parameters:
//
//   - value (optional) to set.
func (message *DBusMessage) SetMember(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_member(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// SetMessageType sets message to be of type.
//
// The function takes the following parameters:
//
//   - typ: 8-bit unsigned integer (typically a value from the BusMessageType
//     enumeration).
func (message *DBusMessage) SetMessageType(typ DBusMessageType) {
	var _arg0 *C.GDBusMessage    // out
	var _arg1 C.GDBusMessageType // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.GDBusMessageType(typ)

	C.g_dbus_message_set_message_type(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(typ)
}

// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
//
// The function takes the following parameters:
//
//   - value (optional) to set.
func (message *DBusMessage) SetPath(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_path(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// SetReplySerial: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
//
// The function takes the following parameters:
//
//   - value to set.
func (message *DBusMessage) SetReplySerial(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
//
// The function takes the following parameters:
//
//   - value (optional) to set.
func (message *DBusMessage) SetSender(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_sender(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// SetSerial sets the serial for message.
//
// The function takes the following parameters:
//
//   - serial: #guint32.
func (message *DBusMessage) SetSerial(serial uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(serial)
}

// SetSignature: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
//
// The function takes the following parameters:
//
//   - value (optional) to set.
func (message *DBusMessage) SetSignature(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	if value != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_dbus_message_set_signature(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(value)
}

// ToBlob serializes message to a blob. The byte order returned by
// g_dbus_message_get_byte_order() will be used.
//
// The function takes the following parameters:
//
//   - capabilities describing what protocol features are supported.
//
// The function returns the following values:
//
//   - guint8s: pointer to a valid binary D-Bus message of out_size bytes
//     generated by message or NULL if error is set. Free with g_free().
func (message *DBusMessage) ToBlob(capabilities DBusCapabilityFlags) ([]byte, error) {
	var _arg0 *C.GDBusMessage        // out
	var _arg2 C.GDBusCapabilityFlags // out
	var _cret *C.guchar              // in
	var _arg1 C.gsize                // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg2 = C.GDBusCapabilityFlags(capabilities)

	_cret = C.g_dbus_message_to_blob(_arg0, &_arg1, _arg2, &_cerr)
	runtime.KeepAlive(message)
	runtime.KeepAlive(capabilities)

	var _guint8s []byte // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint8s, _goerr
}

// ToGError: if message is not of type G_DBUS_MESSAGE_TYPE_ERROR does nothing
// and returns FALSE.
//
// Otherwise this method encodes the error in message as a #GError
// using g_dbus_error_set_dbus_error() using the information in the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of message as well as the
// first string item in message's body.
func (message *DBusMessage) ToGError() error {
	var _arg0 *C.GDBusMessage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	C.g_dbus_message_to_gerror(_arg0, &_cerr)
	runtime.KeepAlive(message)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DBusMessageBytesNeeded: utility function to calculate how many bytes are
// needed to completely deserialize the D-Bus message stored at blob.
//
// The function takes the following parameters:
//
//   - blob representing a binary D-Bus message.
//
// The function returns the following values:
//
//   - gssize: number of bytes needed or -1 if error is set (e.g. if blob
//     contains invalid data or not enough data is available to determine the
//     size).
func DBusMessageBytesNeeded(blob []byte) (int, error) {
	var _arg1 *C.guchar // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg2 = (C.gsize)(len(blob))
	if len(blob) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
	}

	_cret = C.g_dbus_message_bytes_needed(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(blob)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// DBusMethodInvocation instances of the GDBusMethodInvocation class are used
// when handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a GDBusMethodInvocation object is to receive it as
// an argument to the handle_method_call() function in a gio.DBusInterfaceVTable
// that was passed to gio.DBusConnection.RegisterObject().
type DBusMethodInvocation struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DBusMethodInvocation)(nil)
)

func wrapDBusMethodInvocation(obj *coreglib.Object) *DBusMethodInvocation {
	return &DBusMethodInvocation{
		Object: obj,
	}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	return wrapDBusMethodInvocation(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Connection gets the BusConnection the method was invoked on.
//
// The function returns the following values:
//
//   - dBusConnection Do not free, it is owned by invocation.
func (invocation *DBusMethodInvocation) Connection() *DBusConnection {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusConnection       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_connection(_arg0)
	runtime.KeepAlive(invocation)

	var _dBusConnection *DBusConnection // out

	_dBusConnection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(_cret)))

	return _dBusConnection
}

// InterfaceName gets the name of the D-Bus interface the method was invoked on.
//
// If this method call is a property Get, Set or GetAll call that has been
// redirected to the method call handler then "org.freedesktop.DBus.Properties"
// will be returned. See BusInterfaceVTable for more information.
//
// The function returns the following values:
//
//   - utf8: string. Do not free, it is owned by invocation.
func (invocation *DBusMethodInvocation) InterfaceName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)
	runtime.KeepAlive(invocation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Message gets the BusMessage for the method invocation. This is useful if
// you need to use low-level protocol features, such as UNIX file descriptor
// passing, that cannot be properly expressed in the #GVariant API.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for
// an example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// The function returns the following values:
//
//   - dBusMessage Do not free, it is owned by invocation.
func (invocation *DBusMethodInvocation) Message() *DBusMessage {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMessage          // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_message(_arg0)
	runtime.KeepAlive(invocation)

	var _dBusMessage *DBusMessage // out

	_dBusMessage = wrapDBusMessage(coreglib.Take(unsafe.Pointer(_cret)))

	return _dBusMessage
}

// MethodInfo gets information about the method call, if any.
//
// If this method invocation is a property Get, Set or GetAll call that has
// been redirected to the method call handler then NULL will be returned.
// See g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
// more information.
//
// The function returns the following values:
//
//   - dBusMethodInfo (optional) or NULL. Do not free, it is owned by
//     invocation.
func (invocation *DBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMethodInfo       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_method_info(_arg0)
	runtime.KeepAlive(invocation)

	var _dBusMethodInfo *DBusMethodInfo // out

	if _cret != nil {
		_dBusMethodInfo = (*DBusMethodInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_method_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusMethodInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(intern.C))
			},
		)
	}

	return _dBusMethodInfo
}

// MethodName gets the name of the method that was invoked.
//
// The function returns the following values:
//
//   - utf8: string. Do not free, it is owned by invocation.
func (invocation *DBusMethodInvocation) MethodName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_method_name(_arg0)
	runtime.KeepAlive(invocation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ObjectPath gets the object path the method was invoked on.
//
// The function returns the following values:
//
//   - utf8: string. Do not free, it is owned by invocation.
func (invocation *DBusMethodInvocation) ObjectPath() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_object_path(_arg0)
	runtime.KeepAlive(invocation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Parameters gets the parameters of the method invocation. If there are no
// input parameters then this will return a GVariant with 0 children rather than
// NULL.
//
// The function returns the following values:
//
//   - variant tuple. Do not unref this because it is owned by invocation.
func (invocation *DBusMethodInvocation) Parameters() *glib.Variant {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GVariant              // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_parameters(_arg0)
	runtime.KeepAlive(invocation)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// PropertyInfo gets information about the property that this method call is
// for, if any.
//
// This will only be set in the case of an invocation in response to a property
// Get or Set call that has been directed to the method call handler for an
// object on account of its property_get() or property_set() vtable pointers
// being unset.
//
// See BusInterfaceVTable for more information.
//
// If the call was GetAll, NULL will be returned.
//
// The function returns the following values:
//
//   - dBusPropertyInfo (optional) or NULL.
func (invocation *DBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusPropertyInfo     // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_property_info(_arg0)
	runtime.KeepAlive(invocation)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	if _cret != nil {
		_dBusPropertyInfo = (*DBusPropertyInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_property_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusPropertyInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(intern.C))
			},
		)
	}

	return _dBusPropertyInfo
}

// Sender gets the bus name that invoked the method.
//
// The function returns the following values:
//
//   - utf8: string. Do not free, it is owned by invocation.
func (invocation *DBusMethodInvocation) Sender() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C.g_dbus_method_invocation_get_sender(_arg0)
	runtime.KeepAlive(invocation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ReturnDBusError finishes handling a D-Bus method call by returning an error.
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
//
// The function takes the following parameters:
//
//   - errorName: valid D-Bus error name.
//   - errorMessage: valid D-Bus error message.
func (invocation *DBusMethodInvocation) ReturnDBusError(errorName, errorMessage string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.gchar                 // out
	var _arg2 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(invocation).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(errorName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(errorMessage)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
	runtime.KeepAlive(invocation)
	runtime.KeepAlive(errorName)
	runtime.KeepAlive(errorMessage)
}

// ReturnErrorLiteral: like g_dbus_method_invocation_return_error() but without
// printf()-style formatting.
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
//
// The function takes the following parameters:
//
//   - domain for the #GError error domain.
//   - code: error code.
//   - message: error message.
func (invocation *DBusMethodInvocation) ReturnErrorLiteral(domain glib.Quark, code int, message string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 C.GQuark                 // out
	var _arg2 C.gint                   // out
	var _arg3 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(invocation).Native()))
	_arg1 = C.GQuark(domain)
	_arg2 = C.gint(code)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_dbus_method_invocation_return_error_literal(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(invocation)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(message)
}

// ReturnGError: like g_dbus_method_invocation_return_error() but takes a
// #GError instead of the error domain, error code and message.
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
//
// The function takes the following parameters:
//
//   - err: #GError.
func (invocation *DBusMethodInvocation) ReturnGError(err error) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GError                // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(invocation).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
	runtime.KeepAlive(invocation)
	runtime.KeepAlive(err)
}

// ReturnValue finishes handling a D-Bus method call by returning parameters.
// If the parameters GVariant is floating, it is consumed.
//
// It is an error if parameters is not of the right format: it must be a tuple
// containing the out-parameters of the D-Bus method. Even if the method has a
// single out-parameter, it must be contained in a tuple. If the method has no
// out-parameters, parameters may be NULL or an empty tuple.
//
//	GDBusMethodInvocation *invocation = some_invocation;
//	g_autofree gchar *result_string = NULL;
//	g_autoptr (GError) error = NULL;
//
//	result_string = calculate_result (&error);
//
//	if (error != NULL)
//	  g_dbus_method_invocation_return_gerror (invocation, error);
//	else
//	  g_dbus_method_invocation_return_value (invocation,
//	                                         g_variant_new ("(s)", result_string));
//
//	// Do not free invocation here; returning a value does that
//
// This method will take ownership of invocation. See BusInterfaceVTable for
// more information about the ownership of invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent then this
// call will sink parameters and free invocation, but otherwise do nothing (as
// per the recommendations of the D-Bus specification).
//
// The function takes the following parameters:
//
//   - parameters (optional) tuple with out parameters for the method or NULL if
//     not passing any parameters.
func (invocation *DBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(invocation).Native()))
	if parameters != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}

	C.g_dbus_method_invocation_return_value(_arg0, _arg1)
	runtime.KeepAlive(invocation)
	runtime.KeepAlive(parameters)
}

// DBusObjectManagerClientOverrides contains methods that are overridable.
type DBusObjectManagerClientOverrides struct {
	// InterfaceProxySignal: signal class handler for the
	// BusObjectManagerClient::interface-proxy-signal signal.
	//
	// The function takes the following parameters:
	//
	//   - objectProxy
	//   - interfaceProxy
	//   - senderName
	//   - signalName
	//   - parameters
	InterfaceProxySignal func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, senderName, signalName string, parameters *glib.Variant)
}

func defaultDBusObjectManagerClientOverrides(v *DBusObjectManagerClient) DBusObjectManagerClientOverrides {
	return DBusObjectManagerClientOverrides{
		InterfaceProxySignal: v.interfaceProxySignal,
	}
}

// DBusObjectManagerClient: GDBusObjectManagerClient is used
// to create, monitor and delete object proxies for remote
// objects exported by a gio.DBusObjectManagerServer (or any
// code implementing the org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to the
// gio.DBusObjectManager::object-added and gio.DBusObjectManager::object-removed
// signals and inspect the gio.DBusObjectProxy objects returned by
// gio.DBusObjectManager.GetObjects().
//
// If the name for a GDBusObjectManagerClient is not owned by anyone at
// object construction time, the default behavior is to request the message
// bus to launch an owner for the name. This behavior can be disabled using
// the G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. Its also
// worth noting that this only works if the name of interest is activatable
// in the first place. E.g. in some cases it is not possible to launch an
// owner for the requested name. In this case, GDBusObjectManagerClient object
// construction still succeeds but there will be no object proxies (e.g.
// gio.DBusObjectManager.GetObjects() returns the empty list) and the
// gio.DBusObjectManagerClient:name-owner property is NULL.
//
// The owner of the requested name can come and go (for example consider a
// system service being restarted)  GDBusObjectManagerClient handles this
// case too; simply connect to the gobject.Object::notify signal to watch for
// changes on the gio.DBusObjectManagerClient:name-owner property. When the name
// owner vanishes, the behavior is that gio.DBusObjectManagerClient:name-owner
// is set to NULL (this includes emission of the gobject.Object::notify
// signal) and then gio.DBusObjectManager::object-removed signals
// are synthesized for all currently existing object proxies. Since
// gio.DBusObjectManagerClient:name-owner is NULL when this happens,
// you can use this information to disambiguate a synthesized signal from a
// genuine signal caused by object removal on the remote gio.DBusObjectManager.
// Similarly, when a new name owner appears, gio.DBusObjectManager::object-added
// signals are synthesized while gio.DBusObjectManagerClient:name-owner
// is still NULL. Only when all object proxies have been added, the
// gio.DBusObjectManagerClient:name-owner is set to the new name owner (this
// includes emission of the gobject.Object::notify signal). Furthermore,
// you are guaranteed that gio.DBusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. :1.42) and NULL even in the case where the name of
// interest is atomically replaced
//
// Ultimately, GDBusObjectManagerClient is used to obtain
// gio.DBusProxy instances. All signals (including the
// org.freedesktop.DBus.Properties::PropertiesChanged signal) delivered to
// gio.DBusProxy instances are guaranteed to originate from the name owner.
// This guarantee along with the behavior described above, means that certain
// race conditions including the half the proxy is from the old owner and the
// other half is from the new owner problem cannot happen.
//
// To avoid having the application connect to signals on the
// returned gio.DBusObjectProxy and gio.DBusProxy objects, the
// gio.DBusObject::interface-added, gio.DBusObject::interface-removed,
// gio.DBusProxy::g-properties-changed and gio.DBusProxy::g-signal signals
// are also emitted on the GDBusObjectManagerClient instance managing these
// objects. The signals emitted are gio.DBusObjectManager::interface-added,
// gio.DBusObjectManager::interface-removed,
// gio.DBusObjectManagerClient::interface-proxy-properties-changed and
// gio.DBusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the thread-default
// main context (see glib.MainContext.PushThreadDefault()) that the
// GDBusObjectManagerClient object was constructed in. Additionally,
// the gio.DBusObjectProxy and gio.DBusProxy objects originating from the
// GDBusObjectManagerClient object will be created in the same context and,
// consequently, will deliver signals in the same main loop.
type DBusObjectManagerClient struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncInitable
	DBusObjectManager
	Initable
}

var (
	_ coreglib.Objector = (*DBusObjectManagerClient)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DBusObjectManagerClient, *DBusObjectManagerClientClass, DBusObjectManagerClientOverrides](
		GTypeDBusObjectManagerClient,
		initDBusObjectManagerClientClass,
		wrapDBusObjectManagerClient,
		defaultDBusObjectManagerClientOverrides,
	)
}

func initDBusObjectManagerClientClass(gclass unsafe.Pointer, overrides DBusObjectManagerClientOverrides, classInitFunc func(*DBusObjectManagerClientClass)) {
	pclass := (*C.GDBusObjectManagerClientClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDBusObjectManagerClient))))

	if overrides.InterfaceProxySignal != nil {
		pclass.interface_proxy_signal = (*[0]byte)(C._gotk4_gio2_DBusObjectManagerClientClass_interface_proxy_signal)
	}

	if classInitFunc != nil {
		class := (*DBusObjectManagerClientClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusObjectManagerClient(obj *coreglib.Object) *DBusObjectManagerClient {
	return &DBusObjectManagerClient{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		DBusObjectManager: DBusObjectManager{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
	return wrapDBusObjectManagerClient(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectInterfaceProxyPropertiesChanged is emitted when one or more
// D-Bus properties on proxy changes. The local cache has already been
// updated when this signal fires. Note that both changed_properties and
// invalidated_properties are guaranteed to never be NULL (either may be empty
// though).
//
// This signal exists purely as a convenience to avoid having to connect signals
// to all interface proxies managed by manager.
//
// This signal is emitted in the [thread-default main
// context][g-main-context-push-thread-default] that manager was constructed in.
func (manager *DBusObjectManagerClient) ConnectInterfaceProxyPropertiesChanged(f func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, changedProperties *glib.Variant, invalidatedProperties []string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "interface-proxy-properties-changed", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxyPropertiesChanged), f)
}

// ConnectInterfaceProxySignal is emitted when a D-Bus signal is received on
// interface_proxy.
//
// This signal exists purely as a convenience to avoid having to connect signals
// to all interface proxies managed by manager.
//
// This signal is emitted in the [thread-default main
// context][g-main-context-push-thread-default] that manager was constructed in.
func (manager *DBusObjectManagerClient) ConnectInterfaceProxySignal(f func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, senderName, signalName string, parameters *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "interface-proxy-signal", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxySignal), f)
}

// NewDBusObjectManagerClientFinish finishes an operation started with
// g_dbus_object_manager_client_new().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to
//     g_dbus_object_manager_client_new().
//
// The function returns the following values:
//
//   - dBusObjectManagerClient: a BusObjectManagerClient object or NULL if error
//     is set. Free with g_object_unref().
func NewDBusObjectManagerClientFinish(res AsyncResulter) (*DBusObjectManagerClient, error) {
	var _arg1 *C.GAsyncResult       // out
	var _cret *C.GDBusObjectManager // in
	var _cerr *C.GError             // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_object_manager_client_new_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusObjectManagerClient *DBusObjectManagerClient // out
	var _goerr error                                      // out

	_dBusObjectManagerClient = wrapDBusObjectManagerClient(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusObjectManagerClient, _goerr
}

// NewDBusObjectManagerClientForBusFinish finishes an operation started with
// g_dbus_object_manager_client_new_for_bus().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to
//     g_dbus_object_manager_client_new_for_bus().
//
// The function returns the following values:
//
//   - dBusObjectManagerClient: a BusObjectManagerClient object or NULL if error
//     is set. Free with g_object_unref().
func NewDBusObjectManagerClientForBusFinish(res AsyncResulter) (*DBusObjectManagerClient, error) {
	var _arg1 *C.GAsyncResult       // out
	var _cret *C.GDBusObjectManager // in
	var _cerr *C.GError             // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_object_manager_client_new_for_bus_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusObjectManagerClient *DBusObjectManagerClient // out
	var _goerr error                                      // out

	_dBusObjectManagerClient = wrapDBusObjectManagerClient(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusObjectManagerClient, _goerr
}

// Connection gets the BusConnection used by manager.
//
// The function returns the following values:
//
//   - dBusConnection object. Do not free, the object belongs to manager.
func (manager *DBusObjectManagerClient) Connection() *DBusConnection {
	var _arg0 *C.GDBusObjectManagerClient // out
	var _cret *C.GDBusConnection          // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.g_dbus_object_manager_client_get_connection(_arg0)
	runtime.KeepAlive(manager)

	var _dBusConnection *DBusConnection // out

	_dBusConnection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(_cret)))

	return _dBusConnection
}

// Flags gets the flags that manager was constructed with.
//
// The function returns the following values:
//
//   - dBusObjectManagerClientFlags: zero of more flags from the
//     BusObjectManagerClientFlags enumeration.
func (manager *DBusObjectManagerClient) Flags() DBusObjectManagerClientFlags {
	var _arg0 *C.GDBusObjectManagerClient     // out
	var _cret C.GDBusObjectManagerClientFlags // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.g_dbus_object_manager_client_get_flags(_arg0)
	runtime.KeepAlive(manager)

	var _dBusObjectManagerClientFlags DBusObjectManagerClientFlags // out

	_dBusObjectManagerClientFlags = DBusObjectManagerClientFlags(_cret)

	return _dBusObjectManagerClientFlags
}

// Name gets the name that manager is for, or NULL if not a message bus
// connection.
//
// The function returns the following values:
//
//   - utf8: unique or well-known name. Do not free, the string belongs to
//     manager.
func (manager *DBusObjectManagerClient) Name() string {
	var _arg0 *C.GDBusObjectManagerClient // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.g_dbus_object_manager_client_get_name(_arg0)
	runtime.KeepAlive(manager)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NameOwner: unique name that owns the name that manager is for or NULL if
// no-one currently owns that name. You can connect to the #GObject::notify
// signal to track changes to the BusObjectManagerClient:name-owner property.
//
// The function returns the following values:
//
//   - utf8 (optional): name owner or NULL if no name owner exists. Free with
//     g_free().
func (manager *DBusObjectManagerClient) NameOwner() string {
	var _arg0 *C.GDBusObjectManagerClient // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.g_dbus_object_manager_client_get_name_owner(_arg0)
	runtime.KeepAlive(manager)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// interfaceProxySignal: signal class handler for the
// BusObjectManagerClient::interface-proxy-signal signal.
//
// The function takes the following parameters:
//
//   - objectProxy
//   - interfaceProxy
//   - senderName
//   - signalName
//   - parameters
func (manager *DBusObjectManagerClient) interfaceProxySignal(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, senderName, signalName string, parameters *glib.Variant) {
	gclass := (*C.GDBusObjectManagerClientClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.interface_proxy_signal

	var _arg0 *C.GDBusObjectManagerClient // out
	var _arg1 *C.GDBusObjectProxy         // out
	var _arg2 *C.GDBusProxy               // out
	var _arg3 *C.gchar                    // out
	var _arg4 *C.gchar                    // out
	var _arg5 *C.GVariant                 // out

	_arg0 = (*C.GDBusObjectManagerClient)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObjectProxy)(unsafe.Pointer(coreglib.InternObject(objectProxy).Native()))
	_arg2 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(interfaceProxy).Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(senderName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(signalName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))

	C._gotk4_gio2_DBusObjectManagerClient_virtual_interface_proxy_signal(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(objectProxy)
	runtime.KeepAlive(interfaceProxy)
	runtime.KeepAlive(senderName)
	runtime.KeepAlive(signalName)
	runtime.KeepAlive(parameters)
}

// DBusObjectManagerServerOverrides contains methods that are overridable.
type DBusObjectManagerServerOverrides struct {
}

func defaultDBusObjectManagerServerOverrides(v *DBusObjectManagerServer) DBusObjectManagerServerOverrides {
	return DBusObjectManagerServerOverrides{}
}

// DBusObjectManagerServer: GDBusObjectManagerServer
// is used to export gio.DBusObject instances using
// the standardized org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface. For example, remote D-Bus clients can get all objects and
// properties in a single call. Additionally, any change in the object hierarchy
// is broadcast using signals. This means that D-Bus clients can keep caches up
// to date by only listening to D-Bus signals.
//
// The recommended path to export an object manager at is the path form of
// the well-known name of a D-Bus service, or below. For example, if a D-Bus
// service is available at the well-known name net.example.ExampleService1, the
// object manager should typically be exported at /net/example/ExampleService1,
// or below (to allow for multiple object managers in a service).
//
// It is supported, but not recommended, to export an object manager at the root
// path, /.
//
// See gio.DBusObjectManagerClient for the client-side code that is intended to
// be used with GDBusObjectManagerServer or any D-Bus object implementing the
// org.freedesktop.DBus.ObjectManager interface.
type DBusObjectManagerServer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DBusObjectManager
}

var (
	_ coreglib.Objector = (*DBusObjectManagerServer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DBusObjectManagerServer, *DBusObjectManagerServerClass, DBusObjectManagerServerOverrides](
		GTypeDBusObjectManagerServer,
		initDBusObjectManagerServerClass,
		wrapDBusObjectManagerServer,
		defaultDBusObjectManagerServerOverrides,
	)
}

func initDBusObjectManagerServerClass(gclass unsafe.Pointer, overrides DBusObjectManagerServerOverrides, classInitFunc func(*DBusObjectManagerServerClass)) {
	if classInitFunc != nil {
		class := (*DBusObjectManagerServerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusObjectManagerServer(obj *coreglib.Object) *DBusObjectManagerServer {
	return &DBusObjectManagerServer{
		Object: obj,
		DBusObjectManager: DBusObjectManager{
			Object: obj,
		},
	}
}

func marshalDBusObjectManagerServer(p uintptr) (interface{}, error) {
	return wrapDBusObjectManagerServer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDBusObjectManagerServer creates a new BusObjectManagerServer object.
//
// The returned server isn't yet exported on any connection. To do so,
// use g_dbus_object_manager_server_set_connection(). Normally you want
// to export all of your objects before doing so to avoid InterfacesAdded
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// signals being emitted.
//
// The function takes the following parameters:
//
//   - objectPath: object path to export the manager object at.
//
// The function returns the following values:
//
//   - dBusObjectManagerServer object. Free with g_object_unref().
func NewDBusObjectManagerServer(objectPath string) *DBusObjectManagerServer {
	var _arg1 *C.gchar                    // out
	var _cret *C.GDBusObjectManagerServer // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_manager_server_new(_arg1)
	runtime.KeepAlive(objectPath)

	var _dBusObjectManagerServer *DBusObjectManagerServer // out

	_dBusObjectManagerServer = wrapDBusObjectManagerServer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusObjectManagerServer
}

// Export exports object on manager.
//
// If there is already a BusObject exported at the object path, then the old
// object is removed.
//
// The object path for object must be in the hierarchy rooted by the object path
// for manager.
//
// Note that manager will take a reference on object for as long as it is
// exported.
//
// The function takes the following parameters:
//
//   - object: BusObjectSkeleton.
func (manager *DBusObjectManagerServer) Export(object *DBusObjectSkeleton) {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusObjectSkeleton      // out

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	C.g_dbus_object_manager_server_export(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(object)
}

// ExportUniquely: like g_dbus_object_manager_server_export() but appends
// a string of the form _N (with N being a natural number) to object's
// object path if an object with the given path already exists. As such,
// the BusObjectProxy:g-object-path property of object may be modified.
//
// The function takes the following parameters:
//
//   - object: object.
func (manager *DBusObjectManagerServer) ExportUniquely(object *DBusObjectSkeleton) {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusObjectSkeleton      // out

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	C.g_dbus_object_manager_server_export_uniquely(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(object)
}

// Connection gets the BusConnection used by manager.
//
// The function returns the following values:
//
//   - dBusConnection (optional) object or NULL if manager isn't exported on a
//     connection. The returned object should be freed with g_object_unref().
func (manager *DBusObjectManagerServer) Connection() *DBusConnection {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _cret *C.GDBusConnection          // in

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.g_dbus_object_manager_server_get_connection(_arg0)
	runtime.KeepAlive(manager)

	var _dBusConnection *DBusConnection // out

	if _cret != nil {
		_dBusConnection = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _dBusConnection
}

// IsExported returns whether object is currently exported on manager.
//
// The function takes the following parameters:
//
//   - object: object.
//
// The function returns the following values:
//
//   - ok: TRUE if object is exported.
func (manager *DBusObjectManagerServer) IsExported(object *DBusObjectSkeleton) bool {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusObjectSkeleton      // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.g_dbus_object_manager_server_is_exported(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(object)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetConnection exports all objects managed by manager on connection.
// If connection is NULL, stops exporting objects.
//
// The function takes the following parameters:
//
//   - connection (optional) or NULL.
func (manager *DBusObjectManagerServer) SetConnection(connection *DBusConnection) {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.GDBusConnection          // out

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	if connection != nil {
		_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	}

	C.g_dbus_object_manager_server_set_connection(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(connection)
}

// Unexport: if manager has an object at path, removes the object. Otherwise
// does nothing.
//
// Note that object_path must be in the hierarchy rooted by the object path for
// manager.
//
// The function takes the following parameters:
//
//   - objectPath: object path.
//
// The function returns the following values:
//
//   - ok: TRUE if object at object_path was removed, FALSE otherwise.
func (manager *DBusObjectManagerServer) Unexport(objectPath string) bool {
	var _arg0 *C.GDBusObjectManagerServer // out
	var _arg1 *C.gchar                    // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GDBusObjectManagerServer)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_manager_server_unexport(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(objectPath)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusObjectProxyOverrides contains methods that are overridable.
type DBusObjectProxyOverrides struct {
}

func defaultDBusObjectProxyOverrides(v *DBusObjectProxy) DBusObjectProxyOverrides {
	return DBusObjectProxyOverrides{}
}

// DBusObjectProxy: GDBusObjectProxy is an object used to represent a remote
// object with one or more D-Bus interfaces. Normally, you dont instantiate a
// GDBusObjectProxy yourself  typically gio.DBusObjectManagerClient is used to
// obtain it.
type DBusObjectProxy struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DBusObject
}

var (
	_ coreglib.Objector = (*DBusObjectProxy)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DBusObjectProxy, *DBusObjectProxyClass, DBusObjectProxyOverrides](
		GTypeDBusObjectProxy,
		initDBusObjectProxyClass,
		wrapDBusObjectProxy,
		defaultDBusObjectProxyOverrides,
	)
}

func initDBusObjectProxyClass(gclass unsafe.Pointer, overrides DBusObjectProxyOverrides, classInitFunc func(*DBusObjectProxyClass)) {
	if classInitFunc != nil {
		class := (*DBusObjectProxyClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusObjectProxy(obj *coreglib.Object) *DBusObjectProxy {
	return &DBusObjectProxy{
		Object: obj,
		DBusObject: DBusObject{
			Object: obj,
		},
	}
}

func marshalDBusObjectProxy(p uintptr) (interface{}, error) {
	return wrapDBusObjectProxy(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDBusObjectProxy creates a new BusObjectProxy for the given connection and
// object path.
//
// The function takes the following parameters:
//
//   - connection: BusConnection.
//   - objectPath: object path.
//
// The function returns the following values:
//
//   - dBusObjectProxy: new BusObjectProxy.
func NewDBusObjectProxy(connection *DBusConnection, objectPath string) *DBusObjectProxy {
	var _arg1 *C.GDBusConnection  // out
	var _arg2 *C.gchar            // out
	var _cret *C.GDBusObjectProxy // in

	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_object_proxy_new(_arg1, _arg2)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)

	var _dBusObjectProxy *DBusObjectProxy // out

	_dBusObjectProxy = wrapDBusObjectProxy(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusObjectProxy
}

// Connection gets the connection that proxy is for.
//
// The function returns the following values:
//
//   - dBusConnection Do not free, the object is owned by proxy.
func (proxy *DBusObjectProxy) Connection() *DBusConnection {
	var _arg0 *C.GDBusObjectProxy // out
	var _cret *C.GDBusConnection  // in

	_arg0 = (*C.GDBusObjectProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_object_proxy_get_connection(_arg0)
	runtime.KeepAlive(proxy)

	var _dBusConnection *DBusConnection // out

	_dBusConnection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(_cret)))

	return _dBusConnection
}

// DBusObjectSkeletonOverrides contains methods that are overridable.
type DBusObjectSkeletonOverrides struct {
	// AuthorizeMethod: signal class handler for the
	// BusObjectSkeleton::authorize-method signal.
	//
	// The function takes the following parameters:
	//
	//   - interface_
	//   - invocation
	AuthorizeMethod func(interface_ DBusInterfaceSkeletonner, invocation *DBusMethodInvocation) bool
}

func defaultDBusObjectSkeletonOverrides(v *DBusObjectSkeleton) DBusObjectSkeletonOverrides {
	return DBusObjectSkeletonOverrides{
		AuthorizeMethod: v.authorizeMethod,
	}
}

// DBusObjectSkeleton: GDBusObjectSkeleton instance is essentially a group of
// D-Bus interfaces. The set of exported interfaces on the object may be dynamic
// and change at runtime.
//
// This type is intended to be used with gio.DBusObjectManager.
type DBusObjectSkeleton struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DBusObject
}

var (
	_ coreglib.Objector = (*DBusObjectSkeleton)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DBusObjectSkeleton, *DBusObjectSkeletonClass, DBusObjectSkeletonOverrides](
		GTypeDBusObjectSkeleton,
		initDBusObjectSkeletonClass,
		wrapDBusObjectSkeleton,
		defaultDBusObjectSkeletonOverrides,
	)
}

func initDBusObjectSkeletonClass(gclass unsafe.Pointer, overrides DBusObjectSkeletonOverrides, classInitFunc func(*DBusObjectSkeletonClass)) {
	pclass := (*C.GDBusObjectSkeletonClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDBusObjectSkeleton))))

	if overrides.AuthorizeMethod != nil {
		pclass.authorize_method = (*[0]byte)(C._gotk4_gio2_DBusObjectSkeletonClass_authorize_method)
	}

	if classInitFunc != nil {
		class := (*DBusObjectSkeletonClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusObjectSkeleton(obj *coreglib.Object) *DBusObjectSkeleton {
	return &DBusObjectSkeleton{
		Object: obj,
		DBusObject: DBusObject{
			Object: obj,
		},
	}
}

func marshalDBusObjectSkeleton(p uintptr) (interface{}, error) {
	return wrapDBusObjectSkeleton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAuthorizeMethod is emitted when a method is invoked by a remote caller
// and used to determine if the method call is authorized.
//
// This signal is like BusInterfaceSkeleton's
// BusInterfaceSkeleton::g-authorize-method signal, except that it is for the
// enclosing object.
//
// The default class handler just returns TRUE.
func (object *DBusObjectSkeleton) ConnectAuthorizeMethod(f func(iface DBusInterfaceSkeletonner, invocation *DBusMethodInvocation) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(object, "authorize-method", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectSkeleton_ConnectAuthorizeMethod), f)
}

// NewDBusObjectSkeleton creates a new BusObjectSkeleton.
//
// The function takes the following parameters:
//
//   - objectPath: object path.
//
// The function returns the following values:
//
//   - dBusObjectSkeleton Free with g_object_unref().
func NewDBusObjectSkeleton(objectPath string) *DBusObjectSkeleton {
	var _arg1 *C.gchar               // out
	var _cret *C.GDBusObjectSkeleton // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_object_skeleton_new(_arg1)
	runtime.KeepAlive(objectPath)

	var _dBusObjectSkeleton *DBusObjectSkeleton // out

	_dBusObjectSkeleton = wrapDBusObjectSkeleton(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dBusObjectSkeleton
}

// AddInterface adds interface_ to object.
//
// If object already contains a BusInterfaceSkeleton with the same interface
// name, it is removed before interface_ is added.
//
// Note that object takes its own reference on interface_ and holds it until
// removed.
//
// The function takes the following parameters:
//
//   - interface_: BusInterfaceSkeleton.
func (object *DBusObjectSkeleton) AddInterface(interface_ DBusInterfaceSkeletonner) {
	var _arg0 *C.GDBusObjectSkeleton    // out
	var _arg1 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C.g_dbus_object_skeleton_add_interface(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interface_)
}

// Flush: this method simply calls g_dbus_interface_skeleton_flush() on all
// interfaces belonging to object. See that method for when flushing is useful.
func (object *DBusObjectSkeleton) Flush() {
	var _arg0 *C.GDBusObjectSkeleton // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	C.g_dbus_object_skeleton_flush(_arg0)
	runtime.KeepAlive(object)
}

// RemoveInterface removes interface_ from object.
//
// The function takes the following parameters:
//
//   - interface_: BusInterfaceSkeleton.
func (object *DBusObjectSkeleton) RemoveInterface(interface_ DBusInterfaceSkeletonner) {
	var _arg0 *C.GDBusObjectSkeleton    // out
	var _arg1 *C.GDBusInterfaceSkeleton // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	C.g_dbus_object_skeleton_remove_interface(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interface_)
}

// RemoveInterfaceByName removes the BusInterface with interface_name from
// object.
//
// If no D-Bus interface of the given interface exists, this function does
// nothing.
//
// The function takes the following parameters:
//
//   - interfaceName d-Bus interface name.
func (object *DBusObjectSkeleton) RemoveInterfaceByName(interfaceName string) {
	var _arg0 *C.GDBusObjectSkeleton // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_object_skeleton_remove_interface_by_name(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interfaceName)
}

// SetObjectPath sets the object path for object.
//
// The function takes the following parameters:
//
//   - objectPath: valid D-Bus object path.
func (object *DBusObjectSkeleton) SetObjectPath(objectPath string) {
	var _arg0 *C.GDBusObjectSkeleton // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_object_skeleton_set_object_path(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(objectPath)
}

// authorizeMethod: signal class handler for the
// BusObjectSkeleton::authorize-method signal.
//
// The function takes the following parameters:
//
//   - interface_
//   - invocation
func (object *DBusObjectSkeleton) authorizeMethod(interface_ DBusInterfaceSkeletonner, invocation *DBusMethodInvocation) bool {
	gclass := (*C.GDBusObjectSkeletonClass)(coreglib.PeekParentClass(object))
	fnarg := gclass.authorize_method

	var _arg0 *C.GDBusObjectSkeleton    // out
	var _arg1 *C.GDBusInterfaceSkeleton // out
	var _arg2 *C.GDBusMethodInvocation  // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GDBusObjectSkeleton)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg2 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C._gotk4_gio2_DBusObjectSkeleton_virtual_authorize_method(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(invocation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusProxyOverrides contains methods that are overridable.
type DBusProxyOverrides struct {
	// GSignal: signal class handler for the BusProxy::g-signal signal.
	//
	// The function takes the following parameters:
	//
	//   - senderName
	//   - signalName
	//   - parameters
	GSignal func(senderName, signalName string, parameters *glib.Variant)
}

func defaultDBusProxyOverrides(v *DBusProxy) DBusProxyOverrides {
	return DBusProxyOverrides{
		GSignal: v.gSignal,
	}
}

// DBusProxy: GDBusProxy is a base class used for proxies to access a D-Bus
// interface on a remote object. A GDBusProxy can be constructed for both
// well-known and unique names.
//
// By default, GDBusProxy will cache all properties (and listen to changes) of
// the remote object, and proxy all signals that get emitted. This behaviour can
// be changed by passing suitable gio.DBusProxyFlags when the proxy is created.
// If the proxy is for a well-known name, the property cache is flushed when the
// name owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxys name is tracked and can be read from
// gio.DBusProxy:g-name-owner. Connect to the gobject.Object::notify signal to
// get notified of changes. Additionally, only signals and property changes
// emitted from the current name owner are considered and calls are always
// sent to the current name owner. This avoids a number of race conditions
// when the name is lost by one owner and claimed by another. However,
// if no name owner currently exists, then calls will be sent to the well-known
// name which may result in the message bus launching an owner (unless
// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is set).
//
// If the proxy is for a stateless D-Bus service, where the name owner may be
// started and stopped between calls, the gio.DBusProxy:g-name-owner tracking
// of GDBusProxy will cause the proxy to drop signal and property changes from
// the service after it has restarted for the first time. When interacting with
// a stateless D-Bus service, do not use GDBusProxy  use direct D-Bus method
// calls and signal connections.
//
// The generic gio.DBusProxy::g-properties-changed and gio.DBusProxy::g-signal
// signals are not very convenient to work with. Therefore, the recommended
// way of working with proxies is to subclass GDBusProxy, and have more
// natural properties and signals in your derived class. This example
// (migrating-gdbus.html#using-gdbus-codegen) shows how this can easily be done
// using the gdbus-codegen (gdbus-codegen.html) tool.
//
// A GDBusProxy instance can be used from multiple threads but note that all
// signals (e.g. gio.DBusProxy::g-signal, gio.DBusProxy::g-properties-changed
// and gobject.Object::notify) are emitted in the thread-default main context
// (see glib.MainContext.PushThreadDefault()) of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name
// can be found in gdbus-example-watch-proxy.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c).
type DBusProxy struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncInitable
	DBusInterface
	Initable
}

var (
	_ coreglib.Objector = (*DBusProxy)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DBusProxy, *DBusProxyClass, DBusProxyOverrides](
		GTypeDBusProxy,
		initDBusProxyClass,
		wrapDBusProxy,
		defaultDBusProxyOverrides,
	)
}

func initDBusProxyClass(gclass unsafe.Pointer, overrides DBusProxyOverrides, classInitFunc func(*DBusProxyClass)) {
	pclass := (*C.GDBusProxyClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDBusProxy))))

	if overrides.GSignal != nil {
		pclass.g_signal = (*[0]byte)(C._gotk4_gio2_DBusProxyClass_g_signal)
	}

	if classInitFunc != nil {
		class := (*DBusProxyClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusProxy(obj *coreglib.Object) *DBusProxy {
	return &DBusProxy{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		DBusInterface: DBusInterface{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	return wrapDBusProxy(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectGPropertiesChanged is emitted when one or more D-Bus properties on
// proxy changes. The local cache has already been updated when this signal
// fires. Note that both changed_properties and invalidated_properties are
// guaranteed to never be NULL (either may be empty though).
//
// If the proxy has the flag G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES set,
// then invalidated_properties will always be empty.
//
// This signal corresponds to the PropertiesChanged D-Bus signal on the
// org.freedesktop.DBus.Properties interface.
func (proxy *DBusProxy) ConnectGPropertiesChanged(f func(changedProperties *glib.Variant, invalidatedProperties []string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(proxy, "g-properties-changed", false, unsafe.Pointer(C._gotk4_gio2_DBusProxy_ConnectGPropertiesChanged), f)
}

// ConnectGSignal is emitted when a signal from the remote object and interface
// that proxy is for, has been received.
//
// Since 2.72 this signal supports detailed connections. You can connect to the
// detailed signal g-signal::x in order to receive callbacks only when signal x
// is received from the remote object.
func (proxy *DBusProxy) ConnectGSignal(f func(senderName, signalName string, parameters *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(proxy, "g-signal", false, unsafe.Pointer(C._gotk4_gio2_DBusProxy_ConnectGSignal), f)
}

// NewDBusProxyFinish finishes creating a BusProxy.
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback function passed to
//     g_dbus_proxy_new().
//
// The function returns the following values:
//
//   - dBusProxy or NULL if error is set. Free with g_object_unref().
func NewDBusProxyFinish(res AsyncResulter) (*DBusProxy, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GDBusProxy   // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_proxy_new_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// NewDBusProxyForBusFinish finishes creating a BusProxy.
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback function passed to
//     g_dbus_proxy_new_for_bus().
//
// The function returns the following values:
//
//   - dBusProxy or NULL if error is set. Free with g_object_unref().
func NewDBusProxyForBusFinish(res AsyncResulter) (*DBusProxy, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GDBusProxy   // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_proxy_new_for_bus_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// NewDBusProxyForBusSync: like g_dbus_proxy_new_sync() but takes a Type instead
// of a BusConnection.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - busType: Type.
//   - flags flags used when constructing the proxy.
//   - info (optional) specifying the minimal interface that proxy conforms to
//     or NULL.
//   - name bus name (well-known or unique).
//   - objectPath: object path.
//   - interfaceName d-Bus interface name.
//
// The function returns the following values:
//
//   - dBusProxy or NULL if error is set. Free with g_object_unref().
func NewDBusProxyForBusSync(ctx context.Context, busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string) (*DBusProxy, error) {
	var _arg7 *C.GCancellable       // out
	var _arg1 C.GBusType            // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _cret *C.GDBusProxy         // in
	var _cerr *C.GError             // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GBusType(busType)
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))

	_cret = C.g_dbus_proxy_new_for_bus_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// NewDBusProxySync creates a proxy for accessing interface_name on the remote
// object at object_path owned by name at connection and synchronously loads
// D-Bus properties unless the G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is
// used.
//
// If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets
// up match rules for signals. Connect to the BusProxy::g-signal signal to
// handle signals from the remote object.
//
// If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
// G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
// guaranteed to return immediately without blocking.
//
// If name is a well-known name and the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and
// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION flags aren't set and no
// name owner currently exists, the message bus will be requested to launch a
// name owner for the name.
//
// This is a synchronous failable constructor. See g_dbus_proxy_new() and
// g_dbus_proxy_new_finish() for the asynchronous version.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connection: BusConnection.
//   - flags flags used when constructing the proxy.
//   - info (optional) specifying the minimal interface that proxy conforms to
//     or NULL.
//   - name (optional) bus name (well-known or unique) or NULL if connection is
//     not a message bus connection.
//   - objectPath: object path.
//   - interfaceName d-Bus interface name.
//
// The function returns the following values:
//
//   - dBusProxy or NULL if error is set. Free with g_object_unref().
func NewDBusProxySync(ctx context.Context, connection *DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string) (*DBusProxy, error) {
	var _arg7 *C.GCancellable       // out
	var _arg1 *C.GDBusConnection    // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _cret *C.GDBusProxy         // in
	var _cerr *C.GError             // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	if name != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))

	_cret = C.g_dbus_proxy_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// Call: asynchronously invokes the method_name method on proxy.
//
// If method_name contains any dots, then name is split into interface and
// method name parts. This allows using proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with proxy is closed then the operation
// will fail with G_IO_ERROR_CLOSED. If cancellable is canceled, the
// operation will fail with G_IO_ERROR_CANCELLED. If parameters contains a
// value not compatible with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//	g_dbus_proxy_call (proxy,
//	                   "TwoStrings",
//	                   g_variant_new ("(ss)",
//	                                  "Thing One",
//	                                  "Thing Two"),
//	                   G_DBUS_CALL_FLAGS_NONE,
//	                   -1,
//	                   NULL,
//	                   (GAsyncReadyCallback) two_strings_done,
//	                   &data);
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// method_name is referenced by it, then the return value is checked against the
// return type.
//
// This is an asynchronous method. When the operation is finished,
// callback will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_proxy_call_finish() to get the
// result of the operation. See g_dbus_proxy_call_sync() for the synchronous
// version of this method.
//
// If callback is NULL then the D-Bus method call message will be sent with the
// G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - methodName: name of method to invoke.
//   - parameters (optional) tuple with parameters for the signal or NULL if not
//     passing parameters.
//   - flags flags from the BusCallFlags enumeration.
//   - timeoutMsec: timeout in milliseconds (with G_MAXINT meaning "infinite")
//     or -1 to use the proxy default timeout.
//   - callback (optional) to call when the request is satisfied or NULL if you
//     don't care about the result of the method invocation.
func (proxy *DBusProxy) Call(ctx context.Context, methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusProxy         // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 C.GDBusCallFlags      // out
	var _arg4 C.gint                // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameters != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}
	_arg3 = C.GDBusCallFlags(flags)
	_arg4 = C.gint(timeoutMsec)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_proxy_call(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(methodName)
	runtime.KeepAlive(parameters)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)
	runtime.KeepAlive(callback)
}

// CallFinish finishes an operation started with g_dbus_proxy_call().
//
// The function takes the following parameters:
//
//   - res obtained from the ReadyCallback passed to g_dbus_proxy_call().
//
// The function returns the following values:
//
//   - variant: NULL if error is set. Otherwise a #GVariant tuple with return
//     values. Free with g_variant_unref().
func (proxy *DBusProxy) CallFinish(res AsyncResulter) (*glib.Variant, error) {
	var _arg0 *C.GDBusProxy   // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GVariant     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_dbus_proxy_call_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(res)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// CallSync: synchronously invokes the method_name method on proxy.
//
// If method_name contains any dots, then name is split into interface and
// method name parts. This allows using proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with proxy is disconnected then the
// operation will fail with G_IO_ERROR_CLOSED. If cancellable is canceled,
// the operation will fail with G_IO_ERROR_CANCELLED. If parameters contains
// a value not compatible with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//	g_dbus_proxy_call_sync (proxy,
//	                        "TwoStrings",
//	                        g_variant_new ("(ss)",
//	                                       "Thing One",
//	                                       "Thing Two"),
//	                        G_DBUS_CALL_FLAGS_NONE,
//	                        -1,
//	                        NULL,
//	                        &error);
//
// The calling thread is blocked until a reply is received. See
// g_dbus_proxy_call() for the asynchronous version of this method.
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// method_name is referenced by it, then the return value is checked against the
// return type.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - methodName: name of method to invoke.
//   - parameters (optional) tuple with parameters for the signal or NULL if not
//     passing parameters.
//   - flags flags from the BusCallFlags enumeration.
//   - timeoutMsec: timeout in milliseconds (with G_MAXINT meaning "infinite")
//     or -1 to use the proxy default timeout.
//
// The function returns the following values:
//
//   - variant: NULL if error is set. Otherwise a #GVariant tuple with return
//     values. Free with g_variant_unref().
func (proxy *DBusProxy) CallSync(ctx context.Context, methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int) (*glib.Variant, error) {
	var _arg0 *C.GDBusProxy    // out
	var _arg5 *C.GCancellable  // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out
	var _arg3 C.GDBusCallFlags // out
	var _arg4 C.gint           // out
	var _cret *C.GVariant      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameters != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}
	_arg3 = C.GDBusCallFlags(flags)
	_arg4 = C.gint(timeoutMsec)

	_cret = C.g_dbus_proxy_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(methodName)
	runtime.KeepAlive(parameters)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// CachedProperty looks up the value for a property from the cache. This call
// does no blocking IO.
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// property_name is referenced by it, then value is checked against the type of
// the property.
//
// The function takes the following parameters:
//
//   - propertyName: property name.
//
// The function returns the following values:
//
//   - variant (optional): reference to the #GVariant instance that holds
//     the value for property_name or NULL if the value is not in the cache.
//     The returned reference must be freed with g_variant_unref().
func (proxy *DBusProxy) CachedProperty(propertyName string) *glib.Variant {
	var _arg0 *C.GDBusProxy // out
	var _arg1 *C.gchar      // out
	var _cret *C.GVariant   // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_proxy_get_cached_property(_arg0, _arg1)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(propertyName)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// CachedPropertyNames gets the names of all cached properties on proxy.
//
// The function returns the following values:
//
//   - utf8s (optional): a NULL-terminated array of strings or NULL if proxy has
//     no cached properties. Free the returned array with g_strfreev().
func (proxy *DBusProxy) CachedPropertyNames() []string {
	var _arg0 *C.GDBusProxy // out
	var _cret **C.gchar     // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_cached_property_names(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// Connection gets the connection proxy is for.
//
// The function returns the following values:
//
//   - dBusConnection owned by proxy. Do not free.
func (proxy *DBusProxy) Connection() *DBusConnection {
	var _arg0 *C.GDBusProxy      // out
	var _cret *C.GDBusConnection // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_connection(_arg0)
	runtime.KeepAlive(proxy)

	var _dBusConnection *DBusConnection // out

	_dBusConnection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(_cret)))

	return _dBusConnection
}

// DefaultTimeout gets the timeout to use if -1 (specifying default
// timeout) is passed as timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
//
// The function returns the following values:
//
//   - gint: timeout to use for proxy.
func (proxy *DBusProxy) DefaultTimeout() int {
	var _arg0 *C.GDBusProxy // out
	var _cret C.gint        // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_default_timeout(_arg0)
	runtime.KeepAlive(proxy)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Flags gets the flags that proxy was constructed with.
//
// The function returns the following values:
//
//   - dBusProxyFlags flags from the BusProxyFlags enumeration.
func (proxy *DBusProxy) Flags() DBusProxyFlags {
	var _arg0 *C.GDBusProxy     // out
	var _cret C.GDBusProxyFlags // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_flags(_arg0)
	runtime.KeepAlive(proxy)

	var _dBusProxyFlags DBusProxyFlags // out

	_dBusProxyFlags = DBusProxyFlags(_cret)

	return _dBusProxyFlags
}

// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the interface
// that proxy conforms to. See the BusProxy:g-interface-info property for more
// details.
//
// The function returns the following values:
//
//   - dBusInterfaceInfo (optional) or NULL. Do not unref the returned object,
//     it is owned by proxy.
func (proxy *DBusProxy) InterfaceInfo() *DBusInterfaceInfo {
	var _arg0 *C.GDBusProxy         // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_interface_info(_arg0)
	runtime.KeepAlive(proxy)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	if _cret != nil {
		_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_interface_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
			},
		)
	}

	return _dBusInterfaceInfo
}

// InterfaceName gets the D-Bus interface name proxy is for.
//
// The function returns the following values:
//
//   - utf8: string owned by proxy. Do not free.
func (proxy *DBusProxy) InterfaceName() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_interface_name(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name gets the name that proxy was constructed for.
//
// When connected to a message bus, this will usually be non-NULL. However,
// it may be NULL for a proxy that communicates using a peer-to-peer pattern.
//
// The function returns the following values:
//
//   - utf8 (optional): string owned by proxy. Do not free.
func (proxy *DBusProxy) Name() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_name(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NameOwner: unique name that owns the name that proxy is for or NULL if no-one
// currently owns that name. You may connect to the #GObject::notify signal to
// track changes to the BusProxy:g-name-owner property.
//
// The function returns the following values:
//
//   - utf8 (optional): name owner or NULL if no name owner exists. Free with
//     g_free().
func (proxy *DBusProxy) NameOwner() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_name_owner(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ObjectPath gets the object path proxy is for.
//
// The function returns the following values:
//
//   - utf8: string owned by proxy. Do not free.
func (proxy *DBusProxy) ObjectPath() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_object_path(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetCachedProperty: if value is not NULL, sets the cached value for the
// property with name property_name to the value in value.
//
// If value is NULL, then the cached value is removed from the property cache.
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// property_name is referenced by it, then value is checked against the type of
// the property.
//
// If the value #GVariant is floating, it is consumed. This allows convenient
// 'inline' use of g_variant_new(), e.g.
//
//	g_dbus_proxy_set_cached_property (proxy,
//	                                  "SomeProperty",
//	                                  g_variant_new ("(si)",
//	                                                "A String",
//	                                                42));
//
// Normally you will not need to use this method since proxy is tracking changes
// using the org.freedesktop.DBus.Properties.PropertiesChanged D-Bus signal.
// However, for performance reasons an object may decide to not use this signal
// for some properties and instead use a proprietary out-of-band mechanism to
// transmit changes.
//
// As a concrete example, consider an object with a property
// ChatroomParticipants which is an array of strings. Instead of
// transmitting the same (long) array every time the property changes,
// it is more efficient to only transmit the delta using e.g. signals
// ChatroomParticipantJoined(String name) and ChatroomParticipantParted(String
// name).
//
// The function takes the following parameters:
//
//   - propertyName: property name.
//   - value (optional): value for the property or NULL to remove it from the
//     cache.
func (proxy *DBusProxy) SetCachedProperty(propertyName string, value *glib.Variant) {
	var _arg0 *C.GDBusProxy // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GVariant   // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	if value != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	}

	C.g_dbus_proxy_set_cached_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// SetDefaultTimeout sets the timeout to use if -1 (specifying default
// timeout) is passed as timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
//
// The function takes the following parameters:
//
//   - timeoutMsec: timeout in milliseconds.
func (proxy *DBusProxy) SetDefaultTimeout(timeoutMsec int) {
	var _arg0 *C.GDBusProxy // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	_arg1 = C.gint(timeoutMsec)

	C.g_dbus_proxy_set_default_timeout(_arg0, _arg1)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(timeoutMsec)
}

// SetInterfaceInfo: ensure that interactions with proxy conform to the given
// interface. See the BusProxy:g-interface-info property for more details.
//
// The function takes the following parameters:
//
//   - info (optional): minimum interface this proxy conforms to or NULL to
//     unset.
func (proxy *DBusProxy) SetInterfaceInfo(info *DBusInterfaceInfo) {
	var _arg0 *C.GDBusProxy         // out
	var _arg1 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	if info != nil {
		_arg1 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}

	C.g_dbus_proxy_set_interface_info(_arg0, _arg1)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(info)
}

// gSignal: signal class handler for the BusProxy::g-signal signal.
//
// The function takes the following parameters:
//
//   - senderName
//   - signalName
//   - parameters
func (proxy *DBusProxy) gSignal(senderName, signalName string, parameters *glib.Variant) {
	gclass := (*C.GDBusProxyClass)(coreglib.PeekParentClass(proxy))
	fnarg := gclass.g_signal

	var _arg0 *C.GDBusProxy // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GVariant   // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(senderName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(signalName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))

	C._gotk4_gio2_DBusProxy_virtual_g_signal(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(senderName)
	runtime.KeepAlive(signalName)
	runtime.KeepAlive(parameters)
}

// NewDBusProxy creates a proxy for accessing interface_name on the remote
// object at object_path owned by name at connection and asynchronously loads
// D-Bus properties unless the G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is
// used. Connect to the BusProxy::g-properties-changed signal to get notified
// about property changes.
//
// If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets
// up match rules for signals. Connect to the BusProxy::g-signal signal to
// handle signals from the remote object.
//
// If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
// G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
// guaranteed to complete immediately without blocking.
//
// If name is a well-known name and the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and
// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION flags aren't set and no
// name owner currently exists, the message bus will be requested to launch a
// name owner for the name.
//
// This is a failable asynchronous constructor - when the proxy is ready,
// callback will be invoked and you can use g_dbus_proxy_new_finish() to get the
// result.
//
// See g_dbus_proxy_new_sync() and for a synchronous version of this
// constructor.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connection: BusConnection.
//   - flags flags used when constructing the proxy.
//   - info (optional) specifying the minimal interface that proxy conforms to
//     or NULL.
//   - name (optional) bus name (well-known or unique) or NULL if connection is
//     not a message bus connection.
//   - objectPath: object path.
//   - interfaceName d-Bus interface name.
//   - callback (optional): callback function to invoke when the proxy is ready.
func NewDBusProxy(ctx context.Context, connection *DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string, callback AsyncReadyCallback) {
	var _arg7 *C.GCancellable       // out
	var _arg1 *C.GDBusConnection    // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _arg8 C.GAsyncReadyCallback // out
	var _arg9 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	if name != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))
	if callback != nil {
		_arg8 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg9 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_proxy_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(callback)
}

// NewDBusProxyForBus: like g_dbus_proxy_new() but takes a Type instead of a
// BusConnection.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - busType: Type.
//   - flags flags used when constructing the proxy.
//   - info (optional) specifying the minimal interface that proxy conforms to
//     or NULL.
//   - name bus name (well-known or unique).
//   - objectPath: object path.
//   - interfaceName d-Bus interface name.
//   - callback (optional): callback function to invoke when the proxy is ready.
func NewDBusProxyForBus(ctx context.Context, busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string, callback AsyncReadyCallback) {
	var _arg7 *C.GCancellable       // out
	var _arg1 C.GBusType            // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _arg8 C.GAsyncReadyCallback // out
	var _arg9 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GBusType(busType)
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))
	if callback != nil {
		_arg8 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg9 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_proxy_new_for_bus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(callback)
}

// DBusServer: GDBusServer is a helper for listening to and accepting
// D-Bus connections. This can be used to create a new D-Bus server,
// allowing two peers to use the D-Bus protocol for their own specialized
// communication. A server instance provided in this way will not perform
// message routing or implement the org.freedesktop.DBus interface
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-messages).
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use gio.BusOwnName().
//
// An example of peer-to-peer communication with
// GDBus can be found in gdbus-example-peer.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal GDBusServer will accept connections from any peer. In
// many use-cases it will be necessary to add a gio.DBusAuthObserver that only
// accepts connections that have successfully authenticated as the same user
// that is running the GDBusServer. Since GLib 2.68 this can be achieved more
// simply by passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER
// flag to the server.
type DBusServer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Initable
}

var (
	_ coreglib.Objector = (*DBusServer)(nil)
)

func wrapDBusServer(obj *coreglib.Object) *DBusServer {
	return &DBusServer{
		Object: obj,
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	return wrapDBusServer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectNewConnection is emitted when a new authenticated connection has
// been made. Use g_dbus_connection_get_peer_credentials() to figure out what
// identity (if any), was authenticated.
//
// If you want to accept the connection, take a reference to the connection
// object and return TRUE. When you are done with the connection call
// g_dbus_connection_close() and give up your reference. Note that the other
// peer may disconnect at any time - a typical thing to do when accepting a
// connection is to listen to the BusConnection::closed signal.
//
// If BusServer:flags contains G_DBUS_SERVER_FLAGS_RUN_IN_THREAD then
// the signal is emitted in a new thread dedicated to the connection.
// Otherwise the signal is emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread that server was
// constructed in.
//
// You are guaranteed that signal handlers for this signal runs before incoming
// messages on connection are processed. This means that it's suitable to call
// g_dbus_connection_register_object() or similar from the signal handler.
func (server *DBusServer) ConnectNewConnection(f func(connection *DBusConnection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "new-connection", false, unsafe.Pointer(C._gotk4_gio2_DBusServer_ConnectNewConnection), f)
}

// NewDBusServerSync creates a new D-Bus server that listens on the first
// address in address that works.
//
// Once constructed, you can use g_dbus_server_get_client_address() to get a
// D-Bus address string that clients can use to connect.
//
// To have control over the available authentication mechanisms and the users
// that are authorized to connect, it is strongly recommended to provide a
// non-NULL BusAuthObserver.
//
// Connect to the BusServer::new-connection signal to handle incoming
// connections.
//
// The returned BusServer isn't active - you have to start it with
// g_dbus_server_start().
//
// BusServer is used in this [example][gdbus-peer-to-peer].
//
// This is a synchronous failable constructor. There is currently no
// asynchronous version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address d-Bus address.
//   - flags flags from the BusServerFlags enumeration.
//   - guid d-Bus GUID.
//   - observer (optional) or NULL.
//
// The function returns the following values:
//
//   - dBusServer or NULL if error is set. Free with g_object_unref().
func NewDBusServerSync(ctx context.Context, address string, flags DBusServerFlags, guid string, observer *DBusAuthObserver) (*DBusServer, error) {
	var _arg5 *C.GCancellable      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.GDBusServerFlags   // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GDBusAuthObserver // out
	var _cret *C.GDBusServer       // in
	var _cerr *C.GError            // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusServerFlags(flags)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(guid)))
	defer C.free(unsafe.Pointer(_arg3))
	if observer != nil {
		_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(coreglib.InternObject(observer).Native()))
	}

	_cret = C.g_dbus_server_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(guid)
	runtime.KeepAlive(observer)

	var _dBusServer *DBusServer // out
	var _goerr error            // out

	_dBusServer = wrapDBusServer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusServer, _goerr
}

// ClientAddress gets a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses) string
// that can be used by clients to connect to server.
//
// This is valid and non-empty if initializing the BusServer succeeded.
//
// The function returns the following values:
//
//   - utf8 d-Bus address string. Do not free, the string is owned by server.
func (server *DBusServer) ClientAddress() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.g_dbus_server_get_client_address(_arg0)
	runtime.KeepAlive(server)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Flags gets the flags for server.
//
// The function returns the following values:
//
//   - dBusServerFlags: set of flags from the BusServerFlags enumeration.
func (server *DBusServer) Flags() DBusServerFlags {
	var _arg0 *C.GDBusServer     // out
	var _cret C.GDBusServerFlags // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.g_dbus_server_get_flags(_arg0)
	runtime.KeepAlive(server)

	var _dBusServerFlags DBusServerFlags // out

	_dBusServerFlags = DBusServerFlags(_cret)

	return _dBusServerFlags
}

// GUID gets the GUID for server, as provided to g_dbus_server_new_sync().
//
// The function returns the following values:
//
//   - utf8 d-Bus GUID. Do not free this string, it is owned by server.
func (server *DBusServer) GUID() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.g_dbus_server_get_guid(_arg0)
	runtime.KeepAlive(server)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsActive gets whether server is active.
//
// The function returns the following values:
//
//   - ok: TRUE if server is active, FALSE otherwise.
func (server *DBusServer) IsActive() bool {
	var _arg0 *C.GDBusServer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.g_dbus_server_is_active(_arg0)
	runtime.KeepAlive(server)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts server.
func (server *DBusServer) Start() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.g_dbus_server_start(_arg0)
	runtime.KeepAlive(server)
}

// Stop stops server.
func (server *DBusServer) Stop() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.g_dbus_server_stop(_arg0)
	runtime.KeepAlive(server)
}

// DataInputStreamOverrides contains methods that are overridable.
type DataInputStreamOverrides struct {
}

func defaultDataInputStreamOverrides(v *DataInputStream) DataInputStreamOverrides {
	return DataInputStreamOverrides{}
}

// DataInputStream: data input stream implements gio.InputStream and includes
// functions for reading structured data directly from a binary input stream.
type DataInputStream struct {
	_ [0]func() // equal guard
	BufferedInputStream
}

var (
	_ FilterInputStreamer = (*DataInputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DataInputStream, *DataInputStreamClass, DataInputStreamOverrides](
		GTypeDataInputStream,
		initDataInputStreamClass,
		wrapDataInputStream,
		defaultDataInputStreamOverrides,
	)
}

func initDataInputStreamClass(gclass unsafe.Pointer, overrides DataInputStreamOverrides, classInitFunc func(*DataInputStreamClass)) {
	if classInitFunc != nil {
		class := (*DataInputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDataInputStream(obj *coreglib.Object) *DataInputStream {
	return &DataInputStream{
		BufferedInputStream: BufferedInputStream{
			FilterInputStream: FilterInputStream{
				InputStream: InputStream{
					Object: obj,
				},
			},
			Seekable: Seekable{
				Object: obj,
			},
		},
	}
}

func marshalDataInputStream(p uintptr) (interface{}, error) {
	return wrapDataInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDataInputStream creates a new data input stream for the base_stream.
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//
// The function returns the following values:
//
//   - dataInputStream: new InputStream.
func NewDataInputStream(baseStream InputStreamer) *DataInputStream {
	var _arg1 *C.GInputStream     // out
	var _cret *C.GDataInputStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))

	_cret = C.g_data_input_stream_new(_arg1)
	runtime.KeepAlive(baseStream)

	var _dataInputStream *DataInputStream // out

	_dataInputStream = wrapDataInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dataInputStream
}

// ByteOrder gets the byte order for the data input stream.
//
// The function returns the following values:
//
//   - dataStreamByteOrder stream's current StreamByteOrder.
func (stream *DataInputStream) ByteOrder() DataStreamByteOrder {
	var _arg0 *C.GDataInputStream    // out
	var _cret C.GDataStreamByteOrder // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_data_input_stream_get_byte_order(_arg0)
	runtime.KeepAlive(stream)

	var _dataStreamByteOrder DataStreamByteOrder // out

	_dataStreamByteOrder = DataStreamByteOrder(_cret)

	return _dataStreamByteOrder
}

// NewlineType gets the current newline type for the stream.
//
// The function returns the following values:
//
//   - dataStreamNewlineType for the given stream.
func (stream *DataInputStream) NewlineType() DataStreamNewlineType {
	var _arg0 *C.GDataInputStream      // out
	var _cret C.GDataStreamNewlineType // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_data_input_stream_get_newline_type(_arg0)
	runtime.KeepAlive(stream)

	var _dataStreamNewlineType DataStreamNewlineType // out

	_dataStreamNewlineType = DataStreamNewlineType(_cret)

	return _dataStreamNewlineType
}

// ReadByte reads an unsigned 8-bit/1-byte value from stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - guint8: unsigned 8-bit/1-byte value read from the stream or 0 if an error
//     occurred.
func (stream *DataInputStream) ReadByte(ctx context.Context) (byte, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guchar            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_byte(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _guint8 byte // out
	var _goerr error // out

	_guint8 = byte(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint8, _goerr
}

// ReadInt16 reads a 16-bit/2-byte value from stream.
//
// In order to get the correct byte order for this read
// operation, see g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - gint16: signed 16-bit/2-byte value read from stream or 0 if an error
//     occurred.
func (stream *DataInputStream) ReadInt16(ctx context.Context) (int16, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.gint16            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_int16(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _gint16 int16 // out
	var _goerr error  // out

	_gint16 = int16(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint16, _goerr
}

// ReadInt32 reads a signed 32-bit/4-byte value from stream.
//
// In order to get the correct byte order for this read
// operation, see g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - gint32: signed 32-bit/4-byte value read from the stream or 0 if an error
//     occurred.
func (stream *DataInputStream) ReadInt32(ctx context.Context) (int32, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.gint32            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_int32(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _gint32 int32 // out
	var _goerr error  // out

	_gint32 = int32(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint32, _goerr
}

// ReadInt64 reads a 64-bit/8-byte value from stream.
//
// In order to get the correct byte order for this read
// operation, see g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - gint64: signed 64-bit/8-byte value read from stream or 0 if an error
//     occurred.
func (stream *DataInputStream) ReadInt64(ctx context.Context) (int64, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.gint64            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_int64(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _gint64 int64 // out
	var _goerr error  // out

	_gint64 = int64(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint64, _goerr
}

// ReadLine reads a line from the data input stream. Note that no encoding
// checks or conversion is performed; the input is not guaranteed to be UTF-8,
// and may in fact have embedded NUL characters.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - guint8s (optional): a NUL terminated byte array with the line that was
//     read in (without the newlines). Set length to a #gsize to get the length
//     of the read line. On an error, it will return NULL and error will be set.
//     If there's no content to read, it will still return NULL, but error won't
//     be set.
func (stream *DataInputStream) ReadLine(ctx context.Context) (uint, []byte, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_line(_arg0, &_arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _length uint    // out
	var _guint8s []byte // out
	var _goerr error    // out

	_length = uint(_arg1)
	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_guint8s = make([]byte, i)
			for i := range src {
				_guint8s[i] = byte(src[i])
			}
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _guint8s, _goerr
}

// ReadLineAsync asynchronous version of g_data_input_stream_read_line().
// It is an error to have two outstanding calls to this function.
//
// When the operation is finished, callback will be called. You can then call
// g_data_input_stream_read_line_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (stream *DataInputStream) ReadLineAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GDataInputStream   // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.gint                // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gint(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_data_input_stream_read_line_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadLineFinish: finish an asynchronous call started by
// g_data_input_stream_read_line_async(). Note the warning about string encoding
// in g_data_input_stream_read_line() applies here as well.
//
// The function takes the following parameters:
//
//   - result that was provided to the callback.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - guint8s (optional): a NUL-terminated byte array with the line that was
//     read in (without the newlines). Set length to a #gsize to get the length
//     of the read line. On an error, it will return NULL and error will be set.
//     If there's no content to read, it will still return NULL, but error won't
//     be set.
func (stream *DataInputStream) ReadLineFinish(result AsyncResulter) (uint, []byte, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_data_input_stream_read_line_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _length uint    // out
	var _guint8s []byte // out
	var _goerr error    // out

	_length = uint(_arg2)
	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_guint8s = make([]byte, i)
			for i := range src {
				_guint8s[i] = byte(src[i])
			}
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _guint8s, _goerr
}

// ReadLineFinishUTF8: finish an asynchronous call started by
// g_data_input_stream_read_line_async().
//
// The function takes the following parameters:
//
//   - result that was provided to the callback.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - utf8 (optional): string with the line that was read in (without the
//     newlines). Set length to a #gsize to get the length of the read line. On
//     an error, it will return NULL and error will be set. For UTF-8 conversion
//     errors, the set error domain is G_CONVERT_ERROR. If there's no content to
//     read, it will still return NULL, but error won't be set.
func (stream *DataInputStream) ReadLineFinishUTF8(result AsyncResulter) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_data_input_stream_read_line_finish_utf8(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = uint(_arg2)
	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8, _goerr
}

// ReadLineUTF8 reads a UTF-8 encoded line from the data input stream.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - utf8 (optional): NUL terminated UTF-8 string with the line that was read
//     in (without the newlines). Set length to a #gsize to get the length of
//     the read line. On an error, it will return NULL and error will be set.
//     For UTF-8 conversion errors, the set error domain is G_CONVERT_ERROR.
//     If there's no content to read, it will still return NULL, but error won't
//     be set.
func (stream *DataInputStream) ReadLineUTF8(ctx context.Context) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_line_utf8(_arg0, &_arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = uint(_arg1)
	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8, _goerr
}

// ReadUint16 reads an unsigned 16-bit/2-byte value from stream.
//
// In order to get the correct byte order for this read
// operation, see g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - guint16: unsigned 16-bit/2-byte value read from the stream or 0 if an
//     error occurred.
func (stream *DataInputStream) ReadUint16(ctx context.Context) (uint16, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guint16           // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_uint16(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _guint16 uint16 // out
	var _goerr error    // out

	_guint16 = uint16(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint16, _goerr
}

// ReadUint32 reads an unsigned 32-bit/4-byte value from stream.
//
// In order to get the correct byte order for this read
// operation, see g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - guint32: unsigned 32-bit/4-byte value read from the stream or 0 if an
//     error occurred.
func (stream *DataInputStream) ReadUint32(ctx context.Context) (uint32, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guint32           // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_uint32(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _guint32 uint32 // out
	var _goerr error    // out

	_guint32 = uint32(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint32, _goerr
}

// ReadUint64 reads an unsigned 64-bit/8-byte value from stream.
//
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - guint64: unsigned 64-bit/8-byte read from stream or 0 if an error
//     occurred.
func (stream *DataInputStream) ReadUint64(ctx context.Context) (uint64, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GCancellable     // out
	var _cret C.guint64           // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_data_input_stream_read_uint64(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _guint64 uint64 // out
	var _goerr error    // out

	_guint64 = uint64(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint64, _goerr
}

// ReadUntil reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
//
// Note that, in contrast to g_data_input_stream_read_until_async(), this
// function consumes the stop character that it finds.
//
// Don't use this function in new code. Its functionality is inconsistent with
// g_data_input_stream_read_until_async(). Both functions will be marked as
// deprecated in a future release. Use g_data_input_stream_read_upto() instead,
// but note that that function does not consume the stop character.
//
// Deprecated: Use g_data_input_stream_read_upto() instead, which has more
// consistent behaviour regarding the stop character.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stopChars characters to terminate the read.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - utf8: string with the data that was read before encountering any of the
//     stop characters. Set length to a #gsize to get the length of the string.
//     This function will return NULL on an error.
func (stream *DataInputStream) ReadUntil(ctx context.Context, stopChars string) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg3 *C.GCancellable     // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_data_input_stream_read_until(_arg0, _arg1, &_arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stopChars)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = uint(_arg2)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8, _goerr
}

// ReadUntilAsync asynchronous version of g_data_input_stream_read_until().
// It is an error to have two outstanding calls to this function.
//
// Note that, in contrast to g_data_input_stream_read_until(), this function
// does not consume the stop character that it finds. You must read it for
// yourself.
//
// When the operation is finished, callback will be called. You can then call
// g_data_input_stream_read_until_finish() to get the result of the operation.
//
// Don't use this function in new code. Its functionality is inconsistent with
// g_data_input_stream_read_until(). Both functions will be marked as deprecated
// in a future release. Use g_data_input_stream_read_upto_async() instead.
//
// Deprecated: Use g_data_input_stream_read_upto_async() instead, which has more
// consistent behaviour regarding the stop character.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stopChars characters to terminate the read.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (stream *DataInputStream) ReadUntilAsync(ctx context.Context, stopChars string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GDataInputStream   // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.gint                // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_data_input_stream_read_until_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadUntilFinish: finish an asynchronous call started by
// g_data_input_stream_read_until_async().
//
// Deprecated: Use g_data_input_stream_read_upto_finish() instead, which has
// more consistent behaviour regarding the stop character.
//
// The function takes the following parameters:
//
//   - result that was provided to the callback.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - utf8: string with the data that was read before encountering any of the
//     stop characters. Set length to a #gsize to get the length of the string.
//     This function will return NULL on an error.
func (stream *DataInputStream) ReadUntilFinish(result AsyncResulter) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_data_input_stream_read_until_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = uint(_arg2)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8, _goerr
}

// ReadUpto reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
//
// In contrast to g_data_input_stream_read_until(), this function does not
// consume the stop character. You have to use g_data_input_stream_read_byte()
// to get it before calling g_data_input_stream_read_upto() again.
//
// Note that stop_chars may contain '\0' if stop_chars_len is specified.
//
// The returned string will always be nul-terminated on success.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stopChars characters to terminate the read.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - utf8: string with the data that was read before encountering any of the
//     stop characters. Set length to a #gsize to get the length of the string.
//     This function will return NULL on an error.
func (stream *DataInputStream) ReadUpto(ctx context.Context, stopChars string) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg4 *C.GCancellable     // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gssize
	var _arg3 C.gsize   // in
	var _cret *C.char   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gssize)(len(stopChars))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(stopChars) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(stopChars)), stopChars)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_data_input_stream_read_upto(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stopChars)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = uint(_arg3)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8, _goerr
}

// ReadUptoAsync asynchronous version of g_data_input_stream_read_upto().
// It is an error to have two outstanding calls to this function.
//
// In contrast to g_data_input_stream_read_until(), this function does not
// consume the stop character. You have to use g_data_input_stream_read_byte()
// to get it before calling g_data_input_stream_read_upto() again.
//
// Note that stop_chars may contain '\0' if stop_chars_len is specified.
//
// When the operation is finished, callback will be called. You can then call
// g_data_input_stream_read_upto_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stopChars characters to terminate the read.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the request is satisfied.
func (stream *DataInputStream) ReadUptoAsync(ctx context.Context, stopChars string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GDataInputStream // out
	var _arg4 *C.GCancellable     // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gssize
	var _arg3 C.gint                // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gssize)(len(stopChars))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(stopChars) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(stopChars)), stopChars)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gint(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_data_input_stream_read_upto_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadUptoFinish: finish an asynchronous call started by
// g_data_input_stream_read_upto_async().
//
// Note that this function does not consume the stop character.
// You have to use g_data_input_stream_read_byte() to get it before calling
// g_data_input_stream_read_upto_async() again.
//
// The returned string will always be nul-terminated on success.
//
// The function takes the following parameters:
//
//   - result that was provided to the callback.
//
// The function returns the following values:
//
//   - length (optional) to get the length of the data read in.
//   - utf8: string with the data that was read before encountering any of the
//     stop characters. Set length to a #gsize to get the length of the string.
//     This function will return NULL on an error.
func (stream *DataInputStream) ReadUptoFinish(result AsyncResulter) (uint, string, error) {
	var _arg0 *C.GDataInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _arg2 C.gsize             // in
	var _cret *C.char             // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_data_input_stream_read_upto_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = uint(_arg2)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8, _goerr
}

// SetByteOrder: this function sets the byte order for the given stream.
// All subsequent reads from the stream will be read in the given order.
//
// The function takes the following parameters:
//
//   - order to set.
func (stream *DataInputStream) SetByteOrder(order DataStreamByteOrder) {
	var _arg0 *C.GDataInputStream    // out
	var _arg1 C.GDataStreamByteOrder // out

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GDataStreamByteOrder(order)

	C.g_data_input_stream_set_byte_order(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(order)
}

// SetNewlineType sets the newline type for the stream.
//
// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
// chunk ends in "CR" we must read an additional byte to know if this is "CR" or
// "CR LF", and this might block if there is no more data available.
//
// The function takes the following parameters:
//
//   - typ: type of new line return as StreamNewlineType.
func (stream *DataInputStream) SetNewlineType(typ DataStreamNewlineType) {
	var _arg0 *C.GDataInputStream      // out
	var _arg1 C.GDataStreamNewlineType // out

	_arg0 = (*C.GDataInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GDataStreamNewlineType(typ)

	C.g_data_input_stream_set_newline_type(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(typ)
}

// DataOutputStreamOverrides contains methods that are overridable.
type DataOutputStreamOverrides struct {
}

func defaultDataOutputStreamOverrides(v *DataOutputStream) DataOutputStreamOverrides {
	return DataOutputStreamOverrides{}
}

// DataOutputStream: data output stream implements gio.OutputStream and includes
// functions for writing data directly to an output stream.
type DataOutputStream struct {
	_ [0]func() // equal guard
	FilterOutputStream

	Seekable
}

var (
	_ FilterOutputStreamer = (*DataOutputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DataOutputStream, *DataOutputStreamClass, DataOutputStreamOverrides](
		GTypeDataOutputStream,
		initDataOutputStreamClass,
		wrapDataOutputStream,
		defaultDataOutputStreamOverrides,
	)
}

func initDataOutputStreamClass(gclass unsafe.Pointer, overrides DataOutputStreamOverrides, classInitFunc func(*DataOutputStreamClass)) {
	if classInitFunc != nil {
		class := (*DataOutputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDataOutputStream(obj *coreglib.Object) *DataOutputStream {
	return &DataOutputStream{
		FilterOutputStream: FilterOutputStream{
			OutputStream: OutputStream{
				Object: obj,
			},
		},
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalDataOutputStream(p uintptr) (interface{}, error) {
	return wrapDataOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDataOutputStream creates a new data output stream for base_stream.
//
// The function takes the following parameters:
//
//   - baseStream: Stream.
//
// The function returns the following values:
//
//   - dataOutputStream: OutputStream.
func NewDataOutputStream(baseStream OutputStreamer) *DataOutputStream {
	var _arg1 *C.GOutputStream     // out
	var _cret *C.GDataOutputStream // in

	_arg1 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(baseStream).Native()))

	_cret = C.g_data_output_stream_new(_arg1)
	runtime.KeepAlive(baseStream)

	var _dataOutputStream *DataOutputStream // out

	_dataOutputStream = wrapDataOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dataOutputStream
}

// ByteOrder gets the byte order for the stream.
//
// The function returns the following values:
//
//   - dataStreamByteOrder for the stream.
func (stream *DataOutputStream) ByteOrder() DataStreamByteOrder {
	var _arg0 *C.GDataOutputStream   // out
	var _cret C.GDataStreamByteOrder // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_data_output_stream_get_byte_order(_arg0)
	runtime.KeepAlive(stream)

	var _dataStreamByteOrder DataStreamByteOrder // out

	_dataStreamByteOrder = DataStreamByteOrder(_cret)

	return _dataStreamByteOrder
}

// PutByte puts a byte into the output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - data: #guchar.
func (stream *DataOutputStream) PutByte(ctx context.Context, data byte) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.guchar             // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.guchar(data)

	C.g_data_output_stream_put_byte(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutInt16 puts a signed 16-bit integer into the output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - data: #gint16.
func (stream *DataOutputStream) PutInt16(ctx context.Context, data int16) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.gint16             // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gint16(data)

	C.g_data_output_stream_put_int16(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutInt32 puts a signed 32-bit integer into the output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - data: #gint32.
func (stream *DataOutputStream) PutInt32(ctx context.Context, data int32) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.gint32             // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gint32(data)

	C.g_data_output_stream_put_int32(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutInt64 puts a signed 64-bit integer into the stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - data: #gint64.
func (stream *DataOutputStream) PutInt64(ctx context.Context, data int64) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.gint64             // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gint64(data)

	C.g_data_output_stream_put_int64(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutString puts a string into the output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - str: string.
func (stream *DataOutputStream) PutString(ctx context.Context, str string) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 *C.char              // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_data_output_stream_put_string(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(str)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutUint16 puts an unsigned 16-bit integer into the output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - data: #guint16.
func (stream *DataOutputStream) PutUint16(ctx context.Context, data uint16) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.guint16            // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.guint16(data)

	C.g_data_output_stream_put_uint16(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutUint32 puts an unsigned 32-bit integer into the stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - data: #guint32.
func (stream *DataOutputStream) PutUint32(ctx context.Context, data uint32) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.guint32            // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.guint32(data)

	C.g_data_output_stream_put_uint32(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PutUint64 puts an unsigned 64-bit integer into the stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - data: #guint64.
func (stream *DataOutputStream) PutUint64(ctx context.Context, data uint64) error {
	var _arg0 *C.GDataOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.guint64            // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.guint64(data)

	C.g_data_output_stream_put_uint64(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetByteOrder sets the byte order of the data output stream to order.
//
// The function takes the following parameters:
//
//   - order: GDataStreamByteOrder.
func (stream *DataOutputStream) SetByteOrder(order DataStreamByteOrder) {
	var _arg0 *C.GDataOutputStream   // out
	var _arg1 C.GDataStreamByteOrder // out

	_arg0 = (*C.GDataOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GDataStreamByteOrder(order)

	C.g_data_output_stream_set_byte_order(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(order)
}

// DebugControllerDBusOverrides contains methods that are overridable.
type DebugControllerDBusOverrides struct {
	// Authorize: default handler for the ControllerDBus::authorize signal.
	Authorize func(invocation *DBusMethodInvocation) bool
}

func defaultDebugControllerDBusOverrides(v *DebugControllerDBus) DebugControllerDBusOverrides {
	return DebugControllerDBusOverrides{
		Authorize: v.authorize,
	}
}

// DebugControllerDBus: GDebugControllerDBus is an implementation of
// gio.DebugController which exposes debug settings as a D-Bus object.
//
// It is a gio.Initable object, and will register an object at
// /org/gtk/Debugging on the bus given as gio.DebugControllerDBus:connection
// once its initialized. The object will be unregistered when the last
// reference to the GDebugControllerDBus is dropped.
//
// This D-Bus object can be used by remote processes to enable or
// disable debug output in this process. Remote processes calling
// org.gtk.Debugging.SetDebugEnabled() will affect the value of
// gio.DebugController:debug-enabled and, by default, glib.LogGetDebugEnabled().
//
// By default, no processes are allowed to call SetDebugEnabled() unless a
// gio.DebugControllerDBus::authorize signal handler is installed. This is
// because the process may be privileged, or might expose sensitive information
// in its debug output. You may want to restrict the ability to enable debug
// output to privileged users or processes.
//
// One option is to install a D-Bus security policy which restricts
// access to SetDebugEnabled(), installing something like the following in
// $datadir/dbus-1/system.d/:
//
//	<?xml version="1.0"?> <!--*-nxml-*-->
//	<!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
//	     "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
//	<busconfig>
//	  <policy user="root">
//	    <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
//	  </policy>
//	  <policy context="default">
//	    <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
//	  </policy>
//	</busconfig>
//
// This will prevent the SetDebugEnabled() method from being called by all
// except root. It will not prevent the DebugEnabled property from being read,
// as its accessed through the org.freedesktop.DBus.Properties interface.
//
// Another option is to use polkit to allow or deny requests on a case-by-case
// basis, allowing for the possibility of dynamic authorisation. To do this,
// connect to the gio.DebugControllerDBus::authorize signal and query polkit in
// it:
//
//	g_autoptr(GError) child_error = NULL;
//	g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
//	gulong debug_controller_authorize_id = 0;
//
//	// Set up the debug controller.
//	debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
//	if (debug_controller == NULL)
//	  {
//	    g_error ("Could not register debug controller on bus: s"),
//	             child_error->message);
//	  }
//
//	debug_controller_authorize_id = g_signal_connect (debug_controller,
//	                                                  "authorize",
//	                                                  G_CALLBACK (debug_controller_authorize_cb),
//	                                                  self);
//
//	static gboolean
//	debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
//	                               GDBusMethodInvocation *invocation,
//	                               gpointer               user_data)
//	{
//	  g_autoptr(PolkitAuthority) authority = NULL;
//	  g_autoptr(PolkitSubject) subject = NULL;
//	  g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
//	  g_autoptr(GError) local_error = NULL;
//	  GDBusMessage *message;
//	  GDBusMessageFlags message_flags;
//	  PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
//
//	  message = g_dbus_method_invocation_get_message (invocation);
//	  message_flags = g_dbus_message_get_flags (message);
//
//	  authority = polkit_authority_get_sync (NULL, &local_error);
//	  if (authority == NULL)
//	    {
//	      g_warning ("Failed to get polkit authority: s", local_error->message);
//	      return FALSE;
//	    }
//
//	  if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
//	    flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
//
//	  subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
//
//	  auth_result = polkit_authority_check_authorization_sync (authority,
//	                                                           subject,
//	                                                           "com.example.MyService.set-debug-enabled",
//	                                                           NULL,
//	                                                           flags,
//	                                                           NULL,
//	                                                           &local_error);
//	  if (auth_result == NULL)
//	    {
//	      g_warning ("Failed to get check polkit authorization: s", local_error->message);
//	      return FALSE;
//	    }
//
//	  return polkit_authorization_result_get_is_authorized (auth_result);
//	}.
type DebugControllerDBus struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DebugController
}

var (
	_ coreglib.Objector = (*DebugControllerDBus)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DebugControllerDBus, *DebugControllerDBusClass, DebugControllerDBusOverrides](
		GTypeDebugControllerDBus,
		initDebugControllerDBusClass,
		wrapDebugControllerDBus,
		defaultDebugControllerDBusOverrides,
	)
}

func initDebugControllerDBusClass(gclass unsafe.Pointer, overrides DebugControllerDBusOverrides, classInitFunc func(*DebugControllerDBusClass)) {
	pclass := (*C.GDebugControllerDBusClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDebugControllerDBus))))

	if overrides.Authorize != nil {
		pclass.authorize = (*[0]byte)(C._gotk4_gio2_DebugControllerDBusClass_authorize)
	}

	if classInitFunc != nil {
		class := (*DebugControllerDBusClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDebugControllerDBus(obj *coreglib.Object) *DebugControllerDBus {
	return &DebugControllerDBus{
		Object: obj,
		DebugController: DebugController{
			Initable: Initable{
				Object: obj,
			},
		},
	}
}

func marshalDebugControllerDBus(p uintptr) (interface{}, error) {
	return wrapDebugControllerDBus(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAuthorize is emitted when a D-Bus peer is trying to change the debug
// settings and used to determine if that is authorized.
//
// This signal is emitted in a dedicated worker thread, so handlers are allowed
// to perform blocking I/O. This means that, for example, it is appropriate to
// call polkit_authority_check_authorization_sync() to check authorization using
// polkit.
//
// If FALSE is returned then no further handlers are run and the request to
// change the debug settings is rejected.
//
// Otherwise, if TRUE is returned, signal emission continues. If no handlers
// return FALSE, then the debug settings are allowed to be changed.
//
// Signal handlers must not modify invocation, or cause it to return a value.
//
// The default class handler just returns TRUE.
func (self *DebugControllerDBus) ConnectAuthorize(f func(invocation *DBusMethodInvocation) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "authorize", false, unsafe.Pointer(C._gotk4_gio2_DebugControllerDBus_ConnectAuthorize), f)
}

// NewDebugControllerDBus: create a new ControllerDBus and synchronously
// initialize it.
//
// Initializing the object will export the debug object on connection. The
// object will remain registered until the last reference to the ControllerDBus
// is dropped.
//
// Initialization may fail if registering the object on connection fails.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connection to register the debug object on.
//
// The function returns the following values:
//
//   - debugControllerDBus (optional): new ControllerDBus, or NULL on failure.
func NewDebugControllerDBus(ctx context.Context, connection *DBusConnection) (*DebugControllerDBus, error) {
	var _arg2 *C.GCancellable         // out
	var _arg1 *C.GDBusConnection      // out
	var _cret *C.GDebugControllerDBus // in
	var _cerr *C.GError               // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_debug_controller_dbus_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)

	var _debugControllerDBus *DebugControllerDBus // out
	var _goerr error                              // out

	if _cret != nil {
		_debugControllerDBus = wrapDebugControllerDBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _debugControllerDBus, _goerr
}

// Stop the debug controller, unregistering its object from the bus.
//
// Any pending method calls to the object will complete successfully,
// but new ones will return an error. This method will block until all
// pending ControllerDBus::authorize signals have been handled. This is
// expected to not take long, as it will just be waiting for threads to join.
// If any ControllerDBus::authorize signal handlers are still executing in other
// threads, this will block until after they have returned.
//
// This method will be called automatically when the final reference to the
// ControllerDBus is dropped. You may want to call it explicitly to know when
// the controller has been fully removed from the bus, or to break reference
// count cycles.
//
// Calling this method from within a ControllerDBus::authorize signal handler
// will cause a deadlock and must not be done.
func (self *DebugControllerDBus) Stop() {
	var _arg0 *C.GDebugControllerDBus // out

	_arg0 = (*C.GDebugControllerDBus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.g_debug_controller_dbus_stop(_arg0)
	runtime.KeepAlive(self)
}

// Authorize: default handler for the ControllerDBus::authorize signal.
func (controller *DebugControllerDBus) authorize(invocation *DBusMethodInvocation) bool {
	gclass := (*C.GDebugControllerDBusClass)(coreglib.PeekParentClass(controller))
	fnarg := gclass.authorize

	var _arg0 *C.GDebugControllerDBus  // out
	var _arg1 *C.GDBusMethodInvocation // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GDebugControllerDBus)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg1 = (*C.GDBusMethodInvocation)(unsafe.Pointer(coreglib.InternObject(invocation).Native()))

	_cret = C._gotk4_gio2_DebugControllerDBus_virtual_authorize(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(invocation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Emblem: GEmblem is an implementation of gio.Icon that supports having an
// emblem, which is an icon with additional properties. It can than be added to
// a gio.EmblemedIcon.
//
// Currently, only metainformation about the emblem's origin is supported.
// More may be added in the future.
type Emblem struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Icon
}

var (
	_ coreglib.Objector = (*Emblem)(nil)
)

func wrapEmblem(obj *coreglib.Object) *Emblem {
	return &Emblem{
		Object: obj,
		Icon: Icon{
			Object: obj,
		},
	}
}

func marshalEmblem(p uintptr) (interface{}, error) {
	return wrapEmblem(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEmblem creates a new emblem for icon.
//
// The function takes the following parameters:
//
//   - icon: GIcon containing the icon.
//
// The function returns the following values:
//
//   - emblem: new #GEmblem.
func NewEmblem(icon Iconner) *Emblem {
	var _arg1 *C.GIcon   // out
	var _cret *C.GEmblem // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_emblem_new(_arg1)
	runtime.KeepAlive(icon)

	var _emblem *Emblem // out

	_emblem = wrapEmblem(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _emblem
}

// NewEmblemWithOrigin creates a new emblem for icon.
//
// The function takes the following parameters:
//
//   - icon: GIcon containing the icon.
//   - origin: GEmblemOrigin enum defining the emblem's origin.
//
// The function returns the following values:
//
//   - emblem: new #GEmblem.
func NewEmblemWithOrigin(icon Iconner, origin EmblemOrigin) *Emblem {
	var _arg1 *C.GIcon        // out
	var _arg2 C.GEmblemOrigin // out
	var _cret *C.GEmblem      // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg2 = C.GEmblemOrigin(origin)

	_cret = C.g_emblem_new_with_origin(_arg1, _arg2)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(origin)

	var _emblem *Emblem // out

	_emblem = wrapEmblem(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _emblem
}

// GetIcon gives back the icon from emblem.
//
// The function returns the following values:
//
//   - icon The returned object belongs to the emblem and should not be modified
//     or freed.
func (emblem *Emblem) GetIcon() *Icon {
	var _arg0 *C.GEmblem // out
	var _cret *C.GIcon   // in

	_arg0 = (*C.GEmblem)(unsafe.Pointer(coreglib.InternObject(emblem).Native()))

	_cret = C.g_emblem_get_icon(_arg0)
	runtime.KeepAlive(emblem)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))

	return _icon
}

// Origin gets the origin of the emblem.
//
// The function returns the following values:
//
//   - emblemOrigin: origin of the emblem.
func (emblem *Emblem) Origin() EmblemOrigin {
	var _arg0 *C.GEmblem      // out
	var _cret C.GEmblemOrigin // in

	_arg0 = (*C.GEmblem)(unsafe.Pointer(coreglib.InternObject(emblem).Native()))

	_cret = C.g_emblem_get_origin(_arg0)
	runtime.KeepAlive(emblem)

	var _emblemOrigin EmblemOrigin // out

	_emblemOrigin = EmblemOrigin(_cret)

	return _emblemOrigin
}

// EmblemedIconOverrides contains methods that are overridable.
type EmblemedIconOverrides struct {
}

func defaultEmblemedIconOverrides(v *EmblemedIcon) EmblemedIconOverrides {
	return EmblemedIconOverrides{}
}

// EmblemedIcon: GEmblemedIcon is an implementation of gio.Icon that supports
// adding an emblem to an icon. Adding multiple emblems to an icon is ensured
// via gio.EmblemedIcon.AddEmblem().
//
// Note that GEmblemedIcon allows no control over the position of the emblems.
// See also gio.Emblem for more information.
type EmblemedIcon struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Icon
}

var (
	_ coreglib.Objector = (*EmblemedIcon)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*EmblemedIcon, *EmblemedIconClass, EmblemedIconOverrides](
		GTypeEmblemedIcon,
		initEmblemedIconClass,
		wrapEmblemedIcon,
		defaultEmblemedIconOverrides,
	)
}

func initEmblemedIconClass(gclass unsafe.Pointer, overrides EmblemedIconOverrides, classInitFunc func(*EmblemedIconClass)) {
	if classInitFunc != nil {
		class := (*EmblemedIconClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapEmblemedIcon(obj *coreglib.Object) *EmblemedIcon {
	return &EmblemedIcon{
		Object: obj,
		Icon: Icon{
			Object: obj,
		},
	}
}

func marshalEmblemedIcon(p uintptr) (interface{}, error) {
	return wrapEmblemedIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEmblemedIcon creates a new emblemed icon for icon with the emblem emblem.
//
// The function takes the following parameters:
//
//   - icon: #GIcon.
//   - emblem (optional) or NULL.
//
// The function returns the following values:
//
//   - emblemedIcon: new #GIcon.
func NewEmblemedIcon(icon Iconner, emblem *Emblem) *EmblemedIcon {
	var _arg1 *C.GIcon   // out
	var _arg2 *C.GEmblem // out
	var _cret *C.GIcon   // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	if emblem != nil {
		_arg2 = (*C.GEmblem)(unsafe.Pointer(coreglib.InternObject(emblem).Native()))
	}

	_cret = C.g_emblemed_icon_new(_arg1, _arg2)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(emblem)

	var _emblemedIcon *EmblemedIcon // out

	_emblemedIcon = wrapEmblemedIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _emblemedIcon
}

// AddEmblem adds emblem to the #GList of #GEmblems.
//
// The function takes the following parameters:
//
//   - emblem: #GEmblem.
func (emblemed *EmblemedIcon) AddEmblem(emblem *Emblem) {
	var _arg0 *C.GEmblemedIcon // out
	var _arg1 *C.GEmblem       // out

	_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(coreglib.InternObject(emblemed).Native()))
	_arg1 = (*C.GEmblem)(unsafe.Pointer(coreglib.InternObject(emblem).Native()))

	C.g_emblemed_icon_add_emblem(_arg0, _arg1)
	runtime.KeepAlive(emblemed)
	runtime.KeepAlive(emblem)
}

// ClearEmblems removes all the emblems from icon.
func (emblemed *EmblemedIcon) ClearEmblems() {
	var _arg0 *C.GEmblemedIcon // out

	_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(coreglib.InternObject(emblemed).Native()))

	C.g_emblemed_icon_clear_emblems(_arg0)
	runtime.KeepAlive(emblemed)
}

// Emblems gets the list of emblems for the icon.
//
// The function returns the following values:
//
//   - list of #GEmblems that is owned by emblemed.
func (emblemed *EmblemedIcon) Emblems() []*Emblem {
	var _arg0 *C.GEmblemedIcon // out
	var _cret *C.GList         // in

	_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(coreglib.InternObject(emblemed).Native()))

	_cret = C.g_emblemed_icon_get_emblems(_arg0)
	runtime.KeepAlive(emblemed)

	var _list []*Emblem // out

	_list = make([]*Emblem, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GEmblem)(v)
		var dst *Emblem // out
		dst = wrapEmblem(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// GetIcon gets the main icon for emblemed.
//
// The function returns the following values:
//
//   - icon that is owned by emblemed.
func (emblemed *EmblemedIcon) GetIcon() *Icon {
	var _arg0 *C.GEmblemedIcon // out
	var _cret *C.GIcon         // in

	_arg0 = (*C.GEmblemedIcon)(unsafe.Pointer(coreglib.InternObject(emblemed).Native()))

	_cret = C.g_emblemed_icon_get_icon(_arg0)
	runtime.KeepAlive(emblemed)

	var _icon *Icon // out

	_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))

	return _icon
}

// FileEnumeratorOverrides contains methods that are overridable.
type FileEnumeratorOverrides struct {
	// CloseFinish finishes closing a file enumerator, started from
	// g_file_enumerator_close_async().
	//
	// If the file enumerator was already closed when
	// g_file_enumerator_close_async() was called, then this function will
	// report G_IO_ERROR_CLOSED in error, and return FALSE. If the file
	// enumerator had pending operation when the close operation was started,
	// then this function will report G_IO_ERROR_PENDING, and return FALSE.
	// If cancellable was not NULL, then the operation may have been cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error G_IO_ERROR_CANCELLED will be set,
	// and FALSE will be returned.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	CloseFinish func(result AsyncResulter) error
	CloseFn     func(ctx context.Context) error
	// NextFile returns information for the next file in the enumerated object.
	// Will block until the information is available. The Info returned from
	// this function will contain attributes that match the attribute string
	// that was passed when the Enumerator was created.
	//
	// See the documentation of Enumerator for information about the order of
	// returned files.
	//
	// On error, returns NULL and sets error to the error. If the enumerator is
	// at the end, NULL will be returned and error will be unset.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//
	// The function returns the following values:
	//
	//   - fileInfo (optional) or NULL on error or end of enumerator. Free the
	//     returned object with g_object_unref() when no longer needed.
	NextFile func(ctx context.Context) (*FileInfo, error)
	// NextFilesFinish finishes the asynchronous operation started with
	// g_file_enumerator_next_files_async().
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - list of Infos. You must free the list with g_list_free() and unref
	//     the infos with g_object_unref() when you're done with them.
	NextFilesFinish func(result AsyncResulter) ([]*FileInfo, error)
}

func defaultFileEnumeratorOverrides(v *FileEnumerator) FileEnumeratorOverrides {
	return FileEnumeratorOverrides{
		CloseFinish:     v.closeFinish,
		CloseFn:         v.closeFn,
		NextFile:        v.nextFile,
		NextFilesFinish: v.nextFilesFinish,
	}
}

// FileEnumerator: GFileEnumerator allows you to operate on a set of gio.File
// objects, returning a gio.FileInfo structure for each file enumerated (e.g.
// gio.File.EnumerateChildren() will return a GFileEnumerator for each of the
// children within a directory).
//
// To get the next file's information from a GFileEnumerator,
// use gio.FileEnumerator.NextFile() or its asynchronous version,
// gio.FileEnumerator.NextFilesAsync(). Note that the asynchronous version will
// return a list of gio.FileInfo objects, whereas the synchronous will only
// return the next file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see glib.Dir.ReadName(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
//
// To close a GFileEnumerator, use gio.FileEnumerator.Close(), or its
// asynchronous version, gio.FileEnumerator.CloseAsync(). Once a GFileEnumerator
// is closed, no further actions may be performed on it, and it should be freed
// with gobject.Object.Unref().
type FileEnumerator struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FileEnumerator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileEnumerator, *FileEnumeratorClass, FileEnumeratorOverrides](
		GTypeFileEnumerator,
		initFileEnumeratorClass,
		wrapFileEnumerator,
		defaultFileEnumeratorOverrides,
	)
}

func initFileEnumeratorClass(gclass unsafe.Pointer, overrides FileEnumeratorOverrides, classInitFunc func(*FileEnumeratorClass)) {
	pclass := (*C.GFileEnumeratorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFileEnumerator))))

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._gotk4_gio2_FileEnumeratorClass_close_finish)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._gotk4_gio2_FileEnumeratorClass_close_fn)
	}

	if overrides.NextFile != nil {
		pclass.next_file = (*[0]byte)(C._gotk4_gio2_FileEnumeratorClass_next_file)
	}

	if overrides.NextFilesFinish != nil {
		pclass.next_files_finish = (*[0]byte)(C._gotk4_gio2_FileEnumeratorClass_next_files_finish)
	}

	if classInitFunc != nil {
		class := (*FileEnumeratorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileEnumerator(obj *coreglib.Object) *FileEnumerator {
	return &FileEnumerator{
		Object: obj,
	}
}

func marshalFileEnumerator(p uintptr) (interface{}, error) {
	return wrapFileEnumerator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Close releases all resources used by this enumerator, making the enumerator
// return G_IO_ERROR_CLOSED on all calls.
//
// This will be automatically called when the last reference is dropped, but you
// might want to call this function to make sure resources are released as early
// as possible.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (enumerator *FileEnumerator) Close(ctx context.Context) error {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_enumerator_close(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CloseAsync: asynchronously closes the file enumerator.
//
// If cancellable is not NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned in
// g_file_enumerator_close_finish().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (enumerator *FileEnumerator) CloseAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFileEnumerator    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_enumerator_close_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CloseFinish finishes closing a file enumerator, started from
// g_file_enumerator_close_async().
//
// If the file enumerator was already closed when
// g_file_enumerator_close_async() was called, then this function will report
// G_IO_ERROR_CLOSED in error, and return FALSE. If the file enumerator had
// pending operation when the close operation was started, then this function
// will report G_IO_ERROR_PENDING, and return FALSE. If cancellable was
// not NULL, then the operation may have been cancelled by triggering the
// cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and FALSE will be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (enumerator *FileEnumerator) CloseFinish(result AsyncResulter) error {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_enumerator_close_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Child: return a new #GFile which refers to the file named by info in the
// source directory of enumerator. This function is primarily intended to be
// used inside loops with g_file_enumerator_next_file().
//
// To use this, G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
// attributes list used when creating the Enumerator.
//
// This is a convenience method that's equivalent to:
//
//	gchar *name = g_file_info_get_name (info);
//	GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
//	                                 name);.
//
// The function takes the following parameters:
//
//   - info gotten from g_file_enumerator_next_file() or the async equivalents.
//
// The function returns the following values:
//
//   - file for the Info passed it.
func (enumerator *FileEnumerator) Child(info *FileInfo) *File {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GFileInfo       // out
	var _cret *C.GFile           // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_enumerator_get_child(_arg0, _arg1)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(info)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// Container: get the #GFile container which is being enumerated.
//
// The function returns the following values:
//
//   - file which is being enumerated.
func (enumerator *FileEnumerator) Container() *File {
	var _arg0 *C.GFileEnumerator // out
	var _cret *C.GFile           // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))

	_cret = C.g_file_enumerator_get_container(_arg0)
	runtime.KeepAlive(enumerator)

	var _file *File // out

	_file = wrapFile(coreglib.Take(unsafe.Pointer(_cret)))

	return _file
}

// HasPending checks if the file enumerator has pending operations.
//
// The function returns the following values:
//
//   - ok: TRUE if the enumerator has pending operations.
func (enumerator *FileEnumerator) HasPending() bool {
	var _arg0 *C.GFileEnumerator // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))

	_cret = C.g_file_enumerator_has_pending(_arg0)
	runtime.KeepAlive(enumerator)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsClosed checks if the file enumerator has been closed.
//
// The function returns the following values:
//
//   - ok: TRUE if the enumerator is closed.
func (enumerator *FileEnumerator) IsClosed() bool {
	var _arg0 *C.GFileEnumerator // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))

	_cret = C.g_file_enumerator_is_closed(_arg0)
	runtime.KeepAlive(enumerator)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iterate: this is a version of g_file_enumerator_next_file() that's easier
// to use correctly from C programs. With g_file_enumerator_next_file(), the
// gboolean return value signifies "end of iteration or error", which requires
// allocation of a temporary #GError.
//
// In contrast, with this function, a FALSE return from
// g_file_enumerator_iterate() *always* means "error". End of iteration is
// signaled by out_info or out_child being NULL.
//
// Another crucial difference is that the references for out_info and out_child
// are owned by direnum (they are cached as hidden properties). You must not
// unref them in your own code. This makes memory management significantly
// easier for C code in combination with loops.
//
// Finally, this function optionally allows retrieving a #GFile as well.
//
// You must specify at least one of out_info or out_child.
//
// The code pattern for correctly using g_file_enumerator_iterate() from C is:
//
//	direnum = g_file_enumerate_children (file, ...);
//	while (TRUE)
//	  {
//	    GFileInfo *info;
//	    if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
//	      goto out;
//	    if (!info)
//	      break;
//	    ... do stuff with "info"; do not unref it! ...
//	  }
//
//	out:
//	  g_object_unref (direnum); // Note: frees the last info.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//   - outInfo (optional): output location for the next Info, or NULL.
//   - outChild (optional): output location for the next #GFile, or NULL.
func (direnum *FileEnumerator) Iterate(ctx context.Context) (*FileInfo, *File, error) {
	var _arg0 *C.GFileEnumerator // out
	var _arg3 *C.GCancellable    // out
	var _arg1 *C.GFileInfo       // in
	var _arg2 *C.GFile           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(direnum).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_enumerator_iterate(_arg0, &_arg1, &_arg2, _arg3, &_cerr)
	runtime.KeepAlive(direnum)
	runtime.KeepAlive(ctx)

	var _outInfo *FileInfo // out
	var _outChild *File    // out
	var _goerr error       // out

	if _arg1 != nil {
		_outInfo = wrapFileInfo(coreglib.Take(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		_outChild = wrapFile(coreglib.Take(unsafe.Pointer(_arg2)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outInfo, _outChild, _goerr
}

// NextFile returns information for the next file in the enumerated object.
// Will block until the information is available. The Info returned from this
// function will contain attributes that match the attribute string that was
// passed when the Enumerator was created.
//
// See the documentation of Enumerator for information about the order of
// returned files.
//
// On error, returns NULL and sets error to the error. If the enumerator is at
// the end, NULL will be returned and error will be unset.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - fileInfo (optional) or NULL on error or end of enumerator. Free the
//     returned object with g_object_unref() when no longer needed.
func (enumerator *FileEnumerator) NextFile(ctx context.Context) (*FileInfo, error) {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GCancellable    // out
	var _cret *C.GFileInfo       // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_enumerator_next_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	if _cret != nil {
		_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// NextFilesAsync: request information for a number of files from the enumerator
// asynchronously. When all I/O for the operation is finished the callback will
// be called with the requested information.
//
// See the documentation of Enumerator for information about the order of
// returned files.
//
// Once the end of the enumerator is reached, or if an error occurs, the
// callback will be called with an empty list. In this case, the previous call
// to g_file_enumerator_next_files_async() will typically have returned fewer
// than num_files items.
//
// If a request is cancelled the callback will be called with
// G_IO_ERROR_CANCELLED.
//
// This leads to the following pseudo-code usage:
//
//	g_autoptr(GFile) dir = get_directory ();
//	g_autoptr(GFileEnumerator) enumerator = NULL;
//	g_autolist(GFileInfo) files = NULL;
//	g_autoptr(GError) local_error = NULL;
//
//	enumerator = yield g_file_enumerate_children_async (dir,
//	                                                    G_FILE_ATTRIBUTE_STANDARD_NAME ","
//	                                                    G_FILE_ATTRIBUTE_STANDARD_TYPE,
//	                                                    G_FILE_QUERY_INFO_NONE,
//	                                                    G_PRIORITY_DEFAULT,
//	                                                    cancellable,
//	                                                    ,
//	                                                    &local_error);
//	if (enumerator == NULL)
//	  g_error ("Error enumerating: s", local_error->message);
//
//	// Loop until no files are returned, either because the end of the enumerator
//	// has been reached, or an error was returned.
//	do
//	  {
//	    files = yield g_file_enumerator_next_files_async (enumerator,
//	                                                      5,  // number of files to request
//	                                                      G_PRIORITY_DEFAULT,
//	                                                      cancellable,
//	                                                      ,
//	                                                      &local_error);
//
//	    // Process the returned files, but dont assume that exactly 5 were returned.
//	    for (GList *l = files; l != NULL; l = l->next)
//	      {
//	        GFileInfo *info = l->data;
//	        handle_file_info (info);
//	      }
//	  }
//	while (files != NULL);
//
//	if (local_error != NULL &&
//	    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
//	  g_error ("Error while enumerating: s", local_error->message);
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - numFiles: number of file info objects to request.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (enumerator *FileEnumerator) NextFilesAsync(ctx context.Context, numFiles, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFileEnumerator    // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(numFiles)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_enumerator_next_files_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(numFiles)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// NextFilesFinish finishes the asynchronous operation started with
// g_file_enumerator_next_files_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list of Infos. You must free the list with g_list_free() and unref the
//     infos with g_object_unref() when you're done with them.
func (enumerator *FileEnumerator) NextFilesFinish(result AsyncResulter) ([]*FileInfo, error) {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GList           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_enumerator_next_files_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var _list []*FileInfo // out
	var _goerr error      // out

	_list = make([]*FileInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GFileInfo)(v)
		var dst *FileInfo // out
		dst = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SetPending sets the file enumerator as having pending operations.
//
// The function takes the following parameters:
//
//   - pending: boolean value.
func (enumerator *FileEnumerator) SetPending(pending bool) {
	var _arg0 *C.GFileEnumerator // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	if pending {
		_arg1 = C.TRUE
	}

	C.g_file_enumerator_set_pending(_arg0, _arg1)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(pending)
}

// closeAsync: asynchronously closes the file enumerator.
//
// If cancellable is not NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned in
// g_file_enumerator_close_finish().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (enumerator *FileEnumerator) closeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.close_async

	var _arg0 *C.GFileEnumerator    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_FileEnumerator_virtual_close_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// closeFinish finishes closing a file enumerator, started from
// g_file_enumerator_close_async().
//
// If the file enumerator was already closed when
// g_file_enumerator_close_async() was called, then this function will report
// G_IO_ERROR_CLOSED in error, and return FALSE. If the file enumerator had
// pending operation when the close operation was started, then this function
// will report G_IO_ERROR_PENDING, and return FALSE. If cancellable was
// not NULL, then the operation may have been cancelled by triggering the
// cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and FALSE will be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
func (enumerator *FileEnumerator) closeFinish(result AsyncResulter) error {
	gclass := (*C.GFileEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.close_finish

	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_FileEnumerator_virtual_close_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (enumerator *FileEnumerator) closeFn(ctx context.Context) error {
	gclass := (*C.GFileEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.close_fn

	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_FileEnumerator_virtual_close_fn(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// nextFile returns information for the next file in the enumerated object.
// Will block until the information is available. The Info returned from this
// function will contain attributes that match the attribute string that was
// passed when the Enumerator was created.
//
// See the documentation of Enumerator for information about the order of
// returned files.
//
// On error, returns NULL and sets error to the error. If the enumerator is at
// the end, NULL will be returned and error will be unset.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - fileInfo (optional) or NULL on error or end of enumerator. Free the
//     returned object with g_object_unref() when no longer needed.
func (enumerator *FileEnumerator) nextFile(ctx context.Context) (*FileInfo, error) {
	gclass := (*C.GFileEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.next_file

	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GCancellable    // out
	var _cret *C.GFileInfo       // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_FileEnumerator_virtual_next_file(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	if _cret != nil {
		_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// nextFilesAsync: request information for a number of files from the enumerator
// asynchronously. When all I/O for the operation is finished the callback will
// be called with the requested information.
//
// See the documentation of Enumerator for information about the order of
// returned files.
//
// Once the end of the enumerator is reached, or if an error occurs, the
// callback will be called with an empty list. In this case, the previous call
// to g_file_enumerator_next_files_async() will typically have returned fewer
// than num_files items.
//
// If a request is cancelled the callback will be called with
// G_IO_ERROR_CANCELLED.
//
// This leads to the following pseudo-code usage:
//
//	g_autoptr(GFile) dir = get_directory ();
//	g_autoptr(GFileEnumerator) enumerator = NULL;
//	g_autolist(GFileInfo) files = NULL;
//	g_autoptr(GError) local_error = NULL;
//
//	enumerator = yield g_file_enumerate_children_async (dir,
//	                                                    G_FILE_ATTRIBUTE_STANDARD_NAME ","
//	                                                    G_FILE_ATTRIBUTE_STANDARD_TYPE,
//	                                                    G_FILE_QUERY_INFO_NONE,
//	                                                    G_PRIORITY_DEFAULT,
//	                                                    cancellable,
//	                                                    ,
//	                                                    &local_error);
//	if (enumerator == NULL)
//	  g_error ("Error enumerating: s", local_error->message);
//
//	// Loop until no files are returned, either because the end of the enumerator
//	// has been reached, or an error was returned.
//	do
//	  {
//	    files = yield g_file_enumerator_next_files_async (enumerator,
//	                                                      5,  // number of files to request
//	                                                      G_PRIORITY_DEFAULT,
//	                                                      cancellable,
//	                                                      ,
//	                                                      &local_error);
//
//	    // Process the returned files, but dont assume that exactly 5 were returned.
//	    for (GList *l = files; l != NULL; l = l->next)
//	      {
//	        GFileInfo *info = l->data;
//	        handle_file_info (info);
//	      }
//	  }
//	while (files != NULL);
//
//	if (local_error != NULL &&
//	    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
//	  g_error ("Error while enumerating: s", local_error->message);
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - numFiles: number of file info objects to request.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (enumerator *FileEnumerator) nextFilesAsync(ctx context.Context, numFiles, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.next_files_async

	var _arg0 *C.GFileEnumerator    // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(numFiles)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_FileEnumerator_virtual_next_files_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(numFiles)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// nextFilesFinish finishes the asynchronous operation started with
// g_file_enumerator_next_files_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list of Infos. You must free the list with g_list_free() and unref the
//     infos with g_object_unref() when you're done with them.
func (enumerator *FileEnumerator) nextFilesFinish(result AsyncResulter) ([]*FileInfo, error) {
	gclass := (*C.GFileEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.next_files_finish

	var _arg0 *C.GFileEnumerator // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GList           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_FileEnumerator_virtual_next_files_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var _list []*FileInfo // out
	var _goerr error      // out

	_list = make([]*FileInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GFileInfo)(v)
		var dst *FileInfo // out
		dst = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// FileIOStreamOverrides contains methods that are overridable.
type FileIOStreamOverrides struct {
	CanSeek     func() bool
	CanTruncate func() bool
	// ETag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	//
	// The function returns the following values:
	//
	//   - utf8 (optional): entity tag for the stream.
	ETag func() string
	// QueryInfo queries a file io stream for the given attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_io_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally,
	// and any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with error being set to G_IO_ERROR_NOT_SUPPORTED).
	// I all cases of failure, NULL will be returned.
	//
	// If cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and NULL will
	// be returned.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//   - attributes: file attribute query string.
	//
	// The function returns the following values:
	//
	//   - fileInfo for the stream, or NULL on error.
	QueryInfo func(ctx context.Context, attributes string) (*FileInfo, error)
	// QueryInfoFinish finalizes the asynchronous query started by
	// g_file_io_stream_query_info_async().
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - fileInfo for the finished query.
	QueryInfoFinish func(result AsyncResulter) (*FileInfo, error)
	// The function takes the following parameters:
	//
	//   - ctx (optional)
	//   - offset
	//   - typ
	Seek func(ctx context.Context, offset int64, typ glib.SeekType) error
	Tell func() int64
	// The function takes the following parameters:
	//
	//   - ctx (optional)
	//   - size
	TruncateFn func(ctx context.Context, size int64) error
}

func defaultFileIOStreamOverrides(v *FileIOStream) FileIOStreamOverrides {
	return FileIOStreamOverrides{
		CanSeek:         v.canSeek,
		CanTruncate:     v.canTruncate,
		ETag:            v.eTag,
		QueryInfo:       v.queryInfo,
		QueryInfoFinish: v.queryInfoFinish,
		Seek:            v.seek,
		Tell:            v.tell,
		TruncateFn:      v.truncateFn,
	}
}

// FileIOStream: GFileIOStream provides I/O streams that both read and write to
// the same file handle.
//
// GFileIOStream implements gio.Seekable, which allows the I/O stream to jump
// to arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
//
// To find the position of a file I/O stream, use gio.Seekable.Tell().
//
// To find out if a file I/O stream supports seeking,
// use gio.Seekable.CanSeek(). To position a file I/O stream, use
// gio.Seekable.Seek(). To find out if a file I/O stream supports truncating,
// use gio.Seekable.CanTruncate(). To truncate a file I/O stream, use
// gio.Seekable.Truncate().
//
// The default implementation of all the GFileIOStream operations and the
// implementation of gio.Seekable just call into the same operations on the
// output stream.
type FileIOStream struct {
	_ [0]func() // equal guard
	IOStream

	*coreglib.Object
	Seekable
}

var (
	_ IOStreamer        = (*FileIOStream)(nil)
	_ coreglib.Objector = (*FileIOStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileIOStream, *FileIOStreamClass, FileIOStreamOverrides](
		GTypeFileIOStream,
		initFileIOStreamClass,
		wrapFileIOStream,
		defaultFileIOStreamOverrides,
	)
}

func initFileIOStreamClass(gclass unsafe.Pointer, overrides FileIOStreamOverrides, classInitFunc func(*FileIOStreamClass)) {
	pclass := (*C.GFileIOStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFileIOStream))))

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_can_seek)
	}

	if overrides.CanTruncate != nil {
		pclass.can_truncate = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_can_truncate)
	}

	if overrides.ETag != nil {
		pclass.get_etag = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_get_etag)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_query_info)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_query_info_finish)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_seek)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_tell)
	}

	if overrides.TruncateFn != nil {
		pclass.truncate_fn = (*[0]byte)(C._gotk4_gio2_FileIOStreamClass_truncate_fn)
	}

	if classInitFunc != nil {
		class := (*FileIOStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileIOStream(obj *coreglib.Object) *FileIOStream {
	return &FileIOStream{
		IOStream: IOStream{
			Object: obj,
		},
		Object: obj,
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalFileIOStream(p uintptr) (interface{}, error) {
	return wrapFileIOStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ETag gets the entity tag for the file when it has been written. This must be
// called after the stream has been written and closed, as the etag can change
// while writing.
//
// The function returns the following values:
//
//   - utf8 (optional): entity tag for the stream.
func (stream *FileIOStream) ETag() string {
	var _arg0 *C.GFileIOStream // out
	var _cret *C.char          // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_file_io_stream_get_etag(_arg0)
	runtime.KeepAlive(stream)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// QueryInfo queries a file io stream for the given attributes. This function
// blocks while querying the stream. For the asynchronous version of this
// function, see g_file_io_stream_query_info_async(). While the stream is
// blocked, the stream will set the pending flag internally, and any other
// operations on the stream will fail with G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with error being set
// to G_IO_ERROR_PENDING), or if querying info is not supported for the stream's
// interface (with error being set to G_IO_ERROR_NOT_SUPPORTED). I all cases of
// failure, NULL will be returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and NULL will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//
// The function returns the following values:
//
//   - fileInfo for the stream, or NULL on error.
func (stream *FileIOStream) QueryInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	var _arg0 *C.GFileIOStream // out
	var _arg2 *C.GCancellable  // out
	var _arg1 *C.char          // out
	var _cret *C.GFileInfo     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_io_stream_query_info(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// QueryInfoAsync: asynchronously queries the stream for a Info. When completed,
// callback will be called with a Result which can be used to finish the
// operation with g_file_io_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_io_stream_query_info().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//   - ioPriority: I/O priority (iface.AsyncResult.html#io-priority) of the
//     request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *FileIOStream) QueryInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFileIOStream      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_io_stream_query_info_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish finalizes the asynchronous query started by
// g_file_io_stream_query_info_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - fileInfo for the finished query.
func (stream *FileIOStream) QueryInfoFinish(result AsyncResulter) (*FileInfo, error) {
	var _arg0 *C.GFileIOStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileInfo     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_io_stream_query_info_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

func (stream *FileIOStream) canSeek() bool {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.can_seek

	var _arg0 *C.GFileIOStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileIOStream_virtual_can_seek(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (stream *FileIOStream) canTruncate() bool {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.can_truncate

	var _arg0 *C.GFileIOStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileIOStream_virtual_can_truncate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// eTag gets the entity tag for the file when it has been written. This must be
// called after the stream has been written and closed, as the etag can change
// while writing.
//
// The function returns the following values:
//
//   - utf8 (optional): entity tag for the stream.
func (stream *FileIOStream) eTag() string {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.get_etag

	var _arg0 *C.GFileIOStream // out
	var _cret *C.char          // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileIOStream_virtual_get_etag(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// queryInfo queries a file io stream for the given attributes. This function
// blocks while querying the stream. For the asynchronous version of this
// function, see g_file_io_stream_query_info_async(). While the stream is
// blocked, the stream will set the pending flag internally, and any other
// operations on the stream will fail with G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with error being set
// to G_IO_ERROR_PENDING), or if querying info is not supported for the stream's
// interface (with error being set to G_IO_ERROR_NOT_SUPPORTED). I all cases of
// failure, NULL will be returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and NULL will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//
// The function returns the following values:
//
//   - fileInfo for the stream, or NULL on error.
func (stream *FileIOStream) queryInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info

	var _arg0 *C.GFileIOStream // out
	var _arg2 *C.GCancellable  // out
	var _arg1 *C.char          // out
	var _cret *C.GFileInfo     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_FileIOStream_virtual_query_info(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// queryInfoAsync: asynchronously queries the stream for a Info. When completed,
// callback will be called with a Result which can be used to finish the
// operation with g_file_io_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_io_stream_query_info().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//   - ioPriority: I/O priority (iface.AsyncResult.html#io-priority) of the
//     request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *FileIOStream) queryInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info_async

	var _arg0 *C.GFileIOStream      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_FileIOStream_virtual_query_info_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// queryInfoFinish finalizes the asynchronous query started by
// g_file_io_stream_query_info_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - fileInfo for the finished query.
func (stream *FileIOStream) queryInfoFinish(result AsyncResulter) (*FileInfo, error) {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info_finish

	var _arg0 *C.GFileIOStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileInfo     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_FileIOStream_virtual_query_info_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// The function takes the following parameters:
//
//   - ctx (optional)
//   - offset
//   - typ
func (stream *FileIOStream) seek(ctx context.Context, offset int64, typ glib.SeekType) error {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.seek

	var _arg0 *C.GFileIOStream // out
	var _arg3 *C.GCancellable  // out
	var _arg1 C.goffset        // out
	var _arg2 C.GSeekType      // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(offset)
	_arg2 = C.GSeekType(typ)

	C._gotk4_gio2_FileIOStream_virtual_seek(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (stream *FileIOStream) tell() int64 {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.tell

	var _arg0 *C.GFileIOStream // out
	var _cret C.goffset        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileIOStream_virtual_tell(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// The function takes the following parameters:
//
//   - ctx (optional)
//   - size
func (stream *FileIOStream) truncateFn(ctx context.Context, size int64) error {
	gclass := (*C.GFileIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.truncate_fn

	var _arg0 *C.GFileIOStream // out
	var _arg2 *C.GCancellable  // out
	var _arg1 C.goffset        // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GFileIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(size)

	C._gotk4_gio2_FileIOStream_virtual_truncate_fn(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FileIcon: GFileIcon specifies an icon by pointing to an image file to be used
// as icon.
//
// It implements gio.LoadableIcon.
type FileIcon struct {
	_ [0]func() // equal guard
	*coreglib.Object

	LoadableIcon
}

var (
	_ coreglib.Objector = (*FileIcon)(nil)
)

func wrapFileIcon(obj *coreglib.Object) *FileIcon {
	return &FileIcon{
		Object: obj,
		LoadableIcon: LoadableIcon{
			Icon: Icon{
				Object: obj,
			},
		},
	}
}

func marshalFileIcon(p uintptr) (interface{}, error) {
	return wrapFileIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFileIcon creates a new icon for a file.
//
// The function takes the following parameters:
//
//   - file: #GFile.
//
// The function returns the following values:
//
//   - fileIcon for the given file, or NULL on error.
func NewFileIcon(file Filer) *FileIcon {
	var _arg1 *C.GFile // out
	var _cret *C.GIcon // in

	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_icon_new(_arg1)
	runtime.KeepAlive(file)

	var _fileIcon *FileIcon // out

	_fileIcon = wrapFileIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileIcon
}

// File gets the #GFile associated with the given icon.
//
// The function returns the following values:
//
//   - file: #GFile.
func (icon *FileIcon) File() *File {
	var _arg0 *C.GFileIcon // out
	var _cret *C.GFile     // in

	_arg0 = (*C.GFileIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_file_icon_get_file(_arg0)
	runtime.KeepAlive(icon)

	var _file *File // out

	_file = wrapFile(coreglib.Take(unsafe.Pointer(_cret)))

	return _file
}

// FileInfo stores information about a file system object referenced by a
// gio.File.
//
// Functionality for manipulating basic metadata for files. GFileInfo implements
// methods for getting information that all files should contain, and allows for
// manipulation of extended attributes.
//
// See file-attributes.html (file attributes) for more information on how GIO
// handles file attributes.
//
// To obtain a GFileInfo for a gio.File, use gio.File.QueryInfo() (or its
// async variant). To obtain a GFileInfo for a file input or output stream,
// use gio.FileInputStream.QueryInfo() or gio.FileOutputStream.QueryInfo() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the
// attribute in the GFileInfo and call gio.File.SetAttributesFromInfo() or
// gio.File.SetAttributesAsync() on a GFile.
//
// However, not all attributes can be changed in the file. For instance,
// the actual size of a file cannot be changed via gio.FileInfo.SetSize().
// You may call gio.File.QuerySettableAttributes() and
// gio.File.QueryWritableNamespaces() to discover the settable attributes of a
// particular file at runtime.
//
// The direct accessors, such as gio.FileInfo.GetName(), are slightly
// more optimized than the generic attribute accessors, such as
// gio.FileInfo.GetAttributeByteString().This optimization will matter only if
// calling the API in a tight loop.
//
// It is an error to call these accessors without specifying their required file
// attributes when creating the GFileInfo. Use gio.FileInfo.HasAttribute() or
// gio.FileInfo.ListAttributes() to check what attributes are specified for a
// GFileInfo.
//
// gio.FileAttributeMatcher allows for searching through a GFileInfo for
// attributes.
type FileInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FileInfo)(nil)
)

func wrapFileInfo(obj *coreglib.Object) *FileInfo {
	return &FileInfo{
		Object: obj,
	}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	return wrapFileInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFileInfo creates a new file info structure.
//
// The function returns the following values:
//
//   - fileInfo: Info.
func NewFileInfo() *FileInfo {
	var _cret *C.GFileInfo // in

	_cret = C.g_file_info_new()

	var _fileInfo *FileInfo // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileInfo
}

// ClearStatus clears the status information from info.
func (info *FileInfo) ClearStatus() {
	var _arg0 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	C.g_file_info_clear_status(_arg0)
	runtime.KeepAlive(info)
}

// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute]
// of dest_info, and then copies all of the file attributes from src_info to
// dest_info.
//
// The function takes the following parameters:
//
//   - destInfo: destination to copy attributes to.
func (srcInfo *FileInfo) CopyInto(destInfo *FileInfo) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(srcInfo).Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(destInfo).Native()))

	C.g_file_info_copy_into(_arg0, _arg1)
	runtime.KeepAlive(srcInfo)
	runtime.KeepAlive(destInfo)
}

// Dup duplicates a file info structure.
//
// The function returns the following values:
//
//   - fileInfo: duplicate Info of other.
func (other *FileInfo) Dup() *FileInfo {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GFileInfo // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(other).Native()))

	_cret = C.g_file_info_dup(_arg0)
	runtime.KeepAlive(other)

	var _fileInfo *FileInfo // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileInfo
}

// AccessDateTime gets the access time of the current info and returns it as a
// Time.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_TIME_ACCESS. If G_FILE_ATTRIBUTE_TIME_ACCESS_USEC is
// provided, the resulting Time will additionally have microsecond precision.
//
// If nanosecond precision is needed, G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC must be
// queried separately using g_file_info_get_attribute_uint32().
//
// The function returns the following values:
//
//   - dateTime (optional) access time, or NULL if unknown.
func (info *FileInfo) AccessDateTime() *glib.DateTime {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_access_date_time(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AttributeAsString gets the value of an attribute, formatted as a string.
// This escapes things as needed to make the string valid UTF-8.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - utf8 (optional): UTF-8 string associated with the given attribute,
//     or NULL if the attribute wasnt set. When you're done with the string it
//     must be freed with g_free().
func (info *FileInfo) AttributeAsString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_as_string(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// AttributeBoolean gets the value of a boolean attribute. If the attribute does
// not contain a boolean value, FALSE will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - ok: boolean value contained within the attribute.
func (info *FileInfo) AttributeBoolean(attribute string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_boolean(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AttributeByteString gets the value of a byte string attribute. If the
// attribute does not contain a byte string, NULL will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - utf8 (optional) contents of the attribute value as a byte string,
//     or NULL otherwise.
func (info *FileInfo) AttributeByteString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_byte_string(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// AttributeData gets the attribute type, value and status for an attribute key.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - typ (optional): return location for the attribute type, or NULL.
//   - valuePp (optional): return location for the attribute value, or NULL;
//     the attribute value will not be NULL.
//   - status (optional): return location for the attribute status, or NULL.
//   - ok: TRUE if info has an attribute named attribute, FALSE otherwise.
func (info *FileInfo) AttributeData(attribute string) (FileAttributeType, unsafe.Pointer, FileAttributeStatus, bool) {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _arg2 C.GFileAttributeType   // in
	var _arg3 C.gpointer             // in
	var _arg4 C.GFileAttributeStatus // in
	var _cret C.gboolean             // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_data(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _typ FileAttributeType      // out
	var _valuePp unsafe.Pointer     // out
	var _status FileAttributeStatus // out
	var _ok bool                    // out

	_typ = FileAttributeType(_arg2)
	_valuePp = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	_status = FileAttributeStatus(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _typ, _valuePp, _status, _ok
}

// AttributeFilePath gets the value of a byte string attribute as a file path.
//
// If the attribute does not contain a byte string, NULL will be returned.
//
// This function is meant to be used by language bindings that have specific
// handling for Unix paths.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - filename (optional) contents of the attribute value as a file path,
//     or NULL otherwise.
func (info *FileInfo) AttributeFilePath(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_file_path(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// AttributeInt32 gets a signed 32-bit integer contained within the attribute.
// If the attribute does not contain a signed 32-bit integer, or is invalid,
// 0 will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - gint32: signed 32-bit integer from the attribute.
func (info *FileInfo) AttributeInt32(attribute string) int32 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gint32     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_int32(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// AttributeInt64 gets a signed 64-bit integer contained within the attribute.
// If the attribute does not contain a signed 64-bit integer, or is invalid,
// 0 will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - gint64: signed 64-bit integer from the attribute.
func (info *FileInfo) AttributeInt64(attribute string) int64 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gint64     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_int64(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// AttributeObject gets the value of a #GObject attribute. If the attribute does
// not contain a #GObject, NULL will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - object (optional) associated with the given attribute, or NULL otherwise.
func (info *FileInfo) AttributeObject(attribute string) *coreglib.Object {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_object(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.Take(unsafe.Pointer(_cret))
	}

	return _object
}

// AttributeStatus gets the attribute status for an attribute key.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - fileAttributeStatus for the given attribute, or
//     G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.
func (info *FileInfo) AttributeStatus(attribute string) FileAttributeStatus {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _cret C.GFileAttributeStatus // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_status(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _fileAttributeStatus FileAttributeStatus // out

	_fileAttributeStatus = FileAttributeStatus(_cret)

	return _fileAttributeStatus
}

// AttributeString gets the value of a string attribute. If the attribute does
// not contain a string, NULL will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - utf8 (optional) contents of the attribute value as a UTF-8 string,
//     or NULL otherwise.
func (info *FileInfo) AttributeString(attribute string) string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_string(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// AttributeStringv gets the value of a stringv attribute. If the attribute does
// not contain a stringv, NULL will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - utf8s (optional) contents of the attribute value as a stringv, or NULL
//     otherwise. Do not free. These returned strings are UTF-8.
func (info *FileInfo) AttributeStringv(attribute string) []string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret **C.char     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_stringv(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8s []string // out

	if _cret != nil {
		{
			var i int
			var z *C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// AttributeType gets the attribute type for an attribute key.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - fileAttributeType for the given attribute, or
//     G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.
func (info *FileInfo) AttributeType(attribute string) FileAttributeType {
	var _arg0 *C.GFileInfo         // out
	var _arg1 *C.char              // out
	var _cret C.GFileAttributeType // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_type(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _fileAttributeType FileAttributeType // out

	_fileAttributeType = FileAttributeType(_cret)

	return _fileAttributeType
}

// AttributeUint32 gets an unsigned 32-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 32-bit integer,
// or is invalid, 0 will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - guint32: unsigned 32-bit integer from the attribute.
func (info *FileInfo) AttributeUint32(attribute string) uint32 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.guint32    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_uint32(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// AttributeUint64 gets a unsigned 64-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 64-bit integer,
// or is invalid, 0 will be returned.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - guint64: unsigned 64-bit integer from the attribute.
func (info *FileInfo) AttributeUint64(attribute string) uint64 {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.guint64    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_uint64(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ContentType gets the file's content type.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the file's content type, or NULL if
//     unknown.
func (info *FileInfo) ContentType() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_content_type(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CreationDateTime gets the creation time of the current info and returns it as
// a Time.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_TIME_CREATED. If G_FILE_ATTRIBUTE_TIME_CREATED_USEC is
// provided, the resulting Time will additionally have microsecond precision.
//
// If nanosecond precision is needed, G_FILE_ATTRIBUTE_TIME_CREATED_NSEC must be
// queried separately using g_file_info_get_attribute_uint32().
//
// The function returns the following values:
//
//   - dateTime (optional): creation time, or NULL if unknown.
func (info *FileInfo) CreationDateTime() *glib.DateTime {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_creation_date_time(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// DeletionDate returns the Time representing the deletion date of the
// file, as available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
// G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, NULL is returned.
//
// The function returns the following values:
//
//   - dateTime (optional) or NULL.
func (info *FileInfo) DeletionDate() *glib.DateTime {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_deletion_date(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// DisplayName gets a display name for a file. This is guaranteed to always be
// set.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
//
// The function returns the following values:
//
//   - utf8: string containing the display name.
func (info *FileInfo) DisplayName() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_display_name(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EditName gets the edit name for a file.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
//
// The function returns the following values:
//
//   - utf8: string containing the edit name.
func (info *FileInfo) EditName() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_edit_name(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ETag gets the entity tag (iface.File.html#entity-tags) for a given Info.
// See G_FILE_ATTRIBUTE_ETAG_VALUE.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_ETAG_VALUE.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the value of the "etag:value"
//     attribute.
func (info *FileInfo) ETag() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_etag(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// FileType gets a file's type (whether it is a regular file,
// symlink, etc). This is different from the file's content type, see
// g_file_info_get_content_type().
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_TYPE.
//
// The function returns the following values:
//
//   - fileType for the given file.
func (info *FileInfo) FileType() FileType {
	var _arg0 *C.GFileInfo // out
	var _cret C.GFileType  // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_file_type(_arg0)
	runtime.KeepAlive(info)

	var _fileType FileType // out

	_fileType = FileType(_cret)

	return _fileType
}

// Icon gets the icon for a file.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_ICON.
//
// The function returns the following values:
//
//   - icon (optional) for the given info.
func (info *FileInfo) Icon() *Icon {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GIcon     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_icon(_arg0)
	runtime.KeepAlive(info)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// IsBackup checks if a file is a backup file.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
//
// The function returns the following values:
//
//   - ok: TRUE if file is a backup file, FALSE otherwise.
func (info *FileInfo) IsBackup() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_is_backup(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsHidden checks if a file is hidden.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
//
// The function returns the following values:
//
//   - ok: TRUE if the file is a hidden file, FALSE otherwise.
func (info *FileInfo) IsHidden() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_is_hidden(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSymlink checks if a file is a symlink.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
//
// The function returns the following values:
//
//   - ok: TRUE if the given info is a symlink.
func (info *FileInfo) IsSymlink() bool {
	var _arg0 *C.GFileInfo // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_is_symlink(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModificationDateTime gets the modification time of the current info and
// returns it as a Time.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_TIME_MODIFIED. If G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
// provided, the resulting Time will additionally have microsecond precision.
//
// If nanosecond precision is needed, G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC must
// be queried separately using g_file_info_get_attribute_uint32().
//
// The function returns the following values:
//
//   - dateTime (optional): modification time, or NULL if unknown.
func (info *FileInfo) ModificationDateTime() *glib.DateTime {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_modification_date_time(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// ModificationTime gets the modification time of the current info and sets it
// in result.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_TIME_MODIFIED. If G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
// provided it will be used too.
//
// Deprecated: Use g_file_info_get_modification_date_time() instead, as Val is
// deprecated due to the year 2038 problem.
//
// The function returns the following values:
//
//   - result: Val.
func (info *FileInfo) ModificationTime() *glib.TimeVal {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.GTimeVal   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	C.g_file_info_get_modification_time(_arg0, &_arg1)
	runtime.KeepAlive(info)

	var _result *glib.TimeVal // out

	_result = (*glib.TimeVal)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _result
}

// Name gets the name for a file. This is guaranteed to always be set.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_NAME.
//
// The function returns the following values:
//
//   - filename: string containing the file name.
func (info *FileInfo) Name() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_name(_arg0)
	runtime.KeepAlive(info)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Size gets the file's size (in bytes). The size is retrieved through the
// value of the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted from
// #guint64 to #goffset before returning the result.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_SIZE.
//
// The function returns the following values:
//
//   - gint64 containing the file's size (in bytes).
func (info *FileInfo) Size() int64 {
	var _arg0 *C.GFileInfo // out
	var _cret C.goffset    // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_size(_arg0)
	runtime.KeepAlive(info)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// SortOrder gets the value of the sort_order attribute from the Info.
// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
//
// The function returns the following values:
//
//   - gint32 containing the value of the "standard::sort_order" attribute.
func (info *FileInfo) SortOrder() int32 {
	var _arg0 *C.GFileInfo // out
	var _cret C.gint32     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_sort_order(_arg0)
	runtime.KeepAlive(info)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// SymbolicIcon gets the symbolic icon for a file.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
//
// The function returns the following values:
//
//   - icon (optional) for the given info.
func (info *FileInfo) SymbolicIcon() *Icon {
	var _arg0 *C.GFileInfo // out
	var _cret *C.GIcon     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_symbolic_icon(_arg0)
	runtime.KeepAlive(info)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// SymlinkTarget gets the symlink target for a given Info.
//
// It is an error to call this if the Info does not contain
// G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
//
// The function returns the following values:
//
//   - filename (optional): string containing the symlink target.
func (info *FileInfo) SymlinkTarget() string {
	var _arg0 *C.GFileInfo // out
	var _cret *C.char      // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.g_file_info_get_symlink_target(_arg0)
	runtime.KeepAlive(info)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// HasAttribute checks if a file info structure has an attribute named
// attribute.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - ok: TRUE if info has an attribute named attribute, FALSE otherwise.
func (info *FileInfo) HasAttribute(attribute string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_has_attribute(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasNamespace checks if a file info structure has an attribute in the
// specified name_space.
//
// The function takes the following parameters:
//
//   - nameSpace: file attribute namespace.
//
// The function returns the following values:
//
//   - ok: TRUE if info has an attribute in name_space, FALSE otherwise.
func (info *FileInfo) HasNamespace(nameSpace string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_has_namespace(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListAttributes lists the file info structure's attributes.
//
// The function takes the following parameters:
//
//   - nameSpace (optional): file attribute key's namespace, or NULL to list all
//     attributes.
//
// The function returns the following values:
//
//   - utf8s (optional): a null-terminated array of strings of all of the
//     possible attribute types for the given name_space, or NULL on error.
func (info *FileInfo) ListAttributes(nameSpace string) []string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret **C.char     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	if nameSpace != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_file_info_list_attributes(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// RemoveAttribute removes all cases of attribute from info if it exists.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
func (info *FileInfo) RemoveAttribute(attribute string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_remove_attribute(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
}

// SetAccessDateTime sets the G_FILE_ATTRIBUTE_TIME_ACCESS and
// G_FILE_ATTRIBUTE_TIME_ACCESS_USEC attributes in the file info to the given
// date/time value.
//
// G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC will be cleared.
//
// The function takes the following parameters:
//
//   - atime: Time.
func (info *FileInfo) SetAccessDateTime(atime *glib.DateTime) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GDateTime // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(atime)))

	C.g_file_info_set_access_date_time(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(atime)
}

// SetAttribute sets the attribute to contain the given value, if possible.
// To unset the attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for type.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - typ: AttributeType.
//   - valueP: pointer to the value.
func (info *FileInfo) SetAttribute(attribute string, typ FileAttributeType, valueP unsafe.Pointer) {
	var _arg0 *C.GFileInfo         // out
	var _arg1 *C.char              // out
	var _arg2 C.GFileAttributeType // out
	var _arg3 C.gpointer           // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeType(typ)
	_arg3 = (C.gpointer)(unsafe.Pointer(valueP))

	C.g_file_info_set_attribute(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(valueP)
}

// SetAttributeBoolean sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: boolean value.
func (info *FileInfo) SetAttributeBoolean(attribute string, attrValue bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	if attrValue {
		_arg2 = C.TRUE
	}

	C.g_file_info_set_attribute_boolean(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeByteString sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: byte string.
func (info *FileInfo) SetAttributeByteString(attribute, attrValue string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_info_set_attribute_byte_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeFilePath sets the attribute to contain the given attr_value,
// if possible.
//
// This function is meant to be used by language bindings that have specific
// handling for Unix paths.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: file path.
func (info *FileInfo) SetAttributeFilePath(attribute, attrValue string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_info_set_attribute_file_path(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt32 sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: signed 32-bit integer.
func (info *FileInfo) SetAttributeInt32(attribute string, attrValue int32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gint32     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint32(attrValue)

	C.g_file_info_set_attribute_int32(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt64 sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute name to set.
//   - attrValue: int64 value to set attribute to.
func (info *FileInfo) SetAttributeInt64(attribute string, attrValue int64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.gint64     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint64(attrValue)

	C.g_file_info_set_attribute_int64(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeMask sets mask on info to match specific attribute types.
//
// The function takes the following parameters:
//
//   - mask: AttributeMatcher.
func (info *FileInfo) SetAttributeMask(mask *FileAttributeMatcher) {
	var _arg0 *C.GFileInfo             // out
	var _arg1 *C.GFileAttributeMatcher // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(mask)))

	C.g_file_info_set_attribute_mask(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mask)
}

// SetAttributeObject sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: #GObject.
func (info *FileInfo) SetAttributeObject(attribute string, attrValue *coreglib.Object) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.GObject   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(attrValue.Native()))

	C.g_file_info_set_attribute_object(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStatus sets the attribute status for an attribute key. This is
// only needed by external code that implement g_file_set_attributes_from_info()
// or similar functions.
//
// The attribute must exist in info for this to work. Otherwise FALSE is
// returned and info is unchanged.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - status: AttributeStatus.
//
// The function returns the following values:
//
//   - ok: TRUE if the status was changed, FALSE if the key was not set.
func (info *FileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _arg2 C.GFileAttributeStatus // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeStatus(status)

	_cret = C.g_file_info_set_attribute_status(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(status)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributeString sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: UTF-8 string.
func (info *FileInfo) SetAttributeString(attribute, attrValue string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_info_set_attribute_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStringv sets the attribute to contain the given attr_value,
// if possible.
//
// Sinze: 2.22.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: NULL terminated array of UTF-8 strings.
func (info *FileInfo) SetAttributeStringv(attribute string, attrValue []string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 **C.char     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(attrValue) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(attrValue)+1)
			var zero *C.char
			out[len(attrValue)] = zero
			for i := range attrValue {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(attrValue[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.g_file_info_set_attribute_stringv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint32 sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: unsigned 32-bit integer.
func (info *FileInfo) SetAttributeUint32(attribute string, attrValue uint32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.guint32    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint32(attrValue)

	C.g_file_info_set_attribute_uint32(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint64 sets the attribute to contain the given attr_value,
// if possible.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//   - attrValue: unsigned 64-bit integer.
func (info *FileInfo) SetAttributeUint64(attribute string, attrValue uint64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _arg2 C.guint64    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint64(attrValue)

	C.g_file_info_set_attribute_uint64(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetContentType sets the content type attribute for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
//
// The function takes the following parameters:
//
//   - contentType: content type. See [GContentType][gio-GContentType].
func (info *FileInfo) SetContentType(contentType string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_content_type(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(contentType)
}

// SetCreationDateTime sets the G_FILE_ATTRIBUTE_TIME_CREATED and
// G_FILE_ATTRIBUTE_TIME_CREATED_USEC attributes in the file info to the given
// date/time value.
//
// G_FILE_ATTRIBUTE_TIME_CREATED_NSEC will be cleared.
//
// The function takes the following parameters:
//
//   - creationTime: Time.
func (info *FileInfo) SetCreationDateTime(creationTime *glib.DateTime) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GDateTime // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(creationTime)))

	C.g_file_info_set_creation_date_time(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(creationTime)
}

// SetDisplayName sets the display name for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
//
// The function takes the following parameters:
//
//   - displayName: string containing a display name.
func (info *FileInfo) SetDisplayName(displayName string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_display_name(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(displayName)
}

// SetEditName sets the edit name for the current file. See
// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
//
// The function takes the following parameters:
//
//   - editName: string containing an edit name.
func (info *FileInfo) SetEditName(editName string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(editName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_edit_name(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(editName)
}

// SetFileType sets the file type in a Info to type. See
// G_FILE_ATTRIBUTE_STANDARD_TYPE.
//
// The function takes the following parameters:
//
//   - typ: Type.
func (info *FileInfo) SetFileType(typ FileType) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.GFileType  // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = C.GFileType(typ)

	C.g_file_info_set_file_type(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(typ)
}

// SetIcon sets the icon for a given Info. See G_FILE_ATTRIBUTE_STANDARD_ICON.
//
// The function takes the following parameters:
//
//   - icon: #GIcon.
func (info *FileInfo) SetIcon(icon Iconner) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.g_file_info_set_icon(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetIsHidden sets the "is_hidden" attribute in a Info according to is_hidden.
// See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
//
// The function takes the following parameters:
//
//   - isHidden: #gboolean.
func (info *FileInfo) SetIsHidden(isHidden bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	if isHidden {
		_arg1 = C.TRUE
	}

	C.g_file_info_set_is_hidden(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isHidden)
}

// SetIsSymlink sets the "is_symlink" attribute in a Info according to
// is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
//
// The function takes the following parameters:
//
//   - isSymlink: #gboolean.
func (info *FileInfo) SetIsSymlink(isSymlink bool) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	if isSymlink {
		_arg1 = C.TRUE
	}

	C.g_file_info_set_is_symlink(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isSymlink)
}

// SetModificationDateTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the given
// date/time value.
//
// G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
//
// The function takes the following parameters:
//
//   - mtime: Time.
func (info *FileInfo) SetModificationDateTime(mtime *glib.DateTime) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GDateTime // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(mtime)))

	C.g_file_info_set_modification_date_time(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mtime)
}

// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the given
// time value.
//
// G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
//
// Deprecated: Use g_file_info_set_modification_date_time() instead, as Val is
// deprecated due to the year 2038 problem.
//
// The function takes the following parameters:
//
//   - mtime: Val.
func (info *FileInfo) SetModificationTime(mtime *glib.TimeVal) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GTimeVal  // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(mtime)))

	C.g_file_info_set_modification_time(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mtime)
}

// SetName sets the name attribute for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_NAME.
//
// The function takes the following parameters:
//
//   - name: string containing a name.
func (info *FileInfo) SetName(name string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_name(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
}

// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info to
// the given size.
//
// The function takes the following parameters:
//
//   - size containing the file's size.
func (info *FileInfo) SetSize(size int64) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.goffset    // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = C.goffset(size)

	C.g_file_info_set_size(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(size)
}

// SetSortOrder sets the sort order attribute in the file info structure.
// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
//
// The function takes the following parameters:
//
//   - sortOrder: sort order integer.
func (info *FileInfo) SetSortOrder(sortOrder int32) {
	var _arg0 *C.GFileInfo // out
	var _arg1 C.gint32     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = C.gint32(sortOrder)

	C.g_file_info_set_sort_order(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(sortOrder)
}

// SetSymbolicIcon sets the symbolic icon for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
//
// The function takes the following parameters:
//
//   - icon: #GIcon.
func (info *FileInfo) SetSymbolicIcon(icon Iconner) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.g_file_info_set_symbolic_icon(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute
// in the file info to the given symlink target.
//
// The function takes the following parameters:
//
//   - symlinkTarget: static string containing a path to a symlink target.
func (info *FileInfo) SetSymlinkTarget(symlinkTarget string) {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkTarget)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_info_set_symlink_target(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(symlinkTarget)
}

// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(),
// if one is set.
func (info *FileInfo) UnsetAttributeMask() {
	var _arg0 *C.GFileInfo // out

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	C.g_file_info_unset_attribute_mask(_arg0)
	runtime.KeepAlive(info)
}

// FileInputStreamOverrides contains methods that are overridable.
type FileInputStreamOverrides struct {
	CanSeek func() bool
	// QueryInfo queries a file input stream the given attributes. This function
	// blocks while querying the stream. For the asynchronous (non-blocking)
	// version of this function, see g_file_input_stream_query_info_async().
	// While the stream is blocked, the stream will set the pending flag
	// internally, and any other operations on the stream will fail with
	// G_IO_ERROR_PENDING.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//   - attributes: file attribute query string.
	//
	// The function returns the following values:
	//
	//   - fileInfo or NULL on error.
	QueryInfo func(ctx context.Context, attributes string) (*FileInfo, error)
	// QueryInfoFinish finishes an asynchronous info query operation.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - fileInfo: Info.
	QueryInfoFinish func(result AsyncResulter) (*FileInfo, error)
	// The function takes the following parameters:
	//
	//   - ctx (optional)
	//   - offset
	//   - typ
	Seek func(ctx context.Context, offset int64, typ glib.SeekType) error
	Tell func() int64
}

func defaultFileInputStreamOverrides(v *FileInputStream) FileInputStreamOverrides {
	return FileInputStreamOverrides{
		CanSeek:         v.canSeek,
		QueryInfo:       v.queryInfo,
		QueryInfoFinish: v.queryInfoFinish,
		Seek:            v.seek,
		Tell:            v.tell,
	}
}

// FileInputStream: GFileInputStream provides input streams that take their
// content from a file.
//
// GFileInputStream implements gio.Seekable, which allows the input stream
// to jump to arbitrary positions in the file, provided the filesystem
// of the file allows it. To find the position of a file input stream,
// use gio.Seekable.Tell(). To find out if a file input stream supports
// seeking, use gio.Seekable.CanSeek(). To position a file input stream,
// use gio.Seekable.Seek().
type FileInputStream struct {
	_ [0]func() // equal guard
	InputStream

	*coreglib.Object
	Seekable
}

var (
	_ InputStreamer     = (*FileInputStream)(nil)
	_ coreglib.Objector = (*FileInputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileInputStream, *FileInputStreamClass, FileInputStreamOverrides](
		GTypeFileInputStream,
		initFileInputStreamClass,
		wrapFileInputStream,
		defaultFileInputStreamOverrides,
	)
}

func initFileInputStreamClass(gclass unsafe.Pointer, overrides FileInputStreamOverrides, classInitFunc func(*FileInputStreamClass)) {
	pclass := (*C.GFileInputStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFileInputStream))))

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._gotk4_gio2_FileInputStreamClass_can_seek)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._gotk4_gio2_FileInputStreamClass_query_info)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._gotk4_gio2_FileInputStreamClass_query_info_finish)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._gotk4_gio2_FileInputStreamClass_seek)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._gotk4_gio2_FileInputStreamClass_tell)
	}

	if classInitFunc != nil {
		class := (*FileInputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileInputStream(obj *coreglib.Object) *FileInputStream {
	return &FileInputStream{
		InputStream: InputStream{
			Object: obj,
		},
		Object: obj,
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalFileInputStream(p uintptr) (interface{}, error) {
	return wrapFileInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// QueryInfo queries a file input stream the given attributes. This function
// blocks while querying the stream. For the asynchronous (non-blocking)
// version of this function, see g_file_input_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag internally,
// and any other operations on the stream will fail with G_IO_ERROR_PENDING.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//
// The function returns the following values:
//
//   - fileInfo or NULL on error.
func (stream *FileInputStream) QueryInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	var _arg0 *C.GFileInputStream // out
	var _arg2 *C.GCancellable     // out
	var _arg1 *C.char             // out
	var _cret *C.GFileInfo        // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_input_stream_query_info(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// QueryInfoAsync queries the stream information asynchronously. When
// the operation is finished callback will be called. You can then call
// g_file_input_stream_query_info_finish() to get the result of the operation.
//
// For the synchronous version of this function, see
// g_file_input_stream_query_info().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *FileInputStream) QueryInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFileInputStream   // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_input_stream_query_info_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish finishes an asynchronous info query operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - fileInfo: Info.
func (stream *FileInputStream) QueryInfoFinish(result AsyncResulter) (*FileInfo, error) {
	var _arg0 *C.GFileInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GFileInfo        // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_input_stream_query_info_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

func (stream *FileInputStream) canSeek() bool {
	gclass := (*C.GFileInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.can_seek

	var _arg0 *C.GFileInputStream // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileInputStream_virtual_can_seek(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// queryInfo queries a file input stream the given attributes. This function
// blocks while querying the stream. For the asynchronous (non-blocking)
// version of this function, see g_file_input_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag internally,
// and any other operations on the stream will fail with G_IO_ERROR_PENDING.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//
// The function returns the following values:
//
//   - fileInfo or NULL on error.
func (stream *FileInputStream) queryInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	gclass := (*C.GFileInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info

	var _arg0 *C.GFileInputStream // out
	var _arg2 *C.GCancellable     // out
	var _arg1 *C.char             // out
	var _cret *C.GFileInfo        // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_FileInputStream_virtual_query_info(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// queryInfoAsync queries the stream information asynchronously. When
// the operation is finished callback will be called. You can then call
// g_file_input_stream_query_info_finish() to get the result of the operation.
//
// For the synchronous version of this function, see
// g_file_input_stream_query_info().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *FileInputStream) queryInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info_async

	var _arg0 *C.GFileInputStream   // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_FileInputStream_virtual_query_info_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// queryInfoFinish finishes an asynchronous info query operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - fileInfo: Info.
func (stream *FileInputStream) queryInfoFinish(result AsyncResulter) (*FileInfo, error) {
	gclass := (*C.GFileInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info_finish

	var _arg0 *C.GFileInputStream // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GFileInfo        // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_FileInputStream_virtual_query_info_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// The function takes the following parameters:
//
//   - ctx (optional)
//   - offset
//   - typ
func (stream *FileInputStream) seek(ctx context.Context, offset int64, typ glib.SeekType) error {
	gclass := (*C.GFileInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.seek

	var _arg0 *C.GFileInputStream // out
	var _arg3 *C.GCancellable     // out
	var _arg1 C.goffset           // out
	var _arg2 C.GSeekType         // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(offset)
	_arg2 = C.GSeekType(typ)

	C._gotk4_gio2_FileInputStream_virtual_seek(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (stream *FileInputStream) tell() int64 {
	gclass := (*C.GFileInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.tell

	var _arg0 *C.GFileInputStream // out
	var _cret C.goffset           // in

	_arg0 = (*C.GFileInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileInputStream_virtual_tell(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// FileMonitorOverrides contains methods that are overridable.
type FileMonitorOverrides struct {
	// Cancel cancels a file monitor.
	//
	// The function returns the following values:
	//
	//   - ok always TRUE.
	Cancel func() bool
	// The function takes the following parameters:
	//
	//   - file
	//   - otherFile
	//   - eventType
	Changed func(file, otherFile Filer, eventType FileMonitorEvent)
}

func defaultFileMonitorOverrides(v *FileMonitor) FileMonitorOverrides {
	return FileMonitorOverrides{
		Cancel:  v.cancel,
		Changed: v.changed,
	}
}

// FileMonitor monitors a file or directory for changes.
//
// To obtain a GFileMonitor for a file or directory, use gio.File.Monitor(),
// gio.File.MonitorFile(), or gio.File.MonitorDirectory().
//
// To get informed about changes to the file or directory you are monitoring,
// connect to the gio.FileMonitor::changed signal. The signal will be emitted in
// the thread-default main context (see glib.MainContext.PushThreadDefault()) of
// the thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
type FileMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FileMonitor)(nil)
)

// FileMonitorrer describes types inherited from class FileMonitor.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FileMonitorrer interface {
	coreglib.Objector
	baseFileMonitor() *FileMonitor
}

var _ FileMonitorrer = (*FileMonitor)(nil)

func init() {
	coreglib.RegisterClassInfo[*FileMonitor, *FileMonitorClass, FileMonitorOverrides](
		GTypeFileMonitor,
		initFileMonitorClass,
		wrapFileMonitor,
		defaultFileMonitorOverrides,
	)
}

func initFileMonitorClass(gclass unsafe.Pointer, overrides FileMonitorOverrides, classInitFunc func(*FileMonitorClass)) {
	pclass := (*C.GFileMonitorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFileMonitor))))

	if overrides.Cancel != nil {
		pclass.cancel = (*[0]byte)(C._gotk4_gio2_FileMonitorClass_cancel)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gio2_FileMonitorClass_changed)
	}

	if classInitFunc != nil {
		class := (*FileMonitorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileMonitor(obj *coreglib.Object) *FileMonitor {
	return &FileMonitor{
		Object: obj,
	}
}

func marshalFileMonitor(p uintptr) (interface{}, error) {
	return wrapFileMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (monitor *FileMonitor) baseFileMonitor() *FileMonitor {
	return monitor
}

// BaseFileMonitor returns the underlying base object.
func BaseFileMonitor(obj FileMonitorrer) *FileMonitor {
	return obj.baseFileMonitor()
}

// ConnectChanged is emitted when file has been changed.
//
// If using G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and the
// information is available (and if supported by the backend), event_type
// may be G_FILE_MONITOR_EVENT_RENAMED, G_FILE_MONITOR_EVENT_MOVED_IN or
// G_FILE_MONITOR_EVENT_MOVED_OUT.
//
// In all cases file will be a child of the monitored directory. For renames,
// file will be the old name and other_file is the new name. For "moved in"
// events, file is the name of the file that appeared and other_file is the old
// name that it was moved from (in another directory). For "moved out" events,
// file is the name of the file that used to be in this directory and other_file
// is the name of the file at its new location.
//
// It makes sense to treat G_FILE_MONITOR_EVENT_MOVED_IN as equivalent
// to G_FILE_MONITOR_EVENT_CREATED and G_FILE_MONITOR_EVENT_MOVED_OUT as
// equivalent to G_FILE_MONITOR_EVENT_DELETED, with extra information.
// G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create pair.
// This is exactly how the events will be reported in the case that the
// G_FILE_MONITOR_WATCH_MOVES flag is not in use.
//
// If using the deprecated flag G_FILE_MONITOR_SEND_MOVED flag and event_type is
// G_FILE_MONITOR_EVENT_MOVED, file will be set to a #GFile containing the old
// path, and other_file will be set to a #GFile containing the new path.
//
// In all the other cases, other_file will be set to LL.
func (monitor *FileMonitor) ConnectChanged(f func(file, otherFile Filer, eventType FileMonitorEvent)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(monitor, "changed", false, unsafe.Pointer(C._gotk4_gio2_FileMonitor_ConnectChanged), f)
}

// Cancel cancels a file monitor.
//
// The function returns the following values:
//
//   - ok always TRUE.
func (monitor *FileMonitor) Cancel() bool {
	var _arg0 *C.GFileMonitor // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_file_monitor_cancel(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EmitEvent emits the Monitor::changed signal if a change has taken place.
// Should be called from file monitor implementations only.
//
// Implementations are responsible to call this method from the [thread-default
// main context][g-main-context-push-thread-default] of the thread that the
// monitor was created in.
//
// The function takes the following parameters:
//
//   - child: #GFile.
//   - otherFile: #GFile.
//   - eventType: set of MonitorEvent flags.
func (monitor *FileMonitor) EmitEvent(child, otherFile Filer, eventType FileMonitorEvent) {
	var _arg0 *C.GFileMonitor     // out
	var _arg1 *C.GFile            // out
	var _arg2 *C.GFile            // out
	var _arg3 C.GFileMonitorEvent // out

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(otherFile).Native()))
	_arg3 = C.GFileMonitorEvent(eventType)

	C.g_file_monitor_emit_event(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(child)
	runtime.KeepAlive(otherFile)
	runtime.KeepAlive(eventType)
}

// IsCancelled returns whether the monitor is canceled.
//
// The function returns the following values:
//
//   - ok: TRUE if monitor is canceled. FALSE otherwise.
func (monitor *FileMonitor) IsCancelled() bool {
	var _arg0 *C.GFileMonitor // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_file_monitor_is_cancelled(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetRateLimit sets the rate limit to which the monitor will report consecutive
// change events to the same file.
//
// The function takes the following parameters:
//
//   - limitMsecs: non-negative integer with the limit in milliseconds to poll
//     for changes.
func (monitor *FileMonitor) SetRateLimit(limitMsecs int) {
	var _arg0 *C.GFileMonitor // out
	var _arg1 C.gint          // out

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = C.gint(limitMsecs)

	C.g_file_monitor_set_rate_limit(_arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(limitMsecs)
}

// Cancel cancels a file monitor.
//
// The function returns the following values:
//
//   - ok always TRUE.
func (monitor *FileMonitor) cancel() bool {
	gclass := (*C.GFileMonitorClass)(coreglib.PeekParentClass(monitor))
	fnarg := gclass.cancel

	var _arg0 *C.GFileMonitor // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C._gotk4_gio2_FileMonitor_virtual_cancel(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - file
//   - otherFile
//   - eventType
func (monitor *FileMonitor) changed(file, otherFile Filer, eventType FileMonitorEvent) {
	gclass := (*C.GFileMonitorClass)(coreglib.PeekParentClass(monitor))
	fnarg := gclass.changed

	var _arg0 *C.GFileMonitor     // out
	var _arg1 *C.GFile            // out
	var _arg2 *C.GFile            // out
	var _arg3 C.GFileMonitorEvent // out

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg2 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(otherFile).Native()))
	_arg3 = C.GFileMonitorEvent(eventType)

	C._gotk4_gio2_FileMonitor_virtual_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(file)
	runtime.KeepAlive(otherFile)
	runtime.KeepAlive(eventType)
}

// FileOutputStreamOverrides contains methods that are overridable.
type FileOutputStreamOverrides struct {
	CanSeek     func() bool
	CanTruncate func() bool
	// ETag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	//
	// The function returns the following values:
	//
	//   - utf8 (optional): entity tag for the stream.
	ETag func() string
	// QueryInfo queries a file output stream for the given attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_output_stream_query_info_async(). While
	// the stream is blocked, the stream will set the pending flag internally,
	// and any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with error being set to G_IO_ERROR_NOT_SUPPORTED).
	// In all cases of failure, NULL will be returned.
	//
	// If cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and NULL will
	// be returned.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//   - attributes: file attribute query string.
	//
	// The function returns the following values:
	//
	//   - fileInfo for the stream, or NULL on error.
	QueryInfo func(ctx context.Context, attributes string) (*FileInfo, error)
	// QueryInfoFinish finalizes the asynchronous query started by
	// g_file_output_stream_query_info_async().
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - fileInfo for the finished query.
	QueryInfoFinish func(result AsyncResulter) (*FileInfo, error)
	// The function takes the following parameters:
	//
	//   - ctx (optional)
	//   - offset
	//   - typ
	Seek func(ctx context.Context, offset int64, typ glib.SeekType) error
	Tell func() int64
	// The function takes the following parameters:
	//
	//   - ctx (optional)
	//   - size
	TruncateFn func(ctx context.Context, size int64) error
}

func defaultFileOutputStreamOverrides(v *FileOutputStream) FileOutputStreamOverrides {
	return FileOutputStreamOverrides{
		CanSeek:         v.canSeek,
		CanTruncate:     v.canTruncate,
		ETag:            v.eTag,
		QueryInfo:       v.queryInfo,
		QueryInfoFinish: v.queryInfoFinish,
		Seek:            v.seek,
		Tell:            v.tell,
		TruncateFn:      v.truncateFn,
	}
}

// FileOutputStream: GFileOutputStream provides output streams that write their
// content to a file.
//
// GFileOutputStream implements gio.Seekable, which allows the output stream to
// jump to arbitrary positions in the file and to truncate the file, provided
// the filesystem of the file supports these operations.
//
// To find the position of a file output stream, use gio.Seekable.Tell().
// To find out if a file output stream supports seeking,
// use gio.Seekable.CanSeek().To position a file output stream, use
// gio.Seekable.Seek(). To find out if a file output stream supports truncating,
// use gio.Seekable.CanTruncate(). To truncate a file output stream, use
// gio.Seekable.Truncate().
type FileOutputStream struct {
	_ [0]func() // equal guard
	OutputStream

	*coreglib.Object
	Seekable
}

var (
	_ OutputStreamer    = (*FileOutputStream)(nil)
	_ coreglib.Objector = (*FileOutputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileOutputStream, *FileOutputStreamClass, FileOutputStreamOverrides](
		GTypeFileOutputStream,
		initFileOutputStreamClass,
		wrapFileOutputStream,
		defaultFileOutputStreamOverrides,
	)
}

func initFileOutputStreamClass(gclass unsafe.Pointer, overrides FileOutputStreamOverrides, classInitFunc func(*FileOutputStreamClass)) {
	pclass := (*C.GFileOutputStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFileOutputStream))))

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_can_seek)
	}

	if overrides.CanTruncate != nil {
		pclass.can_truncate = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_can_truncate)
	}

	if overrides.ETag != nil {
		pclass.get_etag = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_get_etag)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_query_info)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_query_info_finish)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_seek)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_tell)
	}

	if overrides.TruncateFn != nil {
		pclass.truncate_fn = (*[0]byte)(C._gotk4_gio2_FileOutputStreamClass_truncate_fn)
	}

	if classInitFunc != nil {
		class := (*FileOutputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileOutputStream(obj *coreglib.Object) *FileOutputStream {
	return &FileOutputStream{
		OutputStream: OutputStream{
			Object: obj,
		},
		Object: obj,
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalFileOutputStream(p uintptr) (interface{}, error) {
	return wrapFileOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ETag gets the entity tag for the file when it has been written. This must be
// called after the stream has been written and closed, as the etag can change
// while writing.
//
// The function returns the following values:
//
//   - utf8 (optional): entity tag for the stream.
func (stream *FileOutputStream) ETag() string {
	var _arg0 *C.GFileOutputStream // out
	var _cret *C.char              // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_file_output_stream_get_etag(_arg0)
	runtime.KeepAlive(stream)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// QueryInfo queries a file output stream for the given attributes. This
// function blocks while querying the stream. For the asynchronous version of
// this function, see g_file_output_stream_query_info_async(). While the stream
// is blocked, the stream will set the pending flag internally, and any other
// operations on the stream will fail with G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with error being set
// to G_IO_ERROR_PENDING), or if querying info is not supported for the stream's
// interface (with error being set to G_IO_ERROR_NOT_SUPPORTED). In all cases of
// failure, NULL will be returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and NULL will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//
// The function returns the following values:
//
//   - fileInfo for the stream, or NULL on error.
func (stream *FileOutputStream) QueryInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	var _arg0 *C.GFileOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 *C.char              // out
	var _cret *C.GFileInfo         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_output_stream_query_info(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// QueryInfoAsync: asynchronously queries the stream for a Info. When completed,
// callback will be called with a Result which can be used to finish the
// operation with g_file_output_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_output_stream_query_info().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//   - ioPriority: I/O priority (iface.AsyncResult.html#io-priority) of the
//     request.
//   - callback (optional) to call when the request is satisfied.
func (stream *FileOutputStream) QueryInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFileOutputStream  // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_output_stream_query_info_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish finalizes the asynchronous query started by
// g_file_output_stream_query_info_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - fileInfo for the finished query.
func (stream *FileOutputStream) QueryInfoFinish(result AsyncResulter) (*FileInfo, error) {
	var _arg0 *C.GFileOutputStream // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileInfo         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_output_stream_query_info_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

func (stream *FileOutputStream) canSeek() bool {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.can_seek

	var _arg0 *C.GFileOutputStream // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileOutputStream_virtual_can_seek(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (stream *FileOutputStream) canTruncate() bool {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.can_truncate

	var _arg0 *C.GFileOutputStream // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileOutputStream_virtual_can_truncate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// eTag gets the entity tag for the file when it has been written. This must be
// called after the stream has been written and closed, as the etag can change
// while writing.
//
// The function returns the following values:
//
//   - utf8 (optional): entity tag for the stream.
func (stream *FileOutputStream) eTag() string {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.get_etag

	var _arg0 *C.GFileOutputStream // out
	var _cret *C.char              // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileOutputStream_virtual_get_etag(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// queryInfo queries a file output stream for the given attributes. This
// function blocks while querying the stream. For the asynchronous version of
// this function, see g_file_output_stream_query_info_async(). While the stream
// is blocked, the stream will set the pending flag internally, and any other
// operations on the stream will fail with G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with error being set
// to G_IO_ERROR_PENDING), or if querying info is not supported for the stream's
// interface (with error being set to G_IO_ERROR_NOT_SUPPORTED). In all cases of
// failure, NULL will be returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be set, and NULL will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//
// The function returns the following values:
//
//   - fileInfo for the stream, or NULL on error.
func (stream *FileOutputStream) queryInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info

	var _arg0 *C.GFileOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 *C.char              // out
	var _cret *C.GFileInfo         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_FileOutputStream_virtual_query_info(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// queryInfoAsync: asynchronously queries the stream for a Info. When completed,
// callback will be called with a Result which can be used to finish the
// operation with g_file_output_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_output_stream_query_info().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - attributes: file attribute query string.
//   - ioPriority: I/O priority (iface.AsyncResult.html#io-priority) of the
//     request.
//   - callback (optional) to call when the request is satisfied.
func (stream *FileOutputStream) queryInfoAsync(ctx context.Context, attributes string, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info_async

	var _arg0 *C.GFileOutputStream  // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_FileOutputStream_virtual_query_info_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// queryInfoFinish finalizes the asynchronous query started by
// g_file_output_stream_query_info_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - fileInfo for the finished query.
func (stream *FileOutputStream) queryInfoFinish(result AsyncResulter) (*FileInfo, error) {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.query_info_finish

	var _arg0 *C.GFileOutputStream // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GFileInfo         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_FileOutputStream_virtual_query_info_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileInfo, _goerr
}

// The function takes the following parameters:
//
//   - ctx (optional)
//   - offset
//   - typ
func (stream *FileOutputStream) seek(ctx context.Context, offset int64, typ glib.SeekType) error {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.seek

	var _arg0 *C.GFileOutputStream // out
	var _arg3 *C.GCancellable      // out
	var _arg1 C.goffset            // out
	var _arg2 C.GSeekType          // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(offset)
	_arg2 = C.GSeekType(typ)

	C._gotk4_gio2_FileOutputStream_virtual_seek(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (stream *FileOutputStream) tell() int64 {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.tell

	var _arg0 *C.GFileOutputStream // out
	var _cret C.goffset            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_FileOutputStream_virtual_tell(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// The function takes the following parameters:
//
//   - ctx (optional)
//   - size
func (stream *FileOutputStream) truncateFn(ctx context.Context, size int64) error {
	gclass := (*C.GFileOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.truncate_fn

	var _arg0 *C.GFileOutputStream // out
	var _arg2 *C.GCancellable      // out
	var _arg1 C.goffset            // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GFileOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.goffset(size)

	C._gotk4_gio2_FileOutputStream_virtual_truncate_fn(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FilenameCompleterOverrides contains methods that are overridable.
type FilenameCompleterOverrides struct {
	GotCompletionData func()
}

func defaultFilenameCompleterOverrides(v *FilenameCompleter) FilenameCompleterOverrides {
	return FilenameCompleterOverrides{
		GotCompletionData: v.gotCompletionData,
	}
}

// FilenameCompleter completes partial file and directory names given a partial
// string by looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
type FilenameCompleter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FilenameCompleter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FilenameCompleter, *FilenameCompleterClass, FilenameCompleterOverrides](
		GTypeFilenameCompleter,
		initFilenameCompleterClass,
		wrapFilenameCompleter,
		defaultFilenameCompleterOverrides,
	)
}

func initFilenameCompleterClass(gclass unsafe.Pointer, overrides FilenameCompleterOverrides, classInitFunc func(*FilenameCompleterClass)) {
	pclass := (*C.GFilenameCompleterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFilenameCompleter))))

	if overrides.GotCompletionData != nil {
		pclass.got_completion_data = (*[0]byte)(C._gotk4_gio2_FilenameCompleterClass_got_completion_data)
	}

	if classInitFunc != nil {
		class := (*FilenameCompleterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFilenameCompleter(obj *coreglib.Object) *FilenameCompleter {
	return &FilenameCompleter{
		Object: obj,
	}
}

func marshalFilenameCompleter(p uintptr) (interface{}, error) {
	return wrapFilenameCompleter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectGotCompletionData is emitted when the file name completion information
// comes available.
func (completer *FilenameCompleter) ConnectGotCompletionData(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completer, "got-completion-data", false, unsafe.Pointer(C._gotk4_gio2_FilenameCompleter_ConnectGotCompletionData), f)
}

// NewFilenameCompleter creates a new filename completer.
//
// The function returns the following values:
//
//   - filenameCompleter: Completer.
func NewFilenameCompleter() *FilenameCompleter {
	var _cret *C.GFilenameCompleter // in

	_cret = C.g_filename_completer_new()

	var _filenameCompleter *FilenameCompleter // out

	_filenameCompleter = wrapFilenameCompleter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _filenameCompleter
}

// CompletionSuffix obtains a completion for initial_text from completer.
//
// The function takes the following parameters:
//
//   - initialText: text to be completed.
//
// The function returns the following values:
//
//   - utf8 (optional): completed string, or NULL if no completion exists. This
//     string is not owned by GIO, so remember to g_free() it when finished.
func (completer *FilenameCompleter) CompletionSuffix(initialText string) string {
	var _arg0 *C.GFilenameCompleter // out
	var _arg1 *C.char               // out
	var _cret *C.char               // in

	_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(coreglib.InternObject(completer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(initialText)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_completer_get_completion_suffix(_arg0, _arg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(initialText)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Completions gets an array of completion strings for a given initial text.
//
// The function takes the following parameters:
//
//   - initialText: text to be completed.
//
// The function returns the following values:
//
//   - utf8s: array of strings with possible completions for initial_text.
//     This array must be freed by g_strfreev() when finished.
func (completer *FilenameCompleter) Completions(initialText string) []string {
	var _arg0 *C.GFilenameCompleter // out
	var _arg1 *C.char               // out
	var _cret **C.char              // in

	_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(coreglib.InternObject(completer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(initialText)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_completer_get_completions(_arg0, _arg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(initialText)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// SetDirsOnly: if dirs_only is TRUE, completer will only complete directory
// names, and not file names.
//
// The function takes the following parameters:
//
//   - dirsOnly: #gboolean.
func (completer *FilenameCompleter) SetDirsOnly(dirsOnly bool) {
	var _arg0 *C.GFilenameCompleter // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(coreglib.InternObject(completer).Native()))
	if dirsOnly {
		_arg1 = C.TRUE
	}

	C.g_filename_completer_set_dirs_only(_arg0, _arg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(dirsOnly)
}

func (filenameCompleter *FilenameCompleter) gotCompletionData() {
	gclass := (*C.GFilenameCompleterClass)(coreglib.PeekParentClass(filenameCompleter))
	fnarg := gclass.got_completion_data

	var _arg0 *C.GFilenameCompleter // out

	_arg0 = (*C.GFilenameCompleter)(unsafe.Pointer(coreglib.InternObject(filenameCompleter).Native()))

	C._gotk4_gio2_FilenameCompleter_virtual_got_completion_data(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(filenameCompleter)
}

// FilterInputStreamOverrides contains methods that are overridable.
type FilterInputStreamOverrides struct {
}

func defaultFilterInputStreamOverrides(v *FilterInputStream) FilterInputStreamOverrides {
	return FilterInputStreamOverrides{}
}

// FilterInputStream: base class for input stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterInputStream struct {
	_ [0]func() // equal guard
	InputStream
}

var (
	_ InputStreamer = (*FilterInputStream)(nil)
)

// FilterInputStreamer describes types inherited from class FilterInputStream.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FilterInputStreamer interface {
	coreglib.Objector
	baseFilterInputStream() *FilterInputStream
}

var _ FilterInputStreamer = (*FilterInputStream)(nil)

func init() {
	coreglib.RegisterClassInfo[*FilterInputStream, *FilterInputStreamClass, FilterInputStreamOverrides](
		GTypeFilterInputStream,
		initFilterInputStreamClass,
		wrapFilterInputStream,
		defaultFilterInputStreamOverrides,
	)
}

func initFilterInputStreamClass(gclass unsafe.Pointer, overrides FilterInputStreamOverrides, classInitFunc func(*FilterInputStreamClass)) {
	if classInitFunc != nil {
		class := (*FilterInputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFilterInputStream(obj *coreglib.Object) *FilterInputStream {
	return &FilterInputStream{
		InputStream: InputStream{
			Object: obj,
		},
	}
}

func marshalFilterInputStream(p uintptr) (interface{}, error) {
	return wrapFilterInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (stream *FilterInputStream) baseFilterInputStream() *FilterInputStream {
	return stream
}

// BaseFilterInputStream returns the underlying base object.
func BaseFilterInputStream(obj FilterInputStreamer) *FilterInputStream {
	return obj.baseFilterInputStream()
}

// BaseStream gets the base stream for the filter stream.
//
// The function returns the following values:
//
//   - inputStream: Stream.
func (stream *FilterInputStream) BaseStream() InputStreamer {
	var _arg0 *C.GFilterInputStream // out
	var _cret *C.GInputStream       // in

	_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_filter_input_stream_get_base_stream(_arg0)
	runtime.KeepAlive(stream)

	var _inputStream InputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}

	return _inputStream
}

// CloseBaseStream returns whether the base stream will be closed when stream is
// closed.
//
// The function returns the following values:
//
//   - ok: TRUE if the base stream will be closed.
func (stream *FilterInputStream) CloseBaseStream() bool {
	var _arg0 *C.GFilterInputStream // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_filter_input_stream_get_close_base_stream(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCloseBaseStream sets whether the base stream will be closed when stream is
// closed.
//
// The function takes the following parameters:
//
//   - closeBase: TRUE to close the base stream.
func (stream *FilterInputStream) SetCloseBaseStream(closeBase bool) {
	var _arg0 *C.GFilterInputStream // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GFilterInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if closeBase {
		_arg1 = C.TRUE
	}

	C.g_filter_input_stream_set_close_base_stream(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(closeBase)
}

// FilterOutputStreamOverrides contains methods that are overridable.
type FilterOutputStreamOverrides struct {
}

func defaultFilterOutputStreamOverrides(v *FilterOutputStream) FilterOutputStreamOverrides {
	return FilterOutputStreamOverrides{}
}

// FilterOutputStream: base class for output stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterOutputStream struct {
	_ [0]func() // equal guard
	OutputStream
}

var (
	_ OutputStreamer = (*FilterOutputStream)(nil)
)

// FilterOutputStreamer describes types inherited from class FilterOutputStream.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FilterOutputStreamer interface {
	coreglib.Objector
	baseFilterOutputStream() *FilterOutputStream
}

var _ FilterOutputStreamer = (*FilterOutputStream)(nil)

func init() {
	coreglib.RegisterClassInfo[*FilterOutputStream, *FilterOutputStreamClass, FilterOutputStreamOverrides](
		GTypeFilterOutputStream,
		initFilterOutputStreamClass,
		wrapFilterOutputStream,
		defaultFilterOutputStreamOverrides,
	)
}

func initFilterOutputStreamClass(gclass unsafe.Pointer, overrides FilterOutputStreamOverrides, classInitFunc func(*FilterOutputStreamClass)) {
	if classInitFunc != nil {
		class := (*FilterOutputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFilterOutputStream(obj *coreglib.Object) *FilterOutputStream {
	return &FilterOutputStream{
		OutputStream: OutputStream{
			Object: obj,
		},
	}
}

func marshalFilterOutputStream(p uintptr) (interface{}, error) {
	return wrapFilterOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (stream *FilterOutputStream) baseFilterOutputStream() *FilterOutputStream {
	return stream
}

// BaseFilterOutputStream returns the underlying base object.
func BaseFilterOutputStream(obj FilterOutputStreamer) *FilterOutputStream {
	return obj.baseFilterOutputStream()
}

// BaseStream gets the base stream for the filter stream.
//
// The function returns the following values:
//
//   - outputStream: Stream.
func (stream *FilterOutputStream) BaseStream() OutputStreamer {
	var _arg0 *C.GFilterOutputStream // out
	var _cret *C.GOutputStream       // in

	_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_filter_output_stream_get_base_stream(_arg0)
	runtime.KeepAlive(stream)

	var _outputStream OutputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.OutputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(OutputStreamer)
			return ok
		})
		rv, ok := casted.(OutputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.OutputStreamer")
		}
		_outputStream = rv
	}

	return _outputStream
}

// CloseBaseStream returns whether the base stream will be closed when stream is
// closed.
//
// The function returns the following values:
//
//   - ok: TRUE if the base stream will be closed.
func (stream *FilterOutputStream) CloseBaseStream() bool {
	var _arg0 *C.GFilterOutputStream // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_filter_output_stream_get_close_base_stream(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCloseBaseStream sets whether the base stream will be closed when stream is
// closed.
//
// The function takes the following parameters:
//
//   - closeBase: TRUE to close the base stream.
func (stream *FilterOutputStream) SetCloseBaseStream(closeBase bool) {
	var _arg0 *C.GFilterOutputStream // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GFilterOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if closeBase {
		_arg1 = C.TRUE
	}

	C.g_filter_output_stream_set_close_base_stream(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(closeBase)
}

// IOStreamOverrides contains methods that are overridable.
type IOStreamOverrides struct {
	// CloseFinish closes a stream.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	CloseFinish func(result AsyncResulter) error
	CloseFn     func(ctx context.Context) error
	// InputStream gets the input stream for this object. This is used for
	// reading.
	//
	// The function returns the following values:
	//
	//   - inputStream owned by the OStream. Do not free.
	InputStream func() InputStreamer
	// OutputStream gets the output stream for this object. This is used for
	// writing.
	//
	// The function returns the following values:
	//
	//   - outputStream owned by the OStream. Do not free.
	OutputStream func() OutputStreamer
}

func defaultIOStreamOverrides(v *IOStream) IOStreamOverrides {
	return IOStreamOverrides{
		CloseFinish:  v.closeFinish,
		CloseFn:      v.closeFn,
		InputStream:  v.inputStream,
		OutputStream: v.outputStream,
	}
}

// IOStream: GIOStream represents an object that has both read and write
// streams. Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for seekable
// streams, both streams may use the same position.
//
// Examples of GIOStream objects are gio.SocketConnection, which represents a
// two-way network connection; and gio.FileIOStream, which represents a file
// handle opened in read-write mode.
//
// To do the actual reading and writing you need to get the substreams with
// gio.IOStream.GetInputStream() and gio.IOStream.GetOutputStream().
//
// The GIOStream object owns the input and the output streams, not the other way
// around, so keeping the substreams alive will not keep the GIOStream object
// alive. If the GIOStream object is freed it will be closed, thus closing the
// substreams, so even if the substreams stay alive they will always return
// G_IO_ERROR_CLOSED for all operations.
//
// To close a stream use gio.IOStream.Close() which will close the common stream
// object and also the individual substreams. You can also close the substreams
// themselves. In most cases this only marks the substream as closed, so further
// I/O on it fails but common state in the GIOStream may still be open. However,
// some streams may support half-closed states where one direction of the
// stream is actually shut down.
//
// Operations on GIOStreams cannot be started while another operation on the
// GIOStream or its substreams is in progress. Specifically, an application
// can read from the gio.InputStream and write to the gio.OutputStream
// simultaneously (either in separate threads, or as asynchronous operations
// in the same thread), but an application cannot start any GIOStream operation
// while there is a GIOStream, GInputStream or GOutputStream operation in
// progress, and an application cant start any GInputStream or GOutputStream
// operation while there is a GIOStream operation in progress.
//
// This is a product of individual stream operations being associated with a
// given glib.MainContext (the thread-default context at the time the operation
// was started), rather than entire streams being associated with a single
// GMainContext.
//
// GIO may run operations on GIOStreams from other (worker) threads, and this
// may be exposed to application code in the behaviour of wrapper streams,
// such as gio.BufferedInputStream or gio.TLSConnection. With such wrapper APIs,
// application code may only run operations on the base (wrapped) stream when
// the wrapper stream is idle. Note that the semantics of such operations may
// not be well-defined due to the state the wrapper stream leaves the base
// stream in (though they are guaranteed not to crash).
type IOStream struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IOStream)(nil)
)

// IOStreamer describes types inherited from class IOStream.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type IOStreamer interface {
	coreglib.Objector
	baseIOStream() *IOStream
}

var _ IOStreamer = (*IOStream)(nil)

func init() {
	coreglib.RegisterClassInfo[*IOStream, *IOStreamClass, IOStreamOverrides](
		GTypeIOStream,
		initIOStreamClass,
		wrapIOStream,
		defaultIOStreamOverrides,
	)
}

func initIOStreamClass(gclass unsafe.Pointer, overrides IOStreamOverrides, classInitFunc func(*IOStreamClass)) {
	pclass := (*C.GIOStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeIOStream))))

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._gotk4_gio2_IOStreamClass_close_finish)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._gotk4_gio2_IOStreamClass_close_fn)
	}

	if overrides.InputStream != nil {
		pclass.get_input_stream = (*[0]byte)(C._gotk4_gio2_IOStreamClass_get_input_stream)
	}

	if overrides.OutputStream != nil {
		pclass.get_output_stream = (*[0]byte)(C._gotk4_gio2_IOStreamClass_get_output_stream)
	}

	if classInitFunc != nil {
		class := (*IOStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapIOStream(obj *coreglib.Object) *IOStream {
	return &IOStream{
		Object: obj,
	}
}

func marshalIOStream(p uintptr) (interface{}, error) {
	return wrapIOStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (stream *IOStream) baseIOStream() *IOStream {
	return stream
}

// BaseIOStream returns the underlying base object.
func BaseIOStream(obj IOStreamer) *IOStream {
	return obj.baseIOStream()
}

// ClearPending clears the pending flag on stream.
func (stream *IOStream) ClearPending() {
	var _arg0 *C.GIOStream // out

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.g_io_stream_clear_pending(_arg0)
	runtime.KeepAlive(stream)
}

// Close closes the stream, releasing resources related to it. This will also
// close the individual input and output streams, if they are not already
// closed.
//
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an error.
//
// Closing a stream will automatically flush any outstanding buffers in the
// stream.
//
// Streams will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are released
// as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for the
// individual stream for details.
//
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close will
// still return G_IO_ERROR_CLOSED for all operations. Still, it is important to
// check and report the error to the user, otherwise there might be a loss of
// data as all data might not be written.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. Cancelling a close will
// still leave the stream closed, but some streams can use a faster close that
// doesn't block to e.g. check errors.
//
// The default implementation of this method just calls close on the individual
// input/output streams.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (stream *IOStream) Close(ctx context.Context) error {
	var _arg0 *C.GIOStream    // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_io_stream_close(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CloseAsync requests an asynchronous close of the stream, releasing resources
// related to it. When the operation is finished callback will be called. You
// can then call g_io_stream_close_finish() to get the result of the operation.
//
// For behaviour details see g_io_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *IOStream) CloseAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GIOStream          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_io_stream_close_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CloseFinish closes a stream.
//
// The function takes the following parameters:
//
//   - result: Result.
func (stream *IOStream) CloseFinish(result AsyncResulter) error {
	var _arg0 *C.GIOStream    // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_io_stream_close_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// InputStream gets the input stream for this object. This is used for reading.
//
// The function returns the following values:
//
//   - inputStream owned by the OStream. Do not free.
func (stream *IOStream) InputStream() InputStreamer {
	var _arg0 *C.GIOStream    // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_io_stream_get_input_stream(_arg0)
	runtime.KeepAlive(stream)

	var _inputStream InputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}

	return _inputStream
}

// OutputStream gets the output stream for this object. This is used for
// writing.
//
// The function returns the following values:
//
//   - outputStream owned by the OStream. Do not free.
func (stream *IOStream) OutputStream() OutputStreamer {
	var _arg0 *C.GIOStream     // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_io_stream_get_output_stream(_arg0)
	runtime.KeepAlive(stream)

	var _outputStream OutputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.OutputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(OutputStreamer)
			return ok
		})
		rv, ok := casted.(OutputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.OutputStreamer")
		}
		_outputStream = rv
	}

	return _outputStream
}

// HasPending checks if a stream has pending actions.
//
// The function returns the following values:
//
//   - ok: TRUE if stream has pending actions.
func (stream *IOStream) HasPending() bool {
	var _arg0 *C.GIOStream // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_io_stream_has_pending(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsClosed checks if a stream is closed.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream is closed.
func (stream *IOStream) IsClosed() bool {
	var _arg0 *C.GIOStream // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_io_stream_is_closed(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPending sets stream to have actions pending. If the pending flag is
// already set or stream is closed, it will return FALSE and set error.
func (stream *IOStream) SetPending() error {
	var _arg0 *C.GIOStream // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.g_io_stream_set_pending(_arg0, &_cerr)
	runtime.KeepAlive(stream)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SpliceAsync: asynchronously splice the output stream of stream1 to the input
// stream of stream2, and splice the output stream of stream2 to the input
// stream of stream1.
//
// When the operation is finished callback will be called. You can then call
// g_io_stream_splice_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - stream2: OStream.
//   - flags: set of OStreamSpliceFlags.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream1 *IOStream) SpliceAsync(ctx context.Context, stream2 IOStreamer, flags IOStreamSpliceFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GIOStream           // out
	var _arg4 *C.GCancellable        // out
	var _arg1 *C.GIOStream           // out
	var _arg2 C.GIOStreamSpliceFlags // out
	var _arg3 C.int                  // out
	var _arg5 C.GAsyncReadyCallback  // out
	var _arg6 C.gpointer

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream1).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream2).Native()))
	_arg2 = C.GIOStreamSpliceFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_io_stream_splice_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream1)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream2)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// closeAsync requests an asynchronous close of the stream, releasing resources
// related to it. When the operation is finished callback will be called. You
// can then call g_io_stream_close_finish() to get the result of the operation.
//
// For behaviour details see g_io_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *IOStream) closeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_async

	var _arg0 *C.GIOStream          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_IOStream_virtual_close_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// closeFinish closes a stream.
//
// The function takes the following parameters:
//
//   - result: Result.
func (stream *IOStream) closeFinish(result AsyncResulter) error {
	gclass := (*C.GIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_finish

	var _arg0 *C.GIOStream    // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_IOStream_virtual_close_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (stream *IOStream) closeFn(ctx context.Context) error {
	gclass := (*C.GIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_fn

	var _arg0 *C.GIOStream    // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_IOStream_virtual_close_fn(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// inputStream gets the input stream for this object. This is used for reading.
//
// The function returns the following values:
//
//   - inputStream owned by the OStream. Do not free.
func (stream *IOStream) inputStream() InputStreamer {
	gclass := (*C.GIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.get_input_stream

	var _arg0 *C.GIOStream    // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_IOStream_virtual_get_input_stream(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _inputStream InputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}

	return _inputStream
}

// outputStream gets the output stream for this object. This is used for
// writing.
//
// The function returns the following values:
//
//   - outputStream owned by the OStream. Do not free.
func (stream *IOStream) outputStream() OutputStreamer {
	gclass := (*C.GIOStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.get_output_stream

	var _arg0 *C.GIOStream     // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gio2_IOStream_virtual_get_output_stream(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(stream)

	var _outputStream OutputStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.OutputStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(OutputStreamer)
			return ok
		})
		rv, ok := casted.(OutputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.OutputStreamer")
		}
		_outputStream = rv
	}

	return _outputStream
}

// IOStreamSpliceFinish finishes an asynchronous io stream splice operation.
//
// The function takes the following parameters:
//
//   - result: Result.
func IOStreamSpliceFinish(result AsyncResulter) error {
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_io_stream_splice_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// InetAddressOverrides contains methods that are overridable.
type InetAddressOverrides struct {
	// String converts address to string form.
	//
	// The function returns the following values:
	//
	//   - utf8: representation of address as a string, which should be freed
	//     after use.
	String func() string
}

func defaultInetAddressOverrides(v *InetAddress) InetAddressOverrides {
	return InetAddressOverrides{
		String: v.str,
	}
}

// InetAddress: GInetAddress represents an IPv4 or IPv6 internet address.
// Use gio.Resolver.LookupByName() or gio.Resolver.LookupByNameAsync() to look
// up the GInetAddress for a hostname. Use gio.Resolver.LookupByAddress()
// or gio.Resolver.LookupByAddressAsync() to look up the hostname for a
// GInetAddress.
//
// To actually connect to a remote host, you will need a gio.InetSocketAddress
// (which includes a GInetAddress as well as a port number).
type InetAddress struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*InetAddress)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*InetAddress, *InetAddressClass, InetAddressOverrides](
		GTypeInetAddress,
		initInetAddressClass,
		wrapInetAddress,
		defaultInetAddressOverrides,
	)
}

func initInetAddressClass(gclass unsafe.Pointer, overrides InetAddressOverrides, classInitFunc func(*InetAddressClass)) {
	pclass := (*C.GInetAddressClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeInetAddress))))

	if overrides.String != nil {
		pclass.to_string = (*[0]byte)(C._gotk4_gio2_InetAddressClass_to_string)
	}

	if classInitFunc != nil {
		class := (*InetAddressClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapInetAddress(obj *coreglib.Object) *InetAddress {
	return &InetAddress{
		Object: obj,
	}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	return wrapInetAddress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewInetAddressAny creates a Address for the "any" address (unassigned/"don't
// care") for family.
//
// The function takes the following parameters:
//
//   - family address family.
//
// The function returns the following values:
//
//   - inetAddress: new Address corresponding to the "any" address for family.
//     Free the returned object with g_object_unref().
func NewInetAddressAny(family SocketFamily) *InetAddress {
	var _arg1 C.GSocketFamily // out
	var _cret *C.GInetAddress // in

	_arg1 = C.GSocketFamily(family)

	_cret = C.g_inet_address_new_any(_arg1)
	runtime.KeepAlive(family)

	var _inetAddress *InetAddress // out

	_inetAddress = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _inetAddress
}

// NewInetAddressFromString parses string as an IP address and creates a new
// Address.
//
// The function takes the following parameters:
//
//   - str: string representation of an IP address.
//
// The function returns the following values:
//
//   - inetAddress (optional): new Address corresponding to string,
//     or NULL if string could not be parsed. Free the returned object with
//     g_object_unref().
func NewInetAddressFromString(str string) *InetAddress {
	var _arg1 *C.gchar        // out
	var _cret *C.GInetAddress // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_inet_address_new_from_string(_arg1)
	runtime.KeepAlive(str)

	var _inetAddress *InetAddress // out

	if _cret != nil {
		_inetAddress = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _inetAddress
}

// NewInetAddressLoopback creates a Address for the loopback address for family.
//
// The function takes the following parameters:
//
//   - family address family.
//
// The function returns the following values:
//
//   - inetAddress: new Address corresponding to the loopback address for
//     family. Free the returned object with g_object_unref().
func NewInetAddressLoopback(family SocketFamily) *InetAddress {
	var _arg1 C.GSocketFamily // out
	var _cret *C.GInetAddress // in

	_arg1 = C.GSocketFamily(family)

	_cret = C.g_inet_address_new_loopback(_arg1)
	runtime.KeepAlive(family)

	var _inetAddress *InetAddress // out

	_inetAddress = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _inetAddress
}

// Equal checks if two Address instances are equal, e.g. the same address.
//
// The function takes the following parameters:
//
//   - otherAddress: another Address.
//
// The function returns the following values:
//
//   - ok: TRUE if address and other_address are equal, FALSE otherwise.
func (address *InetAddress) Equal(otherAddress *InetAddress) bool {
	var _arg0 *C.GInetAddress // out
	var _arg1 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(otherAddress).Native()))

	_cret = C.g_inet_address_equal(_arg0, _arg1)
	runtime.KeepAlive(address)
	runtime.KeepAlive(otherAddress)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Family gets address's family.
//
// The function returns the following values:
//
//   - socketFamily address's family.
func (address *InetAddress) Family() SocketFamily {
	var _arg0 *C.GInetAddress // out
	var _cret C.GSocketFamily // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_family(_arg0)
	runtime.KeepAlive(address)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

// IsAny tests whether address is the "any" address for its family.
//
// The function returns the following values:
//
//   - ok: TRUE if address is the "any" address for its family.
func (address *InetAddress) IsAny() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_any(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLinkLocal tests whether address is a link-local address (that is, if it
// identifies a host on a local network that is not connected to the Internet).
//
// The function returns the following values:
//
//   - ok: TRUE if address is a link-local address.
func (address *InetAddress) IsLinkLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_link_local(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLoopback tests whether address is the loopback address for its family.
//
// The function returns the following values:
//
//   - ok: TRUE if address is the loopback address for its family.
func (address *InetAddress) IsLoopback() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_loopback(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMcGlobal tests whether address is a global multicast address.
//
// The function returns the following values:
//
//   - ok: TRUE if address is a global multicast address.
func (address *InetAddress) IsMcGlobal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_mc_global(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMcLinkLocal tests whether address is a link-local multicast address.
//
// The function returns the following values:
//
//   - ok: TRUE if address is a link-local multicast address.
func (address *InetAddress) IsMcLinkLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_mc_link_local(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMcNodeLocal tests whether address is a node-local multicast address.
//
// The function returns the following values:
//
//   - ok: TRUE if address is a node-local multicast address.
func (address *InetAddress) IsMcNodeLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_mc_node_local(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMcOrgLocal tests whether address is an organization-local multicast
// address.
//
// The function returns the following values:
//
//   - ok: TRUE if address is an organization-local multicast address.
func (address *InetAddress) IsMcOrgLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_mc_org_local(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMcSiteLocal tests whether address is a site-local multicast address.
//
// The function returns the following values:
//
//   - ok: TRUE if address is a site-local multicast address.
func (address *InetAddress) IsMcSiteLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_mc_site_local(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMulticast tests whether address is a multicast address.
//
// The function returns the following values:
//
//   - ok: TRUE if address is a multicast address.
func (address *InetAddress) IsMulticast() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_multicast(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSiteLocal tests whether address is a site-local address such as 10.0.0.1
// (that is, the address identifies a host on a local network that can not be
// reached directly from the Internet, but which may have outgoing Internet
// connectivity via a NAT or firewall).
//
// The function returns the following values:
//
//   - ok: TRUE if address is a site-local address.
func (address *InetAddress) IsSiteLocal() bool {
	var _arg0 *C.GInetAddress // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_is_site_local(_arg0)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NativeSize gets the size of the native raw binary address for address.
// This is the size of the data that you get from g_inet_address_to_bytes().
//
// The function returns the following values:
//
//   - gsize: number of bytes used for the native version of address.
func (address *InetAddress) NativeSize() uint {
	var _arg0 *C.GInetAddress // out
	var _cret C.gsize         // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_get_native_size(_arg0)
	runtime.KeepAlive(address)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// String converts address to string form.
//
// The function returns the following values:
//
//   - utf8: representation of address as a string, which should be freed after
//     use.
func (address *InetAddress) String() string {
	var _arg0 *C.GInetAddress // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_to_string(_arg0)
	runtime.KeepAlive(address)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Str converts address to string form.
//
// The function returns the following values:
//
//   - utf8: representation of address as a string, which should be freed after
//     use.
func (address *InetAddress) str() string {
	gclass := (*C.GInetAddressClass)(coreglib.PeekParentClass(address))
	fnarg := gclass.to_string

	var _arg0 *C.GInetAddress // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C._gotk4_gio2_InetAddress_virtual_to_string(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(address)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// InetAddressMaskOverrides contains methods that are overridable.
type InetAddressMaskOverrides struct {
}

func defaultInetAddressMaskOverrides(v *InetAddressMask) InetAddressMaskOverrides {
	return InetAddressMaskOverrides{}
}

// InetAddressMask: GInetAddressMask represents a range of IPv4 or IPv6
// addresses described by a base address and a length indicating how many bits
// of the base address are relevant for matching purposes. These are often given
// in string form. For example, 10.0.0.0/8, or fe80::/10.
type InetAddressMask struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Initable
}

var (
	_ coreglib.Objector = (*InetAddressMask)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*InetAddressMask, *InetAddressMaskClass, InetAddressMaskOverrides](
		GTypeInetAddressMask,
		initInetAddressMaskClass,
		wrapInetAddressMask,
		defaultInetAddressMaskOverrides,
	)
}

func initInetAddressMaskClass(gclass unsafe.Pointer, overrides InetAddressMaskOverrides, classInitFunc func(*InetAddressMaskClass)) {
	if classInitFunc != nil {
		class := (*InetAddressMaskClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapInetAddressMask(obj *coreglib.Object) *InetAddressMask {
	return &InetAddressMask{
		Object: obj,
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalInetAddressMask(p uintptr) (interface{}, error) {
	return wrapInetAddressMask(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewInetAddressMask creates a new AddressMask representing all addresses whose
// first length bits match addr.
//
// The function takes the following parameters:
//
//   - addr: Address.
//   - length: number of bits of addr to use.
//
// The function returns the following values:
//
//   - inetAddressMask: new AddressMask, or NULL on error.
func NewInetAddressMask(addr *InetAddress, length uint) (*InetAddressMask, error) {
	var _arg1 *C.GInetAddress     // out
	var _arg2 C.guint             // out
	var _cret *C.GInetAddressMask // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(addr).Native()))
	_arg2 = C.guint(length)

	_cret = C.g_inet_address_mask_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(addr)
	runtime.KeepAlive(length)

	var _inetAddressMask *InetAddressMask // out
	var _goerr error                      // out

	_inetAddressMask = wrapInetAddressMask(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inetAddressMask, _goerr
}

// NewInetAddressMaskFromString parses mask_string as an IP address and
// (optional) length, and creates a new AddressMask. The length, if present,
// is delimited by a "/". If it is not present, then the length is assumed to be
// the full length of the address.
//
// The function takes the following parameters:
//
//   - maskString: IP address or address/length string.
//
// The function returns the following values:
//
//   - inetAddressMask: new AddressMask corresponding to string, or NULL on
//     error.
func NewInetAddressMaskFromString(maskString string) (*InetAddressMask, error) {
	var _arg1 *C.gchar            // out
	var _cret *C.GInetAddressMask // in
	var _cerr *C.GError           // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(maskString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_inet_address_mask_new_from_string(_arg1, &_cerr)
	runtime.KeepAlive(maskString)

	var _inetAddressMask *InetAddressMask // out
	var _goerr error                      // out

	_inetAddressMask = wrapInetAddressMask(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inetAddressMask, _goerr
}

// Equal tests if mask and mask2 are the same mask.
//
// The function takes the following parameters:
//
//   - mask2: another AddressMask.
//
// The function returns the following values:
//
//   - ok: whether mask and mask2 are the same mask.
func (mask *InetAddressMask) Equal(mask2 *InetAddressMask) bool {
	var _arg0 *C.GInetAddressMask // out
	var _arg1 *C.GInetAddressMask // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(coreglib.InternObject(mask).Native()))
	_arg1 = (*C.GInetAddressMask)(unsafe.Pointer(coreglib.InternObject(mask2).Native()))

	_cret = C.g_inet_address_mask_equal(_arg0, _arg1)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(mask2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Address gets mask's base address.
//
// The function returns the following values:
//
//   - inetAddress mask's base address.
func (mask *InetAddressMask) Address() *InetAddress {
	var _arg0 *C.GInetAddressMask // out
	var _cret *C.GInetAddress     // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(coreglib.InternObject(mask).Native()))

	_cret = C.g_inet_address_mask_get_address(_arg0)
	runtime.KeepAlive(mask)

	var _inetAddress *InetAddress // out

	_inetAddress = wrapInetAddress(coreglib.Take(unsafe.Pointer(_cret)))

	return _inetAddress
}

// Family gets the Family of mask's address.
//
// The function returns the following values:
//
//   - socketFamily of mask's address.
func (mask *InetAddressMask) Family() SocketFamily {
	var _arg0 *C.GInetAddressMask // out
	var _cret C.GSocketFamily     // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(coreglib.InternObject(mask).Native()))

	_cret = C.g_inet_address_mask_get_family(_arg0)
	runtime.KeepAlive(mask)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

// Length gets mask's length.
//
// The function returns the following values:
//
//   - guint mask's length.
func (mask *InetAddressMask) Length() uint {
	var _arg0 *C.GInetAddressMask // out
	var _cret C.guint             // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(coreglib.InternObject(mask).Native()))

	_cret = C.g_inet_address_mask_get_length(_arg0)
	runtime.KeepAlive(mask)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Matches tests if address falls within the range described by mask.
//
// The function takes the following parameters:
//
//   - address: Address.
//
// The function returns the following values:
//
//   - ok: whether address falls within the range described by mask.
func (mask *InetAddressMask) Matches(address *InetAddress) bool {
	var _arg0 *C.GInetAddressMask // out
	var _arg1 *C.GInetAddress     // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(coreglib.InternObject(mask).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_address_mask_matches(_arg0, _arg1)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(address)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String converts mask back to its corresponding string form.
//
// The function returns the following values:
//
//   - utf8: string corresponding to mask.
func (mask *InetAddressMask) String() string {
	var _arg0 *C.GInetAddressMask // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GInetAddressMask)(unsafe.Pointer(coreglib.InternObject(mask).Native()))

	_cret = C.g_inet_address_mask_to_string(_arg0)
	runtime.KeepAlive(mask)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// InetSocketAddressOverrides contains methods that are overridable.
type InetSocketAddressOverrides struct {
}

func defaultInetSocketAddressOverrides(v *InetSocketAddress) InetSocketAddressOverrides {
	return InetSocketAddressOverrides{}
}

// InetSocketAddress: IPv4 or IPv6 socket address. That is, the combination of a
// gio.InetAddress and a port number.
//
// In UNIX terms, GInetSocketAddress corresponds to a struct sockaddr_in or
// struct sockaddr_in6 (man:sockaddr(3type)).
type InetSocketAddress struct {
	_ [0]func() // equal guard
	SocketAddress
}

var (
	_ SocketAddresser = (*InetSocketAddress)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*InetSocketAddress, *InetSocketAddressClass, InetSocketAddressOverrides](
		GTypeInetSocketAddress,
		initInetSocketAddressClass,
		wrapInetSocketAddress,
		defaultInetSocketAddressOverrides,
	)
}

func initInetSocketAddressClass(gclass unsafe.Pointer, overrides InetSocketAddressOverrides, classInitFunc func(*InetSocketAddressClass)) {
	if classInitFunc != nil {
		class := (*InetSocketAddressClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapInetSocketAddress(obj *coreglib.Object) *InetSocketAddress {
	return &InetSocketAddress{
		SocketAddress: SocketAddress{
			Object: obj,
			SocketConnectable: SocketConnectable{
				Object: obj,
			},
		},
	}
}

func marshalInetSocketAddress(p uintptr) (interface{}, error) {
	return wrapInetSocketAddress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewInetSocketAddress creates a new SocketAddress for address and port.
//
// The function takes the following parameters:
//
//   - address: Address.
//   - port number.
//
// The function returns the following values:
//
//   - inetSocketAddress: new SocketAddress.
func NewInetSocketAddress(address *InetAddress, port uint16) *InetSocketAddress {
	var _arg1 *C.GInetAddress   // out
	var _arg2 C.guint16         // out
	var _cret *C.GSocketAddress // in

	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg2 = C.guint16(port)

	_cret = C.g_inet_socket_address_new(_arg1, _arg2)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var _inetSocketAddress *InetSocketAddress // out

	_inetSocketAddress = wrapInetSocketAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _inetSocketAddress
}

// NewInetSocketAddressFromString creates a new SocketAddress for address and
// port.
//
// If address is an IPv6 address, it can also contain a scope ID (separated from
// the address by a %).
//
// The function takes the following parameters:
//
//   - address: string form of an IP address.
//   - port number.
//
// The function returns the following values:
//
//   - inetSocketAddress (optional): new SocketAddress, or NULL if address
//     cannot be parsed.
func NewInetSocketAddressFromString(address string, port uint) *InetSocketAddress {
	var _arg1 *C.char           // out
	var _arg2 C.guint           // out
	var _cret *C.GSocketAddress // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(port)

	_cret = C.g_inet_socket_address_new_from_string(_arg1, _arg2)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var _inetSocketAddress *InetSocketAddress // out

	if _cret != nil {
		_inetSocketAddress = wrapInetSocketAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _inetSocketAddress
}

// Address gets address's Address.
//
// The function returns the following values:
//
//   - inetAddress for address, which must be g_object_ref()'d if it will be
//     stored.
func (address *InetSocketAddress) Address() *InetAddress {
	var _arg0 *C.GInetSocketAddress // out
	var _cret *C.GInetAddress       // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_socket_address_get_address(_arg0)
	runtime.KeepAlive(address)

	var _inetAddress *InetAddress // out

	_inetAddress = wrapInetAddress(coreglib.Take(unsafe.Pointer(_cret)))

	return _inetAddress
}

// Flowinfo gets the sin6_flowinfo field from address, which must be an IPv6
// address.
//
// The function returns the following values:
//
//   - guint32: flowinfo field.
func (address *InetSocketAddress) Flowinfo() uint32 {
	var _arg0 *C.GInetSocketAddress // out
	var _cret C.guint32             // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_socket_address_get_flowinfo(_arg0)
	runtime.KeepAlive(address)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Port gets address's port.
//
// The function returns the following values:
//
//   - guint16: port for address.
func (address *InetSocketAddress) Port() uint16 {
	var _arg0 *C.GInetSocketAddress // out
	var _cret C.guint16             // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_socket_address_get_port(_arg0)
	runtime.KeepAlive(address)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// ScopeID gets the sin6_scope_id field from address, which must be an IPv6
// address.
//
// The function returns the following values:
//
//   - guint32: scope id field.
func (address *InetSocketAddress) ScopeID() uint32 {
	var _arg0 *C.GInetSocketAddress // out
	var _cret C.guint32             // in

	_arg0 = (*C.GInetSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_inet_socket_address_get_scope_id(_arg0)
	runtime.KeepAlive(address)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// InputStreamOverrides contains methods that are overridable.
type InputStreamOverrides struct {
	// CloseFinish finishes closing a stream asynchronously, started from
	// g_input_stream_close_async().
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	CloseFinish func(result AsyncResulter) error
	CloseFn     func(ctx context.Context) error
	// ReadFinish finishes an asynchronous stream read operation.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - gssize: number of bytes read in, or -1 on error, or 0 on end of file.
	ReadFinish func(result AsyncResulter) (int, error)
	// Skip tries to skip count bytes from the stream. Will block during the
	// operation.
	//
	// This is identical to g_input_stream_read(), from a behaviour standpoint,
	// but the bytes that are skipped are not returned to the user. Some streams
	// have an implementation that is more efficient than reading the data.
	//
	// This function is optional for inherited classes, as the default
	// implementation emulates it using read.
	//
	// If cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//   - count: number of bytes that will be skipped from the stream.
	//
	// The function returns the following values:
	//
	//   - gssize: number of bytes skipped, or -1 on error.
	Skip func(ctx context.Context, count uint) (int, error)
	// SkipFinish finishes a stream skip operation.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - gssize: size of the bytes skipped, or -1 on error.
	SkipFinish func(result AsyncResulter) (int, error)
}

func defaultInputStreamOverrides(v *InputStream) InputStreamOverrides {
	return InputStreamOverrides{
		CloseFinish: v.closeFinish,
		CloseFn:     v.closeFn,
		ReadFinish:  v.readFinish,
		Skip:        v.skip,
		SkipFinish:  v.skipFinish,
	}
}

// InputStream: GInputStream is a base class for implementing streaming input.
//
// It has functions to read from a stream (gio.InputStream.Read()),
// to close a stream (gio.InputStream.Close()) and to skip some content
// (gio.InputStream.Skip()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use gio.OutputStream.Splice().
//
// See the documentation for gio.IOStream for details of thread safety of
// streaming APIs.
//
// All of these functions have async variants too.
type InputStream struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*InputStream)(nil)
)

// InputStreamer describes types inherited from class InputStream.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type InputStreamer interface {
	coreglib.Objector
	baseInputStream() *InputStream
}

var _ InputStreamer = (*InputStream)(nil)

func init() {
	coreglib.RegisterClassInfo[*InputStream, *InputStreamClass, InputStreamOverrides](
		GTypeInputStream,
		initInputStreamClass,
		wrapInputStream,
		defaultInputStreamOverrides,
	)
}

func initInputStreamClass(gclass unsafe.Pointer, overrides InputStreamOverrides, classInitFunc func(*InputStreamClass)) {
	pclass := (*C.GInputStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeInputStream))))

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._gotk4_gio2_InputStreamClass_close_finish)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._gotk4_gio2_InputStreamClass_close_fn)
	}

	if overrides.ReadFinish != nil {
		pclass.read_finish = (*[0]byte)(C._gotk4_gio2_InputStreamClass_read_finish)
	}

	if overrides.Skip != nil {
		pclass.skip = (*[0]byte)(C._gotk4_gio2_InputStreamClass_skip)
	}

	if overrides.SkipFinish != nil {
		pclass.skip_finish = (*[0]byte)(C._gotk4_gio2_InputStreamClass_skip_finish)
	}

	if classInitFunc != nil {
		class := (*InputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapInputStream(obj *coreglib.Object) *InputStream {
	return &InputStream{
		Object: obj,
	}
}

func marshalInputStream(p uintptr) (interface{}, error) {
	return wrapInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (stream *InputStream) baseInputStream() *InputStream {
	return stream
}

// BaseInputStream returns the underlying base object.
func BaseInputStream(obj InputStreamer) *InputStream {
	return obj.baseInputStream()
}

// ClearPending clears the pending flag on stream.
func (stream *InputStream) ClearPending() {
	var _arg0 *C.GInputStream // out

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.g_input_stream_clear_pending(_arg0)
	runtime.KeepAlive(stream)
}

// Close closes the stream, releasing resources related to it.
//
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an error.
//
// Streams will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are released
// as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for the
// individual stream for details.
//
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close will
// still return G_IO_ERROR_CLOSED for all operations. Still, it is important to
// check and report the error to the user.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. Cancelling a close will
// still leave the stream closed, but some streams can use a faster close that
// doesn't block to e.g. check errors.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
func (stream *InputStream) Close(ctx context.Context) error {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_input_stream_close(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CloseAsync requests an asynchronous closes of the stream, releasing resources
// related to it. When the operation is finished callback will be called.
// You can then call g_input_stream_close_finish() to get the result of the
// operation.
//
// For behaviour details see g_input_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) CloseAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream       // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_input_stream_close_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CloseFinish finishes closing a stream asynchronously, started from
// g_input_stream_close_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (stream *InputStream) CloseFinish(result AsyncResulter) error {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_input_stream_close_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// HasPending checks if an input stream has pending actions.
//
// The function returns the following values:
//
//   - ok: TRUE if stream has pending actions.
func (stream *InputStream) HasPending() bool {
	var _arg0 *C.GInputStream // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_input_stream_has_pending(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsClosed checks if an input stream is closed.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream is closed.
func (stream *InputStream) IsClosed() bool {
	var _arg0 *C.GInputStream // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_input_stream_is_closed(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Read tries to read count bytes from the stream into the buffer starting at
// buffer. Will block during this read.
//
// If count is zero returns zero and does nothing. A value of count larger than
// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// near the end of a file. Zero is returned on end of file (or if count is
// zero), but never otherwise.
//
// The returned buffer is not a nul-terminated string, it can contain nul bytes
// at any position, and this function doesn't nul-terminate the buffer.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer: a buffer to read data into (which should be at least count bytes
//     long).
//
// The function returns the following values:
//
//   - gssize: number of bytes read, or -1 on error, or 0 on end of file.
func (stream *InputStream) Read(ctx context.Context, buffer []byte) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg3 *C.GCancellable // out
	var _arg1 *C.void         // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C.g_input_stream_read(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// ReadAll tries to read count bytes from the stream into the buffer starting at
// buffer. Will block during this read.
//
// This function is similar to g_input_stream_read(), except it tries to read as
// many bytes as requested, only stopping on an error or end of stream.
//
// On a successful read of count bytes, or if we reached the end of the stream,
// TRUE is returned, and bytes_read is set to the number of bytes read into
// buffer.
//
// If there is an error during the operation FALSE is returned and error is set
// to indicate the error status.
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_read
// will be set to the number of bytes that were successfully read before
// the error was encountered. This functionality is only available from C.
// If you need it from another language then you must write your own loop around
// g_input_stream_read().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer: a buffer to read data into (which should be at least count bytes
//     long).
//
// The function returns the following values:
//
//   - bytesRead: location to store the number of bytes that was read from the
//     stream.
func (stream *InputStream) ReadAll(ctx context.Context, buffer []byte) (uint, error) {
	var _arg0 *C.GInputStream // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.void         // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	C.g_input_stream_read_all(_arg0, unsafe.Pointer(_arg1), _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _bytesRead uint // out
	var _goerr error    // out

	_bytesRead = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _goerr
}

// ReadAllAsync: request an asynchronous read of count bytes from the stream
// into the buffer starting at buffer.
//
// This is the asynchronous equivalent of g_input_stream_read_all().
//
// Call g_input_stream_read_all_finish() to collect the result.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer: a buffer to read data into (which should be at least count bytes
//     long).
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) ReadAllAsync(ctx context.Context, buffer []byte, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.void         // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_input_stream_read_all_async(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadAllFinish finishes an asynchronous stream read operation started with
// g_input_stream_read_all_async().
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_read
// will be set to the number of bytes that were successfully read before
// the error was encountered. This functionality is only available from C.
// If you need it from another language then you must write your own loop around
// g_input_stream_read_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - bytesRead: location to store the number of bytes that was read from the
//     stream.
func (stream *InputStream) ReadAllFinish(result AsyncResulter) (uint, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gsize         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_input_stream_read_all_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesRead uint // out
	var _goerr error    // out

	_bytesRead = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _goerr
}

// ReadAsync: request an asynchronous read of count bytes from the stream into
// the buffer starting at buffer. When the operation is finished callback will
// be called. You can then call g_input_stream_read_finish() to get the result
// of the operation.
//
// During an async request no other sync and async calls are allowed on stream,
// and will result in G_IO_ERROR_PENDING errors.
//
// A value of count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer will be passed to the
// callback. It is not an error if this is not the same as the requested size,
// as it can happen e.g. near the end of a file, but generally we try to read
// as many bytes as requested. Zero is returned on end of file (or if count is
// zero), but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer: a buffer to read data into (which should be at least count bytes
//     long).
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) ReadAsync(ctx context.Context, buffer []byte, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.void         // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_input_stream_read_async(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadBytes: like g_input_stream_read(), this tries to read count bytes
// from the stream in a blocking fashion. However, rather than reading into a
// user-supplied buffer, this will create a new #GBytes containing the data that
// was read. This may be easier to use from language bindings.
//
// If count is zero, returns a zero-length #GBytes and does nothing. A value of
// count larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, a new #GBytes is returned. It is not an error if the size of
// this object is not the same as the requested size, as it can happen e.g.
// near the end of a file. A zero-length #GBytes is returned on end of file (or
// if count is zero), but never otherwise.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// On error NULL is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: maximum number of bytes that will be read from the stream.
//     Common values include 4096 and 8192.
//
// The function returns the following values:
//
//   - bytes: new #GBytes, or NULL on error.
func (stream *InputStream) ReadBytes(ctx context.Context, count uint) (*glib.Bytes, error) {
	var _arg0 *C.GInputStream // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.gsize         // out
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gsize(count)

	_cret = C.g_input_stream_read_bytes(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// ReadBytesAsync: request an asynchronous read of count bytes from the stream
// into a new #GBytes. When the operation is finished callback will be called.
// You can then call g_input_stream_read_bytes_finish() to get the result of the
// operation.
//
// During an async request no other sync and async calls are allowed on stream,
// and will result in G_IO_ERROR_PENDING errors.
//
// A value of count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the new #GBytes will be passed to the callback. It is not an
// error if this is smaller than the requested size, as it can happen e.g. near
// the end of a file, but generally we try to read as many bytes as requested.
// Zero is returned on end of file (or if count is zero), but never otherwise.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: number of bytes that will be read from the stream.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) ReadBytesAsync(ctx context.Context, count uint, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream       // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.gsize               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gsize(count)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_input_stream_read_bytes_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadBytesFinish finishes an asynchronous stream read-into-#GBytes operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - bytes: newly-allocated #GBytes, or NULL on error.
func (stream *InputStream) ReadBytesFinish(result AsyncResulter) (*glib.Bytes, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_input_stream_read_bytes_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// ReadFinish finishes an asynchronous stream read operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize: number of bytes read in, or -1 on error, or 0 on end of file.
func (stream *InputStream) ReadFinish(result AsyncResulter) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_input_stream_read_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SetPending sets stream to have actions pending. If the pending flag is
// already set or stream is closed, it will return FALSE and set error.
func (stream *InputStream) SetPending() error {
	var _arg0 *C.GInputStream // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.g_input_stream_set_pending(_arg0, &_cerr)
	runtime.KeepAlive(stream)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Skip tries to skip count bytes from the stream. Will block during the
// operation.
//
// This is identical to g_input_stream_read(), from a behaviour standpoint,
// but the bytes that are skipped are not returned to the user. Some streams
// have an implementation that is more efficient than reading the data.
//
// This function is optional for inherited classes, as the default
// implementation emulates it using read.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: number of bytes that will be skipped from the stream.
//
// The function returns the following values:
//
//   - gssize: number of bytes skipped, or -1 on error.
func (stream *InputStream) Skip(ctx context.Context, count uint) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.gsize         // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gsize(count)

	_cret = C.g_input_stream_skip(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SkipAsync: request an asynchronous skip of count bytes from the stream.
// When the operation is finished callback will be called. You can then call
// g_input_stream_skip_finish() to get the result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// A value of count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes skipped will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it can
// happen e.g. near the end of a file, but generally we try to skip as many
// bytes as requested. Zero is returned on end of file (or if count is zero),
// but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one, you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: number of bytes that will be skipped from the stream.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) SkipAsync(ctx context.Context, count uint, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream       // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.gsize               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gsize(count)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_input_stream_skip_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// SkipFinish finishes a stream skip operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize: size of the bytes skipped, or -1 on error.
func (stream *InputStream) SkipFinish(result AsyncResulter) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_input_stream_skip_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// closeAsync requests an asynchronous closes of the stream, releasing resources
// related to it. When the operation is finished callback will be called.
// You can then call g_input_stream_close_finish() to get the result of the
// operation.
//
// For behaviour details see g_input_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) closeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_async

	var _arg0 *C.GInputStream       // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_InputStream_virtual_close_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// closeFinish finishes closing a stream asynchronously, started from
// g_input_stream_close_async().
//
// The function takes the following parameters:
//
//   - result: Result.
func (stream *InputStream) closeFinish(result AsyncResulter) error {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_finish

	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_InputStream_virtual_close_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (stream *InputStream) closeFn(ctx context.Context) error {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_fn

	var _arg0 *C.GInputStream // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_InputStream_virtual_close_fn(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// readAsync: request an asynchronous read of count bytes from the stream into
// the buffer starting at buffer. When the operation is finished callback will
// be called. You can then call g_input_stream_read_finish() to get the result
// of the operation.
//
// During an async request no other sync and async calls are allowed on stream,
// and will result in G_IO_ERROR_PENDING errors.
//
// A value of count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer will be passed to the
// callback. It is not an error if this is not the same as the requested size,
// as it can happen e.g. near the end of a file, but generally we try to read
// as many bytes as requested. Zero is returned on end of file (or if count is
// zero), but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer (optional): a buffer to read data into (which should be at least
//     count bytes long).
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) readAsync(ctx context.Context, buffer []byte, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.read_async

	var _arg0 *C.GInputStream // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.void         // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_InputStream_virtual_read_async(unsafe.Pointer(fnarg), _arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// readFinish finishes an asynchronous stream read operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize: number of bytes read in, or -1 on error, or 0 on end of file.
func (stream *InputStream) readFinish(result AsyncResulter) (int, error) {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.read_finish

	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_InputStream_virtual_read_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// Skip tries to skip count bytes from the stream. Will block during the
// operation.
//
// This is identical to g_input_stream_read(), from a behaviour standpoint,
// but the bytes that are skipped are not returned to the user. Some streams
// have an implementation that is more efficient than reading the data.
//
// This function is optional for inherited classes, as the default
// implementation emulates it using read.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: number of bytes that will be skipped from the stream.
//
// The function returns the following values:
//
//   - gssize: number of bytes skipped, or -1 on error.
func (stream *InputStream) skip(ctx context.Context, count uint) (int, error) {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.skip

	var _arg0 *C.GInputStream // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.gsize         // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gsize(count)

	_cret = C._gotk4_gio2_InputStream_virtual_skip(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// skipAsync: request an asynchronous skip of count bytes from the stream.
// When the operation is finished callback will be called. You can then call
// g_input_stream_skip_finish() to get the result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// A value of count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes skipped will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it can
// happen e.g. near the end of a file, but generally we try to skip as many
// bytes as requested. Zero is returned on end of file (or if count is zero),
// but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one, you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - count: number of bytes that will be skipped from the stream.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *InputStream) skipAsync(ctx context.Context, count uint, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.skip_async

	var _arg0 *C.GInputStream       // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.gsize               // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gsize(count)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_InputStream_virtual_skip_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// skipFinish finishes a stream skip operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize: size of the bytes skipped, or -1 on error.
func (stream *InputStream) skipFinish(result AsyncResulter) (int, error) {
	gclass := (*C.GInputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.skip_finish

	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_InputStream_virtual_skip_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// ListStoreOverrides contains methods that are overridable.
type ListStoreOverrides struct {
}

func defaultListStoreOverrides(v *ListStore) ListStoreOverrides {
	return ListStoreOverrides{}
}

// ListStore: GListStore is a simple implementation of gio.ListModel that stores
// all items in memory.
//
// It provides insertions, deletions, and lookups in logarithmic time with a
// fast path for the common case of iterating the list linearly.
type ListStore struct {
	_ [0]func() // equal guard
	*coreglib.Object

	ListModel
}

var (
	_ coreglib.Objector = (*ListStore)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ListStore, *ListStoreClass, ListStoreOverrides](
		GTypeListStore,
		initListStoreClass,
		wrapListStore,
		defaultListStoreOverrides,
	)
}

func initListStoreClass(gclass unsafe.Pointer, overrides ListStoreOverrides, classInitFunc func(*ListStoreClass)) {
	if classInitFunc != nil {
		class := (*ListStoreClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapListStore(obj *coreglib.Object) *ListStore {
	return &ListStore{
		Object: obj,
		ListModel: ListModel{
			Object: obj,
		},
	}
}

func marshalListStore(p uintptr) (interface{}, error) {
	return wrapListStore(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewListStore creates a new Store with items of type item_type. item_type must
// be a subclass of #GObject.
//
// The function takes the following parameters:
//
//   - itemType of items in the list.
//
// The function returns the following values:
//
//   - listStore: new Store.
func NewListStore(itemType coreglib.Type) *ListStore {
	var _arg1 C.GType       // out
	var _cret *C.GListStore // in

	_arg1 = C.GType(itemType)

	_cret = C.g_list_store_new(_arg1)
	runtime.KeepAlive(itemType)

	var _listStore *ListStore // out

	_listStore = wrapListStore(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _listStore
}

// Append appends item to store. item must be of type Store:item-type.
//
// This function takes a ref on item.
//
// Use g_list_store_splice() to append multiple items at the same time
// efficiently.
//
// The function takes the following parameters:
//
//   - item: new item.
func (store *ListStore) Append(item *coreglib.Object) {
	var _arg0 *C.GListStore // out
	var _arg1 C.gpointer    // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item.Native()))

	C.g_list_store_append(_arg0, _arg1)
	runtime.KeepAlive(store)
	runtime.KeepAlive(item)
}

// Find looks up the given item in the list store by looping over the items
// until the first occurrence of item. If item was not found, then position will
// not be set, and this method will return FALSE.
//
// If you need to compare the two items with a custom comparison function,
// use g_list_store_find_with_equal_func() with a custom Func instead.
//
// The function takes the following parameters:
//
//   - item: item.
//
// The function returns the following values:
//
//   - position (optional): first position of item, if it was found.
//   - ok: whether store contains item. If it was found, position will be set to
//     the position where item occurred for the first time.
func (store *ListStore) Find(item *coreglib.Object) (uint, bool) {
	var _arg0 *C.GListStore // out
	var _arg1 C.gpointer    // out
	var _arg2 C.guint       // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item.Native()))

	_cret = C.g_list_store_find(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(store)
	runtime.KeepAlive(item)

	var _position uint // out
	var _ok bool       // out

	_position = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _position, _ok
}

// FindWithEqualFuncFull: like g_list_store_find_with_equal_func() but with an
// additional user_data that is passed to equal_func.
//
// item is always passed as second parameter to equal_func.
//
// Since GLib 2.76 it is possible to pass NULL for item.
//
// The function takes the following parameters:
//
//   - item (optional): item.
//   - equalFunc: custom equality check function.
//
// The function returns the following values:
//
//   - position (optional): first position of item, if it was found.
//   - ok: whether store contains item. If it was found, position will be set to
//     the position where item occurred for the first time.
func (store *ListStore) FindWithEqualFuncFull(item *coreglib.Object, equalFunc glib.EqualFuncFull) (uint, bool) {
	var _arg0 *C.GListStore    // out
	var _arg1 C.gpointer       // out
	var _arg2 C.GEqualFuncFull // out
	var _arg3 C.gpointer
	var _arg4 C.guint    // in
	var _cret C.gboolean // in

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item.Native()))
	_arg2 = (*[0]byte)(C._gotk4_glib2_EqualFuncFull)
	_arg3 = C.gpointer(gbox.Assign(equalFunc))
	defer gbox.Delete(uintptr(_arg3))

	_cret = C.g_list_store_find_with_equal_func_full(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(store)
	runtime.KeepAlive(item)
	runtime.KeepAlive(equalFunc)

	var _position uint // out
	var _ok bool       // out

	_position = uint(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _position, _ok
}

// Insert inserts item into store at position. item must be of type
// Store:item-type or derived from it. position must be smaller than the length
// of the list, or equal to it to append.
//
// This function takes a ref on item.
//
// Use g_list_store_splice() to insert multiple items at the same time
// efficiently.
//
// The function takes the following parameters:
//
//   - position at which to insert the new item.
//   - item: new item.
func (store *ListStore) Insert(position uint, item *coreglib.Object) {
	var _arg0 *C.GListStore // out
	var _arg1 C.guint       // out
	var _arg2 C.gpointer    // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.gpointer(unsafe.Pointer(item.Native()))

	C.g_list_store_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(store)
	runtime.KeepAlive(position)
	runtime.KeepAlive(item)
}

// InsertSorted inserts item into store at a position to be determined by the
// compare_func.
//
// The list must already be sorted before calling this function or the result
// is undefined. Usually you would approach this by only ever inserting items by
// way of this function.
//
// This function takes a ref on item.
//
// The function takes the following parameters:
//
//   - item: new item.
//   - compareFunc: pairwise comparison function for sorting.
//
// The function returns the following values:
//
//   - guint: position at which item was inserted.
func (store *ListStore) InsertSorted(item *coreglib.Object, compareFunc glib.CompareDataFunc) uint {
	var _arg0 *C.GListStore      // out
	var _arg1 C.gpointer         // out
	var _arg2 C.GCompareDataFunc // out
	var _arg3 C.gpointer
	var _cret C.guint // in

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item.Native()))
	_arg2 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
	_arg3 = C.gpointer(gbox.Assign(compareFunc))
	defer gbox.Delete(uintptr(_arg3))

	_cret = C.g_list_store_insert_sorted(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(store)
	runtime.KeepAlive(item)
	runtime.KeepAlive(compareFunc)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Remove removes the item from store that is at position. position must be
// smaller than the current length of the list.
//
// Use g_list_store_splice() to remove multiple items at the same time
// efficiently.
//
// The function takes the following parameters:
//
//   - position of the item that is to be removed.
func (store *ListStore) Remove(position uint) {
	var _arg0 *C.GListStore // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = C.guint(position)

	C.g_list_store_remove(_arg0, _arg1)
	runtime.KeepAlive(store)
	runtime.KeepAlive(position)
}

// RemoveAll removes all items from store.
func (store *ListStore) RemoveAll() {
	var _arg0 *C.GListStore // out

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))

	C.g_list_store_remove_all(_arg0)
	runtime.KeepAlive(store)
}

// Sort the items in store according to compare_func.
//
// The function takes the following parameters:
//
//   - compareFunc: pairwise comparison function for sorting.
func (store *ListStore) Sort(compareFunc glib.CompareDataFunc) {
	var _arg0 *C.GListStore      // out
	var _arg1 C.GCompareDataFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
	_arg2 = C.gpointer(gbox.Assign(compareFunc))
	defer gbox.Delete(uintptr(_arg2))

	C.g_list_store_sort(_arg0, _arg1, _arg2)
	runtime.KeepAlive(store)
	runtime.KeepAlive(compareFunc)
}

// Splice changes store by removing n_removals items and adding n_additions
// items to it. additions must contain n_additions items of type
// Store:item-type. NULL is not permitted.
//
// This function is more efficient than g_list_store_insert() and
// g_list_store_remove(), because it only emits Model::items-changed once for
// the change.
//
// This function takes a ref on each item in additions.
//
// The parameters position and n_removals must be correct (ie: position +
// n_removals must be less than or equal to the length of the list at the time
// this function is called).
//
// The function takes the following parameters:
//
//   - position at which to make the change.
//   - nRemovals: number of items to remove.
//   - additions items to add.
func (store *ListStore) Splice(position, nRemovals uint, additions []*coreglib.Object) {
	var _arg0 *C.GListStore // out
	var _arg1 C.guint       // out
	var _arg2 C.guint       // out
	var _arg3 *C.gpointer   // out
	var _arg4 C.guint

	_arg0 = (*C.GListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nRemovals)
	_arg4 = (C.guint)(len(additions))
	_arg3 = (*C.gpointer)(C.calloc(C.size_t(len(additions)), C.size_t(C.sizeof_gpointer)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.gpointer)(_arg3), len(additions))
		for i := range additions {
			out[i] = C.gpointer(unsafe.Pointer(additions[i].Native()))
		}
	}

	C.g_list_store_splice(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(store)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nRemovals)
	runtime.KeepAlive(additions)
}

// MemoryInputStreamOverrides contains methods that are overridable.
type MemoryInputStreamOverrides struct {
}

func defaultMemoryInputStreamOverrides(v *MemoryInputStream) MemoryInputStreamOverrides {
	return MemoryInputStreamOverrides{}
}

// MemoryInputStream: GMemoryInputStream is a class for using arbitrary memory
// chunks as input for GIO streaming input operations.
//
// As of GLib 2.34, GMemoryInputStream implements gio.PollableInputStream.
type MemoryInputStream struct {
	_ [0]func() // equal guard
	InputStream

	*coreglib.Object
	PollableInputStream
	Seekable
}

var (
	_ InputStreamer     = (*MemoryInputStream)(nil)
	_ coreglib.Objector = (*MemoryInputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MemoryInputStream, *MemoryInputStreamClass, MemoryInputStreamOverrides](
		GTypeMemoryInputStream,
		initMemoryInputStreamClass,
		wrapMemoryInputStream,
		defaultMemoryInputStreamOverrides,
	)
}

func initMemoryInputStreamClass(gclass unsafe.Pointer, overrides MemoryInputStreamOverrides, classInitFunc func(*MemoryInputStreamClass)) {
	if classInitFunc != nil {
		class := (*MemoryInputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMemoryInputStream(obj *coreglib.Object) *MemoryInputStream {
	return &MemoryInputStream{
		InputStream: InputStream{
			Object: obj,
		},
		Object: obj,
		PollableInputStream: PollableInputStream{
			InputStream: InputStream{
				Object: obj,
			},
		},
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalMemoryInputStream(p uintptr) (interface{}, error) {
	return wrapMemoryInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMemoryInputStream creates a new empty InputStream.
//
// The function returns the following values:
//
//   - memoryInputStream: new Stream.
func NewMemoryInputStream() *MemoryInputStream {
	var _cret *C.GInputStream // in

	_cret = C.g_memory_input_stream_new()

	var _memoryInputStream *MemoryInputStream // out

	_memoryInputStream = wrapMemoryInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _memoryInputStream
}

// NewMemoryInputStreamFromBytes creates a new InputStream with data from the
// given bytes.
//
// The function takes the following parameters:
//
//   - bytes: #GBytes.
//
// The function returns the following values:
//
//   - memoryInputStream: new Stream read from bytes.
func NewMemoryInputStreamFromBytes(bytes *glib.Bytes) *MemoryInputStream {
	var _arg1 *C.GBytes       // out
	var _cret *C.GInputStream // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.g_memory_input_stream_new_from_bytes(_arg1)
	runtime.KeepAlive(bytes)

	var _memoryInputStream *MemoryInputStream // out

	_memoryInputStream = wrapMemoryInputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _memoryInputStream
}

// AddBytes appends bytes to data that can be read from the input stream.
//
// The function takes the following parameters:
//
//   - bytes: input data.
func (stream *MemoryInputStream) AddBytes(bytes *glib.Bytes) {
	var _arg0 *C.GMemoryInputStream // out
	var _arg1 *C.GBytes             // out

	_arg0 = (*C.GMemoryInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	C.g_memory_input_stream_add_bytes(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(bytes)
}

// MemoryOutputStreamOverrides contains methods that are overridable.
type MemoryOutputStreamOverrides struct {
}

func defaultMemoryOutputStreamOverrides(v *MemoryOutputStream) MemoryOutputStreamOverrides {
	return MemoryOutputStreamOverrides{}
}

// MemoryOutputStream: GMemoryOutputStream is a class for using arbitrary memory
// chunks as output for GIO streaming output operations.
//
// As of GLib 2.34, GMemoryOutputStream trivially implements
// gio.PollableOutputStream: it always polls as ready.
type MemoryOutputStream struct {
	_ [0]func() // equal guard
	OutputStream

	*coreglib.Object
	PollableOutputStream
	Seekable
}

var (
	_ OutputStreamer    = (*MemoryOutputStream)(nil)
	_ coreglib.Objector = (*MemoryOutputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MemoryOutputStream, *MemoryOutputStreamClass, MemoryOutputStreamOverrides](
		GTypeMemoryOutputStream,
		initMemoryOutputStreamClass,
		wrapMemoryOutputStream,
		defaultMemoryOutputStreamOverrides,
	)
}

func initMemoryOutputStreamClass(gclass unsafe.Pointer, overrides MemoryOutputStreamOverrides, classInitFunc func(*MemoryOutputStreamClass)) {
	if classInitFunc != nil {
		class := (*MemoryOutputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMemoryOutputStream(obj *coreglib.Object) *MemoryOutputStream {
	return &MemoryOutputStream{
		OutputStream: OutputStream{
			Object: obj,
		},
		Object: obj,
		PollableOutputStream: PollableOutputStream{
			OutputStream: OutputStream{
				Object: obj,
			},
		},
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalMemoryOutputStream(p uintptr) (interface{}, error) {
	return wrapMemoryOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMemoryOutputStreamResizable creates a new OutputStream, using g_realloc()
// and g_free() for memory allocation.
func NewMemoryOutputStreamResizable() *MemoryOutputStream {
	var _cret *C.GOutputStream // in

	_cret = C.g_memory_output_stream_new_resizable()

	var _memoryOutputStream *MemoryOutputStream // out

	_memoryOutputStream = wrapMemoryOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _memoryOutputStream
}

// Data gets any loaded data from the ostream.
//
// Note that the returned pointer may become invalid on the next write or
// truncate operation on the stream.
//
// The function returns the following values:
//
//   - gpointer (optional): pointer to the stream's data, or NULL if the data
//     has been stolen.
func (ostream *MemoryOutputStream) Data() unsafe.Pointer {
	var _arg0 *C.GMemoryOutputStream // out
	var _cret C.gpointer             // in

	_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(coreglib.InternObject(ostream).Native()))

	_cret = C.g_memory_output_stream_get_data(_arg0)
	runtime.KeepAlive(ostream)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// DataSize returns the number of bytes from the start up to including the last
// byte written in the stream that has not been truncated away.
//
// The function returns the following values:
//
//   - gsize: number of bytes written to the stream.
func (ostream *MemoryOutputStream) DataSize() uint {
	var _arg0 *C.GMemoryOutputStream // out
	var _cret C.gsize                // in

	_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(coreglib.InternObject(ostream).Native()))

	_cret = C.g_memory_output_stream_get_data_size(_arg0)
	runtime.KeepAlive(ostream)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Size gets the size of the currently allocated data area (available from
// g_memory_output_stream_get_data()).
//
// You probably don't want to use this function on resizable streams.
// See g_memory_output_stream_get_data_size() instead. For resizable streams the
// size returned by this function is an implementation detail and may be change
// at any time in response to operations on the stream.
//
// If the stream is fixed-sized (ie: no realloc was passed to
// g_memory_output_stream_new()) then this is the maximum size of the stream and
// further writes will return G_IO_ERROR_NO_SPACE.
//
// In any case, if you want the number of bytes currently written to the stream,
// use g_memory_output_stream_get_data_size().
//
// The function returns the following values:
//
//   - gsize: number of bytes allocated for the data buffer.
func (ostream *MemoryOutputStream) Size() uint {
	var _arg0 *C.GMemoryOutputStream // out
	var _cret C.gsize                // in

	_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(coreglib.InternObject(ostream).Native()))

	_cret = C.g_memory_output_stream_get_size(_arg0)
	runtime.KeepAlive(ostream)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// StealAsBytes returns data from the ostream as a #GBytes. ostream must be
// closed before calling this function.
//
// The function returns the following values:
//
//   - bytes stream's data.
func (ostream *MemoryOutputStream) StealAsBytes() *glib.Bytes {
	var _arg0 *C.GMemoryOutputStream // out
	var _cret *C.GBytes              // in

	_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(coreglib.InternObject(ostream).Native()))

	_cret = C.g_memory_output_stream_steal_as_bytes(_arg0)
	runtime.KeepAlive(ostream)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// StealData gets any loaded data from the ostream. Ownership of the data is
// transferred to the caller; when no longer needed it must be freed using the
// free function set in ostream's OutputStream:destroy-function property.
//
// ostream must be closed before calling this function.
//
// The function returns the following values:
//
//   - gpointer (optional) stream's data, or NULL if it has previously been
//     stolen.
func (ostream *MemoryOutputStream) StealData() unsafe.Pointer {
	var _arg0 *C.GMemoryOutputStream // out
	var _cret C.gpointer             // in

	_arg0 = (*C.GMemoryOutputStream)(unsafe.Pointer(coreglib.InternObject(ostream).Native()))

	_cret = C.g_memory_output_stream_steal_data(_arg0)
	runtime.KeepAlive(ostream)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Menu: GMenu is a simple implementation of gio.MenuModel. You populate a GMenu
// by adding gio.MenuItem instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding gio.MenuItem) for the common cases. To add a regular item,
// use gio.Menu.Insert(). To add a section, use gio.Menu.InsertSection().
// To add a submenu, use gio.Menu.InsertSubmenu().
type Menu struct {
	_ [0]func() // equal guard
	MenuModel
}

var (
	_ MenuModeller = (*Menu)(nil)
)

func wrapMenu(obj *coreglib.Object) *Menu {
	return &Menu{
		MenuModel: MenuModel{
			Object: obj,
		},
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	return wrapMenu(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMenu creates a new #GMenu.
//
// The new menu has no items.
//
// The function returns the following values:
//
//   - menu: new #GMenu.
func NewMenu() *Menu {
	var _cret *C.GMenu // in

	_cret = C.g_menu_new()

	var _menu *Menu // out

	_menu = wrapMenu(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menu
}

// Append: convenience function for appending a normal menu item to the end of
// menu. Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - detailedAction (optional): detailed action string, or NULL.
func (menu *Menu) Append(label, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if detailedAction != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.g_menu_append(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// AppendItem appends item to the end of menu.
//
// See g_menu_insert_item() for more information.
//
// The function takes the following parameters:
//
//   - item to append.
func (menu *Menu) AppendItem(item *MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(item).Native()))

	C.g_menu_append_item(_arg0, _arg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(item)
}

// AppendSection: convenience function for appending a section menu item to the
// end of menu. Combine g_menu_item_new_section() and g_menu_insert_item() for a
// more flexible alternative.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - section with the items of the section.
func (menu *Menu) AppendSection(label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(section).Native()))

	C.g_menu_append_section(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// AppendSubmenu: convenience function for appending a submenu menu item to the
// end of menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
// more flexible alternative.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - submenu with the items of the submenu.
func (menu *Menu) AppendSubmenu(label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(submenu).Native()))

	C.g_menu_append_submenu(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Freeze marks menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any changes to
// it. In effect this means that the #GMenu API must no longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning FALSE,
// which has some positive performance implications.
func (menu *Menu) Freeze() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))

	C.g_menu_freeze(_arg0)
	runtime.KeepAlive(menu)
}

// Insert: convenience function for inserting a normal menu item into menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
//
// The function takes the following parameters:
//
//   - position at which to insert the item.
//   - label (optional): section label, or NULL.
//   - detailedAction (optional): detailed action string, or NULL.
func (menu *Menu) Insert(position int, label, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	_arg1 = C.gint(position)
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if detailedAction != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// InsertItem inserts item into menu.
//
// The "insertion" is actually done by copying all of the attribute and link
// values of item and using them to form a new item within menu. As such,
// item itself is not really inserted, but rather, a menu item that is exactly
// the same as the one presently described by item.
//
// This means that item is essentially useless after the insertion occurs.
// Any changes you make to it are ignored unless it is inserted again (at which
// point its updated values will be copied).
//
// You should probably just free item once you're done.
//
// There are many convenience functions to take care of common cases. See
// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as well
// as "prepend" and "append" variants of each of these functions.
//
// The function takes the following parameters:
//
//   - position at which to insert the item.
//   - item to insert.
func (menu *Menu) InsertItem(position int, item *MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 C.gint       // out
	var _arg2 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(item).Native()))

	C.g_menu_insert_item(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(item)
}

// InsertSection: convenience function for inserting a section menu item into
// menu. Combine g_menu_item_new_section() and g_menu_insert_item() for a more
// flexible alternative.
//
// The function takes the following parameters:
//
//   - position at which to insert the item.
//   - label (optional): section label, or NULL.
//   - section with the items of the section.
func (menu *Menu) InsertSection(position int, label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	_arg1 = C.gint(position)
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(section).Native()))

	C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// InsertSubmenu: convenience function for inserting a submenu menu item into
// menu. Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
// flexible alternative.
//
// The function takes the following parameters:
//
//   - position at which to insert the item.
//   - label (optional): section label, or NULL.
//   - submenu with the items of the submenu.
func (menu *Menu) InsertSubmenu(position int, label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	_arg1 = C.gint(position)
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(submenu).Native()))

	C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Prepend: convenience function for prepending a normal menu item to the
// start of menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - detailedAction (optional): detailed action string, or NULL.
func (menu *Menu) Prepend(label, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if detailedAction != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.g_menu_prepend(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// PrependItem prepends item to the start of menu.
//
// See g_menu_insert_item() for more information.
//
// The function takes the following parameters:
//
//   - item to prepend.
func (menu *Menu) PrependItem(item *MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(item).Native()))

	C.g_menu_prepend_item(_arg0, _arg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(item)
}

// PrependSection: convenience function for prepending a section menu item to
// the start of menu. Combine g_menu_item_new_section() and g_menu_insert_item()
// for a more flexible alternative.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - section with the items of the section.
func (menu *Menu) PrependSection(label string, section MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(section).Native()))

	C.g_menu_prepend_section(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// PrependSubmenu: convenience function for prepending a submenu menu item to
// the start of menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
// for a more flexible alternative.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - submenu with the items of the submenu.
func (menu *Menu) PrependSubmenu(label string, submenu MenuModeller) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(submenu).Native()))

	C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Remove removes an item from the menu.
//
// position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one less than
// the number of items in the menu.
//
// It is not possible to remove items by identity since items are added to the
// menu simply by copying their links and attributes (ie: identity of the item
// itself is not preserved).
//
// The function takes the following parameters:
//
//   - position of the item to remove.
func (menu *Menu) Remove(position int) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	_arg1 = C.gint(position)

	C.g_menu_remove(_arg0, _arg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
}

// RemoveAll removes all items in the menu.
func (menu *Menu) RemoveAll() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(coreglib.InternObject(menu).Native()))

	C.g_menu_remove_all(_arg0)
	runtime.KeepAlive(menu)
}

// MenuAttributeIterOverrides contains methods that are overridable.
type MenuAttributeIterOverrides struct {
	// Next: this function combines g_menu_attribute_iter_next() with
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) attribute.
	// If that fails, then FALSE is returned and there are no other effects.
	//
	// If successful, name and value are set to the name and value of
	// the attribute that has just been advanced to. At this point,
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
	// will return the same values again.
	//
	// The value returned in name remains valid for as long as the iterator
	// remains at the current position. The value returned in value must be
	// unreffed using g_variant_unref() when it is no longer in use.
	//
	// The function returns the following values:
	//
	//   - outName (optional): type of the attribute.
	//   - value (optional): attribute value.
	//   - ok: TRUE on success, or FALSE if there is no additional attribute.
	Next func() (string, *glib.Variant, bool)
}

func defaultMenuAttributeIterOverrides(v *MenuAttributeIter) MenuAttributeIterOverrides {
	return MenuAttributeIterOverrides{
		Next: v.next,
	}
}

// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
type MenuAttributeIter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MenuAttributeIter)(nil)
)

// MenuAttributeIterer describes types inherited from class MenuAttributeIter.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuAttributeIterer interface {
	coreglib.Objector
	baseMenuAttributeIter() *MenuAttributeIter
}

var _ MenuAttributeIterer = (*MenuAttributeIter)(nil)

func init() {
	coreglib.RegisterClassInfo[*MenuAttributeIter, *MenuAttributeIterClass, MenuAttributeIterOverrides](
		GTypeMenuAttributeIter,
		initMenuAttributeIterClass,
		wrapMenuAttributeIter,
		defaultMenuAttributeIterOverrides,
	)
}

func initMenuAttributeIterClass(gclass unsafe.Pointer, overrides MenuAttributeIterOverrides, classInitFunc func(*MenuAttributeIterClass)) {
	pclass := (*C.GMenuAttributeIterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMenuAttributeIter))))

	if overrides.Next != nil {
		pclass.get_next = (*[0]byte)(C._gotk4_gio2_MenuAttributeIterClass_get_next)
	}

	if classInitFunc != nil {
		class := (*MenuAttributeIterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMenuAttributeIter(obj *coreglib.Object) *MenuAttributeIter {
	return &MenuAttributeIter{
		Object: obj,
	}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	return wrapMenuAttributeIter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (iter *MenuAttributeIter) baseMenuAttributeIter() *MenuAttributeIter {
	return iter
}

// BaseMenuAttributeIter returns the underlying base object.
func BaseMenuAttributeIter(obj MenuAttributeIterer) *MenuAttributeIter {
	return obj.baseMenuAttributeIter()
}

// Name gets the name of the attribute at the current iterator position,
// as a string.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//   - utf8: name of the attribute.
func (iter *MenuAttributeIter) Name() string {
	var _arg0 *C.GMenuAttributeIter // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_attribute_iter_get_name(_arg0)
	runtime.KeepAlive(iter)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GetNext: this function combines g_menu_attribute_iter_next() with
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) attribute.
// If that fails, then FALSE is returned and there are no other effects.
//
// If successful, name and value are set to the name and value of
// the attribute that has just been advanced to. At this point,
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
// return the same values again.
//
// The value returned in name remains valid for as long as the iterator remains
// at the current position. The value returned in value must be unreffed using
// g_variant_unref() when it is no longer in use.
//
// The function returns the following values:
//
//   - outName (optional): type of the attribute.
//   - value (optional): attribute value.
//   - ok: TRUE on success, or FALSE if there is no additional attribute.
func (iter *MenuAttributeIter) GetNext() (string, *glib.Variant, bool) {
	var _arg0 *C.GMenuAttributeIter // out
	var _arg1 *C.gchar              // in
	var _arg2 *C.GVariant           // in
	var _cret C.gboolean            // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_attribute_iter_get_next(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _outName string      // out
	var _value *glib.Variant // out
	var _ok bool             // out

	if _arg1 != nil {
		_outName = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		_value = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_value)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _outName, _value, _ok
}

// Value gets the value of the attribute at the current iterator position.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//   - variant: value of the current attribute.
func (iter *MenuAttributeIter) Value() *glib.Variant {
	var _arg0 *C.GMenuAttributeIter // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_attribute_iter_get_value(_arg0)
	runtime.KeepAlive(iter)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Next attempts to advance the iterator to the next (possibly first) attribute.
//
// TRUE is returned on success, or FALSE if there are no more attributes.
//
// You must call this function when you first acquire the iterator to advance it
// to the first attribute (and determine if the first attribute exists at all).
//
// The function returns the following values:
//
//   - ok: TRUE on success, or FALSE when there are no more attributes.
func (iter *MenuAttributeIter) Next() bool {
	var _arg0 *C.GMenuAttributeIter // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_attribute_iter_next(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next: this function combines g_menu_attribute_iter_next() with
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) attribute.
// If that fails, then FALSE is returned and there are no other effects.
//
// If successful, name and value are set to the name and value of
// the attribute that has just been advanced to. At this point,
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
// return the same values again.
//
// The value returned in name remains valid for as long as the iterator remains
// at the current position. The value returned in value must be unreffed using
// g_variant_unref() when it is no longer in use.
//
// The function returns the following values:
//
//   - outName (optional): type of the attribute.
//   - value (optional): attribute value.
//   - ok: TRUE on success, or FALSE if there is no additional attribute.
func (iter *MenuAttributeIter) next() (string, *glib.Variant, bool) {
	gclass := (*C.GMenuAttributeIterClass)(coreglib.PeekParentClass(iter))
	fnarg := gclass.get_next

	var _arg0 *C.GMenuAttributeIter // out
	var _arg1 *C.gchar              // in
	var _arg2 *C.GVariant           // in
	var _cret C.gboolean            // in

	_arg0 = (*C.GMenuAttributeIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C._gotk4_gio2_MenuAttributeIter_virtual_get_next(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _outName string      // out
	var _value *glib.Variant // out
	var _ok bool             // out

	if _arg1 != nil {
		_outName = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		_value = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_value)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _outName, _value, _ok
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MenuItem)(nil)
)

func wrapMenuItem(obj *coreglib.Object) *MenuItem {
	return &MenuItem{
		Object: obj,
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	return wrapMenuItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMenuItem creates a new Item.
//
// If label is non-NULL it is used to set the "label" attribute of the new item.
//
// If detailed_action is non-NULL it is used to set the "action" and possibly
// the "target" attribute of the new item. See g_menu_item_set_detailed_action()
// for more information.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - detailedAction (optional): detailed action string, or NULL.
//
// The function returns the following values:
//
//   - menuItem: new Item.
func NewMenuItem(label, detailedAction string) *MenuItem {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GMenuItem // in

	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if detailedAction != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_menu_item_new(_arg1, _arg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemFromModel creates a Item as an exact copy of an existing menu item
// in a Model.
//
// item_index must be valid (ie: be sure to call g_menu_model_get_n_items()
// first).
//
// The function takes the following parameters:
//
//   - model: Model.
//   - itemIndex: index of an item in model.
//
// The function returns the following values:
//
//   - menuItem: new Item.
func NewMenuItemFromModel(model MenuModeller, itemIndex int) *MenuItem {
	var _arg1 *C.GMenuModel // out
	var _arg2 C.gint        // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg2 = C.gint(itemIndex)

	_cret = C.g_menu_item_new_from_model(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemSection creates a new Item representing a section.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
//
// The effect of having one menu appear as a section of another is exactly
// as it sounds: the items from section become a direct part of the menu that
// menu_item is added to.
//
// Visual separation is typically displayed between two non-empty sections. If
// label is non-NULL then it will be encorporated into this visual indication.
// This allows for labeled subsections of a menu.
//
// As a simple example, consider a typical "Edit" menu from a simple program.
// It probably contains an "Undo" and "Redo" item, followed by a separator,
// followed by "Cut", "Copy" and "Paste".
//
// This would be accomplished by creating three #GMenu instances. The first
// would be populated with the "Undo" and "Redo" items, and the second with the
// "Cut", "Copy" and "Paste" items. The first and second menus would then be
// added as submenus of the third. In XML format, this would look something like
// the following:
//
//	<menu id='edit-menu'>
//	  <section>
//	    <item label='Undo'/>
//	    <item label='Redo'/>
//	  </section>
//	  <section>
//	    <item label='Cut'/>
//	    <item label='Copy'/>
//	    <item label='Paste'/>
//	  </section>
//	</menu>
//
// The following example is exactly equivalent. It is more illustrative of the
// exact relationship between the menus and items (keeping in mind that the
// 'link' element defines a new menu that is linked to the containing one).
// The style of the second example is more verbose and difficult to read (and
// therefore not recommended except for the purpose of understanding what is
// really going on).
//
//	<menu id='edit-menu'>
//	  <item>
//	    <link name='section'>
//	      <item label='Undo'/>
//	      <item label='Redo'/>
//	    </link>
//	  </item>
//	  <item>
//	    <link name='section'>
//	      <item label='Cut'/>
//	      <item label='Copy'/>
//	      <item label='Paste'/>
//	    </link>
//	  </item>
//	</menu>.
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - section with the items of the section.
//
// The function returns the following values:
//
//   - menuItem: new Item.
func NewMenuItemSection(label string, section MenuModeller) *MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(section).Native()))

	_cret = C.g_menu_item_new_section(_arg1, _arg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemSubmenu creates a new Item representing a submenu.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
//
// The function takes the following parameters:
//
//   - label (optional): section label, or NULL.
//   - submenu with the items of the submenu.
//
// The function returns the following values:
//
//   - menuItem: new Item.
func NewMenuItemSubmenu(label string, submenu MenuModeller) *MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(submenu).Native()))

	_cret = C.g_menu_item_new_submenu(_arg1, _arg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)

	var _menuItem *MenuItem // out

	_menuItem = wrapMenuItem(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _menuItem
}

// AttributeValue queries the named attribute on menu_item.
//
// If expected_type is specified and the attribute does not have this type, NULL
// is returned. NULL is also returned if the attribute simply does not exist.
//
// The function takes the following parameters:
//
//   - attribute name to query.
//   - expectedType (optional): expected type of the attribute.
//
// The function returns the following values:
//
//   - variant (optional): attribute value, or NULL.
func (menuItem *MenuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuItem    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	if expectedType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(expectedType)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Link queries the named link on menu_item.
//
// The function takes the following parameters:
//
//   - link name to query.
//
// The function returns the following values:
//
//   - menuModel (optional): link, or NULL.
func (menuItem *MenuItem) Link(link string) MenuModeller {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_menu_item_get_link(_arg0, _arg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(link)

	var _menuModel MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// SetActionAndTargetValue sets or unsets the "action" and "target" attributes
// of menu_item.
//
// If action is NULL then both the "action" and "target" attributes are unset
// (and target_value is ignored).
//
// If action is non-NULL then the "action" attribute is set. The "target"
// attribute is then set to the value of target_value if it is non-NULL or unset
// otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item types) are
// expected to have the "action" attribute set to identify the action that
// they are associated with. The state type of the action help to determine
// the disposition of the menu item. See #GAction and Group for an overview of
// actions.
//
// In general, clicking on the menu item will result in activation of the named
// action with the "target" attribute given as the parameter to the action
// invocation. If the "target" attribute is not set then the action is invoked
// with no parameter.
//
// If the action has no state then the menu item is usually drawn as a plain
// menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn as a
// toggle menu item (ie: with a checkmark or equivalent indication). The item
// should be marked as 'toggled' or 'checked' when the boolean state is TRUE.
//
// If the action has a string state then the menu item is usually drawn as a
// radio menu item (ie: with a radio bullet or equivalent indication). The item
// should be marked as 'selected' when the string state is equal to the value of
// the target property.
//
// See g_menu_item_set_action_and_target() or g_menu_item_set_detailed_action()
// for two equivalent calls that are probably more convenient for most uses.
//
// The function takes the following parameters:
//
//   - action (optional): name of the action for this item.
//   - targetValue (optional) to use as the action target.
func (menuItem *MenuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	if action != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(action)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if targetValue != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(targetValue)))
	}

	C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(action)
	runtime.KeepAlive(targetValue)
}

// SetAttributeValue sets or unsets an attribute on menu_item.
//
// The attribute to set or unset is specified by attribute. This can be one of
// the standard attribute names G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, or a custom attribute name. Attribute names are
// restricted to lowercase characters, numbers and '-'. Furthermore, the names
// must begin with a lowercase character, must not end with a '-', and must not
// contain consecutive dashes.
//
// must consist only of lowercase ASCII characters, digits and '-'.
//
// If value is non-NULL then it is used as the new value for the attribute.
// If value is NULL then the attribute is unset. If the value #GVariant is
// floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do the
// same.
//
// The function takes the following parameters:
//
//   - attribute to set.
//   - value (optional) to use as the value, or NULL.
func (menuItem *MenuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	if value != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	}

	C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
}

// SetDetailedAction sets the "action" and possibly the "target" attribute of
// menu_item.
//
// The format of detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but slightly
// less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of the
// semantics of the action and target attributes.
//
// The function takes the following parameters:
//
//   - detailedAction: "detailed" action string.
func (menuItem *MenuItem) SetDetailedAction(detailedAction string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_detailed_action(_arg0, _arg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(detailedAction)
}

// SetIcon sets (or unsets) the icon on menu_item.
//
// This call is the same as calling g_icon_serialize() and using the result as
// the value to g_menu_item_set_attribute_value() for G_MENU_ATTRIBUTE_ICON.
//
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu. Don't use it on menu items
// corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
//
// If icon is NULL then the icon is unset.
//
// The function takes the following parameters:
//
//   - icon or NULL.
func (menuItem *MenuItem) SetIcon(icon Iconner) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.g_menu_item_set_icon(_arg0, _arg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(icon)
}

// SetLabel sets or unsets the "label" attribute of menu_item.
//
// If label is non-NULL it is used as the label for the menu item. If it is NULL
// then the label attribute is unset.
//
// The function takes the following parameters:
//
//   - label (optional) to set, or NULL to unset.
func (menuItem *MenuItem) SetLabel(label string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	if label != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_menu_item_set_label(_arg0, _arg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(label)
}

// SetLink creates a link from menu_item to model if non-NULL, or unsets it.
//
// Links are used to establish a relationship between a particular menu item
// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate
// a submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
// create a section. Other types of link can be used, but there is no guarantee
// that clients will be able to make sense of them. Link types are restricted
// to lowercase characters, numbers and '-'. Furthermore, the names must begin
// with a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// The function takes the following parameters:
//
//   - link: type of link to establish or unset.
//   - model (optional) to link to (or NULL to unset).
func (menuItem *MenuItem) SetLink(link string, model MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(_arg1))
	if model != nil {
		_arg2 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.g_menu_item_set_link(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(link)
	runtime.KeepAlive(model)
}

// SetSection sets or unsets the "section" link of menu_item to section.
//
// The effect of having one menu appear as a section of another is exactly
// as it sounds: the items from section become a direct part of the menu that
// menu_item is added to. See g_menu_item_new_section() for more information
// about what it means for a menu item to be a section.
//
// The function takes the following parameters:
//
//   - section (optional) or NULL.
func (menuItem *MenuItem) SetSection(section MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	if section != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(section).Native()))
	}

	C.g_menu_item_set_section(_arg0, _arg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(section)
}

// SetSubmenu sets or unsets the "submenu" link of menu_item to submenu.
//
// If submenu is non-NULL, it is linked to. If it is NULL then the link is
// unset.
//
// The effect of having one menu appear as a submenu of another is exactly as it
// sounds.
//
// The function takes the following parameters:
//
//   - submenu (optional) or NULL.
func (menuItem *MenuItem) SetSubmenu(submenu MenuModeller) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	if submenu != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(submenu).Native()))
	}

	C.g_menu_item_set_submenu(_arg0, _arg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(submenu)
}

// MenuLinkIterOverrides contains methods that are overridable.
type MenuLinkIterOverrides struct {
	// Next: this function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) link.
	// If that fails, then FALSE is returned and there are no other effects.
	//
	// If successful, out_link and value are set to the name and Model
	// of the link that has just been advanced to. At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
	// the same values again.
	//
	// The value returned in out_link remains valid for as long as the iterator
	// remains at the current position. The value returned in value must be
	// unreffed using g_object_unref() when it is no longer in use.
	//
	// The function returns the following values:
	//
	//   - outLink (optional): name of the link.
	//   - value (optional): linked Model.
	//   - ok: TRUE on success, or FALSE if there is no additional link.
	Next func() (string, MenuModeller, bool)
}

func defaultMenuLinkIterOverrides(v *MenuLinkIter) MenuLinkIterOverrides {
	return MenuLinkIterOverrides{
		Next: v.next,
	}
}

// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
type MenuLinkIter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MenuLinkIter)(nil)
)

// MenuLinkIterer describes types inherited from class MenuLinkIter.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuLinkIterer interface {
	coreglib.Objector
	baseMenuLinkIter() *MenuLinkIter
}

var _ MenuLinkIterer = (*MenuLinkIter)(nil)

func init() {
	coreglib.RegisterClassInfo[*MenuLinkIter, *MenuLinkIterClass, MenuLinkIterOverrides](
		GTypeMenuLinkIter,
		initMenuLinkIterClass,
		wrapMenuLinkIter,
		defaultMenuLinkIterOverrides,
	)
}

func initMenuLinkIterClass(gclass unsafe.Pointer, overrides MenuLinkIterOverrides, classInitFunc func(*MenuLinkIterClass)) {
	pclass := (*C.GMenuLinkIterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMenuLinkIter))))

	if overrides.Next != nil {
		pclass.get_next = (*[0]byte)(C._gotk4_gio2_MenuLinkIterClass_get_next)
	}

	if classInitFunc != nil {
		class := (*MenuLinkIterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMenuLinkIter(obj *coreglib.Object) *MenuLinkIter {
	return &MenuLinkIter{
		Object: obj,
	}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	return wrapMenuLinkIter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (iter *MenuLinkIter) baseMenuLinkIter() *MenuLinkIter {
	return iter
}

// BaseMenuLinkIter returns the underlying base object.
func BaseMenuLinkIter(obj MenuLinkIterer) *MenuLinkIter {
	return obj.baseMenuLinkIter()
}

// Name gets the name of the link at the current iterator position.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//   - utf8: type of the link.
func (iter *MenuLinkIter) Name() string {
	var _arg0 *C.GMenuLinkIter // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_link_iter_get_name(_arg0)
	runtime.KeepAlive(iter)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GetNext: this function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) link. If that
// fails, then FALSE is returned and there are no other effects.
//
// If successful, out_link and value are set to the name and Model of the link
// that has just been advanced to. At this point, g_menu_link_iter_get_name()
// and g_menu_link_iter_get_value() will return the same values again.
//
// The value returned in out_link remains valid for as long as the iterator
// remains at the current position. The value returned in value must be unreffed
// using g_object_unref() when it is no longer in use.
//
// The function returns the following values:
//
//   - outLink (optional): name of the link.
//   - value (optional): linked Model.
//   - ok: TRUE on success, or FALSE if there is no additional link.
func (iter *MenuLinkIter) GetNext() (string, MenuModeller, bool) {
	var _arg0 *C.GMenuLinkIter // out
	var _arg1 *C.gchar         // in
	var _arg2 *C.GMenuModel    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_link_iter_get_next(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _outLink string     // out
	var _value MenuModeller // out
	var _ok bool            // out

	if _arg1 != nil {
		_outLink = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_value = rv
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _outLink, _value, _ok
}

// Value gets the linked Model at the current iterator position.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//   - menuModel that is linked to.
func (iter *MenuLinkIter) Value() MenuModeller {
	var _arg0 *C.GMenuLinkIter // out
	var _cret *C.GMenuModel    // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_link_iter_get_value(_arg0)
	runtime.KeepAlive(iter)

	var _menuModel MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuModeller)
			return ok
		})
		rv, ok := casted.(MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// Next attempts to advance the iterator to the next (possibly first) link.
//
// TRUE is returned on success, or FALSE if there are no more links.
//
// You must call this function when you first acquire the iterator to advance it
// to the first link (and determine if the first link exists at all).
//
// The function returns the following values:
//
//   - ok: TRUE on success, or FALSE when there are no more links.
func (iter *MenuLinkIter) Next() bool {
	var _arg0 *C.GMenuLinkIter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C.g_menu_link_iter_next(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next: this function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) link. If that
// fails, then FALSE is returned and there are no other effects.
//
// If successful, out_link and value are set to the name and Model of the link
// that has just been advanced to. At this point, g_menu_link_iter_get_name()
// and g_menu_link_iter_get_value() will return the same values again.
//
// The value returned in out_link remains valid for as long as the iterator
// remains at the current position. The value returned in value must be unreffed
// using g_object_unref() when it is no longer in use.
//
// The function returns the following values:
//
//   - outLink (optional): name of the link.
//   - value (optional): linked Model.
//   - ok: TRUE on success, or FALSE if there is no additional link.
func (iter *MenuLinkIter) next() (string, MenuModeller, bool) {
	gclass := (*C.GMenuLinkIterClass)(coreglib.PeekParentClass(iter))
	fnarg := gclass.get_next

	var _arg0 *C.GMenuLinkIter // out
	var _arg1 *C.gchar         // in
	var _arg2 *C.GMenuModel    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GMenuLinkIter)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_cret = C._gotk4_gio2_MenuLinkIter_virtual_get_next(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _outLink string     // out
	var _value MenuModeller // out
	var _ok bool            // out

	if _arg1 != nil {
		_outLink = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_value = rv
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _outLink, _value, _ok
}

// MenuModelOverrides contains methods that are overridable.
type MenuModelOverrides struct {
	// ItemAttributeValue queries the item at position item_index in model for
	// the attribute specified by attribute.
	//
	// If expected_type is non-NULL then it specifies the expected type of the
	// attribute. If it is NULL then any type will be accepted.
	//
	// If the attribute exists and matches expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// NULL is returned.
	//
	// The function takes the following parameters:
	//
	//   - itemIndex: index of the item.
	//   - attribute to query.
	//   - expectedType (optional): expected type of the attribute, or NULL.
	//
	// The function returns the following values:
	//
	//   - variant (optional): value of the attribute.
	ItemAttributeValue func(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant
	// ItemAttributes gets all the attributes associated with the item in the
	// menu model.
	//
	// The function takes the following parameters:
	//
	//   - itemIndex to query.
	//
	// The function returns the following values:
	//
	//   - attributes attributes on the item.
	ItemAttributes func(itemIndex int) map[string]*glib.Variant
	// ItemLink queries the item at position item_index in model for the link
	// specified by link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, NULL is returned.
	//
	// The function takes the following parameters:
	//
	//   - itemIndex: index of the item.
	//   - link to query.
	//
	// The function returns the following values:
	//
	//   - menuModel (optional): linked Model, or NULL.
	ItemLink func(itemIndex int, link string) MenuModeller
	// ItemLinks gets all the links associated with the item in the menu model.
	//
	// The function takes the following parameters:
	//
	//   - itemIndex to query.
	//
	// The function returns the following values:
	//
	//   - links links from the item.
	ItemLinks func(itemIndex int) map[string]MenuModeller
	// NItems: query the number of items in model.
	//
	// The function returns the following values:
	//
	//   - gint: number of items.
	NItems func() int
	// IsMutable queries if model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the model is mutable (ie: "items-changed" may be
	//     emitted).
	IsMutable func() bool
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position item_index in model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// The function takes the following parameters:
	//
	//   - itemIndex: index of the item.
	//
	// The function returns the following values:
	//
	//   - menuAttributeIter: new AttributeIter.
	IterateItemAttributes func(itemIndex int) MenuAttributeIterer
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position item_index in model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// The function takes the following parameters:
	//
	//   - itemIndex: index of the item.
	//
	// The function returns the following values:
	//
	//   - menuLinkIter: new LinkIter.
	IterateItemLinks func(itemIndex int) MenuLinkIterer
}

func defaultMenuModelOverrides(v *MenuModel) MenuModelOverrides {
	return MenuModelOverrides{
		ItemAttributeValue:    v.itemAttributeValue,
		ItemAttributes:        v.itemAttributes,
		ItemLink:              v.itemLink,
		ItemLinks:             v.itemLinks,
		NItems:                v.nItems,
		IsMutable:             v.isMutable,
		IterateItemAttributes: v.iterateItemAttributes,
		IterateItemLinks:      v.iterateItemLinks,
	}
}

// MenuModel: GMenuModel represents the contents of a menu  an ordered
// list of menu items. The items are associated with actions, which can be
// activated through them. Items can be grouped in sections, and may have
// submenus associated with them. Both items and sections usually have some
// representation data, such as labels or icons. The type of the associated
// action (ie whether it is stateful, and what kind of state it has) can
// influence the representation of the item.
//
// The conceptual model of menus in GMenuModel is hierarchical: sections and
// submenus are again represented by GMenuModels. Menus themselves do not define
// their own roles. Rather, the role of a particular GMenuModel is defined by
// the item that references it (or, in the case of the root menu, is defined
// by the context in which it is used).
//
// As an example, consider the visible portions of this menu:
//
// # An example menu
//
// ! (menu-example.png)
//
// There are 8 menus visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items)
//
// - the View submenu (containing 3 sections)
//
// - the first section of the View submenu (containing 2 items)
//
// - the second section of the View submenu (containing 1 item)
//
// - the final section of the View submenu (containing 1 item)
//
// - the Highlight Mode submenu (containing 2 sections)
//
// - the Sources section (containing 2 items)
//
// - the Markup section (containing 2 items)
//
// The example (#a-menu-example) illustrates the conceptual connection between
// these 8 menus. Each large block in the figure represents a menu and the
// smaller blocks within the large block represent items in that menu. Some
// items contain references to other menus.
//
// # A menu example
//
// ! (menu-model.png)
//
// Notice that the separators visible in the example (#an-example-menu) appear
// nowhere in the menu model (#a-menu-example). This is because separators
// are not explicitly represented in the menu model. Instead, a separator is
// inserted between any two non-empty sections of a menu. Section items can have
// labels just like any other item. In that case, a display system may show a
// section header instead of a separator.
//
// The motivation for this abstract model of application controls is that
// modern user interfaces tend to make these controls available outside
// the application. Examples include global menus, jumplists, dash boards,
// etc. To support such uses, it is necessary to export information about
// actions and their representation in menus, which is exactly what the action
// group exporter and the menu model exporter do for gio.ActionGroup and
// gio.MenuModel. The client-side counterparts to make use of the exported
// information are gio.DBusActionGroup and gio.DBusMenuModel.
//
// The API of GMenuModel is very generic, with iterators for the attributes
// and links of an item, see gio.MenuModel.IterateItemAttributes() and
// gio.MenuModel.IterateItemLinks(). The standard attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a GMenuModel represent active controls if they refer to
// an action that can get activated when the user interacts with the
// menu item. The reference to the action is encoded by the string ID
// in the G_MENU_ATTRIBUTE_ACTION attribute. An action ID uniquely
// identifies an action in an action group. Which action group(s) provide
// actions depends on the context in which the menu model is used. E.g.
// when the model is exported as the application menu of a GtkApplication
// (https://docs.gtk.org/gtk4/class.Application.html), actions can be
// application-wide or window-specific (and thus come from two different action
// groups). By convention, the application-wide actions have names that start
// with app., while the names of window-specific actions start with win..
//
// While a wide variety of stateful actions is possible, the following is
// the minimum that is expected to be supported by all users of exported menu
// information:
//
// - an action with no parameter type and no state
//
// - an action with no parameter type and boolean state
//
// - an action with string parameter type and string state
//
// # Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
// # Boolean State
//
// An action with a boolean state will most typically be used with a toggle or
// switch menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as checked when the state is true.
//
// # String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will
// have a target value. Selecting that menu item will result in activation of
// the action with the target value as the parameter. The menu item should be
// rendered as selected when the state of the action is equal to the target
// value of the menu item.
type MenuModel struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MenuModel)(nil)
)

// MenuModeller describes types inherited from class MenuModel.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuModeller interface {
	coreglib.Objector
	baseMenuModel() *MenuModel
}

var _ MenuModeller = (*MenuModel)(nil)

func init() {
	coreglib.RegisterClassInfo[*MenuModel, *MenuModelClass, MenuModelOverrides](
		GTypeMenuModel,
		initMenuModelClass,
		wrapMenuModel,
		defaultMenuModelOverrides,
	)
}

func initMenuModelClass(gclass unsafe.Pointer, overrides MenuModelOverrides, classInitFunc func(*MenuModelClass)) {
	pclass := (*C.GMenuModelClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMenuModel))))

	if overrides.ItemAttributeValue != nil {
		pclass.get_item_attribute_value = (*[0]byte)(C._gotk4_gio2_MenuModelClass_get_item_attribute_value)
	}

	if overrides.ItemAttributes != nil {
		pclass.get_item_attributes = (*[0]byte)(C._gotk4_gio2_MenuModelClass_get_item_attributes)
	}

	if overrides.ItemLink != nil {
		pclass.get_item_link = (*[0]byte)(C._gotk4_gio2_MenuModelClass_get_item_link)
	}

	if overrides.ItemLinks != nil {
		pclass.get_item_links = (*[0]byte)(C._gotk4_gio2_MenuModelClass_get_item_links)
	}

	if overrides.NItems != nil {
		pclass.get_n_items = (*[0]byte)(C._gotk4_gio2_MenuModelClass_get_n_items)
	}

	if overrides.IsMutable != nil {
		pclass.is_mutable = (*[0]byte)(C._gotk4_gio2_MenuModelClass_is_mutable)
	}

	if overrides.IterateItemAttributes != nil {
		pclass.iterate_item_attributes = (*[0]byte)(C._gotk4_gio2_MenuModelClass_iterate_item_attributes)
	}

	if overrides.IterateItemLinks != nil {
		pclass.iterate_item_links = (*[0]byte)(C._gotk4_gio2_MenuModelClass_iterate_item_links)
	}

	if classInitFunc != nil {
		class := (*MenuModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMenuModel(obj *coreglib.Object) *MenuModel {
	return &MenuModel{
		Object: obj,
	}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	return wrapMenuModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (model *MenuModel) baseMenuModel() *MenuModel {
	return model
}

// BaseMenuModel returns the underlying base object.
func BaseMenuModel(obj MenuModeller) *MenuModel {
	return obj.baseMenuModel()
}

// ConnectItemsChanged is emitted when a change has occurred to the menu.
//
// The only changes that can occur to a menu is that items are removed or added.
// Items may not change (except by being removed and added back in the same
// location). This signal is capable of describing both of those changes (at the
// same time).
//
// The signal means that starting at the index position, removed items were
// removed and added items were added in their place. If removed is zero then
// only items were added. If added is zero then only items were removed.
//
// As an example, if the menu contains items a, b, c, d (in that order) and the
// signal (2, 1, 3) occurs then the new composition of the menu will be a, b, _,
// _, _, d (with each _ representing some new item).
//
// Signal handlers may query the model (particularly the added items) and expect
// to see the results of the modification that is being reported. The signal is
// emitted after the modification.
func (model *MenuModel) ConnectItemsChanged(f func(position, removed, added int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(model, "items-changed", false, unsafe.Pointer(C._gotk4_gio2_MenuModel_ConnectItemsChanged), f)
}

// ItemAttributeValue queries the item at position item_index in model for the
// attribute specified by attribute.
//
// If expected_type is non-NULL then it specifies the expected type of the
// attribute. If it is NULL then any type will be accepted.
//
// If the attribute exists and matches expected_type (or if the expected type is
// unspecified) then the value is returned.
//
// If the attribute does not exist, or does not match the expected type then
// NULL is returned.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//   - attribute to query.
//   - expectedType (optional): expected type of the attribute, or NULL.
//
// The function returns the following values:
//
//   - variant (optional): value of the attribute.
func (model *MenuModel) ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuModel   // out
	var _arg1 C.gint          // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))
	if expectedType != nil {
		_arg3 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_cret = C.g_menu_model_get_item_attribute_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(expectedType)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// ItemLink queries the item at position item_index in model for the link
// specified by link.
//
// If the link exists, the linked Model is returned. If the link does not exist,
// NULL is returned.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//   - link to query.
//
// The function returns the following values:
//
//   - menuModel (optional): linked Model, or NULL.
func (model *MenuModel) ItemLink(itemIndex int, link string) MenuModeller {
	var _arg0 *C.GMenuModel // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_menu_model_get_item_link(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(link)

	var _menuModel MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// NItems: query the number of items in model.
//
// The function returns the following values:
//
//   - gint: number of items.
func (model *MenuModel) NItems() int {
	var _arg0 *C.GMenuModel // out
	var _cret C.gint        // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.g_menu_model_get_n_items(_arg0)
	runtime.KeepAlive(model)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsMutable queries if model is mutable.
//
// An immutable Model will never emit the Model::items-changed signal. Consumers
// of the model may make optimisations accordingly.
//
// The function returns the following values:
//
//   - ok: TRUE if the model is mutable (ie: "items-changed" may be emitted).
func (model *MenuModel) IsMutable() bool {
	var _arg0 *C.GMenuModel // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.g_menu_model_is_mutable(_arg0)
	runtime.KeepAlive(model)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ItemsChanged requests emission of the Model::items-changed signal on model.
//
// This function should never be called except by Model subclasses. Any other
// calls to this function will very likely lead to a violation of the interface
// of the model.
//
// The implementation should update its internal representation of the menu
// before emitting the signal. The implementation should further expect to
// receive queries about the new state of the menu (and particularly added menu
// items) while signal handlers are running.
//
// The implementation must dispatch this call directly from a mainloop entry
// and not in response to calls -- particularly those from the Model API.
// Said another way: the menu must not change while user code is running without
// returning to the mainloop.
//
// The function takes the following parameters:
//
//   - position of the change.
//   - removed: number of items removed.
//   - added: number of items added.
func (model *MenuModel) ItemsChanged(position, removed, added int) {
	var _arg0 *C.GMenuModel // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // out
	var _arg3 C.gint        // out

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(position)
	_arg2 = C.gint(removed)
	_arg3 = C.gint(added)

	C.g_menu_model_items_changed(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// IterateItemAttributes creates a AttributeIter to iterate over the attributes
// of the item at position item_index in model.
//
// You must free the iterator with g_object_unref() when you are done.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//
// The function returns the following values:
//
//   - menuAttributeIter: new AttributeIter.
func (model *MenuModel) IterateItemAttributes(itemIndex int) MenuAttributeIterer {
	var _arg0 *C.GMenuModel         // out
	var _arg1 C.gint                // out
	var _cret *C.GMenuAttributeIter // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)

	_cret = C.g_menu_model_iterate_item_attributes(_arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _menuAttributeIter MenuAttributeIterer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuAttributeIterer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuAttributeIterer)
			return ok
		})
		rv, ok := casted.(MenuAttributeIterer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuAttributeIterer")
		}
		_menuAttributeIter = rv
	}

	return _menuAttributeIter
}

// IterateItemLinks creates a LinkIter to iterate over the links of the item at
// position item_index in model.
//
// You must free the iterator with g_object_unref() when you are done.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//
// The function returns the following values:
//
//   - menuLinkIter: new LinkIter.
func (model *MenuModel) IterateItemLinks(itemIndex int) MenuLinkIterer {
	var _arg0 *C.GMenuModel    // out
	var _arg1 C.gint           // out
	var _cret *C.GMenuLinkIter // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)

	_cret = C.g_menu_model_iterate_item_links(_arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _menuLinkIter MenuLinkIterer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuLinkIterer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuLinkIterer)
			return ok
		})
		rv, ok := casted.(MenuLinkIterer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuLinkIterer")
		}
		_menuLinkIter = rv
	}

	return _menuLinkIter
}

// itemAttributeValue queries the item at position item_index in model for the
// attribute specified by attribute.
//
// If expected_type is non-NULL then it specifies the expected type of the
// attribute. If it is NULL then any type will be accepted.
//
// If the attribute exists and matches expected_type (or if the expected type is
// unspecified) then the value is returned.
//
// If the attribute does not exist, or does not match the expected type then
// NULL is returned.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//   - attribute to query.
//   - expectedType (optional): expected type of the attribute, or NULL.
//
// The function returns the following values:
//
//   - variant (optional): value of the attribute.
func (model *MenuModel) itemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.get_item_attribute_value

	var _arg0 *C.GMenuModel   // out
	var _arg1 C.gint          // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))
	if expectedType != nil {
		_arg3 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_cret = C._gotk4_gio2_MenuModel_virtual_get_item_attribute_value(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(expectedType)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// itemAttributes gets all the attributes associated with the item in the menu
// model.
//
// The function takes the following parameters:
//
//   - itemIndex to query.
//
// The function returns the following values:
//
//   - attributes attributes on the item.
func (model *MenuModel) itemAttributes(itemIndex int) map[string]*glib.Variant {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.get_item_attributes

	var _arg0 *C.GMenuModel // out
	var _arg1 C.gint        // out
	var _arg2 *C.GHashTable // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)

	C._gotk4_gio2_MenuModel_virtual_get_item_attributes(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _attributes map[string]*glib.Variant // out

	_attributes = make(map[string]*glib.Variant, gextras.HashTableSize(unsafe.Pointer(_arg2)))
	gextras.MoveHashTable(unsafe.Pointer(_arg2), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.GVariant)(v)
		var kdst string        // out
		var vdst *glib.Variant // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		vdst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(vsrc)))
		C.g_variant_ref(vsrc)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(vdst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
		_attributes[kdst] = vdst
	})

	return _attributes
}

// itemLink queries the item at position item_index in model for the link
// specified by link.
//
// If the link exists, the linked Model is returned. If the link does not exist,
// NULL is returned.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//   - link to query.
//
// The function returns the following values:
//
//   - menuModel (optional): linked Model, or NULL.
func (model *MenuModel) itemLink(itemIndex int, link string) MenuModeller {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.get_item_link

	var _arg0 *C.GMenuModel // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gio2_MenuModel_virtual_get_item_link(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(link)

	var _menuModel MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// itemLinks gets all the links associated with the item in the menu model.
//
// The function takes the following parameters:
//
//   - itemIndex to query.
//
// The function returns the following values:
//
//   - links links from the item.
func (model *MenuModel) itemLinks(itemIndex int) map[string]MenuModeller {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.get_item_links

	var _arg0 *C.GMenuModel // out
	var _arg1 C.gint        // out
	var _arg2 *C.GHashTable // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)

	C._gotk4_gio2_MenuModel_virtual_get_item_links(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _links map[string]MenuModeller // out

	_links = make(map[string]MenuModeller, gextras.HashTableSize(unsafe.Pointer(_arg2)))
	gextras.MoveHashTable(unsafe.Pointer(_arg2), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.GMenuModel)(v)
		var kdst string       // out
		var vdst MenuModeller // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		{
			objptr := unsafe.Pointer(vsrc)
			if objptr == nil {
				panic("object of type gio.MenuModeller is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			vdst = rv
		}
		_links[kdst] = vdst
	})

	return _links
}

// nItems: query the number of items in model.
//
// The function returns the following values:
//
//   - gint: number of items.
func (model *MenuModel) nItems() int {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.get_n_items

	var _arg0 *C.GMenuModel // out
	var _cret C.gint        // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C._gotk4_gio2_MenuModel_virtual_get_n_items(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(model)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// isMutable queries if model is mutable.
//
// An immutable Model will never emit the Model::items-changed signal. Consumers
// of the model may make optimisations accordingly.
//
// The function returns the following values:
//
//   - ok: TRUE if the model is mutable (ie: "items-changed" may be emitted).
func (model *MenuModel) isMutable() bool {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.is_mutable

	var _arg0 *C.GMenuModel // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C._gotk4_gio2_MenuModel_virtual_is_mutable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(model)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// iterateItemAttributes creates a AttributeIter to iterate over the attributes
// of the item at position item_index in model.
//
// You must free the iterator with g_object_unref() when you are done.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//
// The function returns the following values:
//
//   - menuAttributeIter: new AttributeIter.
func (model *MenuModel) iterateItemAttributes(itemIndex int) MenuAttributeIterer {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.iterate_item_attributes

	var _arg0 *C.GMenuModel         // out
	var _arg1 C.gint                // out
	var _cret *C.GMenuAttributeIter // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)

	_cret = C._gotk4_gio2_MenuModel_virtual_iterate_item_attributes(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _menuAttributeIter MenuAttributeIterer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuAttributeIterer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuAttributeIterer)
			return ok
		})
		rv, ok := casted.(MenuAttributeIterer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuAttributeIterer")
		}
		_menuAttributeIter = rv
	}

	return _menuAttributeIter
}

// iterateItemLinks creates a LinkIter to iterate over the links of the item at
// position item_index in model.
//
// You must free the iterator with g_object_unref() when you are done.
//
// The function takes the following parameters:
//
//   - itemIndex: index of the item.
//
// The function returns the following values:
//
//   - menuLinkIter: new LinkIter.
func (model *MenuModel) iterateItemLinks(itemIndex int) MenuLinkIterer {
	gclass := (*C.GMenuModelClass)(coreglib.PeekParentClass(model))
	fnarg := gclass.iterate_item_links

	var _arg0 *C.GMenuModel    // out
	var _arg1 C.gint           // out
	var _cret *C.GMenuLinkIter // in

	_arg0 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.gint(itemIndex)

	_cret = C._gotk4_gio2_MenuModel_virtual_iterate_item_links(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _menuLinkIter MenuLinkIterer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuLinkIterer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuLinkIterer)
			return ok
		})
		rv, ok := casted.(MenuLinkIterer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuLinkIterer")
		}
		_menuLinkIter = rv
	}

	return _menuLinkIter
}

// MountOperationOverrides contains methods that are overridable.
type MountOperationOverrides struct {
	Aborted func()
	// The function takes the following parameters:
	//
	//   - message
	//   - defaultUser
	//   - defaultDomain
	//   - flags
	AskPassword func(message, defaultUser, defaultDomain string, flags AskPasswordFlags)
	// AskQuestion: virtual implementation of Operation::ask-question.
	//
	// The function takes the following parameters:
	//
	//   - message: string containing a message to display to the user.
	//   - choices: array of strings for each possible choice.
	AskQuestion func(message string, choices []string)
	// Reply emits the Operation::reply signal.
	//
	// The function takes the following parameters:
	//
	//   - result: OperationResult.
	Reply func(result MountOperationResult)
	// The function takes the following parameters:
	//
	//   - message
	//   - timeLeft
	//   - bytesLeft
	ShowUnmountProgress func(message string, timeLeft, bytesLeft int64)
}

func defaultMountOperationOverrides(v *MountOperation) MountOperationOverrides {
	return MountOperationOverrides{
		Aborted:             v.aborted,
		AskPassword:         v.askPassword,
		AskQuestion:         v.askQuestion,
		Reply:               v.reply,
		ShowUnmountProgress: v.showUnmountProgress,
	}
}

// MountOperation: GMountOperation provides a mechanism for interacting
// with the user. It can be used for authenticating mountable operations,
// such as loop mounting files, hard drive partitions or server locations.
// It can also be used to ask the user questions or show a list of applications
// preventing unmount or eject operations from completing.
//
// Note that GMountOperation is used for more than just gio.Mount objects  for
// example it is also used in gio.Drive.Start() and gio.Drive.Stop().
//
// Users should instantiate a subclass of this that implements all the
// various callbacks to show the required dialogs, such as GtkMountOperation
// (https://docs.gtk.org/gtk4/class.MountOperation.html). If no user interaction
// is desired (for example when automounting filesystems at login time), usually
// NULL can be passed, see each method taking a GMountOperation for details.
//
// Throughout the API, the term TCRYPT is used to mean compatible with
// TrueCrypt and VeraCrypt. TrueCrypt (https://en.wikipedia.org/wiki/TrueCrypt)
// is a discontinued system for encrypting file containers, partitions or whole
// disks, typically used with Windows. VeraCrypt (https://www.veracrypt.fr/) is
// a maintained fork of TrueCrypt with various improvements and auditing fixes.
type MountOperation struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MountOperation)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MountOperation, *MountOperationClass, MountOperationOverrides](
		GTypeMountOperation,
		initMountOperationClass,
		wrapMountOperation,
		defaultMountOperationOverrides,
	)
}

func initMountOperationClass(gclass unsafe.Pointer, overrides MountOperationOverrides, classInitFunc func(*MountOperationClass)) {
	pclass := (*C.GMountOperationClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMountOperation))))

	if overrides.Aborted != nil {
		pclass.aborted = (*[0]byte)(C._gotk4_gio2_MountOperationClass_aborted)
	}

	if overrides.AskPassword != nil {
		pclass.ask_password = (*[0]byte)(C._gotk4_gio2_MountOperationClass_ask_password)
	}

	if overrides.AskQuestion != nil {
		pclass.ask_question = (*[0]byte)(C._gotk4_gio2_MountOperationClass_ask_question)
	}

	if overrides.Reply != nil {
		pclass.reply = (*[0]byte)(C._gotk4_gio2_MountOperationClass_reply)
	}

	if overrides.ShowUnmountProgress != nil {
		pclass.show_unmount_progress = (*[0]byte)(C._gotk4_gio2_MountOperationClass_show_unmount_progress)
	}

	if classInitFunc != nil {
		class := (*MountOperationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMountOperation(obj *coreglib.Object) *MountOperation {
	return &MountOperation{
		Object: obj,
	}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	return wrapMountOperation(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAborted is emitted by the backend when e.g. a device becomes
// unavailable while a mount operation is in progress.
//
// Implementations of GMountOperation should handle this signal by dismissing
// open password dialogs.
func (op *MountOperation) ConnectAborted(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "aborted", false, unsafe.Pointer(C._gotk4_gio2_MountOperation_ConnectAborted), f)
}

// ConnectAskPassword is emitted when a mount operation asks the user for a
// password.
//
// If the message contains a line break, the first line should be presented as a
// heading. For example, it may be used as the primary text in a MessageDialog.
func (op *MountOperation) ConnectAskPassword(f func(message, defaultUser, defaultDomain string, flags AskPasswordFlags)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "ask-password", false, unsafe.Pointer(C._gotk4_gio2_MountOperation_ConnectAskPassword), f)
}

// ConnectAskQuestion is emitted when asking the user a question and gives a
// list of choices for the user to choose from.
//
// If the message contains a line break, the first line should be presented as a
// heading. For example, it may be used as the primary text in a MessageDialog.
func (op *MountOperation) ConnectAskQuestion(f func(message string, choices []string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "ask-question", false, unsafe.Pointer(C._gotk4_gio2_MountOperation_ConnectAskQuestion), f)
}

// ConnectReply is emitted when the user has replied to the mount operation.
func (op *MountOperation) ConnectReply(f func(result MountOperationResult)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "reply", false, unsafe.Pointer(C._gotk4_gio2_MountOperation_ConnectReply), f)
}

// ConnectShowUnmountProgress is emitted when an unmount operation has been busy
// for more than some time (typically 1.5 seconds).
//
// When unmounting or ejecting a volume, the kernel might need to flush pending
// data in its buffers to the volume stable storage, and this operation can take
// a considerable amount of time. This signal may be emitted several times as
// long as the unmount operation is outstanding, and then one last time when the
// operation is completed, with bytes_left set to zero.
//
// Implementations of GMountOperation should handle this signal by showing
// an UI notification, and then dismiss it, or show another notification of
// completion, when bytes_left reaches zero.
//
// If the message contains a line break, the first line should be presented as a
// heading. For example, it may be used as the primary text in a MessageDialog.
func (op *MountOperation) ConnectShowUnmountProgress(f func(message string, timeLeft, bytesLeft int64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "show-unmount-progress", false, unsafe.Pointer(C._gotk4_gio2_MountOperation_ConnectShowUnmountProgress), f)
}

// NewMountOperation creates a new mount operation.
//
// The function returns the following values:
//
//   - mountOperation: Operation.
func NewMountOperation() *MountOperation {
	var _cret *C.GMountOperation // in

	_cret = C.g_mount_operation_new()

	var _mountOperation *MountOperation // out

	_mountOperation = wrapMountOperation(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mountOperation
}

// Anonymous: check to see whether the mount operation is being used for an
// anonymous user.
//
// The function returns the following values:
//
//   - ok: TRUE if mount operation is anonymous.
func (op *MountOperation) Anonymous() bool {
	var _arg0 *C.GMountOperation // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_anonymous(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Choice gets a choice from the mount operation.
//
// The function returns the following values:
//
//   - gint: integer containing an index of the user's choice from the choice's
//     list, or 0.
func (op *MountOperation) Choice() int {
	var _arg0 *C.GMountOperation // out
	var _cret C.int              // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_choice(_arg0)
	runtime.KeepAlive(op)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Domain gets the domain of the mount operation.
//
// The function returns the following values:
//
//   - utf8 (optional): string set to the domain.
func (op *MountOperation) Domain() string {
	var _arg0 *C.GMountOperation // out
	var _cret *C.char            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_domain(_arg0)
	runtime.KeepAlive(op)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IsTcryptHiddenVolume: check to see whether the mount operation is being used
// for a TCRYPT hidden volume.
//
// The function returns the following values:
//
//   - ok: TRUE if mount operation is for hidden volume.
func (op *MountOperation) IsTcryptHiddenVolume() bool {
	var _arg0 *C.GMountOperation // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_is_tcrypt_hidden_volume(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsTcryptSystemVolume: check to see whether the mount operation is being used
// for a TCRYPT system volume.
//
// The function returns the following values:
//
//   - ok: TRUE if mount operation is for system volume.
func (op *MountOperation) IsTcryptSystemVolume() bool {
	var _arg0 *C.GMountOperation // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_is_tcrypt_system_volume(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Password gets a password from the mount operation.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the password within op.
func (op *MountOperation) Password() string {
	var _arg0 *C.GMountOperation // out
	var _cret *C.char            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_password(_arg0)
	runtime.KeepAlive(op)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PasswordSave gets the state of saving passwords for the mount operation.
//
// The function returns the following values:
//
//   - passwordSave: Save flag.
func (op *MountOperation) PasswordSave() PasswordSave {
	var _arg0 *C.GMountOperation // out
	var _cret C.GPasswordSave    // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_password_save(_arg0)
	runtime.KeepAlive(op)

	var _passwordSave PasswordSave // out

	_passwordSave = PasswordSave(_cret)

	return _passwordSave
}

// Pim gets a PIM from the mount operation.
//
// The function returns the following values:
//
//   - guint: veraCrypt PIM within op.
func (op *MountOperation) Pim() uint {
	var _arg0 *C.GMountOperation // out
	var _cret C.guint            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_pim(_arg0)
	runtime.KeepAlive(op)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Username: get the user name from the mount operation.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the user name.
func (op *MountOperation) Username() string {
	var _arg0 *C.GMountOperation // out
	var _cret *C.char            // in

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.g_mount_operation_get_username(_arg0)
	runtime.KeepAlive(op)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Reply emits the Operation::reply signal.
//
// The function takes the following parameters:
//
//   - result: OperationResult.
func (op *MountOperation) Reply(result MountOperationResult) {
	var _arg0 *C.GMountOperation      // out
	var _arg1 C.GMountOperationResult // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.GMountOperationResult(result)

	C.g_mount_operation_reply(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(result)
}

// SetAnonymous sets the mount operation to use an anonymous user if anonymous
// is TRUE.
//
// The function takes the following parameters:
//
//   - anonymous: boolean value.
func (op *MountOperation) SetAnonymous(anonymous bool) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if anonymous {
		_arg1 = C.TRUE
	}

	C.g_mount_operation_set_anonymous(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(anonymous)
}

// SetChoice sets a default choice for the mount operation.
//
// The function takes the following parameters:
//
//   - choice: integer.
func (op *MountOperation) SetChoice(choice int) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.int              // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.int(choice)

	C.g_mount_operation_set_choice(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(choice)
}

// SetDomain sets the mount operation's domain.
//
// The function takes the following parameters:
//
//   - domain (optional) to set.
func (op *MountOperation) SetDomain(domain string) {
	var _arg0 *C.GMountOperation // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if domain != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_mount_operation_set_domain(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(domain)
}

// SetIsTcryptHiddenVolume sets the mount operation to use a hidden volume if
// hidden_volume is TRUE.
//
// The function takes the following parameters:
//
//   - hiddenVolume: boolean value.
func (op *MountOperation) SetIsTcryptHiddenVolume(hiddenVolume bool) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if hiddenVolume {
		_arg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_hidden_volume(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(hiddenVolume)
}

// SetIsTcryptSystemVolume sets the mount operation to use a system volume if
// system_volume is TRUE.
//
// The function takes the following parameters:
//
//   - systemVolume: boolean value.
func (op *MountOperation) SetIsTcryptSystemVolume(systemVolume bool) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if systemVolume {
		_arg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_system_volume(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(systemVolume)
}

// SetPassword sets the mount operation's password to password.
//
// The function takes the following parameters:
//
//   - password (optional) to set.
func (op *MountOperation) SetPassword(password string) {
	var _arg0 *C.GMountOperation // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if password != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_mount_operation_set_password(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(password)
}

// SetPasswordSave sets the state of saving passwords for the mount operation.
//
// The function takes the following parameters:
//
//   - save: set of Save flags.
func (op *MountOperation) SetPasswordSave(save PasswordSave) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.GPasswordSave    // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.GPasswordSave(save)

	C.g_mount_operation_set_password_save(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(save)
}

// SetPim sets the mount operation's PIM to pim.
//
// The function takes the following parameters:
//
//   - pim: unsigned integer.
func (op *MountOperation) SetPim(pim uint) {
	var _arg0 *C.GMountOperation // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.guint(pim)

	C.g_mount_operation_set_pim(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(pim)
}

// SetUsername sets the user name within op to username.
//
// The function takes the following parameters:
//
//   - username (optional): input username.
func (op *MountOperation) SetUsername(username string) {
	var _arg0 *C.GMountOperation // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if username != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(username)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_mount_operation_set_username(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(username)
}

func (op *MountOperation) aborted() {
	gclass := (*C.GMountOperationClass)(coreglib.PeekParentClass(op))
	fnarg := gclass.aborted

	var _arg0 *C.GMountOperation // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	C._gotk4_gio2_MountOperation_virtual_aborted(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(op)
}

// The function takes the following parameters:
//
//   - message
//   - defaultUser
//   - defaultDomain
//   - flags
func (op *MountOperation) askPassword(message, defaultUser, defaultDomain string, flags AskPasswordFlags) {
	gclass := (*C.GMountOperationClass)(coreglib.PeekParentClass(op))
	fnarg := gclass.ask_password

	var _arg0 *C.GMountOperation  // out
	var _arg1 *C.char             // out
	var _arg2 *C.char             // out
	var _arg3 *C.char             // out
	var _arg4 C.GAskPasswordFlags // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(defaultUser)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(defaultDomain)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.GAskPasswordFlags(flags)

	C._gotk4_gio2_MountOperation_virtual_ask_password(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(defaultUser)
	runtime.KeepAlive(defaultDomain)
	runtime.KeepAlive(flags)
}

// askQuestion: virtual implementation of Operation::ask-question.
//
// The function takes the following parameters:
//
//   - message: string containing a message to display to the user.
//   - choices: array of strings for each possible choice.
func (op *MountOperation) askQuestion(message string, choices []string) {
	gclass := (*C.GMountOperationClass)(coreglib.PeekParentClass(op))
	fnarg := gclass.ask_question

	var _arg0 *C.GMountOperation // out
	var _arg1 *C.char            // out
	var _arg2 **C.char           // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(choices) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(choices)+1)
			var zero *C.char
			out[len(choices)] = zero
			for i := range choices {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(choices[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C._gotk4_gio2_MountOperation_virtual_ask_question(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(choices)
}

// Reply emits the Operation::reply signal.
//
// The function takes the following parameters:
//
//   - result: OperationResult.
func (op *MountOperation) reply(result MountOperationResult) {
	gclass := (*C.GMountOperationClass)(coreglib.PeekParentClass(op))
	fnarg := gclass.reply

	var _arg0 *C.GMountOperation      // out
	var _arg1 C.GMountOperationResult // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.GMountOperationResult(result)

	C._gotk4_gio2_MountOperation_virtual_reply(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(result)
}

// The function takes the following parameters:
//
//   - message
//   - timeLeft
//   - bytesLeft
func (op *MountOperation) showUnmountProgress(message string, timeLeft, bytesLeft int64) {
	gclass := (*C.GMountOperationClass)(coreglib.PeekParentClass(op))
	fnarg := gclass.show_unmount_progress

	var _arg0 *C.GMountOperation // out
	var _arg1 *C.gchar           // out
	var _arg2 C.gint64           // out
	var _arg3 C.gint64           // out

	_arg0 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint64(timeLeft)
	_arg3 = C.gint64(bytesLeft)

	C._gotk4_gio2_MountOperation_virtual_show_unmount_progress(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(timeLeft)
	runtime.KeepAlive(bytesLeft)
}

// NativeSocketAddressOverrides contains methods that are overridable.
type NativeSocketAddressOverrides struct {
}

func defaultNativeSocketAddressOverrides(v *NativeSocketAddress) NativeSocketAddressOverrides {
	return NativeSocketAddressOverrides{}
}

// NativeSocketAddress: socket address of some unknown native type.
//
// This corresponds to a general struct sockaddr of a type not otherwise handled
// by GLib.
type NativeSocketAddress struct {
	_ [0]func() // equal guard
	SocketAddress
}

var (
	_ SocketAddresser = (*NativeSocketAddress)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NativeSocketAddress, *NativeSocketAddressClass, NativeSocketAddressOverrides](
		GTypeNativeSocketAddress,
		initNativeSocketAddressClass,
		wrapNativeSocketAddress,
		defaultNativeSocketAddressOverrides,
	)
}

func initNativeSocketAddressClass(gclass unsafe.Pointer, overrides NativeSocketAddressOverrides, classInitFunc func(*NativeSocketAddressClass)) {
	if classInitFunc != nil {
		class := (*NativeSocketAddressClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNativeSocketAddress(obj *coreglib.Object) *NativeSocketAddress {
	return &NativeSocketAddress{
		SocketAddress: SocketAddress{
			Object: obj,
			SocketConnectable: SocketConnectable{
				Object: obj,
			},
		},
	}
}

func marshalNativeSocketAddress(p uintptr) (interface{}, error) {
	return wrapNativeSocketAddress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNativeSocketAddress creates a new SocketAddress for native and len.
//
// The function takes the following parameters:
//
//   - native (optional) address object.
//   - len: length of native, in bytes.
//
// The function returns the following values:
//
//   - nativeSocketAddress: new SocketAddress.
func NewNativeSocketAddress(native unsafe.Pointer, len uint) *NativeSocketAddress {
	var _arg1 C.gpointer        // out
	var _arg2 C.gsize           // out
	var _cret *C.GSocketAddress // in

	_arg1 = (C.gpointer)(unsafe.Pointer(native))
	_arg2 = C.gsize(len)

	_cret = C.g_native_socket_address_new(_arg1, _arg2)
	runtime.KeepAlive(native)
	runtime.KeepAlive(len)

	var _nativeSocketAddress *NativeSocketAddress // out

	_nativeSocketAddress = wrapNativeSocketAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _nativeSocketAddress
}

// NativeVolumeMonitorOverrides contains methods that are overridable.
type NativeVolumeMonitorOverrides struct {
}

func defaultNativeVolumeMonitorOverrides(v *NativeVolumeMonitor) NativeVolumeMonitorOverrides {
	return NativeVolumeMonitorOverrides{}
}

type NativeVolumeMonitor struct {
	_ [0]func() // equal guard
	VolumeMonitor
}

var (
	_ coreglib.Objector = (*NativeVolumeMonitor)(nil)
)

// NativeVolumeMonitorrer describes types inherited from class NativeVolumeMonitor.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type NativeVolumeMonitorrer interface {
	coreglib.Objector
	baseNativeVolumeMonitor() *NativeVolumeMonitor
}

var _ NativeVolumeMonitorrer = (*NativeVolumeMonitor)(nil)

func init() {
	coreglib.RegisterClassInfo[*NativeVolumeMonitor, *NativeVolumeMonitorClass, NativeVolumeMonitorOverrides](
		GTypeNativeVolumeMonitor,
		initNativeVolumeMonitorClass,
		wrapNativeVolumeMonitor,
		defaultNativeVolumeMonitorOverrides,
	)
}

func initNativeVolumeMonitorClass(gclass unsafe.Pointer, overrides NativeVolumeMonitorOverrides, classInitFunc func(*NativeVolumeMonitorClass)) {
	if classInitFunc != nil {
		class := (*NativeVolumeMonitorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNativeVolumeMonitor(obj *coreglib.Object) *NativeVolumeMonitor {
	return &NativeVolumeMonitor{
		VolumeMonitor: VolumeMonitor{
			Object: obj,
		},
	}
}

func marshalNativeVolumeMonitor(p uintptr) (interface{}, error) {
	return wrapNativeVolumeMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *NativeVolumeMonitor) baseNativeVolumeMonitor() *NativeVolumeMonitor {
	return v
}

// BaseNativeVolumeMonitor returns the underlying base object.
func BaseNativeVolumeMonitor(obj NativeVolumeMonitorrer) *NativeVolumeMonitor {
	return obj.baseNativeVolumeMonitor()
}

// NetworkAddressOverrides contains methods that are overridable.
type NetworkAddressOverrides struct {
}

func defaultNetworkAddressOverrides(v *NetworkAddress) NetworkAddressOverrides {
	return NetworkAddressOverrides{}
}

// NetworkAddress: GNetworkAddress provides an easy way to resolve a hostname
// and then attempt to connect to that host, handling the possibility of
// multiple IP addresses and multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long as this
// object is kept alive which may have unexpected results if alive for too long.
//
// See gio.SocketConnectable for an example of using the connectable interface.
type NetworkAddress struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SocketConnectable
}

var (
	_ coreglib.Objector = (*NetworkAddress)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NetworkAddress, *NetworkAddressClass, NetworkAddressOverrides](
		GTypeNetworkAddress,
		initNetworkAddressClass,
		wrapNetworkAddress,
		defaultNetworkAddressOverrides,
	)
}

func initNetworkAddressClass(gclass unsafe.Pointer, overrides NetworkAddressOverrides, classInitFunc func(*NetworkAddressClass)) {
	if classInitFunc != nil {
		class := (*NetworkAddressClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNetworkAddress(obj *coreglib.Object) *NetworkAddress {
	return &NetworkAddress{
		Object: obj,
		SocketConnectable: SocketConnectable{
			Object: obj,
		},
	}
}

func marshalNetworkAddress(p uintptr) (interface{}, error) {
	return wrapNetworkAddress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNetworkAddress creates a new Connectable for connecting to the given
// hostname and port.
//
// Note that depending on the configuration of the machine, a hostname of
// localhost may refer to the IPv4 loopback address only, or to both IPv4
// and IPv6; use g_network_address_new_loopback() to create a Address that is
// guaranteed to resolve to both addresses.
//
// The function takes the following parameters:
//
//   - hostname: hostname.
//   - port: port.
//
// The function returns the following values:
//
//   - networkAddress: new Address.
func NewNetworkAddress(hostname string, port uint16) *NetworkAddress {
	var _arg1 *C.gchar              // out
	var _arg2 C.guint16             // out
	var _cret *C.GSocketConnectable // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(port)

	_cret = C.g_network_address_new(_arg1, _arg2)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)

	var _networkAddress *NetworkAddress // out

	_networkAddress = wrapNetworkAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkAddress
}

// NewNetworkAddressLoopback creates a new Connectable for connecting to the
// local host over a loopback connection to the given port. This is intended for
// use in connecting to local services which may be running on IPv4 or IPv6.
//
// The connectable will return IPv4 and IPv6 loopback addresses, regardless of
// how the host resolves localhost. By contrast, g_network_address_new() will
// often only return an IPv4 address when resolving localhost, and an IPv6
// address for localhost6.
//
// g_network_address_get_hostname() will always return localhost for a Address
// created with this constructor.
//
// The function takes the following parameters:
//
//   - port: port.
//
// The function returns the following values:
//
//   - networkAddress: new Address.
func NewNetworkAddressLoopback(port uint16) *NetworkAddress {
	var _arg1 C.guint16             // out
	var _cret *C.GSocketConnectable // in

	_arg1 = C.guint16(port)

	_cret = C.g_network_address_new_loopback(_arg1)
	runtime.KeepAlive(port)

	var _networkAddress *NetworkAddress // out

	_networkAddress = wrapNetworkAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkAddress
}

// Hostname gets addr's hostname. This might be either UTF-8 or ASCII-encoded,
// depending on what addr was created with.
//
// The function returns the following values:
//
//   - utf8 addr's hostname.
func (addr *NetworkAddress) Hostname() string {
	var _arg0 *C.GNetworkAddress // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(coreglib.InternObject(addr).Native()))

	_cret = C.g_network_address_get_hostname(_arg0)
	runtime.KeepAlive(addr)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Port gets addr's port number.
//
// The function returns the following values:
//
//   - guint16 addr's port (which may be 0).
func (addr *NetworkAddress) Port() uint16 {
	var _arg0 *C.GNetworkAddress // out
	var _cret C.guint16          // in

	_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(coreglib.InternObject(addr).Native()))

	_cret = C.g_network_address_get_port(_arg0)
	runtime.KeepAlive(addr)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Scheme gets addr's scheme.
//
// The function returns the following values:
//
//   - utf8 (optional) addr's scheme (NULL if not built from URI).
func (addr *NetworkAddress) Scheme() string {
	var _arg0 *C.GNetworkAddress // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkAddress)(unsafe.Pointer(coreglib.InternObject(addr).Native()))

	_cret = C.g_network_address_get_scheme(_arg0)
	runtime.KeepAlive(addr)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NetworkAddressParse creates a new Connectable for connecting to the given
// hostname and port. May fail and return NULL in case parsing host_and_port
// fails.
//
// host_and_port may be in any of a number of recognised formats; an IPv6
// address, an IPv4 address, or a domain name (in which case a DNS lookup
// is performed). Quoting with [] is supported for all address types. A port
// override may be specified in the usual way with a colon.
//
// If no port is specified in host_and_port then default_port will be used as
// the port number to connect to.
//
// In general, host_and_port is expected to be provided by the user (allowing
// them to give the hostname, and a port override if necessary) and default_port
// is expected to be provided by the application.
//
// (The port component of host_and_port can also be specified as a service
// name rather than as a numeric port, but this functionality is deprecated,
// because it depends on the contents of /etc/services, which is generally quite
// sparse on platforms other than Linux.).
//
// The function takes the following parameters:
//
//   - hostAndPort: hostname and optionally a port.
//   - defaultPort: default port if not in host_and_port.
//
// The function returns the following values:
//
//   - networkAddress: new Address, or NULL on error.
func NetworkAddressParse(hostAndPort string, defaultPort uint16) (*NetworkAddress, error) {
	var _arg1 *C.gchar              // out
	var _arg2 C.guint16             // out
	var _cret *C.GSocketConnectable // in
	var _cerr *C.GError             // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)

	_cret = C.g_network_address_parse(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)

	var _networkAddress *NetworkAddress // out
	var _goerr error                    // out

	_networkAddress = wrapNetworkAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _networkAddress, _goerr
}

// NetworkAddressParseURI creates a new Connectable for connecting to the given
// uri. May fail and return NULL in case parsing uri fails.
//
// Using this rather than g_network_address_new() or g_network_address_parse()
// allows Client to determine when to use application-specific proxy protocols.
//
// The function takes the following parameters:
//
//   - uri: hostname and optionally a port.
//   - defaultPort: default port if none is found in the URI.
//
// The function returns the following values:
//
//   - networkAddress: new Address, or NULL on error.
func NetworkAddressParseURI(uri string, defaultPort uint16) (*NetworkAddress, error) {
	var _arg1 *C.gchar              // out
	var _arg2 C.guint16             // out
	var _cret *C.GSocketConnectable // in
	var _cerr *C.GError             // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)

	_cret = C.g_network_address_parse_uri(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)

	var _networkAddress *NetworkAddress // out
	var _goerr error                    // out

	_networkAddress = wrapNetworkAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _networkAddress, _goerr
}

// NetworkServiceOverrides contains methods that are overridable.
type NetworkServiceOverrides struct {
}

func defaultNetworkServiceOverrides(v *NetworkService) NetworkServiceOverrides {
	return NetworkServiceOverrides{}
}

// NetworkService: like gio.NetworkAddress does with hostnames, GNetworkService
// provides an easy way to resolve a SRV record, and then attempt to connect
// to one of the hosts that implements that service, handling service
// priority/weighting, multiple IP addresses, and multiple address families.
//
// See gio.SrvTarget for more information about SRV records, and see
// gio.SocketConnectable for an example of using the connectable interface.
type NetworkService struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SocketConnectable
}

var (
	_ coreglib.Objector = (*NetworkService)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NetworkService, *NetworkServiceClass, NetworkServiceOverrides](
		GTypeNetworkService,
		initNetworkServiceClass,
		wrapNetworkService,
		defaultNetworkServiceOverrides,
	)
}

func initNetworkServiceClass(gclass unsafe.Pointer, overrides NetworkServiceOverrides, classInitFunc func(*NetworkServiceClass)) {
	if classInitFunc != nil {
		class := (*NetworkServiceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNetworkService(obj *coreglib.Object) *NetworkService {
	return &NetworkService{
		Object: obj,
		SocketConnectable: SocketConnectable{
			Object: obj,
		},
	}
}

func marshalNetworkService(p uintptr) (interface{}, error) {
	return wrapNetworkService(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNetworkService creates a new Service representing the given service,
// protocol, and domain. This will initially be unresolved; use the Connectable
// interface to resolve it.
//
// The function takes the following parameters:
//
//   - service type to look up (eg, "ldap").
//   - protocol: networking protocol to use for service (eg, "tcp").
//   - domain: DNS domain to look up the service in.
//
// The function returns the following values:
//
//   - networkService: new Service.
func NewNetworkService(service, protocol, domain string) *NetworkService {
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret *C.GSocketConnectable // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_network_service_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)

	var _networkService *NetworkService // out

	_networkService = wrapNetworkService(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _networkService
}

// Domain gets the domain that srv serves. This might be either UTF-8 or
// ASCII-encoded, depending on what srv was created with.
//
// The function returns the following values:
//
//   - utf8 srv's domain name.
func (srv *NetworkService) Domain() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(coreglib.InternObject(srv).Native()))

	_cret = C.g_network_service_get_domain(_arg0)
	runtime.KeepAlive(srv)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Protocol gets srv's protocol name (eg, "tcp").
//
// The function returns the following values:
//
//   - utf8 srv's protocol name.
func (srv *NetworkService) Protocol() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(coreglib.InternObject(srv).Native()))

	_cret = C.g_network_service_get_protocol(_arg0)
	runtime.KeepAlive(srv)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Scheme gets the URI scheme used to resolve proxies. By default, the service
// name is used as scheme.
//
// The function returns the following values:
//
//   - utf8 srv's scheme name.
func (srv *NetworkService) Scheme() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(coreglib.InternObject(srv).Native()))

	_cret = C.g_network_service_get_scheme(_arg0)
	runtime.KeepAlive(srv)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Service gets srv's service name (eg, "ldap").
//
// The function returns the following values:
//
//   - utf8 srv's service name.
func (srv *NetworkService) Service() string {
	var _arg0 *C.GNetworkService // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(coreglib.InternObject(srv).Native()))

	_cret = C.g_network_service_get_service(_arg0)
	runtime.KeepAlive(srv)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetScheme set's the URI scheme used to resolve proxies. By default, the
// service name is used as scheme.
//
// The function takes the following parameters:
//
//   - scheme: URI scheme.
func (srv *NetworkService) SetScheme(scheme string) {
	var _arg0 *C.GNetworkService // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GNetworkService)(unsafe.Pointer(coreglib.InternObject(srv).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_network_service_set_scheme(_arg0, _arg1)
	runtime.KeepAlive(srv)
	runtime.KeepAlive(scheme)
}

// Notification: GNotification is a mechanism for creating a notification to
// be shown to the user  typically as a pop-up notification presented by the
// desktop environment shell.
//
// The key difference between GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using GNotification should be able to be started as a
// D-Bus service, using gio.Application.
//
// In order for GNotification to work, the application must have installed a
// .desktop file. For example:
//
//	[Desktop Entry]
//	Name=Test Application
//	Comment=Description of what Test Application does
//	Exec=gnome-test-application
//	Icon=org.gnome.TestApplication
//	Terminal=false
//	Type=Application
//	Categories=GNOME;GTK;TestApplication Category;
//	StartupNotify=true
//	DBusActivatable=true
//	X-GNOME-UsesNotifications=true
//
// The X-GNOME-UsesNotifications key indicates to GNOME Control Center that this
// application uses notifications, so it can be listed in the Control Centers
// Notifications panel.
//
// The .desktop file must be named as org.gnome.TestApplication.desktop,
// where org.gnome.TestApplication is the ID passed to gio.Application.New.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: app. actions).
// It is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with gio.Application.SendNotification().
type Notification struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Notification)(nil)
)

func wrapNotification(obj *coreglib.Object) *Notification {
	return &Notification{
		Object: obj,
	}
}

func marshalNotification(p uintptr) (interface{}, error) {
	return wrapNotification(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNotification creates a new #GNotification with title as its title.
//
// After populating notification with more details, it can be sent to the
// desktop shell with g_application_send_notification(). Changing any properties
// after this call will not have any effect until resending notification.
//
// The function takes the following parameters:
//
//   - title of the notification.
//
// The function returns the following values:
//
//   - notification: new #GNotification instance.
func NewNotification(title string) *Notification {
	var _arg1 *C.gchar         // out
	var _cret *C.GNotification // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_notification_new(_arg1)
	runtime.KeepAlive(title)

	var _notification *Notification // out

	_notification = wrapNotification(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _notification
}

// AddButton adds a button to notification that activates the action in
// detailed_action when clicked. That action must be an application-wide action
// (starting with "app."). If detailed_action contains a target, the action will
// be activated with that target as its parameter.
//
// See g_action_parse_detailed_name() for a description of the format for
// detailed_action.
//
// The function takes the following parameters:
//
//   - label of the button.
//   - detailedAction: detailed action name.
func (notification *Notification) AddButton(label, detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_notification_add_button(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// AddButtonWithTarget adds a button to notification that activates action
// when clicked. action must be an application-wide action (it must start with
// "app.").
//
// If target is non-NULL, action will be activated with target as its parameter.
//
// The function takes the following parameters:
//
//   - label of the button.
//   - action name.
//   - target (optional) to use as action's parameter, or NULL.
func (notification *Notification) AddButtonWithTarget(label, action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(action)))
	defer C.free(unsafe.Pointer(_arg2))
	if target != nil {
		_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(target)))
	}

	C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(label)
	runtime.KeepAlive(action)
	runtime.KeepAlive(target)
}

// SetBody sets the body of notification to body.
//
// The function takes the following parameters:
//
//   - body (optional): new body for notification, or NULL.
func (notification *Notification) SetBody(body string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	if body != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(body)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_notification_set_body(_arg0, _arg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(body)
}

// SetCategory sets the type of notification to category. Categories have a main
// type like email, im or device and can have a detail separated by a ., e.g.
// im.received or email.arrived. Setting the category helps the notification
// server to select proper feedback to the user.
//
// Standard categories are listed in the specification
// (https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
//
// The function takes the following parameters:
//
//   - category (optional) for notification, or NULL for no category.
func (notification *Notification) SetCategory(category string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	if category != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_notification_set_category(_arg0, _arg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(category)
}

// SetDefaultAction sets the default action of notification to detailed_action.
// This action is activated when the notification is clicked on.
//
// The action in detailed_action must be an application-wide action
// (it must start with "app."). If detailed_action contains a target,
// the given action will be activated with that target as its parameter.
// See g_action_parse_detailed_name() for a description of the format for
// detailed_action.
//
// When no default action is set, the application that the notification was sent
// on is activated.
//
// The function takes the following parameters:
//
//   - detailedAction: detailed action name.
func (notification *Notification) SetDefaultAction(detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_default_action(_arg0, _arg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(detailedAction)
}

// SetDefaultActionAndTarget sets the default action of notification to action.
// This action is activated when the notification is clicked on. It must be an
// application-wide action (start with "app.").
//
// If target is non-NULL, action will be activated with target as its parameter.
// If target is floating, it will be consumed.
//
// When no default action is set, the application that the notification was sent
// on is activated.
//
// The function takes the following parameters:
//
//   - action name.
//   - target (optional) to use as action's parameter, or NULL.
func (notification *Notification) SetDefaultActionAndTarget(action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(action)))
	defer C.free(unsafe.Pointer(_arg1))
	if target != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(target)))
	}

	C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(action)
	runtime.KeepAlive(target)
}

// SetIcon sets the icon of notification to icon.
//
// The function takes the following parameters:
//
//   - icon to be shown in notification, as a #GIcon.
func (notification *Notification) SetIcon(icon Iconner) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.g_notification_set_icon(_arg0, _arg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(icon)
}

// SetPriority sets the priority of notification to priority. See Priority for
// possible values.
//
// The function takes the following parameters:
//
//   - priority: Priority.
func (notification *Notification) SetPriority(priority NotificationPriority) {
	var _arg0 *C.GNotification        // out
	var _arg1 C.GNotificationPriority // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	_arg1 = C.GNotificationPriority(priority)

	C.g_notification_set_priority(_arg0, _arg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(priority)
}

// SetTitle sets the title of notification to title.
//
// The function takes the following parameters:
//
//   - title: new title for notification.
func (notification *Notification) SetTitle(title string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_title(_arg0, _arg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(title)
}

// SetUrgent: deprecated in favor of g_notification_set_priority().
//
// Deprecated: Since 2.42, this has been deprecated in favour of
// g_notification_set_priority().
//
// The function takes the following parameters:
//
//   - urgent: TRUE if notification is urgent.
func (notification *Notification) SetUrgent(urgent bool) {
	var _arg0 *C.GNotification // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))
	if urgent {
		_arg1 = C.TRUE
	}

	C.g_notification_set_urgent(_arg0, _arg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(urgent)
}

// OutputStreamOverrides contains methods that are overridable.
type OutputStreamOverrides struct {
	// CloseFinish closes an output stream.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	CloseFinish func(result AsyncResulter) error
	CloseFn     func(ctx context.Context) error
	// Flush forces a write of all user-space buffered data for the given
	// stream. Will block during the operation. Closing the stream will
	// implicitly cause a flush.
	//
	// This function is optional for inherited classes.
	//
	// If cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional cancellable object.
	Flush func(ctx context.Context) error
	// FlushFinish finishes flushing an output stream.
	//
	// The function takes the following parameters:
	//
	//   - result: GAsyncResult.
	FlushFinish func(result AsyncResulter) error
	// Splice splices an input stream into an output stream.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//   - source: Stream.
	//   - flags: set of StreamSpliceFlags.
	//
	// The function returns the following values:
	//
	//   - gssize containing the size of the data spliced, or -1 if an error
	//     occurred. Note that if the number of bytes spliced is greater than
	//     G_MAXSSIZE, then that will be returned, and there is no way to
	//     determine the actual number of bytes spliced.
	Splice func(ctx context.Context, source InputStreamer, flags OutputStreamSpliceFlags) (int, error)
	// SpliceFinish finishes an asynchronous stream splice operation.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - gssize of the number of bytes spliced. Note that if the number of
	//     bytes spliced is greater than G_MAXSSIZE, then that will be returned,
	//     and there is no way to determine the actual number of bytes spliced.
	SpliceFinish func(result AsyncResulter) (int, error)
	// WriteFinish finishes a stream write operation.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - gssize containing the number of bytes written to the stream.
	WriteFinish func(result AsyncResulter) (int, error)
	// WritevFinish finishes a stream writev operation.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - bytesWritten (optional): location to store the number of bytes that
	//     were written to the stream.
	WritevFinish func(result AsyncResulter) (uint, error)
}

func defaultOutputStreamOverrides(v *OutputStream) OutputStreamOverrides {
	return OutputStreamOverrides{
		CloseFinish:  v.closeFinish,
		CloseFn:      v.closeFn,
		Flush:        v.flush,
		FlushFinish:  v.flushFinish,
		Splice:       v.splice,
		SpliceFinish: v.spliceFinish,
		WriteFinish:  v.writeFinish,
		WritevFinish: v.writevFinish,
	}
}

// OutputStream: GOutputStream is a base class for implementing streaming
// output.
//
// It has functions to write to a stream (gio.OutputStream.Write()),
// to close a stream (gio.OutputStream.Close()) and to flush pending writes
// (gio.OutputStream.Flush()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use gio.OutputStream.Splice().
//
// See the documentation for gio.IOStream for details of thread safety of
// streaming APIs.
//
// All of these functions have async variants too.
//
// All classes derived from GOutputStream *should* implement synchronous
// writing, splicing, flushing and closing streams, but *may* implement
// asynchronous versions.
type OutputStream struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*OutputStream)(nil)
)

// OutputStreamer describes types inherited from class OutputStream.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type OutputStreamer interface {
	coreglib.Objector
	baseOutputStream() *OutputStream
}

var _ OutputStreamer = (*OutputStream)(nil)

func init() {
	coreglib.RegisterClassInfo[*OutputStream, *OutputStreamClass, OutputStreamOverrides](
		GTypeOutputStream,
		initOutputStreamClass,
		wrapOutputStream,
		defaultOutputStreamOverrides,
	)
}

func initOutputStreamClass(gclass unsafe.Pointer, overrides OutputStreamOverrides, classInitFunc func(*OutputStreamClass)) {
	pclass := (*C.GOutputStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeOutputStream))))

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_close_finish)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_close_fn)
	}

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_flush)
	}

	if overrides.FlushFinish != nil {
		pclass.flush_finish = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_flush_finish)
	}

	if overrides.Splice != nil {
		pclass.splice = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_splice)
	}

	if overrides.SpliceFinish != nil {
		pclass.splice_finish = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_splice_finish)
	}

	if overrides.WriteFinish != nil {
		pclass.write_finish = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_write_finish)
	}

	if overrides.WritevFinish != nil {
		pclass.writev_finish = (*[0]byte)(C._gotk4_gio2_OutputStreamClass_writev_finish)
	}

	if classInitFunc != nil {
		class := (*OutputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapOutputStream(obj *coreglib.Object) *OutputStream {
	return &OutputStream{
		Object: obj,
	}
}

func marshalOutputStream(p uintptr) (interface{}, error) {
	return wrapOutputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (stream *OutputStream) baseOutputStream() *OutputStream {
	return stream
}

// BaseOutputStream returns the underlying base object.
func BaseOutputStream(obj OutputStreamer) *OutputStream {
	return obj.baseOutputStream()
}

// ClearPending clears the pending flag on stream.
func (stream *OutputStream) ClearPending() {
	var _arg0 *C.GOutputStream // out

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.g_output_stream_clear_pending(_arg0)
	runtime.KeepAlive(stream)
}

// Close closes the stream, releasing resources related to it.
//
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an error.
//
// Closing a stream will automatically flush any outstanding buffers in the
// stream.
//
// Streams will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are released
// as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for the
// individual stream for details.
//
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close will
// still return G_IO_ERROR_CLOSED for all operations. Still, it is important to
// check and report the error to the user, otherwise there might be a loss of
// data as all data might not be written.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. Cancelling a close will
// still leave the stream closed, but there some streams can use a faster close
// that doesn't block to e.g. check errors. On cancellation (as with any error)
// there is no guarantee that all written data will reach the target.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
func (stream *OutputStream) Close(ctx context.Context) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_output_stream_close(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CloseAsync requests an asynchronous close of the stream, releasing resources
// related to it. When the operation is finished callback will be called.
// You can then call g_output_stream_close_finish() to get the result of the
// operation.
//
// For behaviour details see g_output_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) CloseAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_close_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CloseFinish closes an output stream.
//
// The function takes the following parameters:
//
//   - result: Result.
func (stream *OutputStream) CloseFinish(result AsyncResulter) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_output_stream_close_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Flush forces a write of all user-space buffered data for the given stream.
// Will block during the operation. Closing the stream will implicitly cause a
// flush.
//
// This function is optional for inherited classes.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
func (stream *OutputStream) Flush(ctx context.Context) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_output_stream_flush(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FlushAsync forces an asynchronous write of all user-space buffered data for
// the given stream. For behaviour details see g_output_stream_flush().
//
// When the operation is finished callback will be called. You can then call
// g_output_stream_flush_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) FlushAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_flush_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// FlushFinish finishes flushing an output stream.
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
func (stream *OutputStream) FlushFinish(result AsyncResulter) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_output_stream_flush_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// HasPending checks if an output stream has pending actions.
//
// The function returns the following values:
//
//   - ok: TRUE if stream has pending actions.
func (stream *OutputStream) HasPending() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_output_stream_has_pending(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsClosed checks if an output stream has already been closed.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is closed. FALSE otherwise.
func (stream *OutputStream) IsClosed() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_output_stream_is_closed(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsClosing checks if an output stream is being closed. This can be used inside
// e.g. a flush implementation to see if the flush (or other i/o operation) is
// called from within the closing operation.
//
// The function returns the following values:
//
//   - ok: TRUE if stream is being closed. FALSE otherwise.
func (stream *OutputStream) IsClosing() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.g_output_stream_is_closing(_arg0)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPending sets stream to have actions pending. If the pending flag is
// already set or stream is closed, it will return FALSE and set error.
func (stream *OutputStream) SetPending() error {
	var _arg0 *C.GOutputStream // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.g_output_stream_set_pending(_arg0, &_cerr)
	runtime.KeepAlive(stream)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Splice splices an input stream into an output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - source: Stream.
//   - flags: set of StreamSpliceFlags.
//
// The function returns the following values:
//
//   - gssize containing the size of the data spliced, or -1 if an error
//     occurred. Note that if the number of bytes spliced is greater than
//     G_MAXSSIZE, then that will be returned, and there is no way to determine
//     the actual number of bytes spliced.
func (stream *OutputStream) Splice(ctx context.Context, source InputStreamer, flags OutputStreamSpliceFlags) (int, error) {
	var _arg0 *C.GOutputStream           // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.GInputStream            // out
	var _arg2 C.GOutputStreamSpliceFlags // out
	var _cret C.gssize                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	_arg2 = C.GOutputStreamSpliceFlags(flags)

	_cret = C.g_output_stream_splice(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SpliceAsync splices a stream asynchronously. When the operation is finished
// callback will be called. You can then call g_output_stream_splice_finish() to
// get the result of the operation.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_splice().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - source: Stream.
//   - flags: set of StreamSpliceFlags.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) SpliceAsync(ctx context.Context, source InputStreamer, flags OutputStreamSpliceFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream           // out
	var _arg4 *C.GCancellable            // out
	var _arg1 *C.GInputStream            // out
	var _arg2 C.GOutputStreamSpliceFlags // out
	var _arg3 C.int                      // out
	var _arg5 C.GAsyncReadyCallback      // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	_arg2 = C.GOutputStreamSpliceFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_splice_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// SpliceFinish finishes an asynchronous stream splice operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize of the number of bytes spliced. Note that if the number of bytes
//     spliced is greater than G_MAXSSIZE, then that will be returned, and there
//     is no way to determine the actual number of bytes spliced.
func (stream *OutputStream) SpliceFinish(result AsyncResulter) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_output_stream_splice_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// Write tries to write count bytes from buffer into the stream. Will block
// during the operation.
//
// If count is 0, returns 0 and does nothing. A value of count larger than
// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream.
// All writes block until at least one byte is written or an error occurs;
// 0 is never returned (unless count is 0).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - buffer containing the data to write.
//
// The function returns the following values:
//
//   - gssize: number of bytes written, or -1 on error.
func (stream *OutputStream) Write(ctx context.Context, buffer []byte) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg3 *C.GCancellable  // out
	var _arg1 *C.void          // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C.g_output_stream_write(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// WriteAll tries to write count bytes from buffer into the stream. Will block
// during the operation.
//
// This function is similar to g_output_stream_write(), except it tries to write
// as many bytes as requested, only stopping on an error.
//
// On a successful write of count bytes, TRUE is returned, and bytes_written is
// set to count.
//
// If there is an error during the operation FALSE is returned and error is set
// to indicate the error status.
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_written
// will be set to the number of bytes that were successfully written before
// the error was encountered. This functionality is only available from C.
// If you need it from another language then you must write your own loop around
// g_output_stream_write().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer containing the data to write.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that was
//     written to the stream.
func (stream *OutputStream) WriteAll(ctx context.Context, buffer []byte) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.void          // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	C.g_output_stream_write_all(_arg0, unsafe.Pointer(_arg1), _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WriteAllAsync: request an asynchronous write of count bytes from buffer
// into the stream. When the operation is finished callback will be called.
// You can then call g_output_stream_write_all_finish() to get the result of the
// operation.
//
// This is the asynchronous version of g_output_stream_write_all().
//
// Call g_output_stream_write_all_finish() to collect the result.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// Note that no copy of buffer will be made, so it must stay valid until
// callback is called.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer containing the data to write.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) WriteAllAsync(ctx context.Context, buffer []byte, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.void          // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_write_all_async(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WriteAllFinish finishes an asynchronous stream write operation started with
// g_output_stream_write_all_async().
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_written
// will be set to the number of bytes that were successfully written before
// the error was encountered. This functionality is only available from C.
// If you need it from another language then you must write your own loop around
// g_output_stream_write_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that was
//     written to the stream.
func (stream *OutputStream) WriteAllFinish(result AsyncResulter) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_output_stream_write_all_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WriteAsync: request an asynchronous write of count bytes from buffer into the
// stream. When the operation is finished callback will be called. You can then
// call g_output_stream_write_finish() to get the result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// A value of count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes written will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it can
// happen e.g. on a partial I/O error, but generally we try to write as many
// bytes as requested.
//
// You are guaranteed that this method will never fail with
// G_IO_ERROR_WOULD_BLOCK - if stream can't accept more data, the method will
// just wait until this changes.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_write().
//
// Note that no copy of buffer will be made, so it must stay valid until
// callback is called. See g_output_stream_write_bytes_async() for a #GBytes
// version that will automatically hold a reference to the contents (without
// copying) for the duration of the call.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer containing the data to write.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) WriteAsync(ctx context.Context, buffer []byte, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.void          // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_write_async(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WriteBytes: wrapper function for g_output_stream_write() which takes a
// #GBytes as input. This can be more convenient for use by language bindings or
// in other cases where the refcounted nature of #GBytes is helpful over a bare
// pointer interface.
//
// However, note that this function may still perform partial writes,
// just like g_output_stream_write(). If that occurs, to continue writing,
// you will need to create a new #GBytes containing just the remaining bytes,
// using g_bytes_new_from_bytes(). Passing the same #GBytes instance multiple
// times potentially can result in duplicated data in the output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - bytes to write.
//
// The function returns the following values:
//
//   - gssize: number of bytes written, or -1 on error.
func (stream *OutputStream) WriteBytes(ctx context.Context, bytes *glib.Bytes) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg2 *C.GCancellable  // out
	var _arg1 *C.GBytes        // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.g_output_stream_write_bytes(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(bytes)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// WriteBytesAsync: this function is similar to g_output_stream_write_async(),
// but takes a #GBytes as input. Due to the refcounted nature of #GBytes,
// this allows the stream to avoid taking a copy of the data.
//
// However, note that this function may still perform partial writes,
// just like g_output_stream_write_async(). If that occurs, to continue writing,
// you will need to create a new #GBytes containing just the remaining bytes,
// using g_bytes_new_from_bytes(). Passing the same #GBytes instance multiple
// times potentially can result in duplicated data in the output stream.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_write_bytes().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - bytes to write.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) WriteBytesAsync(ctx context.Context, bytes *glib.Bytes, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GBytes             // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_write_bytes_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WriteBytesFinish finishes a stream write-from-#GBytes operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize containing the number of bytes written to the stream.
func (stream *OutputStream) WriteBytesFinish(result AsyncResulter) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_output_stream_write_bytes_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// WriteFinish finishes a stream write operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize containing the number of bytes written to the stream.
func (stream *OutputStream) WriteFinish(result AsyncResulter) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_output_stream_write_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// Writev tries to write the bytes contained in the n_vectors vectors into the
// stream. Will block during the operation.
//
// If n_vectors is 0 or the sum of all bytes in vectors is 0, returns 0 and does
// nothing.
//
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream.
// All writes block until at least one byte is written or an error occurs;
// 0 is never returned (unless n_vectors is 0 or the sum of all bytes in vectors
// is 0).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// Some implementations of g_output_stream_writev() may have limitations on the
// aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if these
// are exceeded. For example, when writing to a local file on UNIX platforms,
// the aggregate buffer size must not exceed G_MAXSSIZE bytes.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
func (stream *OutputStream) Writev(ctx context.Context, vectors []OutputVector) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	C.g_output_stream_writev(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WritevAll tries to write the bytes contained in the n_vectors vectors into
// the stream. Will block during the operation.
//
// This function is similar to g_output_stream_writev(), except it tries to
// write as many bytes as requested, only stopping on an error.
//
// On a successful write of all n_vectors vectors, TRUE is returned, and
// bytes_written is set to the sum of all the sizes of vectors.
//
// If there is an error during the operation FALSE is returned and error is set
// to indicate the error status.
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_written
// will be set to the number of bytes that were successfully written before
// the error was encountered. This functionality is only available from C.
// If you need it from another language then you must write your own loop around
// g_output_stream_write().
//
// The content of the individual elements of vectors might be changed by this
// function.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
func (stream *OutputStream) WritevAll(ctx context.Context, vectors []OutputVector) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	C.g_output_stream_writev_all(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WritevAllAsync: request an asynchronous write of the bytes contained in the
// n_vectors vectors into the stream. When the operation is finished callback
// will be called. You can then call g_output_stream_writev_all_finish() to get
// the result of the operation.
//
// This is the asynchronous version of g_output_stream_writev_all().
//
// Call g_output_stream_writev_all_finish() to collect the result.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// Note that no copy of vectors will be made, so it must stay valid until
// callback is called. The content of the individual elements of vectors might
// be changed by this function.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - vectors: buffer containing the Vectors to write.
//   - ioPriority: i/O priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) WritevAllAsync(ctx context.Context, vectors []OutputVector, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_writev_all_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WritevAllFinish finishes an asynchronous stream write operation started with
// g_output_stream_writev_all_async().
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_written
// will be set to the number of bytes that were successfully written before
// the error was encountered. This functionality is only available from C.
// If you need it from another language then you must write your own loop around
// g_output_stream_writev_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
func (stream *OutputStream) WritevAllFinish(result AsyncResulter) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_output_stream_writev_all_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WritevAsync: request an asynchronous write of the bytes contained in
// n_vectors vectors into the stream. When the operation is finished callback
// will be called. You can then call g_output_stream_writev_finish() to get the
// result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// On success, the number of bytes written will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it can
// happen e.g. on a partial I/O error, but generally we try to write as many
// bytes as requested.
//
// You are guaranteed that this method will never fail with
// G_IO_ERROR_WOULD_BLOCK  if stream can't accept more data, the method will
// just wait until this changes.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_writev().
//
// Note that no copy of vectors will be made, so it must stay valid until
// callback is called.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - vectors: buffer containing the Vectors to write.
//   - ioPriority: i/O priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) WritevAsync(ctx context.Context, vectors []OutputVector, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_writev_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WritevFinish finishes a stream writev operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
func (stream *OutputStream) WritevFinish(result AsyncResulter) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_output_stream_writev_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// closeAsync requests an asynchronous close of the stream, releasing resources
// related to it. When the operation is finished callback will be called.
// You can then call g_output_stream_close_finish() to get the result of the
// operation.
//
// For behaviour details see g_output_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) closeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_async

	var _arg0 *C.GOutputStream      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_OutputStream_virtual_close_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// closeFinish closes an output stream.
//
// The function takes the following parameters:
//
//   - result: Result.
func (stream *OutputStream) closeFinish(result AsyncResulter) error {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_finish

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_OutputStream_virtual_close_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (stream *OutputStream) closeFn(ctx context.Context) error {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.close_fn

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_OutputStream_virtual_close_fn(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Flush forces a write of all user-space buffered data for the given stream.
// Will block during the operation. Closing the stream will implicitly cause a
// flush.
//
// This function is optional for inherited classes.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
func (stream *OutputStream) flush(ctx context.Context) error {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.flush

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_OutputStream_virtual_flush(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// flushAsync forces an asynchronous write of all user-space buffered data for
// the given stream. For behaviour details see g_output_stream_flush().
//
// When the operation is finished callback will be called. You can then call
// g_output_stream_flush_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) flushAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.flush_async

	var _arg0 *C.GOutputStream      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_OutputStream_virtual_flush_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// flushFinish finishes flushing an output stream.
//
// The function takes the following parameters:
//
//   - result: GAsyncResult.
func (stream *OutputStream) flushFinish(result AsyncResulter) error {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.flush_finish

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_OutputStream_virtual_flush_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Splice splices an input stream into an output stream.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - source: Stream.
//   - flags: set of StreamSpliceFlags.
//
// The function returns the following values:
//
//   - gssize containing the size of the data spliced, or -1 if an error
//     occurred. Note that if the number of bytes spliced is greater than
//     G_MAXSSIZE, then that will be returned, and there is no way to determine
//     the actual number of bytes spliced.
func (stream *OutputStream) splice(ctx context.Context, source InputStreamer, flags OutputStreamSpliceFlags) (int, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.splice

	var _arg0 *C.GOutputStream           // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.GInputStream            // out
	var _arg2 C.GOutputStreamSpliceFlags // out
	var _cret C.gssize                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	_arg2 = C.GOutputStreamSpliceFlags(flags)

	_cret = C._gotk4_gio2_OutputStream_virtual_splice(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// spliceAsync splices a stream asynchronously. When the operation is finished
// callback will be called. You can then call g_output_stream_splice_finish() to
// get the result of the operation.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_splice().
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - source: Stream.
//   - flags: set of StreamSpliceFlags.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) spliceAsync(ctx context.Context, source InputStreamer, flags OutputStreamSpliceFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.splice_async

	var _arg0 *C.GOutputStream           // out
	var _arg4 *C.GCancellable            // out
	var _arg1 *C.GInputStream            // out
	var _arg2 C.GOutputStreamSpliceFlags // out
	var _arg3 C.int                      // out
	var _arg5 C.GAsyncReadyCallback      // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	_arg2 = C.GOutputStreamSpliceFlags(flags)
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_OutputStream_virtual_splice_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// spliceFinish finishes an asynchronous stream splice operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize of the number of bytes spliced. Note that if the number of bytes
//     spliced is greater than G_MAXSSIZE, then that will be returned, and there
//     is no way to determine the actual number of bytes spliced.
func (stream *OutputStream) spliceFinish(result AsyncResulter) (int, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.splice_finish

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_OutputStream_virtual_splice_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// writeAsync: request an asynchronous write of count bytes from buffer into the
// stream. When the operation is finished callback will be called. You can then
// call g_output_stream_write_finish() to get the result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// A value of count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes written will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it can
// happen e.g. on a partial I/O error, but generally we try to write as many
// bytes as requested.
//
// You are guaranteed that this method will never fail with
// G_IO_ERROR_WOULD_BLOCK - if stream can't accept more data, the method will
// just wait until this changes.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_write().
//
// Note that no copy of buffer will be made, so it must stay valid until
// callback is called. See g_output_stream_write_bytes_async() for a #GBytes
// version that will automatically hold a reference to the contents (without
// copying) for the duration of the call.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - buffer (optional) containing the data to write.
//   - ioPriority: io priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) writeAsync(ctx context.Context, buffer []byte, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.write_async

	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.void          // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_OutputStream_virtual_write_async(unsafe.Pointer(fnarg), _arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// writeFinish finishes a stream write operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - gssize containing the number of bytes written to the stream.
func (stream *OutputStream) writeFinish(result AsyncResulter) (int, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.write_finish

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_OutputStream_virtual_write_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// writeFn tries to write count bytes from buffer into the stream. Will block
// during the operation.
//
// If count is 0, returns 0 and does nothing. A value of count larger than
// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream.
// All writes block until at least one byte is written or an error occurs;
// 0 is never returned (unless count is 0).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - buffer (optional) containing the data to write.
//
// The function returns the following values:
//
//   - gssize: number of bytes written, or -1 on error.
func (stream *OutputStream) writeFn(ctx context.Context, buffer []byte) (int, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.write_fn

	var _arg0 *C.GOutputStream // out
	var _arg3 *C.GCancellable  // out
	var _arg1 *C.void          // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C._gotk4_gio2_OutputStream_virtual_write_fn(unsafe.Pointer(fnarg), _arg0, unsafe.Pointer(_arg1), _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// writevAsync: request an asynchronous write of the bytes contained in
// n_vectors vectors into the stream. When the operation is finished callback
// will be called. You can then call g_output_stream_writev_finish() to get the
// result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// On success, the number of bytes written will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it can
// happen e.g. on a partial I/O error, but generally we try to write as many
// bytes as requested.
//
// You are guaranteed that this method will never fail with
// G_IO_ERROR_WOULD_BLOCK  if stream can't accept more data, the method will
// just wait until this changes.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_writev().
//
// Note that no copy of vectors will be made, so it must stay valid until
// callback is called.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - vectors: buffer containing the Vectors to write.
//   - ioPriority: i/O priority of the request.
//   - callback (optional): ReadyCallback to call when the request is satisfied.
func (stream *OutputStream) writevAsync(ctx context.Context, vectors []OutputVector, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.writev_async

	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_OutputStream_virtual_writev_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// writevFinish finishes a stream writev operation.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
func (stream *OutputStream) writevFinish(result AsyncResulter) (uint, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.writev_finish

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_OutputStream_virtual_writev_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// writevFn tries to write the bytes contained in the n_vectors vectors into the
// stream. Will block during the operation.
//
// If n_vectors is 0 or the sum of all bytes in vectors is 0, returns 0 and does
// nothing.
//
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream.
// All writes block until at least one byte is written or an error occurs;
// 0 is never returned (unless n_vectors is 0 or the sum of all bytes in vectors
// is 0).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// Some implementations of g_output_stream_writev() may have limitations on the
// aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if these
// are exceeded. For example, when writing to a local file on UNIX platforms,
// the aggregate buffer size must not exceed G_MAXSSIZE bytes.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional cancellable object.
//   - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the stream.
func (stream *OutputStream) writevFn(ctx context.Context, vectors []OutputVector) (uint, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.writev_fn

	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	C._gotk4_gio2_OutputStream_virtual_writev_fn(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// PermissionOverrides contains methods that are overridable.
type PermissionOverrides struct {
	// Acquire attempts to acquire the permission represented by permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. A simple example is that a
	// dialog may appear asking the user to enter their password.
	//
	// You should check with g_permission_get_can_acquire() before calling this
	// function.
	//
	// If the permission is acquired then TRUE is returned. Otherwise, FALSE is
	// returned and error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required). See g_permission_acquire_async() for the
	// non-blocking version.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	Acquire func(ctx context.Context) error
	// AcquireFinish collects the result of attempting to acquire the permission
	// represented by permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_acquire().
	//
	// The function takes the following parameters:
	//
	//   - result given to the ReadyCallback.
	AcquireFinish func(result AsyncResulter) error
	// Release attempts to release the permission represented by permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. In most cases the permission
	// will be dropped immediately without further action.
	//
	// You should check with g_permission_get_can_release() before calling this
	// function.
	//
	// If the permission is released then TRUE is returned. Otherwise, FALSE is
	// returned and error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required). See g_permission_release_async() for the
	// non-blocking version.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	Release func(ctx context.Context) error
	// ReleaseFinish collects the result of attempting to release the permission
	// represented by permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_release().
	//
	// The function takes the following parameters:
	//
	//   - result given to the ReadyCallback.
	ReleaseFinish func(result AsyncResulter) error
}

func defaultPermissionOverrides(v *Permission) PermissionOverrides {
	return PermissionOverrides{
		Acquire:       v.acquire,
		AcquireFinish: v.acquireFinish,
		Release:       v.release,
		ReleaseFinish: v.releaseFinish,
	}
}

// Permission: GPermission represents the status of the callers permission to
// perform a certain action.
//
// You can query if the action is currently allowed and if it is possible to
// acquire the permission so that the action will be allowed in the future.
//
// There is also an API to actually acquire the permission and one to release
// it.
//
// As an example, a GPermission might represent the ability for the user to
// write to a gio.Settings object. This GPermission object could then be used
// to decide if it is appropriate to show a Click here to unlock button in a
// dialog and to provide the mechanism to invoke when that button is clicked.
type Permission struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Permission)(nil)
)

// Permissioner describes types inherited from class Permission.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Permissioner interface {
	coreglib.Objector
	basePermission() *Permission
}

var _ Permissioner = (*Permission)(nil)

func init() {
	coreglib.RegisterClassInfo[*Permission, *PermissionClass, PermissionOverrides](
		GTypePermission,
		initPermissionClass,
		wrapPermission,
		defaultPermissionOverrides,
	)
}

func initPermissionClass(gclass unsafe.Pointer, overrides PermissionOverrides, classInitFunc func(*PermissionClass)) {
	pclass := (*C.GPermissionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypePermission))))

	if overrides.Acquire != nil {
		pclass.acquire = (*[0]byte)(C._gotk4_gio2_PermissionClass_acquire)
	}

	if overrides.AcquireFinish != nil {
		pclass.acquire_finish = (*[0]byte)(C._gotk4_gio2_PermissionClass_acquire_finish)
	}

	if overrides.Release != nil {
		pclass.release = (*[0]byte)(C._gotk4_gio2_PermissionClass_release)
	}

	if overrides.ReleaseFinish != nil {
		pclass.release_finish = (*[0]byte)(C._gotk4_gio2_PermissionClass_release_finish)
	}

	if classInitFunc != nil {
		class := (*PermissionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPermission(obj *coreglib.Object) *Permission {
	return &Permission{
		Object: obj,
	}
}

func marshalPermission(p uintptr) (interface{}, error) {
	return wrapPermission(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (permission *Permission) basePermission() *Permission {
	return permission
}

// BasePermission returns the underlying base object.
func BasePermission(obj Permissioner) *Permission {
	return obj.basePermission()
}

// Acquire attempts to acquire the permission represented by permission.
//
// The precise method by which this happens depends on the permission and the
// underlying authentication mechanism. A simple example is that a dialog may
// appear asking the user to enter their password.
//
// You should check with g_permission_get_can_acquire() before calling this
// function.
//
// If the permission is acquired then TRUE is returned. Otherwise, FALSE is
// returned and error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required). See g_permission_acquire_async() for the
// non-blocking version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (permission *Permission) Acquire(ctx context.Context) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_permission_acquire(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AcquireAsync attempts to acquire the permission represented by permission.
//
// This is the first half of the asynchronous version of g_permission_acquire().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional) to call when done.
func (permission *Permission) AcquireAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GPermission        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_permission_acquire_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// AcquireFinish collects the result of attempting to acquire the permission
// represented by permission.
//
// This is the second half of the asynchronous version of
// g_permission_acquire().
//
// The function takes the following parameters:
//
//   - result given to the ReadyCallback.
func (permission *Permission) AcquireFinish(result AsyncResulter) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_permission_acquire_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Allowed gets the value of the 'allowed' property. This property is TRUE if
// the caller currently has permission to perform the action that permission
// represents the permission to perform.
//
// The function returns the following values:
//
//   - ok: value of the 'allowed' property.
func (permission *Permission) Allowed() bool {
	var _arg0 *C.GPermission // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))

	_cret = C.g_permission_get_allowed(_arg0)
	runtime.KeepAlive(permission)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanAcquire gets the value of the 'can-acquire' property. This property
// is TRUE if it is generally possible to acquire the permission by calling
// g_permission_acquire().
//
// The function returns the following values:
//
//   - ok: value of the 'can-acquire' property.
func (permission *Permission) CanAcquire() bool {
	var _arg0 *C.GPermission // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))

	_cret = C.g_permission_get_can_acquire(_arg0)
	runtime.KeepAlive(permission)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanRelease gets the value of the 'can-release' property. This property
// is TRUE if it is generally possible to release the permission by calling
// g_permission_release().
//
// The function returns the following values:
//
//   - ok: value of the 'can-release' property.
func (permission *Permission) CanRelease() bool {
	var _arg0 *C.GPermission // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))

	_cret = C.g_permission_get_can_release(_arg0)
	runtime.KeepAlive(permission)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ImplUpdate: this function is called by the #GPermission implementation to
// update the properties of the permission. You should never call this function
// except from a #GPermission implementation.
//
// GObject notify signals are generated, as appropriate.
//
// The function takes the following parameters:
//
//   - allowed: new value for the 'allowed' property.
//   - canAcquire: new value for the 'can-acquire' property.
//   - canRelease: new value for the 'can-release' property.
func (permission *Permission) ImplUpdate(allowed, canAcquire, canRelease bool) {
	var _arg0 *C.GPermission // out
	var _arg1 C.gboolean     // out
	var _arg2 C.gboolean     // out
	var _arg3 C.gboolean     // out

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	if allowed {
		_arg1 = C.TRUE
	}
	if canAcquire {
		_arg2 = C.TRUE
	}
	if canRelease {
		_arg3 = C.TRUE
	}

	C.g_permission_impl_update(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(allowed)
	runtime.KeepAlive(canAcquire)
	runtime.KeepAlive(canRelease)
}

// Release attempts to release the permission represented by permission.
//
// The precise method by which this happens depends on the permission and the
// underlying authentication mechanism. In most cases the permission will be
// dropped immediately without further action.
//
// You should check with g_permission_get_can_release() before calling this
// function.
//
// If the permission is released then TRUE is returned. Otherwise, FALSE is
// returned and error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required). See g_permission_release_async() for the
// non-blocking version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (permission *Permission) Release(ctx context.Context) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_permission_release(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ReleaseAsync attempts to release the permission represented by permission.
//
// This is the first half of the asynchronous version of g_permission_release().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional) to call when done.
func (permission *Permission) ReleaseAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GPermission        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_permission_release_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// ReleaseFinish collects the result of attempting to release the permission
// represented by permission.
//
// This is the second half of the asynchronous version of
// g_permission_release().
//
// The function takes the following parameters:
//
//   - result given to the ReadyCallback.
func (permission *Permission) ReleaseFinish(result AsyncResulter) error {
	var _arg0 *C.GPermission  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_permission_release_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Acquire attempts to acquire the permission represented by permission.
//
// The precise method by which this happens depends on the permission and the
// underlying authentication mechanism. A simple example is that a dialog may
// appear asking the user to enter their password.
//
// You should check with g_permission_get_can_acquire() before calling this
// function.
//
// If the permission is acquired then TRUE is returned. Otherwise, FALSE is
// returned and error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required). See g_permission_acquire_async() for the
// non-blocking version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (permission *Permission) acquire(ctx context.Context) error {
	gclass := (*C.GPermissionClass)(coreglib.PeekParentClass(permission))
	fnarg := gclass.acquire

	var _arg0 *C.GPermission  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_Permission_virtual_acquire(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// acquireAsync attempts to acquire the permission represented by permission.
//
// This is the first half of the asynchronous version of g_permission_acquire().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional) to call when done.
func (permission *Permission) acquireAsync(ctx context.Context, callback AsyncReadyCallback) {
	gclass := (*C.GPermissionClass)(coreglib.PeekParentClass(permission))
	fnarg := gclass.acquire_async

	var _arg0 *C.GPermission        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Permission_virtual_acquire_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// acquireFinish collects the result of attempting to acquire the permission
// represented by permission.
//
// This is the second half of the asynchronous version of
// g_permission_acquire().
//
// The function takes the following parameters:
//
//   - result given to the ReadyCallback.
func (permission *Permission) acquireFinish(result AsyncResulter) error {
	gclass := (*C.GPermissionClass)(coreglib.PeekParentClass(permission))
	fnarg := gclass.acquire_finish

	var _arg0 *C.GPermission  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Permission_virtual_acquire_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Release attempts to release the permission represented by permission.
//
// The precise method by which this happens depends on the permission and the
// underlying authentication mechanism. In most cases the permission will be
// dropped immediately without further action.
//
// You should check with g_permission_get_can_release() before calling this
// function.
//
// If the permission is released then TRUE is returned. Otherwise, FALSE is
// returned and error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required). See g_permission_release_async() for the
// non-blocking version.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (permission *Permission) release(ctx context.Context) error {
	gclass := (*C.GPermissionClass)(coreglib.PeekParentClass(permission))
	fnarg := gclass.release

	var _arg0 *C.GPermission  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_Permission_virtual_release(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// releaseAsync attempts to release the permission represented by permission.
//
// This is the first half of the asynchronous version of g_permission_release().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional) to call when done.
func (permission *Permission) releaseAsync(ctx context.Context, callback AsyncReadyCallback) {
	gclass := (*C.GPermissionClass)(coreglib.PeekParentClass(permission))
	fnarg := gclass.release_async

	var _arg0 *C.GPermission        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Permission_virtual_release_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// releaseFinish collects the result of attempting to release the permission
// represented by permission.
//
// This is the second half of the asynchronous version of
// g_permission_release().
//
// The function takes the following parameters:
//
//   - result given to the ReadyCallback.
func (permission *Permission) releaseFinish(result AsyncResulter) error {
	gclass := (*C.GPermissionClass)(coreglib.PeekParentClass(permission))
	fnarg := gclass.release_finish

	var _arg0 *C.GPermission  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_Permission_virtual_release_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PropertyAction: GPropertyAction is a way to get a gio.Action with a state
// value reflecting and controlling the value of a gobject.Object property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the gobject.ParamSpec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and nick string as
// per the gobject.EnumValue table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of glib.Variant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between).
// GPropertyAction does not have a separate state that is kept in sync with the
// property value  its state is the property value.
//
// For example, it might be useful to create a gio.Action
// corresponding to the visible-child-name property of a GtkStack
// (https://docs.gtk.org/gtk4/class.Stack.html) so that the current page can
// be switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the GtkStack.
//
// An anti-example would be binding the active-id property on a GtkComboBox
// (https://docs.gtk.org/gtk4/class.ComboBox.html). This is because the state of
// the combo box itself is probably uninteresting and is actually being used to
// control something else.
//
// Another anti-example would be to bind to the visible-child-name property
// of a GtkStack (https://docs.gtk.org/gtk4/class.Stack.html) if this value is
// actually stored in gio.Settings. In that case, the real source of the value
// is* gio.Settings. If you want a gio.Action to control a setting stored in
// gio.Settings, see gio.Settings.CreateAction() instead, and possibly combine
// its use with gio.Settings.Bind().
type PropertyAction struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Action
}

var (
	_ coreglib.Objector = (*PropertyAction)(nil)
)

func wrapPropertyAction(obj *coreglib.Object) *PropertyAction {
	return &PropertyAction{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	return wrapPropertyAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPropertyAction creates a #GAction corresponding to the value of property
// property_name on object.
//
// The property must be existent and readable and writable (and not
// construct-only).
//
// This function takes a reference on object and doesn't release it until the
// action is destroyed.
//
// The function takes the following parameters:
//
//   - name of the action to create.
//   - object that has the property to wrap.
//   - propertyName: name of the property.
//
// The function returns the following values:
//
//   - propertyAction: new Action.
func NewPropertyAction(name string, object *coreglib.Object, propertyName string) *PropertyAction {
	var _arg1 *C.gchar           // out
	var _arg2 C.gpointer         // out
	var _arg3 *C.gchar           // out
	var _cret *C.GPropertyAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_property_action_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(name)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)

	var _propertyAction *PropertyAction // out

	_propertyAction = wrapPropertyAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _propertyAction
}

// ProxyAddressOverrides contains methods that are overridable.
type ProxyAddressOverrides struct {
}

func defaultProxyAddressOverrides(v *ProxyAddress) ProxyAddressOverrides {
	return ProxyAddressOverrides{}
}

// ProxyAddress: gio.InetSocketAddress representing a connection via a proxy
// server.
type ProxyAddress struct {
	_ [0]func() // equal guard
	InetSocketAddress
}

var (
	_ SocketAddresser = (*ProxyAddress)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ProxyAddress, *ProxyAddressClass, ProxyAddressOverrides](
		GTypeProxyAddress,
		initProxyAddressClass,
		wrapProxyAddress,
		defaultProxyAddressOverrides,
	)
}

func initProxyAddressClass(gclass unsafe.Pointer, overrides ProxyAddressOverrides, classInitFunc func(*ProxyAddressClass)) {
	if classInitFunc != nil {
		class := (*ProxyAddressClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapProxyAddress(obj *coreglib.Object) *ProxyAddress {
	return &ProxyAddress{
		InetSocketAddress: InetSocketAddress{
			SocketAddress: SocketAddress{
				Object: obj,
				SocketConnectable: SocketConnectable{
					Object: obj,
				},
			},
		},
	}
}

func marshalProxyAddress(p uintptr) (interface{}, error) {
	return wrapProxyAddress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewProxyAddress creates a new Address for inetaddr with protocol that should
// tunnel through dest_hostname and dest_port.
//
// (Note that this method doesn't set the Address:uri or
// Address:destination-protocol fields; use g_object_new() directly if you want
// to set those.).
//
// The function takes the following parameters:
//
//   - inetaddr: proxy server Address.
//   - port: proxy server port.
//   - protocol: proxy protocol to support, in lower case (e.g. socks, http).
//   - destHostname: destination hostname the proxy should tunnel to.
//   - destPort: destination port to tunnel to.
//   - username (optional) to authenticate to the proxy server (or NULL).
//   - password (optional) to authenticate to the proxy server (or NULL).
//
// The function returns the following values:
//
//   - proxyAddress: new Address.
func NewProxyAddress(inetaddr *InetAddress, port uint16, protocol, destHostname string, destPort uint16, username, password string) *ProxyAddress {
	var _arg1 *C.GInetAddress   // out
	var _arg2 C.guint16         // out
	var _arg3 *C.gchar          // out
	var _arg4 *C.gchar          // out
	var _arg5 C.guint16         // out
	var _arg6 *C.gchar          // out
	var _arg7 *C.gchar          // out
	var _cret *C.GSocketAddress // in

	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(inetaddr).Native()))
	_arg2 = C.guint16(port)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(destHostname)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.guint16(destPort)
	if username != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(username)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if password != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(_arg7))
	}

	_cret = C.g_proxy_address_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(inetaddr)
	runtime.KeepAlive(port)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(destHostname)
	runtime.KeepAlive(destPort)
	runtime.KeepAlive(username)
	runtime.KeepAlive(password)

	var _proxyAddress *ProxyAddress // out

	_proxyAddress = wrapProxyAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _proxyAddress
}

// DestinationHostname gets proxy's destination hostname; that is, the name of
// the host that will be connected to via the proxy, not the name of the proxy
// itself.
//
// The function returns the following values:
//
//   - utf8 proxy's destination hostname.
func (proxy *ProxyAddress) DestinationHostname() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_address_get_destination_hostname(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DestinationPort gets proxy's destination port; that is, the port on the
// destination host that will be connected to via the proxy, not the port number
// of the proxy itself.
//
// The function returns the following values:
//
//   - guint16 proxy's destination port.
func (proxy *ProxyAddress) DestinationPort() uint16 {
	var _arg0 *C.GProxyAddress // out
	var _cret C.guint16        // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_address_get_destination_port(_arg0)
	runtime.KeepAlive(proxy)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// DestinationProtocol gets the protocol that is being spoken to the destination
// server; eg, "http" or "ftp".
//
// The function returns the following values:
//
//   - utf8 proxy's destination protocol.
func (proxy *ProxyAddress) DestinationProtocol() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_address_get_destination_protocol(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Password gets proxy's password.
//
// The function returns the following values:
//
//   - utf8 (optional) proxy's password.
func (proxy *ProxyAddress) Password() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_address_get_password(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Protocol gets proxy's protocol. eg, "socks" or "http".
//
// The function returns the following values:
//
//   - utf8 proxy's protocol.
func (proxy *ProxyAddress) Protocol() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_address_get_protocol(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// URI gets the proxy URI that proxy was constructed from.
//
// The function returns the following values:
//
//   - utf8 (optional) proxy's URI, or NULL if unknown.
func (proxy *ProxyAddress) URI() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_address_get_uri(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Username gets proxy's username.
//
// The function returns the following values:
//
//   - utf8 (optional) proxy's username.
func (proxy *ProxyAddress) Username() string {
	var _arg0 *C.GProxyAddress // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GProxyAddress)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	_cret = C.g_proxy_address_get_username(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ProxyAddressEnumeratorOverrides contains methods that are overridable.
type ProxyAddressEnumeratorOverrides struct {
}

func defaultProxyAddressEnumeratorOverrides(v *ProxyAddressEnumerator) ProxyAddressEnumeratorOverrides {
	return ProxyAddressEnumeratorOverrides{}
}

// ProxyAddressEnumerator: GProxyAddressEnumerator is a wrapper around
// gio.SocketAddressEnumerator which takes the gio.SocketAddress
// instances returned by the gio.SocketAddressEnumerator and
// wraps them in gio.ProxyAddress instances, using the given
// gio.ProxyAddressEnumerator:proxy-resolver.
//
// This enumerator will be returned (for example, by
// gio.SocketConnectable.Enumerate()) as appropriate when a proxy is configured;
// there should be no need to manually wrap a gio.SocketAddressEnumerator
// instance with one.
type ProxyAddressEnumerator struct {
	_ [0]func() // equal guard
	SocketAddressEnumerator
}

var (
	_ SocketAddressEnumeratorrer = (*ProxyAddressEnumerator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ProxyAddressEnumerator, *ProxyAddressEnumeratorClass, ProxyAddressEnumeratorOverrides](
		GTypeProxyAddressEnumerator,
		initProxyAddressEnumeratorClass,
		wrapProxyAddressEnumerator,
		defaultProxyAddressEnumeratorOverrides,
	)
}

func initProxyAddressEnumeratorClass(gclass unsafe.Pointer, overrides ProxyAddressEnumeratorOverrides, classInitFunc func(*ProxyAddressEnumeratorClass)) {
	if classInitFunc != nil {
		class := (*ProxyAddressEnumeratorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapProxyAddressEnumerator(obj *coreglib.Object) *ProxyAddressEnumerator {
	return &ProxyAddressEnumerator{
		SocketAddressEnumerator: SocketAddressEnumerator{
			Object: obj,
		},
	}
}

func marshalProxyAddressEnumerator(p uintptr) (interface{}, error) {
	return wrapProxyAddressEnumerator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ResolverOverrides contains methods that are overridable.
type ResolverOverrides struct {
	// LookupByAddress: synchronously reverse-resolves address to determine its
	// associated hostname.
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation,
	// in which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - address to reverse-resolve.
	//
	// The function returns the following values:
	//
	//   - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL
	//     on error.
	LookupByAddress func(ctx context.Context, address *InetAddress) (string, error)
	// LookupByAddressFinish retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a
	// value from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//   - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//   - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL
	//     on error.
	LookupByAddressFinish func(result AsyncResulter) (string, error)
	// LookupByName: synchronously resolves hostname to determine its associated
	// IP address(es). hostname may be an ASCII-only or UTF-8 hostname, or the
	// textual form of an IP address (in which case this just becomes a wrapper
	// around g_inet_address_new_from_string()).
	//
	// On success, g_resolver_lookup_by_name() will return a non-empty
	// #GList of Address, sorted in order of preference and guaranteed to
	// not contain duplicates. That is, if using the result to connect to
	// hostname, you should attempt to connect to the first address first,
	// then the second if the first fails, etc. If you are using the result
	// to listen on a socket, it is appropriate to add each result using e.g.
	// g_socket_listener_add_address().
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error and NULL will be returned.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation,
	// in which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// If you are planning to connect to a socket on the resolved IP address,
	// it may be easier to create a Address and use its Connectable interface.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - hostname to look up.
	//
	// The function returns the following values:
	//
	//   - list: non-empty #GList of Address, or NULL on error. You must unref
	//     each of the addresses and free the list when you are done with it.
	//     (You can use g_resolver_free_addresses() to do this.).
	LookupByName func(ctx context.Context, hostname string) ([]*InetAddress, error)
	// LookupByNameFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a
	// value from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//   - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//   - list Address, or NULL on error. See g_resolver_lookup_by_name() for
	//     more details.
	LookupByNameFinish func(result AsyncResulter) ([]*InetAddress, error)
	// LookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in
	// that you can modify the lookup behavior with flags. For example this can
	// be used to limit results with G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - hostname to look up.
	//   - flags: extra NameLookupFlags for the lookup.
	//
	// The function returns the following values:
	//
	//   - list: non-empty #GList of Address, or NULL on error. You must unref
	//     each of the addresses and free the list when you are done with it.
	//     (You can use g_resolver_free_addresses() to do this.).
	LookupByNameWithFlags func(ctx context.Context, hostname string, flags ResolverNameLookupFlags) ([]*InetAddress, error)
	// LookupByNameWithFlagsFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_with_flags_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a
	// value from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//   - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//   - list Address, or NULL on error. See g_resolver_lookup_by_name() for
	//     more details.
	LookupByNameWithFlagsFinish func(result AsyncResulter) ([]*InetAddress, error)
	// LookupRecords: synchronously performs a DNS record lookup for the given
	// rrname and returns a list of records as #GVariant tuples. See RecordType
	// for information on what the records contain for each record_type.
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error and NULL will be returned.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation,
	// in which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - rrname: DNS name to look up the record for.
	//   - recordType: type of DNS record to look up.
	//
	// The function returns the following values:
	//
	//   - list: non-empty #GList of #GVariant, or NULL on error. You must
	//     free each of the records and the list when you are done with it.
	//     (You can use g_list_free_full() with g_variant_unref() to do this.).
	LookupRecords func(ctx context.Context, rrname string, recordType ResolverRecordType) ([]*glib.Variant, error)
	// LookupRecordsFinish retrieves the result of a previous call to
	// g_resolver_lookup_records_async(). Returns a non-empty list of records
	// as #GVariant tuples. See RecordType for information on what the records
	// contain.
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a
	// value from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//   - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//   - list: non-empty #GList of #GVariant, or NULL on error. You must
	//     free each of the records and the list when you are done with it.
	//     (You can use g_list_free_full() with g_variant_unref() to do this.).
	LookupRecordsFinish func(result AsyncResulter) ([]*glib.Variant, error)
	// LookupServiceFinish retrieves the result of a previous call to
	// g_resolver_lookup_service_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a
	// value from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//   - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//   - list: non-empty #GList of Target, or NULL on error. See
	//     g_resolver_lookup_service() for more details.
	LookupServiceFinish func(result AsyncResulter) ([]*SrvTarget, error)
	Reload              func()
}

func defaultResolverOverrides(v *Resolver) ResolverOverrides {
	return ResolverOverrides{
		LookupByAddress:             v.lookupByAddress,
		LookupByAddressFinish:       v.lookupByAddressFinish,
		LookupByName:                v.lookupByName,
		LookupByNameFinish:          v.lookupByNameFinish,
		LookupByNameWithFlags:       v.lookupByNameWithFlags,
		LookupByNameWithFlagsFinish: v.lookupByNameWithFlagsFinish,
		LookupRecords:               v.lookupRecords,
		LookupRecordsFinish:         v.lookupRecordsFinish,
		LookupServiceFinish:         v.lookupServiceFinish,
		Reload:                      v.reload,
	}
}

// Resolver: object that handles DNS resolution. Use gio.Resolver().GetDefault
// to get the default resolver.
//
// GResolver provides cancellable synchronous and asynchronous
// DNS resolution, for hostnames (gio.Resolver.LookupByAddress(),
// gio.Resolver.LookupByName() and their async variants) and SRV (service)
// records (gio.Resolver.LookupService()).
//
// gio.NetworkAddress and gio.NetworkService provide wrappers around GResolver
// functionality that also implement gio.SocketConnectable, making it easy to
// connect to a remote host/service.
//
// The default resolver (see gio.Resolver().GetDefault) has a timeout of 30s
// set on it since GLib 2.78. Earlier versions of GLib did not support resolver
// timeouts.
//
// This is an abstract type; subclasses of it implement different resolvers for
// different platforms and situations.
type Resolver struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Resolver)(nil)
)

// Resolverer describes types inherited from class Resolver.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Resolverer interface {
	coreglib.Objector
	baseResolver() *Resolver
}

var _ Resolverer = (*Resolver)(nil)

func init() {
	coreglib.RegisterClassInfo[*Resolver, *ResolverClass, ResolverOverrides](
		GTypeResolver,
		initResolverClass,
		wrapResolver,
		defaultResolverOverrides,
	)
}

func initResolverClass(gclass unsafe.Pointer, overrides ResolverOverrides, classInitFunc func(*ResolverClass)) {
	pclass := (*C.GResolverClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeResolver))))

	if overrides.LookupByAddress != nil {
		pclass.lookup_by_address = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_address)
	}

	if overrides.LookupByAddressFinish != nil {
		pclass.lookup_by_address_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_address_finish)
	}

	if overrides.LookupByName != nil {
		pclass.lookup_by_name = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name)
	}

	if overrides.LookupByNameFinish != nil {
		pclass.lookup_by_name_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_finish)
	}

	if overrides.LookupByNameWithFlags != nil {
		pclass.lookup_by_name_with_flags = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_with_flags)
	}

	if overrides.LookupByNameWithFlagsFinish != nil {
		pclass.lookup_by_name_with_flags_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish)
	}

	if overrides.LookupRecords != nil {
		pclass.lookup_records = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_records)
	}

	if overrides.LookupRecordsFinish != nil {
		pclass.lookup_records_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_records_finish)
	}

	if overrides.LookupServiceFinish != nil {
		pclass.lookup_service_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_service_finish)
	}

	if overrides.Reload != nil {
		pclass.reload = (*[0]byte)(C._gotk4_gio2_ResolverClass_reload)
	}

	if classInitFunc != nil {
		class := (*ResolverClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapResolver(obj *coreglib.Object) *Resolver {
	return &Resolver{
		Object: obj,
	}
}

func marshalResolver(p uintptr) (interface{}, error) {
	return wrapResolver(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (resolver *Resolver) baseResolver() *Resolver {
	return resolver
}

// BaseResolver returns the underlying base object.
func BaseResolver(obj Resolverer) *Resolver {
	return obj.baseResolver()
}

// ConnectReload is emitted when the resolver notices that the system resolver
// configuration has changed.
func (resolver *Resolver) ConnectReload(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(resolver, "reload", false, unsafe.Pointer(C._gotk4_gio2_Resolver_ConnectReload), f)
}

// Timeout: get the timeout applied to all resolver lookups. See
// #GResolver:timeout.
//
// The function returns the following values:
//
//   - guint: resolver timeout, in milliseconds, or 0 for no timeout.
func (resolver *Resolver) Timeout() uint {
	var _arg0 *C.GResolver // out
	var _cret C.unsigned   // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))

	_cret = C.g_resolver_get_timeout(_arg0)
	runtime.KeepAlive(resolver)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// LookupByAddress: synchronously reverse-resolves address to determine its
// associated hostname.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address to reverse-resolve.
//
// The function returns the following values:
//
//   - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//     error.
func (resolver *Resolver) LookupByAddress(ctx context.Context, address *InetAddress) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.GInetAddress // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_resolver_lookup_by_address(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByAddressAsync begins asynchronously reverse-resolving address to
// determine its associated hostname, and eventually calls callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address to reverse-resolve.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) LookupByAddressAsync(ctx context.Context, address *InetAddress, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GInetAddress       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_address_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// LookupByAddressFinish retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//     error.
func (resolver *Resolver) LookupByAddressFinish(result AsyncResulter) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_by_address_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByName: synchronously resolves hostname to determine its associated IP
// address(es). hostname may be an ASCII-only or UTF-8 hostname, or the textual
// form of an IP address (in which case this just becomes a wrapper around
// g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList
// of Address, sorted in order of preference and guaranteed to not contain
// duplicates. That is, if using the result to connect to hostname, you should
// attempt to connect to the first address first, then the second if the
// first fails, etc. If you are using the result to listen on a socket, it is
// appropriate to add each result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP address,
// it may be easier to create a Address and use its Connectable interface.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up.
//
// The function returns the following values:
//
//   - list: non-empty #GList of Address, or NULL on error. You must unref each
//     of the addresses and free the list when you are done with it. (You can
//     use g_resolver_free_addresses() to do this.).
func (resolver *Resolver) LookupByName(ctx context.Context, hostname string) ([]*InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_resolver_lookup_by_name(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameAsync begins asynchronously resolving hostname to determine
// its associated IP address(es), and eventually calls callback,
// which must call g_resolver_lookup_by_name_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up the address of.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) LookupByNameAsync(ctx context.Context, hostname string, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_name_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(callback)
}

// LookupByNameFinish retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//     details.
func (resolver *Resolver) LookupByNameFinish(result AsyncResulter) ([]*InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_by_name_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in that
// you can modify the lookup behavior with flags. For example this can be used
// to limit results with G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up.
//   - flags: extra NameLookupFlags for the lookup.
//
// The function returns the following values:
//
//   - list: non-empty #GList of Address, or NULL on error. You must unref each
//     of the addresses and free the list when you are done with it. (You can
//     use g_resolver_free_addresses() to do this.).
func (resolver *Resolver) LookupByNameWithFlags(ctx context.Context, hostname string, flags ResolverNameLookupFlags) ([]*InetAddress, error) {
	var _arg0 *C.GResolver               // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.gchar                   // out
	var _arg2 C.GResolverNameLookupFlags // out
	var _cret *C.GList                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverNameLookupFlags(flags)

	_cret = C.g_resolver_lookup_by_name_with_flags(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameWithFlagsAsync begins asynchronously resolving hostname to
// determine its associated IP address(es), and eventually calls callback, which
// must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up the address of.
//   - flags: extra NameLookupFlags for the lookup.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) LookupByNameWithFlagsAsync(ctx context.Context, hostname string, flags ResolverNameLookupFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver               // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.gchar                   // out
	var _arg2 C.GResolverNameLookupFlags // out
	var _arg4 C.GAsyncReadyCallback      // out
	var _arg5 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverNameLookupFlags(flags)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_name_with_flags_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// LookupByNameWithFlagsFinish retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//     details.
func (resolver *Resolver) LookupByNameWithFlagsFinish(result AsyncResulter) ([]*InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_by_name_with_flags_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupRecords: synchronously performs a DNS record lookup for the given
// rrname and returns a list of records as #GVariant tuples. See RecordType for
// information on what the records contain for each record_type.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - rrname: DNS name to look up the record for.
//   - recordType: type of DNS record to look up.
//
// The function returns the following values:
//
//   - list: non-empty #GList of #GVariant, or NULL on error. You must free
//     each of the records and the list when you are done with it. (You can use
//     g_list_free_full() with g_variant_unref() to do this.).
func (resolver *Resolver) LookupRecords(ctx context.Context, rrname string, recordType ResolverRecordType) ([]*glib.Variant, error) {
	var _arg0 *C.GResolver          // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GResolverRecordType // out
	var _cret *C.GList              // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverRecordType(recordType)

	_cret = C.g_resolver_lookup_records(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)

	var _list []*glib.Variant // out
	var _goerr error          // out

	_list = make([]*glib.Variant, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVariant)(v)
		var dst *glib.Variant // out
		dst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupRecordsAsync begins asynchronously performing a DNS lookup
// for the given rrname, and eventually calls callback, which must
// call g_resolver_lookup_records_finish() to get the final result. See
// g_resolver_lookup_records() for more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - rrname: DNS name to look up the record for.
//   - recordType: type of DNS record to look up.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) LookupRecordsAsync(ctx context.Context, rrname string, recordType ResolverRecordType, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GResolverRecordType // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverRecordType(recordType)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_records_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)
	runtime.KeepAlive(callback)
}

// LookupRecordsFinish retrieves the result of a previous call to
// g_resolver_lookup_records_async(). Returns a non-empty list of records as
// #GVariant tuples. See RecordType for information on what the records contain.
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list: non-empty #GList of #GVariant, or NULL on error. You must free
//     each of the records and the list when you are done with it. (You can use
//     g_list_free_full() with g_variant_unref() to do this.).
func (resolver *Resolver) LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_records_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*glib.Variant // out
	var _goerr error          // out

	_list = make([]*glib.Variant, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVariant)(v)
		var dst *glib.Variant // out
		dst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupService: synchronously performs a DNS SRV lookup for the given service
// and protocol in the given domain and returns an array of Target. domain may
// be an ASCII-only or UTF-8 hostname. Note also that the service and protocol
// arguments do not include the leading underscore that appears in the actual
// DNS entry.
//
// On success, g_resolver_lookup_service() will return a non-empty #GList
// of Target, sorted in order of preference. (That is, you should attempt to
// connect to the first target first, then the second if the first fails, etc.)
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to the service, it is usually easier to create
// a Service and use its Connectable interface.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - service type to look up (eg, "ldap").
//   - protocol: networking protocol to use for service (eg, "tcp").
//   - domain: DNS domain to look up the service in.
//
// The function returns the following values:
//
//   - list: non-empty #GList of Target, or NULL on error. You must free each
//     of the targets and the list when you are done with it. (You can use
//     g_resolver_free_targets() to do this.).
func (resolver *Resolver) LookupService(ctx context.Context, service, protocol, domain string) ([]*SrvTarget, error) {
	var _arg0 *C.GResolver    // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_resolver_lookup_service(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupServiceAsync begins asynchronously performing a DNS SRV lookup for
// the given service and protocol in the given domain, and eventually calls
// callback, which must call g_resolver_lookup_service_finish() to get the final
// result. See g_resolver_lookup_service() for more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - service type to look up (eg, "ldap").
//   - protocol: networking protocol to use for service (eg, "tcp").
//   - domain: DNS domain to look up the service in.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) LookupServiceAsync(ctx context.Context, service, protocol, domain string, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_service_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(callback)
}

// LookupServiceFinish retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list: non-empty #GList of Target, or NULL on error. See
//     g_resolver_lookup_service() for more details.
func (resolver *Resolver) LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_service_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SetDefault sets resolver to be the application's default resolver (reffing
// resolver, and unreffing the previous default resolver, if any). Future calls
// to g_resolver_get_default() will return this resolver.
//
// This can be used if an application wants to perform any sort of DNS caching
// or "pinning"; it can implement its own #GResolver that calls the original
// default resolver for DNS operations, and implements its own cache policies on
// top of that, and then set itself as the default resolver for all later code
// to use.
func (resolver *Resolver) SetDefault() {
	var _arg0 *C.GResolver // out

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))

	C.g_resolver_set_default(_arg0)
	runtime.KeepAlive(resolver)
}

// SetTimeout: set the timeout applied to all resolver lookups. See
// #GResolver:timeout.
//
// The function takes the following parameters:
//
//   - timeoutMs: timeout in milliseconds, or 0 for no timeouts.
func (resolver *Resolver) SetTimeout(timeoutMs uint) {
	var _arg0 *C.GResolver // out
	var _arg1 C.unsigned   // out

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = C.unsigned(timeoutMs)

	C.g_resolver_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(timeoutMs)
}

// lookupByAddress: synchronously reverse-resolves address to determine its
// associated hostname.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address to reverse-resolve.
//
// The function returns the following values:
//
//   - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//     error.
func (resolver *Resolver) lookupByAddress(ctx context.Context, address *InetAddress) (string, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_address

	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.GInetAddress // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_address(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// lookupByAddressAsync begins asynchronously reverse-resolving address to
// determine its associated hostname, and eventually calls callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - address to reverse-resolve.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) lookupByAddressAsync(ctx context.Context, address *InetAddress, callback AsyncReadyCallback) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_address_async

	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GInetAddress       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Resolver_virtual_lookup_by_address_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// lookupByAddressFinish retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//     error.
func (resolver *Resolver) lookupByAddressFinish(result AsyncResulter) (string, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_address_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_address_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// lookupByName: synchronously resolves hostname to determine its associated IP
// address(es). hostname may be an ASCII-only or UTF-8 hostname, or the textual
// form of an IP address (in which case this just becomes a wrapper around
// g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList
// of Address, sorted in order of preference and guaranteed to not contain
// duplicates. That is, if using the result to connect to hostname, you should
// attempt to connect to the first address first, then the second if the
// first fails, etc. If you are using the result to listen on a socket, it is
// appropriate to add each result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP address,
// it may be easier to create a Address and use its Connectable interface.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up.
//
// The function returns the following values:
//
//   - list: non-empty #GList of Address, or NULL on error. You must unref each
//     of the addresses and free the list when you are done with it. (You can
//     use g_resolver_free_addresses() to do this.).
func (resolver *Resolver) lookupByName(ctx context.Context, hostname string) ([]*InetAddress, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name

	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_name(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupByNameAsync begins asynchronously resolving hostname to determine
// its associated IP address(es), and eventually calls callback,
// which must call g_resolver_lookup_by_name_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up the address of.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) lookupByNameAsync(ctx context.Context, hostname string, callback AsyncReadyCallback) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name_async

	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Resolver_virtual_lookup_by_name_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(callback)
}

// lookupByNameFinish retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//     details.
func (resolver *Resolver) lookupByNameFinish(result AsyncResulter) ([]*InetAddress, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_name_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in that
// you can modify the lookup behavior with flags. For example this can be used
// to limit results with G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up.
//   - flags: extra NameLookupFlags for the lookup.
//
// The function returns the following values:
//
//   - list: non-empty #GList of Address, or NULL on error. You must unref each
//     of the addresses and free the list when you are done with it. (You can
//     use g_resolver_free_addresses() to do this.).
func (resolver *Resolver) lookupByNameWithFlags(ctx context.Context, hostname string, flags ResolverNameLookupFlags) ([]*InetAddress, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name_with_flags

	var _arg0 *C.GResolver               // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.gchar                   // out
	var _arg2 C.GResolverNameLookupFlags // out
	var _cret *C.GList                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverNameLookupFlags(flags)

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_name_with_flags(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupByNameWithFlagsAsync begins asynchronously resolving hostname to
// determine its associated IP address(es), and eventually calls callback, which
// must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostname to look up the address of.
//   - flags: extra NameLookupFlags for the lookup.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) lookupByNameWithFlagsAsync(ctx context.Context, hostname string, flags ResolverNameLookupFlags, callback AsyncReadyCallback) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name_with_flags_async

	var _arg0 *C.GResolver               // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.gchar                   // out
	var _arg2 C.GResolverNameLookupFlags // out
	var _arg4 C.GAsyncReadyCallback      // out
	var _arg5 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverNameLookupFlags(flags)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Resolver_virtual_lookup_by_name_with_flags_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// lookupByNameWithFlagsFinish retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//     details.
func (resolver *Resolver) lookupByNameWithFlagsFinish(result AsyncResulter) ([]*InetAddress, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name_with_flags_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_name_with_flags_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupRecords: synchronously performs a DNS record lookup for the given
// rrname and returns a list of records as #GVariant tuples. See RecordType for
// information on what the records contain for each record_type.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - rrname: DNS name to look up the record for.
//   - recordType: type of DNS record to look up.
//
// The function returns the following values:
//
//   - list: non-empty #GList of #GVariant, or NULL on error. You must free
//     each of the records and the list when you are done with it. (You can use
//     g_list_free_full() with g_variant_unref() to do this.).
func (resolver *Resolver) lookupRecords(ctx context.Context, rrname string, recordType ResolverRecordType) ([]*glib.Variant, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_records

	var _arg0 *C.GResolver          // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GResolverRecordType // out
	var _cret *C.GList              // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverRecordType(recordType)

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_records(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)

	var _list []*glib.Variant // out
	var _goerr error          // out

	_list = make([]*glib.Variant, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVariant)(v)
		var dst *glib.Variant // out
		dst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupRecordsAsync begins asynchronously performing a DNS lookup
// for the given rrname, and eventually calls callback, which must
// call g_resolver_lookup_records_finish() to get the final result. See
// g_resolver_lookup_records() for more details.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - rrname: DNS name to look up the record for.
//   - recordType: type of DNS record to look up.
//   - callback (optional) to call after resolution completes.
func (resolver *Resolver) lookupRecordsAsync(ctx context.Context, rrname string, recordType ResolverRecordType, callback AsyncReadyCallback) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_records_async

	var _arg0 *C.GResolver          // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GResolverRecordType // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverRecordType(recordType)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Resolver_virtual_lookup_records_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)
	runtime.KeepAlive(callback)
}

// lookupRecordsFinish retrieves the result of a previous call to
// g_resolver_lookup_records_async(). Returns a non-empty list of records as
// #GVariant tuples. See RecordType for information on what the records contain.
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list: non-empty #GList of #GVariant, or NULL on error. You must free
//     each of the records and the list when you are done with it. (You can use
//     g_list_free_full() with g_variant_unref() to do this.).
func (resolver *Resolver) lookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_records_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_records_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*glib.Variant // out
	var _goerr error          // out

	_list = make([]*glib.Variant, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVariant)(v)
		var dst *glib.Variant // out
		dst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// The function takes the following parameters:
//
//   - ctx (optional)
//   - rrname
//   - callback (optional)
func (resolver *Resolver) lookupServiceAsync(ctx context.Context, rrname string, callback AsyncReadyCallback) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_service_async

	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Resolver_virtual_lookup_service_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(callback)
}

// lookupServiceFinish retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a
// value from Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//   - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//   - list: non-empty #GList of Target, or NULL on error. See
//     g_resolver_lookup_service() for more details.
func (resolver *Resolver) lookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_service_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_service_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

func (resolver *Resolver) reload() {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.reload

	var _arg0 *C.GResolver // out

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))

	C._gotk4_gio2_Resolver_virtual_reload(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(resolver)
}

// ResolverGetDefault gets the default #GResolver. You should unref it when you
// are done with it. #GResolver may use its reference count as a hint about how
// many threads it should allocate for concurrent DNS resolutions.
//
// The function returns the following values:
//
//   - resolver: default #GResolver.
func ResolverGetDefault() Resolverer {
	var _cret *C.GResolver // in

	_cret = C.g_resolver_get_default()

	var _resolver Resolverer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.Resolverer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Resolverer)
			return ok
		})
		rv, ok := casted.(Resolverer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Resolverer")
		}
		_resolver = rv
	}

	return _resolver
}

// SettingsOverrides contains methods that are overridable.
type SettingsOverrides struct {
	// The function takes the following parameters:
	//
	//   - keys
	//   - nKeys
	ChangeEvent         func(keys *glib.Quark, nKeys int) bool
	Changed             func(key string)
	WritableChangeEvent func(key glib.Quark) bool
	WritableChanged     func(key string)
}

func defaultSettingsOverrides(v *Settings) SettingsOverrides {
	return SettingsOverrides{
		ChangeEvent:         v.changeEvent,
		Changed:             v.changed,
		WritableChangeEvent: v.writableChangeEvent,
		WritableChanged:     v.writableChanged,
	}
}

// Settings: GSettings class provides a convenient API for storing and
// retrieving application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings
// with GSettings is typically extremely fast: on approximately the same order
// of magnitude (but slower than) a glib.HashTable lookup. Writing settings
// is also extremely fast in terms of time to return to your application,
// but can be extremely expensive for other threads and other processes.
// Many settings backends (including dconf) have lazy initialisation which means
// in the common case of the user using their computer without modifying any
// settings a lot of work can be avoided. For dconf, the D-Bus service doesnt
// even need to be started in this case. For this reason, you should only ever
// modify GSettings keys in response to explicit user action. Particular care
// should be paid to ensure that modifications are not made during startup
//  for example, when setting the initial value of preferences widgets. The
// built-in gio.Settings.Bind() functionality is careful not to write settings
// in response to notify signals as a result of modifications that it makes to
// widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values,
// as well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be relocatable (#relocatable-schemas), i.e. not equipped with a fixed path.
// This is useful e.g. when the schema describes an account, and you want to
// be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character (/) and must
// not contain two sequential slash characters. Paths should be chosen based
// on a domain name associated with the program or library to which the
// settings belong. Examples of paths are /org/gtk/settings/file-chooser/ and
// /ca/desrt/dconf-editor/. Paths should not start with /apps/, /desktop/ or
// /system/ as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// glib.Variant, and allows any glib.VariantType for keys. Key names are
// restricted to lowercase characters, numbers and -. Furthermore, the names
// must begin with a lowercase character, must not end with a -, and must not
// contain consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up
// with the domain that is specified in the gettext-domain attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// l10n attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The l10n attribute must be set to messages
// or time, and sets the [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The messages category should be used by default; use time for translatable
// date or time formats. A translation comment can be added as an XML comment
// immediately above the <default> element  it is recommended to add these
// comments to aid translators understand the meaning and implications of the
// default value. An optional translation context attribute can be set on the
// <default> element to disambiguate multiple defaults which use the same
// string.
//
// For example:
//
//	<!-- Translators: A list of words which are not allowed to be typed, in
//	     GVariant serialization syntax.
//	     See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//	<default l10n='messages' context='Banned words'>['bad', 'words']</default>
//
// Translations of default values must remain syntactically valid serialized
// glib.Variants (e.g. retaining any surrounding quotation marks) or runtime
// errors will occur.
//
// GSettings uses schemas in a compact binary form that is created by the
// glib-compile-schemas (glib-compile-schemas.html) utility. The input is a
// schema description in an XML format.
//
// A DTD for the gschema XML format can be found here: gschema.dtd
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
//
// The glib-compile-schemas (glib-compile-schemas.html) tool expects schema
// files to have the extension .gschema.xml.
//
// At runtime, schemas are identified by their ID (as specified in the
// id attribute of the <schema> element). The convention for schema IDs
// is to use a dotted name, similar in style to a D-Bus bus name, e.g.
// org.gnome.SessionManager. In particular, if the settings are for a specific
// service that owns a D-Bus bus name, the D-Bus bus name and schema ID should
// match. For schemas which deal with settings not associated with one named
// application, the ID should not use StudlyCaps, e.g. org.gnome.font-rendering.
//
// In addition to glib.Variant types, keys can have types that have enumerated
// types. These can be described by a <choice>, <enum> or <flags> element,
// as seen in the second example below. The underlying type of such a key is
// string, but you can use gio.Settings.GetEnum(), gio.Settings.SetEnum(),
// gio.Settings.GetFlags(), gio.Settings.SetFlags() access the numeric values
// corresponding to the string value of enum and flags keys.
//
// An example for default value:
//
//	<schemalist>
//	  <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
//
//	    <key name="greeting" type="s">
//	      <default l10n="messages">"Hello, earthlings"</default>
//	      <summary>A greeting</summary>
//	      <description>
//	        Greeting of the invading martians
//	      </description>
//	    </key>
//
//	    <key name="box" type="(ii)">
//	      <default>(20,30)</default>
//	    </key>
//
//	    <key name="empty-string" type="s">
//	      <default>""</default>
//	      <summary>Empty strings have to be provided in GVariant form</summary>
//	    </key>
//
//	  </schema>
//	</schemalist>
//
// An example for ranges, choices and enumerated types:
//
//	<schemalist>
//
//	  <enum id="org.gtk.Test.myenum">
//	    <value nick="first" value="1"/>
//	    <value nick="second" value="2"/>
//	  </enum>
//
//	  <flags id="org.gtk.Test.myflags">
//	    <value nick="flag1" value="1"/>
//	    <value nick="flag2" value="2"/>
//	    <value nick="flag3" value="4"/>
//	  </flags>
//
//	  <schema id="org.gtk.Test">
//
//	    <key name="key-with-range" type="i">
//	      <range min="1" max="100"/>
//	      <default>10</default>
//	    </key>
//
//	    <key name="key-with-choices" type="s">
//	      <choices>
//	        <choice value='Elisabeth'/>
//	        <choice value='Annabeth'/>
//	        <choice value='Joe'/>
//	      </choices>
//	      <aliases>
//	        <alias value='Anna' target='Annabeth'/>
//	        <alias value='Beth' target='Elisabeth'/>
//	      </aliases>
//	      <default>'Joe'</default>
//	    </key>
//
//	    <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//	      <default>'first'</default>
//	    </key>
//
//	    <key name='flags-key' flags='org.gtk.Test.myflags'>
//	      <default>["flag1","flag2"]</default>
//	    </key>
//	  </schema>
//	</schemalist>
//
// # Vendor overrides
//
// Default values are defined in the schemas that get installed by an
// application. Sometimes, it is necessary for a vendor or distributor to adjust
// these defaults. Since patching the XML source for the schema is inconvenient
// and error-prone, glib-compile-schemas (glib-compile-schemas.html) reads
// so-called vendor override files. These are keyfiles in the same directory
// as the XML schema sources which can override default values. The schema ID
// serves as the group name in the key file, and the values are expected in
// serialized glib.Variant form, as in the following example:
//
//	[org.gtk.Example]
//	key1='string'
//	key2=1.5
//
// glib-compile-schemas expects schema files to have the extension
// .gschema.override.
//
// # Binding
//
// A very convenient feature of GSettings lets you bind gobject.Object
// properties directly to settings, using gio.Settings.Bind(). Once a
// gobject.Object property has been bound to a setting, changes on either side
// are automatically propagated to the other side. GSettings handles details
// like mapping between gobject.Object and glib.Variant types, and preventing
// infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the underlying
// settings. To make this even more convenient, GSettings looks for a boolean
// property with the name sensitivity and automatically binds it to the
// writability of the bound setting. If this magic gets in the way, it can be
// suppressed with the G_SETTINGS_BIND_NO_SENSITIVITY flag.
//
// # Relocatable schemas
//
// A relocatable schema is one with no path attribute specified on its <schema>
// element. By using gio.Settings.NewWithPath, a GSettings object can be
// instantiated for a relocatable schema, assigning a path to the instance.
// Paths passed to gio.Settings.NewWithPath will typically be constructed
// dynamically from a constant prefix plus some form of instance identifier; but
// they must still be valid GSettings paths. Paths could also be constant and
// used with a globally installed schema originating from a dependency library.
//
// For example, a relocatable schema could be used to store geometry
// information for different windows in an application. If the schema
// ID was org.foo.MyApp.Window, it could be instantiated for paths
// /org/foo/MyApp/main/, /org/foo/MyApp/document-1/, /org/foo/MyApp/document-2/,
// etc. If any of the paths are well-known they can be specified as <child>
// elements in the parent schema, e.g.:
//
//	<schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//	  <child name="main" schema="org.foo.MyApp.Window"/>
//	</schema>
//
// # Build system integration
//
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your configure.ac:
//
//	GLIB_GSETTINGS
//
// In the appropriate Makefile.am, use the following snippet to compile and
// install the named schema:
//
//	gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
//	EXTRA_DIST = $(gsettings_SCHEMAS)
//
//	GSETTINGS_RULES@
//
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the gettext-domain attribute, a schema may be
// marked for translation by adding it to POTFILES.in, assuming gettext 0.19 is
// in use (the preferred method for translation):
//
//	data/org.foo.MyApp.gschema.xml
//
// Alternatively, if intltool 0.50.1 is in use:
//
//	[type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//
// GSettings will use gettext to look up translations for the <summary> and
// <description> elements, and also any <default> elements which have a l10n
// attribute set. Translations must not be included in the .gschema.xml
// file by the build system, for example by using intltool XML rules with a
// .gschema.xml.in template.
//
// If an enumerated type defined in a C header file is to be used in a
// GSettings schema, it can either be defined manually using an <enum> element
// in the schema XML, or it can be extracted automatically from the C header.
// This approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant Makefile.am:
//
//	gsettings_ENUM_NAMESPACE = org.foo.MyApp
//	gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
// gsettings_ENUM_NAMESPACE specifies the schema namespace for the enum files,
// which are specified in gsettings_ENUM_FILES. This will generate a
// org.foo.MyApp.enums.xml file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// EXTRA_DIST.
type Settings struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Settings)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Settings, *SettingsClass, SettingsOverrides](
		GTypeSettings,
		initSettingsClass,
		wrapSettings,
		defaultSettingsOverrides,
	)
}

func initSettingsClass(gclass unsafe.Pointer, overrides SettingsOverrides, classInitFunc func(*SettingsClass)) {
	pclass := (*C.GSettingsClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSettings))))

	if overrides.ChangeEvent != nil {
		pclass.change_event = (*[0]byte)(C._gotk4_gio2_SettingsClass_change_event)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gio2_SettingsClass_changed)
	}

	if overrides.WritableChangeEvent != nil {
		pclass.writable_change_event = (*[0]byte)(C._gotk4_gio2_SettingsClass_writable_change_event)
	}

	if overrides.WritableChanged != nil {
		pclass.writable_changed = (*[0]byte)(C._gotk4_gio2_SettingsClass_writable_changed)
	}

	if classInitFunc != nil {
		class := (*SettingsClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSettings(obj *coreglib.Object) *Settings {
	return &Settings{
		Object: obj,
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	return wrapSettings(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChangeEvent: "change-event" signal is emitted once per change event
// that affects this settings object. You should connect to this signal only
// if you are interested in viewing groups of changes before they are split out
// into multiple emissions of the "changed" signal. For most use cases it is
// more appropriate to use the "changed" signal.
//
// In the event that the change event applies to one or more specified keys,
// keys will be an array of #GQuark of length n_keys. In the event that the
// change event applies to the #GSettings object as a whole (ie: potentially
// every key has been changed) then keys will be NULL and n_keys will be 0.
//
// The default handler for this signal invokes the "changed" signal for each
// affected key. If any other connected handler returns TRUE then this default
// functionality will be suppressed.
func (settings *Settings) ConnectChangeEvent(f func(keys []glib.Quark) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "change-event", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectChangeEvent), f)
}

// ConnectChanged: "changed" signal is emitted when a key has potentially
// changed. You should call one of the g_settings_get() calls to check the new
// value.
//
// This signal supports detailed connections. You can connect to the detailed
// signal "changed::x" in order to only receive callbacks when key "x" changes.
//
// Note that settings only emits this signal if you have read key at least once
// while a signal handler was already connected for key.
func (settings *Settings) ConnectChanged(f func(key string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "changed", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectChanged), f)
}

// ConnectWritableChangeEvent: "writable-change-event" signal is emitted
// once per writability change event that affects this settings object.
// You should connect to this signal if you are interested in viewing groups
// of changes before they are split out into multiple emissions of the
// "writable-changed" signal. For most use cases it is more appropriate to use
// the "writable-changed" signal.
//
// In the event that the writability change applies only to a single key, key
// will be set to the #GQuark for that key. In the event that the writability
// change affects the entire settings object, key will be 0.
//
// The default handler for this signal invokes the "writable-changed" and
// "changed" signals for each affected key. This is done because changes
// in writability might also imply changes in value (if for example, a new
// mandatory setting is introduced). If any other connected handler returns TRUE
// then this default functionality will be suppressed.
func (settings *Settings) ConnectWritableChangeEvent(f func(key uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "writable-change-event", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectWritableChangeEvent), f)
}

// ConnectWritableChanged: "writable-changed" signal is emitted when
// the writability of a key has potentially changed. You should call
// g_settings_is_writable() in order to determine the new status.
//
// This signal supports detailed connections. You can connect to the detailed
// signal "writable-changed::x" in order to only receive callbacks when the
// writability of "x" changes.
func (settings *Settings) ConnectWritableChanged(f func(key string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "writable-changed", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectWritableChanged), f)
}

// NewSettings creates a new #GSettings object with the schema specified by
// schema_id.
//
// It is an error for the schema to not exist: schemas are an essential part
// of a program, as they provide type information. If schemas need to be
// dynamically loaded (for example, from an optional runtime dependency),
// g_settings_schema_source_lookup() can be used to test for their existence
// before loading them.
//
// Signals on the newly created #GSettings object will be dispatched
// via the thread-default Context in effect at the time of the call to
// g_settings_new(). The new #GSettings will hold a reference on the context.
// See g_main_context_push_thread_default().
//
// The function takes the following parameters:
//
//   - schemaId: id of the schema.
//
// The function returns the following values:
//
//   - settings: new #GSettings object.
func NewSettings(schemaId string) *Settings {
	var _arg1 *C.gchar     // out
	var _cret *C.GSettings // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_new(_arg1)
	runtime.KeepAlive(schemaId)

	var _settings *Settings // out

	_settings = wrapSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _settings
}

// NewSettingsWithPath creates a new #GSettings object with the relocatable
// schema specified by schema_id and a given path.
//
// You only need to do this if you want to directly create a settings object
// with a schema that doesn't have a specified path of its own. That's quite
// rare.
//
// It is a programmer error to call this function for a schema that has an
// explicitly specified path.
//
// It is a programmer error if path is not a valid path. A valid path begins and
// ends with '/' and does not contain two consecutive '/' characters.
//
// The function takes the following parameters:
//
//   - schemaId: id of the schema.
//   - path to use.
//
// The function returns the following values:
//
//   - settings: new #GSettings object.
func NewSettingsWithPath(schemaId, path string) *Settings {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GSettings // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_settings_new_with_path(_arg1, _arg2)
	runtime.KeepAlive(schemaId)
	runtime.KeepAlive(path)

	var _settings *Settings // out

	_settings = wrapSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _settings
}

// Apply applies any changes that have been made to the settings.
// This function does nothing unless settings is in 'delay-apply' mode;
// see g_settings_delay(). In the normal case settings are always applied
// immediately.
func (settings *Settings) Apply() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	C.g_settings_apply(_arg0)
	runtime.KeepAlive(settings)
}

// Bind: create a binding between the key in the settings object and the
// property property of object.
//
// The binding uses the default GIO mapping functions to map between the
// settings and property values. These functions handle booleans, numeric types
// and string types in a straightforward way. Use g_settings_bind_with_mapping()
// if you need a custom mapping, or map between types that are not supported by
// the default mapping functions.
//
// Unless the flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function also
// establishes a binding between the writability of key and the "sensitive"
// property of object (if object has a boolean property by that name). See
// g_settings_bind_writable() for more details about writable bindings.
//
// Note that the lifecycle of the binding is tied to object, and that you can
// have only one binding per object property. If you bind the same property
// twice on the same object, the second binding overrides the first one.
//
// The function takes the following parameters:
//
//   - key to bind.
//   - object: #GObject.
//   - property: name of the property to bind.
//   - flags for the binding.
func (settings *Settings) Bind(key string, object *coreglib.Object, property string, flags SettingsBindFlags) {
	var _arg0 *C.GSettings         // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gpointer           // out
	var _arg3 *C.gchar             // out
	var _arg4 C.GSettingsBindFlags // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.GSettingsBindFlags(flags)

	C.g_settings_bind(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(object)
	runtime.KeepAlive(property)
	runtime.KeepAlive(flags)
}

// BindWritable: create a binding between the writability of key in the settings
// object and the property property of object. The property must be boolean;
// "sensitive" or "visible" properties of widgets are the most likely
// candidates.
//
// Writable bindings are always uni-directional; changes of the writability of
// the setting will be propagated to the object property, not the other way.
//
// When the inverted argument is TRUE, the binding inverts the value as it
// passes from the setting to the object, i.e. property will be set to TRUE if
// the key is not writable.
//
// Note that the lifecycle of the binding is tied to object, and that you can
// have only one binding per object property. If you bind the same property
// twice on the same object, the second binding overrides the first one.
//
// The function takes the following parameters:
//
//   - key to bind.
//   - object: #GObject.
//   - property: name of a boolean property to bind.
//   - inverted: whether to 'invert' the value.
func (settings *Settings) BindWritable(key string, object *coreglib.Object, property string, inverted bool) {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gpointer   // out
	var _arg3 *C.gchar     // out
	var _arg4 C.gboolean   // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg3))
	if inverted {
		_arg4 = C.TRUE
	}

	C.g_settings_bind_writable(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(object)
	runtime.KeepAlive(property)
	runtime.KeepAlive(inverted)
}

// CreateAction creates a #GAction corresponding to a given #GSettings key.
//
// The action has the same name as the key.
//
// The value of the key becomes the state of the action and the action is
// enabled when the key is writable. Changing the state of the action results
// in the key being written to. Changes to the value or writability of the key
// cause appropriate change notifications to be emitted for the action.
//
// For boolean-valued keys, action activations take no parameter and result
// in the toggling of the value. For all other types, activations take the new
// value for the key (which must have the correct type).
//
// The function takes the following parameters:
//
//   - key: name of a key in settings.
//
// The function returns the following values:
//
//   - action: new #GAction.
func (settings *Settings) CreateAction(key string) *Action {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GAction   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_create_action(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _action *Action // out

	_action = wrapAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _action
}

// Delay changes the #GSettings object into 'delay-apply' mode. In this mode,
// changes to settings are not immediately propagated to the backend, but kept
// locally until g_settings_apply() is called.
func (settings *Settings) Delay() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	C.g_settings_delay(_arg0)
	runtime.KeepAlive(settings)
}

// Boolean gets the value that is stored at key in settings.
//
// A convenience variant of g_settings_get() for booleans.
//
// It is a programmer error to give a key that isn't specified as having a
// boolean type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - ok: boolean.
func (settings *Settings) Boolean(key string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_boolean(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Child creates a child settings object which has a base path of
// base-path/name, where base-path is the base path of settings.
//
// The schema for the child settings object must have been declared in the
// schema of settings using a <child> element.
//
// The created child settings object will inherit the #GSettings:delay-apply
// mode from settings.
//
// The function takes the following parameters:
//
//   - name of the child schema.
//
// The function returns the following values:
//
//   - ret: 'child' settings object.
func (settings *Settings) Child(name string) *Settings {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GSettings // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_child(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(name)

	var _ret *Settings // out

	_ret = wrapSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// DefaultValue gets the "default value" of a key.
//
// This is the value that would be read if g_settings_reset() were to be called
// on the key.
//
// Note that this may be a different value than returned by
// g_settings_schema_key_get_default_value() if the system administrator has
// provided a default value.
//
// Comparing the return values of g_settings_get_default_value() and
// g_settings_get_value() is not sufficient for determining if a value has
// been set because the user may have explicitly set the value to something
// that happens to be equal to the default. The difference here is that if the
// default changes in the future, the user's key will still be set.
//
// This function may be useful for adding an indication to a UI of what the
// default value was before the user set it.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings.
//
// The function takes the following parameters:
//
//   - key to get the default value for.
//
// The function returns the following values:
//
//   - variant (optional): default value.
func (settings *Settings) DefaultValue(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_default_value(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Double gets the value that is stored at key in settings.
//
// A convenience variant of g_settings_get() for doubles.
//
// It is a programmer error to give a key that isn't specified as having a
// 'double' type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - gdouble: double.
func (settings *Settings) Double(key string) float64 {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_double(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Enum gets the value that is stored in settings for key and converts it to the
// enum value that it represents.
//
// In order to use this function the type of the value must be a string and it
// must be marked in the schema file as an enumerated type.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings or is not marked as an enumerated type.
//
// If the value stored in the configuration database is not a valid value for
// the enumerated type then this function will return the default value.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - gint: enum value.
func (settings *Settings) Enum(key string) int {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gint       // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_enum(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Flags gets the value that is stored in settings for key and converts it to
// the flags value that it represents.
//
// In order to use this function the type of the value must be an array of
// strings and it must be marked in the schema file as a flags type.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings or is not marked as a flags type.
//
// If the value stored in the configuration database is not a valid value for
// the flags type then this function will return the default value.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - guint flags value.
func (settings *Settings) Flags(key string) uint {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.guint      // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_flags(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// HasUnapplied returns whether the #GSettings object has any unapplied changes.
// This can only be the case if it is in 'delayed-apply' mode.
//
// The function returns the following values:
//
//   - ok: TRUE if settings has unapplied changes.
func (settings *Settings) HasUnapplied() bool {
	var _arg0 *C.GSettings // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.g_settings_get_has_unapplied(_arg0)
	runtime.KeepAlive(settings)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Int gets the value that is stored at key in settings.
//
// A convenience variant of g_settings_get() for 32-bit integers.
//
// It is a programmer error to give a key that isn't specified as having a int32
// type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - gint: integer.
func (settings *Settings) Int(key string) int {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gint       // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_int(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Int64 gets the value that is stored at key in settings.
//
// A convenience variant of g_settings_get() for 64-bit integers.
//
// It is a programmer error to give a key that isn't specified as having a int64
// type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - gint64: 64-bit integer.
func (settings *Settings) Int64(key string) int64 {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gint64     // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_int64(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Mapped gets the value that is stored at key in settings, subject to
// application-level validation/mapping.
//
// You should use this function when the application needs to perform some
// processing on the value of the key (for example, parsing). The mapping
// function performs that processing. If the function indicates that the
// processing was unsuccessful (due to a parse error, for example) then the
// mapping is tried again with another value.
//
// This allows a robust 'fall back to defaults' behaviour to be implemented
// somewhat automatically.
//
// The first value that is tried is the user's setting for the key. If the
// mapping function fails to map this value, other values may be tried in an
// unspecified order (system or site defaults, translated schema default values,
// untranslated schema default values, etc).
//
// If the mapping function fails for all possible values, one additional attempt
// is made: the mapping function is called with a NULL value. If the mapping
// function still indicates failure at this point then the application will be
// aborted.
//
// The result parameter for the mapping function is pointed to a #gpointer
// which is initially set to NULL. The same pointer is given to each invocation
// of mapping. The final value of that #gpointer is what is returned by this
// function. NULL is valid; it is returned just as any other value would be.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//   - mapping: function to map the value in the settings database to the value
//     used by the application.
//
// The function returns the following values:
//
//   - gpointer (optional): result, which may be NULL.
func (settings *Settings) Mapped(key string, mapping SettingsGetMapping) unsafe.Pointer {
	var _arg0 *C.GSettings          // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GSettingsGetMapping // out
	var _arg3 C.gpointer
	var _cret C.gpointer // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*[0]byte)(C._gotk4_gio2_SettingsGetMapping)
	_arg3 = C.gpointer(gbox.Assign(mapping))
	defer gbox.Delete(uintptr(_arg3))

	_cret = C.g_settings_get_mapped(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(mapping)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Range queries the range of a key.
//
// Deprecated: Use g_settings_schema_key_get_range() instead.
//
// The function takes the following parameters:
//
//   - key to query the range of.
func (settings *Settings) Range(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_range(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// String gets the value that is stored at key in settings.
//
// A convenience variant of g_settings_get() for strings.
//
// It is a programmer error to give a key that isn't specified as having a
// string type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string.
func (settings *Settings) String(key string) string {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_string(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Strv: convenience variant of g_settings_get() for string arrays.
//
// It is a programmer error to give a key that isn't specified as having an
// array of strings type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - utf8s: a newly-allocated, NULL-terminated array of strings, the value
//     that is stored at key in settings.
func (settings *Settings) Strv(key string) []string {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_strv(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Uint gets the value that is stored at key in settings.
//
// A convenience variant of g_settings_get() for 32-bit unsigned integers.
//
// It is a programmer error to give a key that isn't specified as having a
// uint32 type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - guint: unsigned integer.
func (settings *Settings) Uint(key string) uint {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.guint      // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_uint(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Uint64 gets the value that is stored at key in settings.
//
// A convenience variant of g_settings_get() for 64-bit unsigned integers.
//
// It is a programmer error to give a key that isn't specified as having a
// uint64 type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - guint64: 64-bit unsigned integer.
func (settings *Settings) Uint64(key string) uint64 {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.guint64    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_uint64(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UserValue checks the "user value" of a key, if there is one.
//
// The user value of a key is the last value that was set by the user.
//
// After calling g_settings_reset() this function should always return NULL
// (assuming something is not wrong with the system configuration).
//
// It is possible that g_settings_get_value() will return a different value than
// this function. This can happen in the case that the user set a value for a
// key that was subsequently locked down by the system administrator -- this
// function will return the user's old value.
//
// This function may be useful for adding a "reset" option to a UI or for
// providing indication that a particular value has been changed.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings.
//
// The function takes the following parameters:
//
//   - key to get the user value for.
//
// The function returns the following values:
//
//   - variant (optional) user's value, if set.
func (settings *Settings) UserValue(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_user_value(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Value gets the value that is stored in settings for key.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings.
//
// The function takes the following parameters:
//
//   - key to get the value for.
//
// The function returns the following values:
//
//   - variant: new #GVariant.
func (settings *Settings) Value(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_value(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// IsWritable finds out if a key can be written or not.
//
// The function takes the following parameters:
//
//   - name of a key.
//
// The function returns the following values:
//
//   - ok: TRUE if the key name is writable.
func (settings *Settings) IsWritable(name string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_is_writable(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListChildren gets the list of children on settings.
//
// The list is exactly the list of strings for which it is not an error to call
// g_settings_get_child().
//
// There is little reason to call this function from "normal" code, since you
// should already know what children are in your schema. This function may still
// be useful there for introspection reasons, however.
//
// You should free the return value with g_strfreev() when you are done with it.
//
// The function returns the following values:
//
//   - utf8s: list of the children on settings, in no defined order.
func (settings *Settings) ListChildren() []string {
	var _arg0 *C.GSettings // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.g_settings_list_children(_arg0)
	runtime.KeepAlive(settings)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ListKeys introspects the list of keys on settings.
//
// You should probably not be calling this function from "normal" code (since
// you should already know what keys are in your schema). This function is
// intended for introspection reasons.
//
// You should free the return value with g_strfreev() when you are done with it.
//
// Deprecated: Use g_settings_schema_list_keys() instead.
//
// The function returns the following values:
//
//   - utf8s: list of the keys on settings, in no defined order.
func (settings *Settings) ListKeys() []string {
	var _arg0 *C.GSettings // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.g_settings_list_keys(_arg0)
	runtime.KeepAlive(settings)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// RangeCheck checks if the given value is of the correct type and within the
// permitted range for key.
//
// Deprecated: Use g_settings_schema_key_range_check() instead.
//
// The function takes the following parameters:
//
//   - key to check.
//   - value to check.
//
// The function returns the following values:
//
//   - ok: TRUE if value is valid for key.
func (settings *Settings) RangeCheck(key string, value *glib.Variant) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_settings_range_check(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reset resets key to its default value.
//
// This call resets the key, as much as possible, to its default value.
// That might be the value specified in the schema or the one set by the
// administrator.
//
// The function takes the following parameters:
//
//   - key: name of a key.
func (settings *Settings) Reset(key string) {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_settings_reset(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// Revert reverts all non-applied changes to the settings. This function does
// nothing unless settings is in 'delay-apply' mode; see g_settings_delay().
// In the normal case settings are always applied immediately.
//
// Change notifications will be emitted for affected keys.
func (settings *Settings) Revert() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	C.g_settings_revert(_arg0)
	runtime.KeepAlive(settings)
}

// SetBoolean sets key in settings to value.
//
// A convenience variant of g_settings_set() for booleans.
//
// It is a programmer error to give a key that isn't specified as having a
// boolean type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value to set it to.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetBoolean(key string, value bool) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	if value {
		_arg2 = C.TRUE
	}

	_cret = C.g_settings_set_boolean(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDouble sets key in settings to value.
//
// A convenience variant of g_settings_set() for doubles.
//
// It is a programmer error to give a key that isn't specified as having a
// 'double' type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value to set it to.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetDouble(key string, value float64) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gdouble    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gdouble(value)

	_cret = C.g_settings_set_double(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetEnum looks up the enumerated type nick for value and writes it to key,
// within settings.
//
// It is a programmer error to give a key that isn't contained in the schema
// for settings or is not marked as an enumerated type, or for value not to be a
// valid value for the named type.
//
// After performing the write, accessing key directly with
// g_settings_get_string() will return the 'nick' associated with value.
//
// The function takes the following parameters:
//
//   - key: key, within settings.
//   - value: enumerated value.
//
// The function returns the following values:
//
//   - ok: TRUE, if the set succeeds.
func (settings *Settings) SetEnum(key string, value int) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(value)

	_cret = C.g_settings_set_enum(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlags looks up the flags type nicks for the bits specified by value, puts
// them in an array of strings and writes the array to key, within settings.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings or is not marked as a flags type, or for value to contain any bits
// that are not value for the named type.
//
// After performing the write, accessing key directly with g_settings_get_strv()
// will return an array of 'nicks'; one for each bit in value.
//
// The function takes the following parameters:
//
//   - key: key, within settings.
//   - value flags value.
//
// The function returns the following values:
//
//   - ok: TRUE, if the set succeeds.
func (settings *Settings) SetFlags(key string, value uint) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(value)

	_cret = C.g_settings_set_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetInt sets key in settings to value.
//
// A convenience variant of g_settings_set() for 32-bit integers.
//
// It is a programmer error to give a key that isn't specified as having a int32
// type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value to set it to.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetInt(key string, value int) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(value)

	_cret = C.g_settings_set_int(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetInt64 sets key in settings to value.
//
// A convenience variant of g_settings_set() for 64-bit integers.
//
// It is a programmer error to give a key that isn't specified as having a int64
// type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value to set it to.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetInt64(key string, value int64) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint64     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint64(value)

	_cret = C.g_settings_set_int64(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetString sets key in settings to value.
//
// A convenience variant of g_settings_set() for strings.
//
// It is a programmer error to give a key that isn't specified as having a
// string type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value to set it to.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetString(key, value string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_settings_set_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetStrv sets key in settings to value.
//
// A convenience variant of g_settings_set() for string arrays. If value is
// NULL, then key is set to be the empty array.
//
// It is a programmer error to give a key that isn't specified as having an
// array of strings type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value (optional) to set it to, or NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetStrv(key string, value []string) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 **C.gchar    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(value) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(value)+1)
			var zero *C.gchar
			out[len(value)] = zero
			for i := range value {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(value[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.g_settings_set_strv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUint sets key in settings to value.
//
// A convenience variant of g_settings_set() for 32-bit unsigned integers.
//
// It is a programmer error to give a key that isn't specified as having a
// uint32 type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value to set it to.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetUint(key string, value uint) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(value)

	_cret = C.g_settings_set_uint(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUint64 sets key in settings to value.
//
// A convenience variant of g_settings_set() for 64-bit unsigned integers.
//
// It is a programmer error to give a key that isn't specified as having a
// uint64 type in the schema for settings.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value to set it to.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetUint64(key string, value uint64) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.guint64    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint64(value)

	_cret = C.g_settings_set_uint64(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetValue sets key in settings to value.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings or for value to have the incorrect type, per the schema.
//
// If value is floating then this function consumes the reference.
//
// The function takes the following parameters:
//
//   - key: name of the key to set.
//   - value of the correct type.
//
// The function returns the following values:
//
//   - ok: TRUE if setting the key succeeded, FALSE if the key was not writable.
func (settings *Settings) SetValue(key string, value *glib.Variant) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_settings_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - keys
//   - nKeys
func (settings *Settings) changeEvent(keys *glib.Quark, nKeys int) bool {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.change_event

	var _arg0 *C.GSettings // out
	var _arg1 *C.GQuark    // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.GQuark)(unsafe.Pointer(keys))
	_arg2 = C.gint(nKeys)

	_cret = C._gotk4_gio2_Settings_virtual_change_event(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(keys)
	runtime.KeepAlive(nKeys)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (settings *Settings) changed(key string) {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.changed

	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_Settings_virtual_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

func (settings *Settings) writableChangeEvent(key glib.Quark) bool {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.writable_change_event

	var _arg0 *C.GSettings // out
	var _arg1 C.GQuark     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GQuark(key)

	_cret = C._gotk4_gio2_Settings_virtual_writable_change_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (settings *Settings) writableChanged(key string) {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.writable_changed

	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_Settings_virtual_writable_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// SettingsListRelocatableSchemas: deprecated.
//
// Deprecated: Use g_settings_schema_source_list_schemas() instead.
//
// The function returns the following values:
//
//   - utf8s: list of relocatable #GSettings schemas that are available,
//     in no defined order. The list must not be modified or freed.
func SettingsListRelocatableSchemas() []string {
	var _cret **C.gchar // in

	_cret = C.g_settings_list_relocatable_schemas()

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// SettingsListSchemas: deprecated.
//
// Deprecated: Use g_settings_schema_source_list_schemas() instead. If you used
// g_settings_list_schemas() to check for the presence of a particular schema,
// use g_settings_schema_source_lookup() instead of your whole loop.
//
// The function returns the following values:
//
//   - utf8s: list of #GSettings schemas that are available, in no defined
//     order. The list must not be modified or freed.
func SettingsListSchemas() []string {
	var _cret **C.gchar // in

	_cret = C.g_settings_list_schemas()

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// SettingsSync ensures that all pending operations are complete for the default
// backend.
//
// Writes made to a #GSettings are handled asynchronously. For this reason,
// it is very unlikely that the changes have it to disk by the time
// g_settings_set() returns.
//
// This call will block until all of the writes have made it to the backend.
// Since the mainloop is not running, no change notifications will be dispatched
// during this call (but some may be queued by the time the call is done).
func SettingsSync() {
	C.g_settings_sync()
}

// SettingsUnbind removes an existing binding for property on object.
//
// Note that bindings are automatically removed when the object is finalized,
// so it is rarely necessary to call this function.
//
// The function takes the following parameters:
//
//   - object: object.
//   - property whose binding is removed.
func SettingsUnbind(object *coreglib.Object, property string) {
	var _arg1 C.gpointer // out
	var _arg2 *C.gchar   // out

	_arg1 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_settings_unbind(_arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(property)
}

// SimpleAction: GSimpleAction is the obvious simple implementation of the
// gio.Action interface. This is the easiest way to create an action for
// purposes of adding it to a gio.SimpleActionGroup.
type SimpleAction struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Action
}

var (
	_ coreglib.Objector = (*SimpleAction)(nil)
)

func wrapSimpleAction(obj *coreglib.Object) *SimpleAction {
	return &SimpleAction{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	return wrapSimpleAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate indicates that the action was just activated.
//
// parameter will always be of the expected type, i.e. the parameter type
// specified when the action was created. If an incorrect type is given when
// activating the action, this signal is not emitted.
//
// Since GLib 2.40, if no handler is connected to this signal then the default
// behaviour for boolean-stated actions with a NULL parameter type is to toggle
// them via the Action::change-state signal. For stateful actions where the
// state type is equal to the parameter type, the default is to forward them
// directly to Action::change-state. This should allow almost all users of
// Action to connect only one handler or the other.
func (simple *SimpleAction) ConnectActivate(f func(parameter *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(simple, "activate", false, unsafe.Pointer(C._gotk4_gio2_SimpleAction_ConnectActivate), f)
}

// ConnectChangeState indicates that the action just received a request to
// change its state.
//
// value will always be of the correct state type, i.e. the type of the initial
// state passed to g_simple_action_new_stateful(). If an incorrect type is given
// when requesting to change the state, this signal is not emitted.
//
// If no handler is connected to this signal then the default behaviour is to
// call g_simple_action_set_state() to set the state to the requested value.
// If you connect a signal handler then no default action is taken. If the
// state should change then you must call g_simple_action_set_state() from the
// handler.
//
// An example of a 'change-state' handler:
//
//	static void
//	change_volume_state (GSimpleAction *action,
//	                     GVariant      *value,
//	                     gpointer       user_data)
//	{
//	  gint requested;
//
//	  requested = g_variant_get_int32 (value);
//
//	  // Volume only goes from 0 to 10
//	  if (0 <= requested && requested <= 10)
//	    g_simple_action_set_state (action, value);
//	}
//
// The handler need not set the state to the requested value. It could set it to
// any value at all, or take some other action.
func (simple *SimpleAction) ConnectChangeState(f func(value *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(simple, "change-state", false, unsafe.Pointer(C._gotk4_gio2_SimpleAction_ConnectChangeState), f)
}

// NewSimpleAction creates a new action.
//
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
//
// The function takes the following parameters:
//
//   - name of the action.
//   - parameterType (optional): type of parameter that will be passed to
//     handlers for the Action::activate signal, or NULL for no parameter.
//
// The function returns the following values:
//
//   - simpleAction: new Action.
func NewSimpleAction(name string, parameterType *glib.VariantType) *SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameterType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(parameterType)))
	}

	_cret = C.g_simple_action_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(parameterType)

	var _simpleAction *SimpleAction // out

	_simpleAction = wrapSimpleAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAction
}

// NewSimpleActionStateful creates a new stateful action.
//
// All future state values must have the same Type as the initial state.
//
// If the state #GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - name of the action.
//   - parameterType (optional): type of the parameter that will be passed to
//     handlers for the Action::activate signal, or NULL for no parameter.
//   - state: initial state of the action.
//
// The function returns the following values:
//
//   - simpleAction: new Action.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) *SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _arg3 *C.GVariant      // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameterType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(parameterType)))
	}
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(state)))

	_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)
	runtime.KeepAlive(name)
	runtime.KeepAlive(parameterType)
	runtime.KeepAlive(state)

	var _simpleAction *SimpleAction // out

	_simpleAction = wrapSimpleAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAction
}

// SetEnabled sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to modify its enabled flag.
//
// The function takes the following parameters:
//
//   - enabled: whether the action is enabled.
func (simple *SimpleAction) SetEnabled(enabled bool) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(enabled)
}

// SetState sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to directly modify the 'state' property. Instead,
// they should call g_action_change_state() to request the change.
//
// If the value GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//   - value: new #GVariant for the state.
func (simple *SimpleAction) SetState(value *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_simple_action_set_state(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(value)
}

// SetStateHint sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about action state hints.
//
// The function takes the following parameters:
//
//   - stateHint (optional) representing the state hint.
func (simple *SimpleAction) SetStateHint(stateHint *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if stateHint != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(stateHint)))
	}

	C.g_simple_action_set_state_hint(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(stateHint)
}

// SimpleActionGroupOverrides contains methods that are overridable.
type SimpleActionGroupOverrides struct {
}

func defaultSimpleActionGroupOverrides(v *SimpleActionGroup) SimpleActionGroupOverrides {
	return SimpleActionGroupOverrides{}
}

// SimpleActionGroup: GSimpleActionGroup is a hash table filled with gio.Action
// objects, implementing the gio.ActionGroup and gio.ActionMap interfaces.
type SimpleActionGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object

	ActionGroup
	ActionMap
}

var (
	_ coreglib.Objector = (*SimpleActionGroup)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SimpleActionGroup, *SimpleActionGroupClass, SimpleActionGroupOverrides](
		GTypeSimpleActionGroup,
		initSimpleActionGroupClass,
		wrapSimpleActionGroup,
		defaultSimpleActionGroupOverrides,
	)
}

func initSimpleActionGroupClass(gclass unsafe.Pointer, overrides SimpleActionGroupOverrides, classInitFunc func(*SimpleActionGroupClass)) {
	if classInitFunc != nil {
		class := (*SimpleActionGroupClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSimpleActionGroup(obj *coreglib.Object) *SimpleActionGroup {
	return &SimpleActionGroup{
		Object: obj,
		ActionGroup: ActionGroup{
			Object: obj,
		},
		ActionMap: ActionMap{
			Object: obj,
		},
	}
}

func marshalSimpleActionGroup(p uintptr) (interface{}, error) {
	return wrapSimpleActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSimpleActionGroup creates a new, empty, ActionGroup.
//
// The function returns the following values:
//
//   - simpleActionGroup: new ActionGroup.
func NewSimpleActionGroup() *SimpleActionGroup {
	var _cret *C.GSimpleActionGroup // in

	_cret = C.g_simple_action_group_new()

	var _simpleActionGroup *SimpleActionGroup // out

	_simpleActionGroup = wrapSimpleActionGroup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleActionGroup
}

// AddEntries: convenience function for creating multiple Action instances and
// adding them to the action group.
//
// Deprecated: Use g_action_map_add_action_entries().
//
// The function takes the following parameters:
//
//   - entries: pointer to the first item in an array of Entry structs.
//   - userData (optional): user data for signal connections.
func (simple *SimpleActionGroup) AddEntries(entries []ActionEntry, userData unsafe.Pointer) {
	var _arg0 *C.GSimpleActionGroup // out
	var _arg1 *C.GActionEntry       // out
	var _arg2 C.gint
	var _arg3 C.gpointer // out

	_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	_arg2 = (C.gint)(len(entries))
	_arg1 = (*C.GActionEntry)(C.calloc(C.size_t(len(entries)), C.size_t(C.sizeof_GActionEntry)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GActionEntry)(_arg1), len(entries))
		for i := range entries {
			out[i] = *(*C.GActionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
		}
	}
	_arg3 = (C.gpointer)(unsafe.Pointer(userData))

	C.g_simple_action_group_add_entries(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(entries)
	runtime.KeepAlive(userData)
}

// Insert adds an action to the action group.
//
// If the action group already contains an action with the same name as action
// then the old action is dropped from the group.
//
// The action group takes its own reference on action.
//
// Deprecated: Use g_action_map_add_action().
//
// The function takes the following parameters:
//
//   - action: #GAction.
func (simple *SimpleActionGroup) Insert(action Actioner) {
	var _arg0 *C.GSimpleActionGroup // out
	var _arg1 *C.GAction            // out

	_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	_arg1 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	C.g_simple_action_group_insert(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(action)
}

// Lookup looks up the action with the name action_name in the group.
//
// If no such action exists, returns NULL.
//
// Deprecated: Use g_action_map_lookup_action().
//
// The function takes the following parameters:
//
//   - actionName: name of an action.
//
// The function returns the following values:
//
//   - action or NULL.
func (simple *SimpleActionGroup) Lookup(actionName string) *Action {
	var _arg0 *C.GSimpleActionGroup // out
	var _arg1 *C.gchar              // out
	var _cret *C.GAction            // in

	_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_simple_action_group_lookup(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(actionName)

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(_cret)))

	return _action
}

// Remove removes the named action from the action group.
//
// If no action of this name is in the group then nothing happens.
//
// Deprecated: Use g_action_map_remove_action().
//
// The function takes the following parameters:
//
//   - actionName: name of the action.
func (simple *SimpleActionGroup) Remove(actionName string) {
	var _arg0 *C.GSimpleActionGroup // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GSimpleActionGroup)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_simple_action_group_remove(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(actionName)
}

// SimpleAsyncResult as of GLib 2.46, GSimpleAsyncResult is deprecated in favor
// of gio.Task, which provides a simpler API.
//
// GSimpleAsyncResult implements gio.AsyncResult.
//
// GSimpleAsyncResult handles gio.AsyncReadyCallbacks, error reporting,
// operation cancellation and the final state of an operation, completely
// transparent to the application. Results can be returned as a pointer e.g.
// for functions that return data that is collected asynchronously, a boolean
// value for checking the success or failure of an operation, or a gssize for
// operations which return the number of bytes modified by the operation;
// all of the simple return cases are covered.
//
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled
// by gio.AsyncResults interface. However, if implementing a new GIO module,
// for writing language bindings, or for complex applications that need better
// control of how asynchronous operations are completed, it is important to
// understand this functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
//
// To create a new GSimpleAsyncResult, call gio.SimpleAsyncResult.New.
// If the result needs to be created for a GError, use
// gio.SimpleAsyncResult.NewFromError or gio.SimpleAsyncResult.NewTakeError.
// If a GError is not available (e.g. the asynchronous operation doesnt
// take a GError argument), but the result still needs to be created
// for an error condition, use gio.SimpleAsyncResult.NewError (or
// gio.SimpleAsyncResult.SetErrorVa() if your application or binding requires
// passing a variable argument list directly), and the error can then be
// propagated through the use of gio.SimpleAsyncResult.PropagateError().
//
// An asynchronous operation can be made to ignore a cancellation event
// by calling gio.SimpleAsyncResult.SetHandleCancellation() with a
// GSimpleAsyncResult for the operation and FALSE. This is useful for operations
// that are dangerous to cancel, such as close (which would cause a leak if
// cancelled before being run).
//
// GSimpleAsyncResult can integrate into GLibs event loop, glib.MainLoop,
// or it can use glib.Threads. gio.SimpleAsyncResult.Complete() will
// finish an I/O task directly from the point where it is called.
// gio.SimpleAsyncResult.CompleteInIdle() will finish it from an idle handler in
// the thread-default main context (see glib.MainContext.PushThreadDefault())
// where the GSimpleAsyncResult was created. gio.SimpleAsyncResult.RunInThread()
// will run the job in a separate thread and then use
// gio.SimpleAsyncResult.CompleteInIdle() to deliver the result.
//
// To set the results of an asynchronous function,
// gio.SimpleAsyncResult.SetOpResGpointer(),
// gio.SimpleAsyncResult.SetOpResGboolean(), and
// gio.SimpleAsyncResult.SetOpResGssize() are provided, setting the operation's
// result to a gpointer, gboolean, or gssize, respectively.
//
// Likewise, to get the result of an asynchronous
// function, gio.SimpleAsyncResult.GetOpResGpointer(),
// gio.SimpleAsyncResult.GetOpResGboolean(), and
// gio.SimpleAsyncResult.GetOpResGssize() are provided, getting the operations
// result as a gpointer, gboolean, and gssize, respectively.
//
// For the details of the requirements implementations must respect, see
// gio.AsyncResult. A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
//
//	static void
//	baked_cb (Cake    *cake,
//	          gpointer user_data)
//	{
//	  // In this example, this callback is not given a reference to the cake,
//	  // so the GSimpleAsyncResult has to take a reference to it.
//	  GSimpleAsyncResult *result = user_data;
//
//	  if (cake == NULL)
//	    g_simple_async_result_set_error (result,
//	                                     BAKER_ERRORS,
//	                                     BAKER_ERROR_NO_FLOUR,
//	                                     "Go to the supermarket");
//	  else
//	    g_simple_async_result_set_op_res_gpointer (result,
//	                                               g_object_ref (cake),
//	                                               g_object_unref);
//
//
//	  // In this example, we assume that baked_cb is called as a callback from
//	  // the mainloop, so it's safe to complete the operation synchronously here.
//	  // If, however, _baker_prepare_cake () might call its callback without
//	  // first returning to the mainloop  inadvisable, but some APIs do so 
//	  // we would need to use g_simple_async_result_complete_in_idle().
//	  g_simple_async_result_complete (result);
//	  g_object_unref (result);
//	}
//
//	void
//	baker_bake_cake_async (Baker              *self,
//	                       guint               radius,
//	                       GAsyncReadyCallback callback,
//	                       gpointer            user_data)
//	{
//	  GSimpleAsyncResult *simple;
//	  Cake               *cake;
//
//	  if (radius < 3)
//	    {
//	      g_simple_async_report_error_in_idle (G_OBJECT (self),
//	                                           callback,
//	                                           user_data,
//	                                           BAKER_ERRORS,
//	                                           BAKER_ERROR_TOO_SMALL,
//	                                           "ucm radius cakes are silly",
//	                                           radius);
//	      return;
//	    }
//
//	  simple = g_simple_async_result_new (G_OBJECT (self),
//	                                      callback,
//	                                      user_data,
//	                                      baker_bake_cake_async);
//	  cake = _baker_get_cached_cake (self, radius);
//
//	  if (cake != NULL)
//	    {
//	      g_simple_async_result_set_op_res_gpointer (simple,
//	                                                 g_object_ref (cake),
//	                                                 g_object_unref);
//	      g_simple_async_result_complete_in_idle (simple);
//	      g_object_unref (simple);
//	      // Drop the reference returned by _baker_get_cached_cake();
//	      // the GSimpleAsyncResult has taken its own reference.
//	      g_object_unref (cake);
//	      return;
//	    }
//
//	  _baker_prepare_cake (self, radius, baked_cb, simple);
//	}
//
//	Cake *
//	baker_bake_cake_finish (Baker        *self,
//	                        GAsyncResult *result,
//	                        GError      **error)
//	{
//	  GSimpleAsyncResult *simple;
//	  Cake               *cake;
//
//	  g_return_val_if_fail (g_simple_async_result_is_valid (result,
//	                                                        G_OBJECT (self),
//	                                                        baker_bake_cake_async),
//	                        NULL);
//
//	  simple = (GSimpleAsyncResult *) result;
//
//	  if (g_simple_async_result_propagate_error (simple, error))
//	    return NULL;
//
//	  cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//	  return g_object_ref (cake);
//	}.
type SimpleAsyncResult struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncResult
}

var (
	_ coreglib.Objector = (*SimpleAsyncResult)(nil)
)

func wrapSimpleAsyncResult(obj *coreglib.Object) *SimpleAsyncResult {
	return &SimpleAsyncResult{
		Object: obj,
		AsyncResult: AsyncResult{
			Object: obj,
		},
	}
}

func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
	return wrapSimpleAsyncResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSimpleAsyncResult creates a AsyncResult.
//
// The common convention is to create the AsyncResult in the function that
// starts the asynchronous operation and use that same function as the
// source_tag.
//
// If your operation supports cancellation with #GCancellable (which it
// probably should) then you should provide the user's cancellable to
// g_simple_async_result_set_check_cancellable() immediately after this function
// returns.
//
// Deprecated: Use g_task_new() instead.
//
// The function takes the following parameters:
//
//   - sourceObject (optional) or NULL.
//   - callback (optional): ReadyCallback.
//   - sourceTag (optional) asynchronous function.
//
// The function returns the following values:
//
//   - simpleAsyncResult: AsyncResult.
func NewSimpleAsyncResult(sourceObject *coreglib.Object, callback AsyncReadyCallback, sourceTag unsafe.Pointer) *SimpleAsyncResult {
	var _arg1 *C.GObject            // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer
	var _arg4 C.gpointer            // out
	var _cret *C.GSimpleAsyncResult // in

	if sourceObject != nil {
		_arg1 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(sourceTag))

	_cret = C.g_simple_async_result_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(sourceObject)
	runtime.KeepAlive(callback)
	runtime.KeepAlive(sourceTag)

	var _simpleAsyncResult *SimpleAsyncResult // out

	_simpleAsyncResult = wrapSimpleAsyncResult(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAsyncResult
}

// NewSimpleAsyncResultFromError creates a AsyncResult from an error condition.
//
// Deprecated: Use g_task_new() and g_task_return_error() instead.
//
// The function takes the following parameters:
//
//   - sourceObject (optional) or NULL.
//   - callback (optional): ReadyCallback.
//   - err: #GError.
//
// The function returns the following values:
//
//   - simpleAsyncResult: AsyncResult.
func NewSimpleAsyncResultFromError(sourceObject *coreglib.Object, callback AsyncReadyCallback, err error) *SimpleAsyncResult {
	var _arg1 *C.GObject            // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer
	var _arg4 *C.GError             // out
	var _cret *C.GSimpleAsyncResult // in

	if sourceObject != nil {
		_arg1 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}
	if err != nil {
		_arg4 = (*C.GError)(gerror.New(err))
	}

	_cret = C.g_simple_async_result_new_from_error(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(sourceObject)
	runtime.KeepAlive(callback)
	runtime.KeepAlive(err)

	var _simpleAsyncResult *SimpleAsyncResult // out

	_simpleAsyncResult = wrapSimpleAsyncResult(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleAsyncResult
}

// Complete completes an asynchronous I/O job immediately. Must be called
// in the thread where the asynchronous result was to be delivered,
// as it invokes the callback directly. If you are in a different thread use
// g_simple_async_result_complete_in_idle().
//
// Calling this function takes a reference to simple for as long as is needed to
// complete the call.
//
// Deprecated: Use #GTask instead.
func (simple *SimpleAsyncResult) Complete() {
	var _arg0 *C.GSimpleAsyncResult // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))

	C.g_simple_async_result_complete(_arg0)
	runtime.KeepAlive(simple)
}

// CompleteInIdle completes an asynchronous function in an idle handler in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that simple was initially created in (and re-pushes that context
// around the invocation of the callback).
//
// Calling this function takes a reference to simple for as long as is needed to
// complete the call.
//
// Deprecated: Use #GTask instead.
func (simple *SimpleAsyncResult) CompleteInIdle() {
	var _arg0 *C.GSimpleAsyncResult // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))

	C.g_simple_async_result_complete_in_idle(_arg0)
	runtime.KeepAlive(simple)
}

// OpResGboolean gets the operation result boolean from within the asynchronous
// result.
//
// Deprecated: Use #GTask and g_task_propagate_boolean() instead.
//
// The function returns the following values:
//
//   - ok: TRUE if the operation's result was TRUE, FALSE if the operation's
//     result was FALSE.
func (simple *SimpleAsyncResult) OpResGboolean() bool {
	var _arg0 *C.GSimpleAsyncResult // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))

	_cret = C.g_simple_async_result_get_op_res_gboolean(_arg0)
	runtime.KeepAlive(simple)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OpResGssize gets a gssize from the asynchronous result.
//
// Deprecated: Use #GTask and g_task_propagate_int() instead.
//
// The function returns the following values:
//
//   - gssize returned from the asynchronous function.
func (simple *SimpleAsyncResult) OpResGssize() int {
	var _arg0 *C.GSimpleAsyncResult // out
	var _cret C.gssize              // in

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))

	_cret = C.g_simple_async_result_get_op_res_gssize(_arg0)
	runtime.KeepAlive(simple)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// PropagateError propagates an error from within the simple asynchronous result
// to a given destination.
//
// If the #GCancellable given to a prior call to
// g_simple_async_result_set_check_cancellable() is cancelled then this function
// will return TRUE with dest set appropriately.
//
// Deprecated: Use #GTask instead.
func (simple *SimpleAsyncResult) PropagateError() error {
	var _arg0 *C.GSimpleAsyncResult // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))

	C.g_simple_async_result_propagate_error(_arg0, &_cerr)
	runtime.KeepAlive(simple)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetCheckCancellable sets a #GCancellable to check before dispatching results.
//
// This function has one very specific purpose: the provided cancellable is
// checked at the time of g_simple_async_result_propagate_error() If it is
// cancelled, these functions will return an "Operation was cancelled" error
// (G_IO_ERROR_CANCELLED).
//
// Implementors of cancellable asynchronous functions should use this in order
// to provide a guarantee to their callers that cancelling an async operation
// will reliably result in an error being returned for that operation (even if
// a positive result for the operation has already been sent as an idle to the
// main context to be dispatched).
//
// The checking described above is done regardless of any call to the unrelated
// g_simple_async_result_set_handle_cancellation() function.
//
// Deprecated: Use #GTask instead.
//
// The function takes the following parameters:
//
//   - ctx (optional) to check, or NULL to unset.
func (simple *SimpleAsyncResult) SetCheckCancellable(ctx context.Context) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 *C.GCancellable       // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_simple_async_result_set_check_cancellable(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(ctx)
}

// SetFromError sets the result from a #GError.
//
// Deprecated: Use #GTask and g_task_return_error() instead.
//
// The function takes the following parameters:
//
//   - err: #GError.
func (simple *SimpleAsyncResult) SetFromError(err error) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 *C.GError             // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	C.g_simple_async_result_set_from_error(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(err)
}

// SetHandleCancellation sets whether to handle cancellation within the
// asynchronous operation.
//
// This function has nothing to do with
// g_simple_async_result_set_check_cancellable(). It only refers to the
// #GCancellable passed to g_simple_async_result_run_in_thread().
//
// Deprecated: since version 2.46.
//
// The function takes the following parameters:
//
//   - handleCancellation: #gboolean.
func (simple *SimpleAsyncResult) SetHandleCancellation(handleCancellation bool) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if handleCancellation {
		_arg1 = C.TRUE
	}

	C.g_simple_async_result_set_handle_cancellation(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(handleCancellation)
}

// SetOpResGboolean sets the operation result to a boolean within the
// asynchronous result.
//
// Deprecated: Use #GTask and g_task_return_boolean() instead.
//
// The function takes the following parameters:
//
//   - opRes: #gboolean.
func (simple *SimpleAsyncResult) SetOpResGboolean(opRes bool) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if opRes {
		_arg1 = C.TRUE
	}

	C.g_simple_async_result_set_op_res_gboolean(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

// SetOpResGssize sets the operation result within the asynchronous result to
// the given op_res.
//
// Deprecated: Use #GTask and g_task_return_int() instead.
//
// The function takes the following parameters:
//
//   - opRes: #gssize.
func (simple *SimpleAsyncResult) SetOpResGssize(opRes int) {
	var _arg0 *C.GSimpleAsyncResult // out
	var _arg1 C.gssize              // out

	_arg0 = (*C.GSimpleAsyncResult)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	_arg1 = C.gssize(opRes)

	C.g_simple_async_result_set_op_res_gssize(_arg0, _arg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

// SimpleAsyncResultIsValid ensures that the data passed to the _finish function
// of an async operation is consistent. Three checks are performed.
//
// First, result is checked to ensure that it is really a AsyncResult. Second,
// source is checked to ensure that it matches the source object of result.
// Third, source_tag is checked to ensure that it is equal to the source_tag
// argument given to g_simple_async_result_new() (which, by convention,
// is a pointer to the _async function corresponding to the _finish function
// from which this function is called). (Alternatively, if either source_tag or
// result's source tag is NULL, then the source tag check is skipped.)
//
// Deprecated: Use #GTask and g_task_is_valid() instead.
//
// The function takes the following parameters:
//
//   - result passed to the _finish function.
//   - source (optional) passed to the _finish function.
//   - sourceTag (optional) asynchronous function.
//
// The function returns the following values:
//
//   - ok if all checks passed or LSE if any failed.
func SimpleAsyncResultIsValid(result AsyncResulter, source *coreglib.Object, sourceTag unsafe.Pointer) bool {
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.GObject      // out
	var _arg3 C.gpointer      // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))
	if source != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(source.Native()))
	}
	_arg3 = (C.gpointer)(unsafe.Pointer(sourceTag))

	_cret = C.g_simple_async_result_is_valid(_arg1, _arg2, _arg3)
	runtime.KeepAlive(result)
	runtime.KeepAlive(source)
	runtime.KeepAlive(sourceTag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SimpleIOStream: GSimpleIOStream creates a gio.IOStream from an arbitrary
// gio.InputStream and gio.OutputStream. This allows any pair of input and
// output streams to be used with gio.IOStream methods.
//
// This is useful when you obtained a gio.InputStream and a gio.OutputStream
// by other means, for instance creating them with platform specific methods as
// g_unix_input_stream_new() (../gio-unix/ctor.UnixInputStream.new.html) (from
// gio-unix-2.0.pc / GioUnix-2.0), and you want to take advantage of the methods
// provided by gio.IOStream.
type SimpleIOStream struct {
	_ [0]func() // equal guard
	IOStream
}

var (
	_ IOStreamer = (*SimpleIOStream)(nil)
)

func wrapSimpleIOStream(obj *coreglib.Object) *SimpleIOStream {
	return &SimpleIOStream{
		IOStream: IOStream{
			Object: obj,
		},
	}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	return wrapSimpleIOStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSimpleIOStream creates a new IOStream wrapping input_stream and
// output_stream. See also OStream.
//
// The function takes the following parameters:
//
//   - inputStream: Stream.
//   - outputStream: Stream.
//
// The function returns the following values:
//
//   - simpleIOStream: new IOStream instance.
func NewSimpleIOStream(inputStream InputStreamer, outputStream OutputStreamer) *SimpleIOStream {
	var _arg1 *C.GInputStream  // out
	var _arg2 *C.GOutputStream // out
	var _cret *C.GIOStream     // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(inputStream).Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(outputStream).Native()))

	_cret = C.g_simple_io_stream_new(_arg1, _arg2)
	runtime.KeepAlive(inputStream)
	runtime.KeepAlive(outputStream)

	var _simpleIOStream *SimpleIOStream // out

	_simpleIOStream = wrapSimpleIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simpleIOStream
}

// SimplePermission: GSimplePermission is a trivial implementation of
// gio.Permission that represents a permission that is either always or never
// allowed. The value is given at construction and doesnt change.
//
// Calling gio.Permission.Acquire() or gio.Permission.Release() on a
// GSimplePermission will result in errors.
type SimplePermission struct {
	_ [0]func() // equal guard
	Permission
}

var (
	_ Permissioner = (*SimplePermission)(nil)
)

func wrapSimplePermission(obj *coreglib.Object) *SimplePermission {
	return &SimplePermission{
		Permission: Permission{
			Object: obj,
		},
	}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	return wrapSimplePermission(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSimplePermission creates a new #GPermission instance that represents an
// action that is either always or never allowed.
//
// The function takes the following parameters:
//
//   - allowed: TRUE if the action is allowed.
//
// The function returns the following values:
//
//   - simplePermission as a #GPermission.
func NewSimplePermission(allowed bool) *SimplePermission {
	var _arg1 C.gboolean     // out
	var _cret *C.GPermission // in

	if allowed {
		_arg1 = C.TRUE
	}

	_cret = C.g_simple_permission_new(_arg1)
	runtime.KeepAlive(allowed)

	var _simplePermission *SimplePermission // out

	_simplePermission = wrapSimplePermission(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _simplePermission
}

// SimpleProxyResolverOverrides contains methods that are overridable.
type SimpleProxyResolverOverrides struct {
}

func defaultSimpleProxyResolverOverrides(v *SimpleProxyResolver) SimpleProxyResolverOverrides {
	return SimpleProxyResolverOverrides{}
}

// SimpleProxyResolver: GSimpleProxyResolver is a simple gio.ProxyResolver
// implementation that handles a single default proxy, multiple
// URI-scheme-specific proxies, and a list of hosts that proxies should not be
// used for.
//
// GSimpleProxyResolver is never the default proxy resolver, but it can be used
// as the base class for another proxy resolver implementation, or it can be
// created and used manually, such as with gio.SocketClient.SetProxyResolver().
type SimpleProxyResolver struct {
	_ [0]func() // equal guard
	*coreglib.Object

	ProxyResolver
}

var (
	_ coreglib.Objector = (*SimpleProxyResolver)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SimpleProxyResolver, *SimpleProxyResolverClass, SimpleProxyResolverOverrides](
		GTypeSimpleProxyResolver,
		initSimpleProxyResolverClass,
		wrapSimpleProxyResolver,
		defaultSimpleProxyResolverOverrides,
	)
}

func initSimpleProxyResolverClass(gclass unsafe.Pointer, overrides SimpleProxyResolverOverrides, classInitFunc func(*SimpleProxyResolverClass)) {
	if classInitFunc != nil {
		class := (*SimpleProxyResolverClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSimpleProxyResolver(obj *coreglib.Object) *SimpleProxyResolver {
	return &SimpleProxyResolver{
		Object: obj,
		ProxyResolver: ProxyResolver{
			Object: obj,
		},
	}
}

func marshalSimpleProxyResolver(p uintptr) (interface{}, error) {
	return wrapSimpleProxyResolver(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SetDefaultProxy sets the default proxy on resolver, to be used for any
// URIs that don't match ProxyResolver:ignore-hosts or a proxy set via
// g_simple_proxy_resolver_set_uri_proxy().
//
// If default_proxy starts with "socks://", ProxyResolver will treat it as
// referring to all three of the socks5, socks4a, and socks4 proxy types.
//
// The function takes the following parameters:
//
//   - defaultProxy (optional): default proxy to use.
func (resolver *SimpleProxyResolver) SetDefaultProxy(defaultProxy string) {
	var _arg0 *C.GSimpleProxyResolver // out
	var _arg1 *C.gchar                // out

	_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	if defaultProxy != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(defaultProxy)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_simple_proxy_resolver_set_default_proxy(_arg0, _arg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(defaultProxy)
}

// SetURIProxy adds a URI-scheme-specific proxy to resolver; URIs whose scheme
// matches uri_scheme (and which don't match ProxyResolver:ignore-hosts) will be
// proxied via proxy.
//
// As with ProxyResolver:default-proxy, if proxy starts with "socks://",
// ProxyResolver will treat it as referring to all three of the socks5, socks4a,
// and socks4 proxy types.
//
// The function takes the following parameters:
//
//   - uriScheme: URI scheme to add a proxy for.
//   - proxy to use for uri_scheme.
func (resolver *SimpleProxyResolver) SetURIProxy(uriScheme, proxy string) {
	var _arg0 *C.GSimpleProxyResolver // out
	var _arg1 *C.gchar                // out
	var _arg2 *C.gchar                // out

	_arg0 = (*C.GSimpleProxyResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(proxy)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_simple_proxy_resolver_set_uri_proxy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(uriScheme)
	runtime.KeepAlive(proxy)
}

// NewSimpleProxyResolver creates a new ProxyResolver. See
// ProxyResolver:default-proxy and ProxyResolver:ignore-hosts for more details
// on how the arguments are interpreted.
//
// The function takes the following parameters:
//
//   - defaultProxy (optional): default proxy to use, eg "socks://192.168.1.1".
//   - ignoreHosts (optional): optional list of hosts/IP addresses to not use a
//     proxy for.
//
// The function returns the following values:
//
//   - proxyResolver: new ProxyResolver.
func NewSimpleProxyResolver(defaultProxy string, ignoreHosts []string) *ProxyResolver {
	var _arg1 *C.gchar          // out
	var _arg2 **C.gchar         // out
	var _cret *C.GProxyResolver // in

	if defaultProxy != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(defaultProxy)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(ignoreHosts) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(ignoreHosts)+1)
			var zero *C.gchar
			out[len(ignoreHosts)] = zero
			for i := range ignoreHosts {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(ignoreHosts[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.g_simple_proxy_resolver_new(_arg1, _arg2)
	runtime.KeepAlive(defaultProxy)
	runtime.KeepAlive(ignoreHosts)

	var _proxyResolver *ProxyResolver // out

	_proxyResolver = wrapProxyResolver(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _proxyResolver
}

// SocketOverrides contains methods that are overridable.
type SocketOverrides struct {
}

func defaultSocketOverrides(v *Socket) SocketOverrides {
	return SocketOverrides{}
}

// Socket: GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API.
// It supports both the UNIX socket implementations and winsock2 on Windows.
//
// GSocket is the platform independent base upon which the higher level
// network primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like gio.SocketClient, gio.SocketService
// and gio.SocketConnection. However there may be cases where direct use of
// GSocket is useful.
//
// GSocket implements the gio.Initable interface, so if it is manually
// constructed by e.g. gobject.Object.New you must call gio.Initable.Init()
// and check the results before using the object. This is done automatically in
// gio.Socket.New and gio.Socket.NewFromFd, so these functions can return NULL.
//
// Sockets operate in two general modes, blocking or non-blocking.
// When in blocking mode all operations (which dont take an explicit
// blocking parameter) block until the requested operation is finished
// or there is an error. In non-blocking mode all calls that would block
// return immediately with a G_IO_ERROR_WOULD_BLOCK error. To know when a
// call would successfully run you can call gio.Socket.ConditionCheck(),
// or gio.Socket.ConditionWait(). You can also use gio.Socket.CreateSource()
// and attach it to a glib.MainContext to get callbacks when I/O is possible.
// Note that all sockets are always set to non blocking mode in the system,
// and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons.
// For instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, GSocket is not inherently thread safe.
// To use a GSocket concurrently from multiple threads, you must implement your
// own locking.
//
// # Nagles algorithm
//
// Since GLib 2.80, GSocket will automatically set the TCP_NODELAY option
// on all G_SOCKET_TYPE_STREAM sockets. This disables Nagles algorithm
// (https://en.wikipedia.org/wiki/Nagle27s_algorithm) as it typically does more
// harm than good on modern networks.
//
// If your application needs Nagles algorithm enabled, call
// gio.Socket.SetOption() after constructing a GSocket to enable it:
//
//	socket = g_socket_new (, G_SOCKET_TYPE_STREAM, );
//	if (socket != NULL)
//	  {
//	    g_socket_set_option (socket, IPPROTO_TCP, TCP_NODELAY, FALSE, &local_error);
//	    // handle error if needed
//	  }.
type Socket struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DatagramBased
	Initable
}

var (
	_ coreglib.Objector = (*Socket)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Socket, *SocketClass, SocketOverrides](
		GTypeSocket,
		initSocketClass,
		wrapSocket,
		defaultSocketOverrides,
	)
}

func initSocketClass(gclass unsafe.Pointer, overrides SocketOverrides, classInitFunc func(*SocketClass)) {
	if classInitFunc != nil {
		class := (*SocketClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocket(obj *coreglib.Object) *Socket {
	return &Socket{
		Object: obj,
		DatagramBased: DatagramBased{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	return wrapSocket(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSocket creates a new #GSocket with the defined family, type and protocol.
// If protocol is 0 (G_SOCKET_PROTOCOL_DEFAULT) the default protocol type for
// the family and type is used.
//
// The protocol is a family and type specific int that specifies what kind
// of protocol to use. Protocol lists several common ones. Many families only
// support one protocol, and use 0 for this, others support several and using 0
// means to use the default protocol for the family and type.
//
// The protocol id is passed directly to the operating system, so you can use
// protocols not listed in Protocol if you know the protocol number used for it.
//
// The function takes the following parameters:
//
//   - family: socket family to use, e.g. G_SOCKET_FAMILY_IPV4.
//   - typ: socket type to use.
//   - protocol: id of the protocol to use, or 0 for default.
//
// The function returns the following values:
//
//   - socket or NULL on error. Free the returned object with g_object_unref().
func NewSocket(family SocketFamily, typ SocketType, protocol SocketProtocol) (*Socket, error) {
	var _arg1 C.GSocketFamily   // out
	var _arg2 C.GSocketType     // out
	var _arg3 C.GSocketProtocol // out
	var _cret *C.GSocket        // in
	var _cerr *C.GError         // in

	_arg1 = C.GSocketFamily(family)
	_arg2 = C.GSocketType(typ)
	_arg3 = C.GSocketProtocol(protocol)

	_cret = C.g_socket_new(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)

	var _socket *Socket // out
	var _goerr error    // out

	_socket = wrapSocket(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socket, _goerr
}

// NewSocketFromFd creates a new #GSocket from a native file descriptor or
// winsock SOCKET handle.
//
// This reads all the settings from the file descriptor so that all properties
// should work. Note that the file descriptor will be set to non-blocking mode,
// independent on the blocking mode of the #GSocket.
//
// On success, the returned #GSocket takes ownership of fd. On failure,
// the caller must close fd themselves.
//
// Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
// descriptor. Instead, a GError will be set with code G_IO_ERROR_FAILED.
//
// The function takes the following parameters:
//
//   - fd: native socket file descriptor.
//
// The function returns the following values:
//
//   - socket or NULL on error. Free the returned object with g_object_unref().
func NewSocketFromFd(fd int) (*Socket, error) {
	var _arg1 C.gint     // out
	var _cret *C.GSocket // in
	var _cerr *C.GError  // in

	_arg1 = C.gint(fd)

	_cret = C.g_socket_new_from_fd(_arg1, &_cerr)
	runtime.KeepAlive(fd)

	var _socket *Socket // out
	var _goerr error    // out

	_socket = wrapSocket(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socket, _goerr
}

// Accept incoming connections on a connection-based socket. This removes the
// first outstanding connection request from the listening socket and creates a
// #GSocket object for it.
//
// The socket must be bound to a local address with g_socket_bind() and must be
// listening for incoming connections (g_socket_listen()).
//
// If there are no outstanding connections then the operation will block or
// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be notified
// of an incoming connection, wait for the G_IO_IN condition.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//
// The function returns the following values:
//
//   - ret: new #GSocket, or NULL on error. Free the returned object with
//     g_object_unref().
func (socket *Socket) Accept(ctx context.Context) (*Socket, error) {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GSocket      // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_socket_accept(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)

	var _ret *Socket // out
	var _goerr error // out

	_ret = wrapSocket(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// Bind: when a socket is created it is attached to an address family, but it
// doesn't have an address in this family. g_socket_bind() assigns the address
// (sometimes called name) of the socket.
//
// It is generally required to bind to a local address before you can receive
// connections. (See g_socket_listen() and g_socket_accept() ). In certain
// situations, you may also want to bind a socket that will be used to initiate
// connections, though this is not normally required.
//
// If socket is a TCP socket, then allow_reuse controls the setting of the
// SO_REUSEADDR socket option; normally it should be TRUE for server sockets
// (sockets that you will eventually call g_socket_accept() on), and FALSE
// for client sockets. (Failing to set this flag on a server socket may cause
// g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the server program is
// stopped and then immediately restarted.)
//
// If socket is a UDP socket, then allow_reuse determines whether or not other
// UDP sockets can be bound to the same address at the same time. In particular,
// you can have several UDP sockets bound to the same address, and they will
// all receive all of the multicast and broadcast packets sent to that address.
// (The behavior of unicast UDP packets to an address with multiple listeners is
// not defined.).
//
// The function takes the following parameters:
//
//   - address specifying the local address.
//   - allowReuse: whether to allow reusing this address.
func (socket *Socket) Bind(address SocketAddresser, allowReuse bool) error {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 C.gboolean        // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if allowReuse {
		_arg2 = C.TRUE
	}

	C.g_socket_bind(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(allowReuse)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CheckConnectResult checks and resets the pending connect error for the
// socket. This is used to check for errors when g_socket_connect() is used in
// non-blocking mode.
func (socket *Socket) CheckConnectResult() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	C.g_socket_check_connect_result(_arg0, &_cerr)
	runtime.KeepAlive(socket)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Close closes the socket, shutting down any active connection.
//
// Closing a socket does not wait for all outstanding I/O operations to finish,
// so the caller should not rely on them to be guaranteed to complete even if
// the close returns with no error.
//
// Once the socket is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an error.
//
// Sockets will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are released
// as early as possible.
//
// Beware that due to the way that TCP works, it is possible for recently-sent
// data to be lost if either you close a socket while the G_IO_IN condition is
// set, or else if the remote connection tries to send something to you after
// you close the socket but before it has finished reading all of the data you
// sent. There is no easy generic way to avoid this problem; the easiest fix is
// to design the network protocol such that the client will never send data "out
// of turn". Another solution is for the server to half-close the connection by
// calling g_socket_shutdown() with only the shutdown_write flag set, and then
// wait for the client to notice this and close its side of the connection,
// after which the server can safely call g_socket_close(). (This is what
// Connection does if you call g_tcp_connection_set_graceful_disconnect().
// But of course, this only works if the client will close its connection after
// the server does.).
func (socket *Socket) Close() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	C.g_socket_close(_arg0, &_cerr)
	runtime.KeepAlive(socket)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ConditionCheck checks on the readiness of socket to perform operations.
// The operations specified in condition are checked for and masked against the
// currently-satisfied conditions on socket. The result is returned.
//
// Note that on Windows, it is possible for an operation to return
// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check()
// has claimed that the socket is ready for writing. Rather than calling
// g_socket_condition_check() and then writing to the socket if it succeeds,
// it is generally better to simply try writing to the socket right away,
// and try again later if the initial attempt returns G_IO_ERROR_WOULD_BLOCK.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be set in the output if they are true.
//
// This call never blocks.
//
// The function takes the following parameters:
//
//   - condition mask to check.
//
// The function returns the following values:
//
//   - ioCondition: GIOCondition mask of the current state.
func (socket *Socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var _arg0 *C.GSocket     // out
	var _arg1 C.GIOCondition // out
	var _cret C.GIOCondition // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.GIOCondition(condition)

	_cret = C.g_socket_condition_check(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)

	var _ioCondition glib.IOCondition // out

	_ioCondition = glib.IOCondition(_cret)

	return _ioCondition
}

// ConditionTimedWait waits for up to timeout_us microseconds for condition to
// become true on socket. If the condition is met, TRUE is returned.
//
// If cancellable is cancelled before the condition is met, or if timeout_us
// (or the socket's #GSocket:timeout) is reached before the condition is met,
// then FALSE is returned and error, if non-NULL, is set to the appropriate
// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// If you don't want a timeout, use g_socket_condition_wait(). (Alternatively,
// you can pass -1 for timeout_us.)
//
// Note that although timeout_us is in microseconds for consistency with other
// GLib APIs, this function actually only has millisecond resolution, and the
// behavior is undefined if timeout_us is not an exact number of milliseconds.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - condition mask to wait for.
//   - timeoutUs: maximum time (in microseconds) to wait, or -1.
func (socket *Socket) ConditionTimedWait(ctx context.Context, condition glib.IOCondition, timeoutUs int64) error {
	var _arg0 *C.GSocket      // out
	var _arg3 *C.GCancellable // out
	var _arg1 C.GIOCondition  // out
	var _arg2 C.gint64        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GIOCondition(condition)
	_arg2 = C.gint64(timeoutUs)

	C.g_socket_condition_timed_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeoutUs)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ConditionWait waits for condition to become true on socket. When the
// condition is met, TRUE is returned.
//
// If cancellable is cancelled before the condition is met, or if the socket
// has a timeout set and it is reached before the condition is met, then
// FALSE is returned and error, if non-NULL, is set to the appropriate value
// (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// See also g_socket_condition_timed_wait().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - condition mask to wait for.
func (socket *Socket) ConditionWait(ctx context.Context, condition glib.IOCondition) error {
	var _arg0 *C.GSocket      // out
	var _arg2 *C.GCancellable // out
	var _arg1 C.GIOCondition  // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GIOCondition(condition)

	C.g_socket_condition_wait(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ConnectSocket: connect the socket to the specified remote address.
//
// For connection oriented socket this generally means we attempt to make a
// connection to the address. For a connection-less socket it sets the default
// address for g_socket_send() and discards all incoming datagrams from other
// sources.
//
// Generally connection oriented sockets can only connect once, but
// connection-less sockets can connect multiple times to change the default
// address.
//
// If the connect call needs to do network I/O it will block, unless
// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and
// the user can be notified of the connection finishing by waiting for the
// G_IO_OUT condition. The result of the connection must then be checked with
// g_socket_check_connect_result().
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - address specifying the remote address.
func (socket *Socket) ConnectSocket(ctx context.Context, address SocketAddresser) error {
	var _arg0 *C.GSocket        // out
	var _arg2 *C.GCancellable   // out
	var _arg1 *C.GSocketAddress // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	C.g_socket_connect(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ConnectionFactoryCreateConnection creates a Connection subclass of the right
// type for socket.
//
// The function returns the following values:
//
//   - socketConnection: Connection.
func (socket *Socket) ConnectionFactoryCreateConnection() *SocketConnection {
	var _arg0 *C.GSocket           // out
	var _cret *C.GSocketConnection // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_connection_factory_create_connection(_arg0)
	runtime.KeepAlive(socket)

	var _socketConnection *SocketConnection // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketConnection
}

// AvailableBytes: get the amount of data pending in the OS input buffer,
// without blocking.
//
// If socket is a UDP or SCTP socket, this will return the size of just the next
// packet, even if additional packets are buffered after that one.
//
// Note that on Windows, this function is rather inefficient in the UDP case,
// and so if you know any plausible upper bound on the size of the incoming
// packet, it is better to just do a g_socket_receive() with a buffer of that
// size, rather than calling g_socket_get_available_bytes() first and then doing
// a receive of exactly the right size.
//
// The function returns the following values:
//
//   - gssize: number of bytes that can be read from the socket without blocking
//     or truncating, or -1 on error.
func (socket *Socket) AvailableBytes() int {
	var _arg0 *C.GSocket // out
	var _cret C.gssize   // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_available_bytes(_arg0)
	runtime.KeepAlive(socket)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// Blocking gets the blocking mode of the socket. For details on blocking I/O,
// see g_socket_set_blocking().
//
// The function returns the following values:
//
//   - ok: TRUE if blocking I/O is used, FALSE otherwise.
func (socket *Socket) Blocking() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_blocking(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Broadcast gets the broadcast setting on socket; if TRUE, it is possible to
// send packets to broadcast addresses.
//
// The function returns the following values:
//
//   - ok: broadcast setting on socket.
func (socket *Socket) Broadcast() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_broadcast(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Credentials returns the credentials of the foreign process connected to this
// socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX sockets).
//
// If this operation isn't supported on the OS, the method fails with the
// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the
// SO_PEERCRED option on the underlying socket.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26
//
// - OpenBSD since GLib 2.30
//
// - Solaris, Illumos and OpenSolaris since GLib 2.40
//
// - NetBSD since GLib 2.42
//
// - macOS, tvOS, iOS since GLib 2.66
//
// Other ways to obtain credentials from a foreign peer includes the
// CredentialsMessage type and g_unix_connection_send_credentials() /
// g_unix_connection_receive_credentials() functions.
//
// The function returns the following values:
//
//   - credentials: NULL if error is set, otherwise a #GCredentials object that
//     must be freed with g_object_unref().
func (socket *Socket) Credentials() (*Credentials, error) {
	var _arg0 *C.GSocket      // out
	var _cret *C.GCredentials // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_credentials(_arg0, &_cerr)
	runtime.KeepAlive(socket)

	var _credentials *Credentials // out
	var _goerr error              // out

	_credentials = wrapCredentials(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _credentials, _goerr
}

// Family gets the socket family of the socket.
//
// The function returns the following values:
//
//   - socketFamily: Family.
func (socket *Socket) Family() SocketFamily {
	var _arg0 *C.GSocket      // out
	var _cret C.GSocketFamily // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_family(_arg0)
	runtime.KeepAlive(socket)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

// Fd returns the underlying OS socket object. On unix this is a socket file
// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
// useful for doing platform specific or otherwise unusual operations on the
// socket.
//
// The function returns the following values:
//
//   - gint: file descriptor of the socket.
func (socket *Socket) Fd() int {
	var _arg0 *C.GSocket // out
	var _cret C.int      // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_fd(_arg0)
	runtime.KeepAlive(socket)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Keepalive gets the keepalive mode of the socket. For details on this,
// see g_socket_set_keepalive().
//
// The function returns the following values:
//
//   - ok: TRUE if keepalive is active, FALSE otherwise.
func (socket *Socket) Keepalive() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_keepalive(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListenBacklog gets the listen backlog setting of the socket. For details on
// this, see g_socket_set_listen_backlog().
//
// The function returns the following values:
//
//   - gint: maximum number of pending connections.
func (socket *Socket) ListenBacklog() int {
	var _arg0 *C.GSocket // out
	var _cret C.gint     // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_listen_backlog(_arg0)
	runtime.KeepAlive(socket)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LocalAddress: try to get the local address of a bound socket. This is only
// useful if the socket has been bound to a local address, either explicitly or
// implicitly when connecting.
//
// The function returns the following values:
//
//   - socketAddress or NULL on error. Free the returned object with
//     g_object_unref().
func (socket *Socket) LocalAddress() (SocketAddresser, error) {
	var _arg0 *C.GSocket        // out
	var _cret *C.GSocketAddress // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_local_address(_arg0, &_cerr)
	runtime.KeepAlive(socket)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddresser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddresser)
			return ok
		})
		rv, ok := casted.(SocketAddresser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
		}
		_socketAddress = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// MulticastLoopback gets the multicast loopback setting on socket; if TRUE
// (the default), outgoing multicast packets will be looped back to multicast
// listeners on the same host.
//
// The function returns the following values:
//
//   - ok: multicast loopback setting on socket.
func (socket *Socket) MulticastLoopback() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_multicast_loopback(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MulticastTTL gets the multicast time-to-live setting on socket; see
// g_socket_set_multicast_ttl() for more details.
//
// The function returns the following values:
//
//   - guint: multicast time-to-live setting on socket.
func (socket *Socket) MulticastTTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_multicast_ttl(_arg0)
	runtime.KeepAlive(socket)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Option gets the value of an integer-valued option on socket, as with
// getsockopt(). (If you need to fetch a non-integer-valued option, you will
// need to call getsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system headers
// that will define most of the standard/portable socket options. For unusual
// socket protocols or platform-dependent options, you may need to include
// additional headers.
//
// Note that even for socket options that are a single byte in size, value is
// still a pointer to a #gint variable, not a #guchar; g_socket_get_option()
// will handle the conversion internally.
//
// The function takes the following parameters:
//
//   - level: "API level" of the option (eg, SOL_SOCKET).
//   - optname: "name" of the option (eg, SO_BROADCAST).
//
// The function returns the following values:
//
//   - value: return location for the option value.
func (socket *Socket) Option(level, optname int) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.gint(level)
	_arg2 = C.gint(optname)

	C.g_socket_get_option(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)

	var _value int   // out
	var _goerr error // out

	_value = int(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// Protocol gets the socket protocol id the socket was created with. In case the
// protocol is unknown, -1 is returned.
//
// The function returns the following values:
//
//   - socketProtocol: protocol id, or -1 if unknown.
func (socket *Socket) Protocol() SocketProtocol {
	var _arg0 *C.GSocket        // out
	var _cret C.GSocketProtocol // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_protocol(_arg0)
	runtime.KeepAlive(socket)

	var _socketProtocol SocketProtocol // out

	_socketProtocol = SocketProtocol(_cret)

	return _socketProtocol
}

// RemoteAddress: try to get the remote address of a connected socket. This is
// only useful for connection oriented sockets that have been connected.
//
// The function returns the following values:
//
//   - socketAddress or NULL on error. Free the returned object with
//     g_object_unref().
func (socket *Socket) RemoteAddress() (SocketAddresser, error) {
	var _arg0 *C.GSocket        // out
	var _cret *C.GSocketAddress // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_remote_address(_arg0, &_cerr)
	runtime.KeepAlive(socket)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddresser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddresser)
			return ok
		})
		rv, ok := casted.(SocketAddresser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
		}
		_socketAddress = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// SocketType gets the socket type of the socket.
//
// The function returns the following values:
//
//   - socketType: Type.
func (socket *Socket) SocketType() SocketType {
	var _arg0 *C.GSocket    // out
	var _cret C.GSocketType // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_socket_type(_arg0)
	runtime.KeepAlive(socket)

	var _socketType SocketType // out

	_socketType = SocketType(_cret)

	return _socketType
}

// Timeout gets the timeout setting of the socket. For details on this,
// see g_socket_set_timeout().
//
// The function returns the following values:
//
//   - guint: timeout in seconds.
func (socket *Socket) Timeout() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_timeout(_arg0)
	runtime.KeepAlive(socket)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TTL gets the unicast time-to-live setting on socket; see g_socket_set_ttl()
// for more details.
//
// The function returns the following values:
//
//   - guint: time-to-live setting on socket.
func (socket *Socket) TTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_ttl(_arg0)
	runtime.KeepAlive(socket)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsClosed checks whether a socket is closed.
//
// The function returns the following values:
//
//   - ok: TRUE if socket is closed, FALSE otherwise.
func (socket *Socket) IsClosed() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_is_closed(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsConnected: check whether the socket is connected. This is only useful for
// connection-oriented sockets.
//
// If using g_socket_shutdown(), this function will return TRUE until the
// socket has been shut down for reading and writing. If you do a non-blocking
// connect, this function will not return TRUE until after you call
// g_socket_check_connect_result().
//
// The function returns the following values:
//
//   - ok: TRUE if socket is connected, FALSE otherwise.
func (socket *Socket) IsConnected() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_is_connected(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// JoinMulticastGroup registers socket to receive multicast messages sent to
// group. socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
//
// If iface is NULL, the system will automatically pick an interface to bind to
// based on group.
//
// If source_specific is TRUE, source-specific multicast as defined in
// RFC 4604 is used. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// To bind to a given source-specific multicast address, use
// g_socket_join_multicast_group_ssm() instead.
//
// The function takes the following parameters:
//
//   - group specifying the group address to join.
//   - sourceSpecific: TRUE if source-specific multicast should be used.
//   - iface (optional): name of the interface to use, or NULL.
func (socket *Socket) JoinMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_join_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// JoinMulticastGroupSSM registers socket to receive multicast messages sent
// to group. socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
//
// If iface is NULL, the system will automatically pick an interface to bind to
// based on group.
//
// If source_specific is not NULL, use source-specific multicast as
// defined in RFC 4604. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// Note that this function can be called multiple times for the same group with
// different source_specific in order to receive multicast packets from more
// than one source.
//
// The function takes the following parameters:
//
//   - group specifying the group address to join.
//   - sourceSpecific (optional) specifying the source-specific multicast
//     address or NULL to ignore.
//   - iface (optional): name of the interface to use, or NULL.
func (socket *Socket) JoinMulticastGroupSSM(group, sourceSpecific *InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific != nil {
		_arg2 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(sourceSpecific).Native()))
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_join_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LeaveMulticastGroup removes socket from the multicast group defined by group,
// iface, and source_specific (which must all have the same values they had when
// you joined the group).
//
// socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
//
// To unbind to a given source-specific multicast address, use
// g_socket_leave_multicast_group_ssm() instead.
//
// The function takes the following parameters:
//
//   - group specifying the group address to leave.
//   - sourceSpecific: TRUE if source-specific multicast was used.
//   - iface (optional): interface used.
func (socket *Socket) LeaveMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_leave_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LeaveMulticastGroupSSM removes socket from the multicast group defined by
// group, iface, and source_specific (which must all have the same values they
// had when you joined the group).
//
// socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
//
// The function takes the following parameters:
//
//   - group specifying the group address to leave.
//   - sourceSpecific (optional) specifying the source-specific multicast
//     address or NULL to ignore.
//   - iface (optional): name of the interface to use, or NULL.
func (socket *Socket) LeaveMulticastGroupSSM(group, sourceSpecific *InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific != nil {
		_arg2 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(sourceSpecific).Native()))
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_leave_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Listen marks the socket as a server socket, i.e. a socket that is used to
// accept incoming requests using g_socket_accept().
//
// Before calling this the socket must be bound to a local address using
// g_socket_bind().
//
// To set the maximum amount of outstanding clients, use
// g_socket_set_listen_backlog().
func (socket *Socket) Listen() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	C.g_socket_listen(_arg0, &_cerr)
	runtime.KeepAlive(socket)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Receive data (up to size bytes) from a socket. This is mainly used by
// connection-oriented sockets; it is identical to g_socket_receive_from() with
// address set to NULL.
//
// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
// g_socket_receive() will always read either 0 or 1 complete messages from the
// socket. If the received message is too large to fit in buffer, then the data
// beyond size bytes will be discarded, without any explicit indication that
// this has occurred.
//
// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any number of
// bytes, up to size. If more than size bytes have been received, the additional
// data will be returned in future calls to g_socket_receive().
//
// If the socket is in blocking mode the call will block until there is
// some data to receive, the connection is closed, or there is an error.
// If there is no data available and the socket is in non-blocking mode,
// a G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data is
// available, wait for the G_IO_IN condition.
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - buffer: a buffer to read data into (which should be at least size bytes
//     long).
//
// The function returns the following values:
//
//   - gssize: number of bytes read, or 0 if the connection was closed by the
//     peer, or -1 on error.
func (socket *Socket) Receive(ctx context.Context, buffer []byte) (int, error) {
	var _arg0 *C.GSocket      // out
	var _arg3 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	_arg1 = (*C.gchar)(C.CBytes(buffer))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_socket_receive(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// ReceiveBytes receives data (up to size bytes) from a socket.
//
// This function is a variant of gio.Socket.Receive() which returns a glib.Bytes
// rather than a plain buffer.
//
// Pass -1 to timeout_us to block indefinitely until data is received (or the
// connection is closed, or there is an error). Pass 0 to use the default
// timeout from gio.Socket:timeout, or pass a positive number to wait for that
// many microseconds for data before returning G_IO_ERROR_TIMED_OUT.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable, or NULL.
//   - size: number of bytes you want to read from the socket.
//   - timeoutUs: timeout to wait for, in microseconds, or -1 to block
//     indefinitely.
//
// The function returns the following values:
//
//   - bytes buffer containing the received bytes, or NULL on error.
func (socket *Socket) ReceiveBytes(ctx context.Context, size uint, timeoutUs int64) (*glib.Bytes, error) {
	var _arg0 *C.GSocket      // out
	var _arg3 *C.GCancellable // out
	var _arg1 C.gsize         // out
	var _arg2 C.gint64        // out
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gsize(size)
	_arg2 = C.gint64(timeoutUs)

	_cret = C.g_socket_receive_bytes(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)
	runtime.KeepAlive(timeoutUs)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// ReceiveBytesFrom: receive data (up to size bytes) from a socket.
//
// This function is a variant of gio.Socket.ReceiveFrom() which returns a
// glib.Bytes rather than a plain buffer.
//
// If address is non-NULL then address will be set equal to the source address
// of the received packet.
//
// The address is owned by the caller.
//
// Pass -1 to timeout_us to block indefinitely until data is received (or the
// connection is closed, or there is an error). Pass 0 to use the default
// timeout from gio.Socket:timeout, or pass a positive number to wait for that
// many microseconds for data before returning G_IO_ERROR_TIMED_OUT.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - size: number of bytes you want to read from the socket.
//   - timeoutUs: timeout to wait for, in microseconds, or -1 to block
//     indefinitely.
//
// The function returns the following values:
//
//   - address (optional): return location for a Address.
//   - bytes buffer containing the received bytes, or NULL on error.
func (socket *Socket) ReceiveBytesFrom(ctx context.Context, size uint, timeoutUs int64) (SocketAddresser, *glib.Bytes, error) {
	var _arg0 *C.GSocket        // out
	var _arg4 *C.GCancellable   // out
	var _arg1 *C.GSocketAddress // in
	var _arg2 C.gsize           // out
	var _arg3 C.gint64          // out
	var _cret *C.GBytes         // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = C.gsize(size)
	_arg3 = C.gint64(timeoutUs)

	_cret = C.g_socket_receive_bytes_from(_arg0, &_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(size)
	runtime.KeepAlive(timeoutUs)

	var _address SocketAddresser // out
	var _bytes *glib.Bytes       // out
	var _goerr error             // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_address = rv
		}
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _address, _bytes, _goerr
}

// ReceiveFrom: receive data (up to size bytes) from a socket.
//
// If address is non-NULL then address will be set equal to the source address
// of the received packet. address is owned by the caller.
//
// See g_socket_receive() for additional information.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - buffer: a buffer to read data into (which should be at least size bytes
//     long).
//
// The function returns the following values:
//
//   - address (optional): pointer to a Address pointer, or NULL.
//   - gssize: number of bytes read, or 0 if the connection was closed by the
//     peer, or -1 on error.
func (socket *Socket) ReceiveFrom(ctx context.Context, buffer []byte) (SocketAddresser, int, error) {
	var _arg0 *C.GSocket        // out
	var _arg4 *C.GCancellable   // out
	var _arg1 *C.GSocketAddress // in
	var _arg2 *C.gchar          // out
	var _arg3 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg3 = (C.gsize)(len(buffer))
	_arg2 = (*C.gchar)(C.CBytes(buffer))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_socket_receive_from(_arg0, &_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _address SocketAddresser // out
	var _gssize int              // out
	var _goerr error             // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_address = rv
		}
	}
	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _address, _gssize, _goerr
}

// ReceiveMessages: receive multiple data messages from socket in one go.
// This is the most complicated and fully-featured version of this call.
// For easier use, see g_socket_receive(), g_socket_receive_from(), and
// g_socket_receive_message().
//
// messages must point to an array of Message structs and num_messages must
// be the length of this array. Each Message contains a pointer to an array of
// Vector structs describing the buffers that the data received in each message
// will be written to. Using multiple Vectors is more memory-efficient than
// manually copying data out of a single buffer to multiple sources, and more
// system-call-efficient than making multiple calls to g_socket_receive(),
// such as in scenarios where a lot of data packets need to be received (e.g.
// high-bandwidth video streaming over RTP/UDP).
//
// flags modify how all messages are received. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can
// pass in system-specific flags too. These flags affect the overall receive
// operation. Flags affecting individual messages are returned in Message.flags.
//
// The other members of Message are treated as described in its documentation.
//
// If #GSocket:blocking is TRUE the call will block until num_messages have been
// received, or the end of the stream is reached.
//
// If #GSocket:blocking is FALSE the call will return up to num_messages
// without blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
// operating system to be received.
//
// In blocking mode, if #GSocket:timeout is positive and is reached before
// any messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up
// to num_messages are returned. (Note: This is effectively the behaviour of
// MSG_WAITFORONE with recvmmsg().)
//
// To be notified when messages are available, wait for the G_IO_IN condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_receive_messages() even if you were previously notified of a G_IO_IN
// condition.
//
// If the remote peer closes the connection, any messages queued in
// the operating system will be returned, and subsequent calls to
// g_socket_receive_messages() will return 0 (with no error set).
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be received; otherwise the number of messages
// successfully received before the error will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - messages: array of Message structs.
//   - flags: int containing MsgFlags flags for the overall operation,
//     which may additionally contain other platform specific flags
//     (http://man7.org/linux/man-pages/man2/recv.2.html).
//
// The function returns the following values:
//
//   - gint: number of messages received, or -1 on error. Note that the number
//     of messages received may be smaller than num_messages if in non-blocking
//     mode, if the peer closed the connection, or if num_messages was larger
//     than UIO_MAXIOV (1024), in which case the caller may re-try to receive
//     the remaining messages.
func (socket *Socket) ReceiveMessages(ctx context.Context, messages []InputMessage, flags int) (int, error) {
	var _arg0 *C.GSocket       // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GInputMessage // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GInputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GInputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GInputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GInputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)

	_cret = C.g_socket_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
// except that the choice of blocking or non-blocking behavior is determined by
// the blocking argument rather than by socket's properties.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - buffer: a buffer to read data into (which should be at least size bytes
//     long).
//   - blocking: whether to do blocking or non-blocking I/O.
//
// The function returns the following values:
//
//   - gssize: number of bytes read, or 0 if the connection was closed by the
//     peer, or -1 on error.
func (socket *Socket) ReceiveWithBlocking(ctx context.Context, buffer []byte, blocking bool) (int, error) {
	var _arg0 *C.GSocket      // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gsize
	var _arg3 C.gboolean // out
	var _cret C.gssize   // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	_arg1 = (*C.gchar)(C.CBytes(buffer))
	defer C.free(unsafe.Pointer(_arg1))
	if blocking {
		_arg3 = C.TRUE
	}

	_cret = C.g_socket_receive_with_blocking(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// Send tries to send size bytes from buffer on the socket. This is mainly used
// by connection-oriented sockets; it is identical to g_socket_send_to() with
// address set to NULL.
//
// If the socket is in blocking mode the call will block until there is space
// for the data in the socket queue. If there is no space available and the
// socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error will be
// returned. To be notified when space is available, wait for the G_IO_OUT
// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_send() even if you were previously notified of a G_IO_OUT condition.
// (On Windows in particular, this is very common due to the way the underlying
// APIs work.)
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - buffer: buffer containing the data to send.
//
// The function returns the following values:
//
//   - gssize: number of bytes written (which may be less than size), or -1 on
//     error.
func (socket *Socket) Send(ctx context.Context, buffer string) (int, error) {
	var _arg0 *C.GSocket      // out
	var _arg3 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(buffer) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(buffer)), buffer)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_socket_send(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SendMessage: send data to address on socket. For sending multiple messages
// see g_socket_send_messages(); for easier use, see g_socket_send() and
// g_socket_send_to().
//
// If address is NULL then the message is sent to the default receiver (set by
// g_socket_connect()).
//
// vectors must point to an array of Vector structs and num_vectors must be
// the length of this array. (If num_vectors is -1, then vectors is assumed to
// be terminated by a Vector with a NULL buffer pointer.) The Vector structs
// describe the buffers that the sent data will be gathered from. Using multiple
// Vectors is more memory-efficient than manually copying data from multiple
// sources into a single buffer, and more network-efficient than making multiple
// calls to g_socket_send().
//
// messages, if non-NULL, is taken to point to an array of num_messages
// ControlMessage instances. These correspond to the control messages to be
// sent on the socket. If num_messages is -1 then messages is treated as a
// NULL-terminated array.
//
// flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same
// as the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
//
// If the socket is in blocking mode the call will block until there is space
// for the data in the socket queue. If there is no space available and the
// socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error will be
// returned. To be notified when space is available, wait for the G_IO_OUT
// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_send() even if you were previously notified of a G_IO_OUT condition.
// (On Windows in particular, this is very common due to the way the underlying
// APIs work.)
//
// The sum of the sizes of each Vector in vectors must not be greater than
// G_MAXSSIZE. If the message can be larger than this, then it is mandatory to
// use the g_socket_send_message_with_timeout() function.
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - address (optional) or NULL.
//   - vectors: array of Vector structs.
//   - messages (optional): pointer to an array of ControlMessages, or NULL.
//   - flags: int containing MsgFlags flags, which may
//     additionally contain other platform specific flags
//     (http://man7.org/linux/man-pages/man2/recv.2.html).
//
// The function returns the following values:
//
//   - gssize: number of bytes written (which may be less than size), or -1 on
//     error.
func (socket *Socket) SendMessage(ctx context.Context, address SocketAddresser, vectors []OutputVector, messages []SocketControlMessager, flags int) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg7 *C.GCancellable   // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GOutputVector  // out
	var _arg3 C.gint
	var _arg4 **C.GSocketControlMessage // out
	var _arg5 C.gint
	var _arg6 C.gint    // out
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if address != nil {
		_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	}
	_arg3 = (C.gint)(len(vectors))
	_arg2 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg2), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	if messages != nil {
		_arg5 = (C.gint)(len(messages))
		_arg4 = (**C.GSocketControlMessage)(C.calloc(C.size_t(len(messages)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice((**C.GSocketControlMessage)(_arg4), len(messages))
			for i := range messages {
				out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(messages[i]).Native()))
			}
		}
	}
	_arg6 = C.gint(flags)

	_cret = C.g_socket_send_message(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SendMessageWithTimeout: this behaves exactly the same as
// g_socket_send_message(), except that the choice of timeout behavior is
// determined by the timeout_us argument rather than by socket's properties.
//
// On error G_POLLABLE_RETURN_FAILED is returned and error is set accordingly,
// or if the socket is currently not writable G_POLLABLE_RETURN_WOULD_BLOCK is
// returned. bytes_written will contain 0 in both cases.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - address (optional) or NULL.
//   - vectors: array of Vector structs.
//   - messages (optional): pointer to an array of ControlMessages, or NULL.
//   - flags: int containing MsgFlags flags, which may
//     additionally contain other platform specific flags
//     (http://man7.org/linux/man-pages/man2/recv.2.html).
//   - timeoutUs: maximum time (in microseconds) to wait, or -1.
//
// The function returns the following values:
//
//   - bytesWritten (optional): location to store the number of bytes that were
//     written to the socket.
//   - pollableReturn: G_POLLABLE_RETURN_OK if all data was successfully
//     written, G_POLLABLE_RETURN_WOULD_BLOCK if the socket is currently not
//     writable, or G_POLLABLE_RETURN_FAILED if an error happened and error is
//     set.
func (socket *Socket) SendMessageWithTimeout(ctx context.Context, address SocketAddresser, vectors []OutputVector, messages []SocketControlMessager, flags int, timeoutUs int64) (uint, PollableReturn, error) {
	var _arg0 *C.GSocket        // out
	var _arg9 *C.GCancellable   // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GOutputVector  // out
	var _arg3 C.gint
	var _arg4 **C.GSocketControlMessage // out
	var _arg5 C.gint
	var _arg6 C.gint            // out
	var _arg7 C.gint64          // out
	var _arg8 C.gsize           // in
	var _cret C.GPollableReturn // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if address != nil {
		_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	}
	_arg3 = (C.gint)(len(vectors))
	_arg2 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg2), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	if messages != nil {
		_arg5 = (C.gint)(len(messages))
		_arg4 = (**C.GSocketControlMessage)(C.calloc(C.size_t(len(messages)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice((**C.GSocketControlMessage)(_arg4), len(messages))
			for i := range messages {
				out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(messages[i]).Native()))
			}
		}
	}
	_arg6 = C.gint(flags)
	_arg7 = C.gint64(timeoutUs)

	_cret = C.g_socket_send_message_with_timeout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_arg8, _arg9, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutUs)

	var _bytesWritten uint             // out
	var _pollableReturn PollableReturn // out
	var _goerr error                   // out

	_bytesWritten = uint(_arg8)
	_pollableReturn = PollableReturn(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _pollableReturn, _goerr
}

// SendMessages: send multiple data messages from socket in one go. This is the
// most complicated and fully-featured version of this call. For easier use,
// see g_socket_send(), g_socket_send_to(), and g_socket_send_message().
//
// messages must point to an array of Message structs and num_messages must be
// the length of this array. Each Message contains an address to send the data
// to, and a pointer to an array of Vector structs to describe the buffers that
// the data to be sent for each message will be gathered from. Using multiple
// Vectors is more memory-efficient than manually copying data from multiple
// sources into a single buffer, and more network-efficient than making multiple
// calls to g_socket_send(). Sending multiple messages in one go avoids the
// overhead of making a lot of syscalls in scenarios where a lot of data packets
// need to be sent (e.g. high-bandwidth video streaming over RTP/UDP), or where
// the same data needs to be sent to multiple recipients.
//
// flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same
// as the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
//
// If the socket is in blocking mode the call will block until there is space
// for all the data in the socket queue. If there is no space available
// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
// will be returned if no data was written at all, otherwise the number of
// messages sent will be returned. To be notified when space is available,
// wait for the G_IO_OUT condition. Note though that you may still receive
// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a G_IO_OUT condition. (On Windows in particular, this is very
// common due to the way the underlying APIs work.)
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - messages: array of Message structs.
//   - flags: int containing MsgFlags flags, which may
//     additionally contain other platform specific flags
//     (http://man7.org/linux/man-pages/man2/recv.2.html).
//
// The function returns the following values:
//
//   - gint: number of messages sent, or -1 on error. Note that the number
//     of messages sent may be smaller than num_messages if the socket is
//     non-blocking or if num_messages was larger than UIO_MAXIOV (1024),
//     in which case the caller may re-try to send the remaining messages.
func (socket *Socket) SendMessages(ctx context.Context, messages []OutputMessage, flags int) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg4 *C.GCancellable   // out
	var _arg1 *C.GOutputMessage // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GOutputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GOutputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GOutputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)

	_cret = C.g_socket_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// SendTo tries to send size bytes from buffer to address. If address is NULL
// then the message is sent to the default receiver (set by g_socket_connect()).
//
// See g_socket_send() for additional information.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - address (optional) or NULL.
//   - buffer: buffer containing the data to send.
//
// The function returns the following values:
//
//   - gssize: number of bytes written (which may be less than size), or -1 on
//     error.
func (socket *Socket) SendTo(ctx context.Context, address SocketAddresser, buffer string) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg4 *C.GCancellable   // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.gchar          // out
	var _arg3 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if address != nil {
		_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	}
	_arg3 = (C.gsize)(len(buffer))
	_arg2 = (*C.gchar)(C.calloc(C.size_t((len(buffer) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(buffer)), buffer)
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_socket_send_to(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SendWithBlocking: this behaves exactly the same as g_socket_send(), except
// that the choice of blocking or non-blocking behavior is determined by the
// blocking argument rather than by socket's properties.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - buffer: buffer containing the data to send.
//   - blocking: whether to do blocking or non-blocking I/O.
//
// The function returns the following values:
//
//   - gssize: number of bytes written (which may be less than size), or -1 on
//     error.
func (socket *Socket) SendWithBlocking(ctx context.Context, buffer string, blocking bool) (int, error) {
	var _arg0 *C.GSocket      // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gsize
	var _arg3 C.gboolean // out
	var _cret C.gssize   // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(buffer) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(buffer)), buffer)
	defer C.free(unsafe.Pointer(_arg1))
	if blocking {
		_arg3 = C.TRUE
	}

	_cret = C.g_socket_send_with_blocking(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SetBlocking sets the blocking mode of the socket. In blocking mode all
// operations (which dont take an explicit blocking parameter) block until
// they succeed or there is an error. In non-blocking mode all functions return
// results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
//
// All sockets are created in blocking mode. However, note that the platform
// level socket is always non-blocking, and blocking mode is a GSocket level
// feature.
//
// The function takes the following parameters:
//
//   - blocking: whether to use blocking I/O or not.
func (socket *Socket) SetBlocking(blocking bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if blocking {
		_arg1 = C.TRUE
	}

	C.g_socket_set_blocking(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(blocking)
}

// SetBroadcast sets whether socket should allow sending to broadcast addresses.
// This is FALSE by default.
//
// The function takes the following parameters:
//
//   - broadcast: whether socket should allow sending to broadcast addresses.
func (socket *Socket) SetBroadcast(broadcast bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if broadcast {
		_arg1 = C.TRUE
	}

	C.g_socket_set_broadcast(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(broadcast)
}

// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying socket.
// When this flag is set on a socket, the system will attempt to verify that the
// remote socket endpoint is still present if a sufficiently long period of time
// passes with no data being exchanged. If the system is unable to verify the
// presence of the remote endpoint, it will automatically close the connection.
//
// This option is only functional on certain kinds of sockets. (Notably,
// G_SOCKET_PROTOCOL_TCP sockets.)
//
// The exact time between pings is system- and protocol-dependent, but will
// normally be at least two hours. Most commonly, you would set this flag
// on a server socket if you want to allow clients to remain idle for long
// periods of time, but also want to ensure that connections are eventually
// garbage-collected if clients crash or become unreachable.
//
// The function takes the following parameters:
//
//   - keepalive: value for the keepalive flag.
func (socket *Socket) SetKeepalive(keepalive bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if keepalive {
		_arg1 = C.TRUE
	}

	C.g_socket_set_keepalive(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(keepalive)
}

// SetListenBacklog sets the maximum number of outstanding connections allowed
// when listening on this socket. If more clients than this are connecting to
// the socket and the application is not handling them on time then the new
// connections will be refused.
//
// Note that this must be called before g_socket_listen() and has no effect if
// called after that.
//
// The function takes the following parameters:
//
//   - backlog: maximum number of pending connections.
func (socket *Socket) SetListenBacklog(backlog int) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.gint(backlog)

	C.g_socket_set_listen_backlog(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(backlog)
}

// SetMulticastLoopback sets whether outgoing multicast packets will be received
// by sockets listening on that multicast address on the same host. This is TRUE
// by default.
//
// The function takes the following parameters:
//
//   - loopback: whether socket should receive messages sent to its multicast
//     groups from the local host.
func (socket *Socket) SetMulticastLoopback(loopback bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if loopback {
		_arg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(loopback)
}

// SetMulticastTTL sets the time-to-live for outgoing multicast datagrams on
// socket. By default, this is 1, meaning that multicast packets will not leave
// the local network.
//
// The function takes the following parameters:
//
//   - ttl: time-to-live value for all multicast datagrams on socket.
func (socket *Socket) SetMulticastTTL(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// SetOption sets the value of an integer-valued option on socket, as with
// setsockopt(). (If you need to set a non-integer-valued option, you will need
// to call setsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system headers
// that will define most of the standard/portable socket options. For unusual
// socket protocols or platform-dependent options, you may need to include
// additional headers.
//
// The function takes the following parameters:
//
//   - level: "API level" of the option (eg, SOL_SOCKET).
//   - optname: "name" of the option (eg, SO_BROADCAST).
//   - value to set the option to.
func (socket *Socket) SetOption(level, optname, value int) error {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.gint(level)
	_arg2 = C.gint(optname)
	_arg3 = C.gint(value)

	C.g_socket_set_option(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)
	runtime.KeepAlive(value)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetTimeout sets the time in seconds after which I/O operations on socket will
// time out if they have not yet completed.
//
// On a blocking socket, this means that any blocking #GSocket operation will
// time out after timeout seconds of inactivity, returning G_IO_ERROR_TIMED_OUT.
//
// On a non-blocking socket, calls to g_socket_condition_wait() will also
// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
// g_socket_create_source() will trigger after timeout seconds of inactivity,
// with the requested condition set, at which point calling g_socket_receive(),
// g_socket_send(), g_socket_check_connect_result(), etc, will fail with
// G_IO_ERROR_TIMED_OUT.
//
// If timeout is 0 (the default), operations will never time out on their own.
//
// Note that if an I/O operation is interrupted by a signal, this may cause the
// timeout to be reset.
//
// The function takes the following parameters:
//
//   - timeout for socket, in seconds, or 0 for none.
func (socket *Socket) SetTimeout(timeout uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.guint(timeout)

	C.g_socket_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(timeout)
}

// SetTTL sets the time-to-live for outgoing unicast packets on socket.
// By default the platform-specific default value is used.
//
// The function takes the following parameters:
//
//   - ttl: time-to-live value for all unicast packets on socket.
func (socket *Socket) SetTTL(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_ttl(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// Shutdown: shut down part or all of a full-duplex connection.
//
// If shutdown_read is TRUE then the receiving side of the connection is shut
// down, and further reading is disallowed.
//
// If shutdown_write is TRUE then the sending side of the connection is shut
// down, and further writing is disallowed.
//
// It is allowed for both shutdown_read and shutdown_write to be TRUE.
//
// One example where it is useful to shut down only one side of a connection
// is graceful disconnect for TCP connections where you close the sending side,
// then wait for the other side to close the connection, thus ensuring that the
// other side saw all sent data.
//
// The function takes the following parameters:
//
//   - shutdownRead: whether to shut down the read side.
//   - shutdownWrite: whether to shut down the write side.
func (socket *Socket) Shutdown(shutdownRead, shutdownWrite bool) error {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out
	var _arg2 C.gboolean // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}

	C.g_socket_shutdown(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SpeaksIPv4 checks if a socket is capable of speaking IPv4.
//
// IPv4 sockets are capable of speaking IPv4. On some operating systems and
// under some combinations of circumstances IPv6 sockets are also capable of
// speaking IPv4. See RFC 3493 section 3.7 for more information.
//
// No other types of sockets are currently considered as being capable of
// speaking IPv4.
//
// The function returns the following values:
//
//   - ok: TRUE if this socket can be used with IPv4.
func (socket *Socket) SpeaksIPv4() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_speaks_ipv4(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SocketAddressOverrides contains methods that are overridable.
type SocketAddressOverrides struct {
	// Family gets the socket family type of address.
	//
	// The function returns the following values:
	//
	//   - socketFamily: socket family type of address.
	Family func() SocketFamily
	// NativeSize gets the size of address's native struct sockaddr. You can use
	// this to allocate memory to pass to g_socket_address_to_native().
	//
	// The function returns the following values:
	//
	//   - gssize: size of the native struct sockaddr that address represents.
	NativeSize func() int
	// ToNative converts a Address to a native struct sockaddr, which can be
	// passed to low-level functions like connect() or bind().
	//
	// If not enough space is available, a G_IO_ERROR_NO_SPACE error is
	// returned. If the address type is not known on the system then a
	// G_IO_ERROR_NOT_SUPPORTED error is returned.
	//
	// The function takes the following parameters:
	//
	//   - dest (optional): pointer to a memory location that will contain the
	//     native struct sockaddr.
	//   - destlen: size of dest. Must be at least as large as
	//     g_socket_address_get_native_size().
	ToNative func(dest unsafe.Pointer, destlen uint) error
}

func defaultSocketAddressOverrides(v *SocketAddress) SocketAddressOverrides {
	return SocketAddressOverrides{
		Family:     v.family,
		NativeSize: v.nativeSize,
		ToNative:   v.toNative,
	}
}

// SocketAddress: GSocketAddress is the equivalent of struct sockaddr
// (man:sockaddr(3type)) and its subtypes in the BSD sockets API. This
// is an abstract class; use gio.InetSocketAddress for internet sockets,
// or gio.UnixSocketAddress for UNIX domain sockets.
type SocketAddress struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SocketConnectable
}

var (
	_ coreglib.Objector = (*SocketAddress)(nil)
)

// SocketAddresser describes types inherited from class SocketAddress.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type SocketAddresser interface {
	coreglib.Objector
	baseSocketAddress() *SocketAddress
}

var _ SocketAddresser = (*SocketAddress)(nil)

func init() {
	coreglib.RegisterClassInfo[*SocketAddress, *SocketAddressClass, SocketAddressOverrides](
		GTypeSocketAddress,
		initSocketAddressClass,
		wrapSocketAddress,
		defaultSocketAddressOverrides,
	)
}

func initSocketAddressClass(gclass unsafe.Pointer, overrides SocketAddressOverrides, classInitFunc func(*SocketAddressClass)) {
	pclass := (*C.GSocketAddressClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSocketAddress))))

	if overrides.Family != nil {
		pclass.get_family = (*[0]byte)(C._gotk4_gio2_SocketAddressClass_get_family)
	}

	if overrides.NativeSize != nil {
		pclass.get_native_size = (*[0]byte)(C._gotk4_gio2_SocketAddressClass_get_native_size)
	}

	if overrides.ToNative != nil {
		pclass.to_native = (*[0]byte)(C._gotk4_gio2_SocketAddressClass_to_native)
	}

	if classInitFunc != nil {
		class := (*SocketAddressClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketAddress(obj *coreglib.Object) *SocketAddress {
	return &SocketAddress{
		Object: obj,
		SocketConnectable: SocketConnectable{
			Object: obj,
		},
	}
}

func marshalSocketAddress(p uintptr) (interface{}, error) {
	return wrapSocketAddress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (address *SocketAddress) baseSocketAddress() *SocketAddress {
	return address
}

// BaseSocketAddress returns the underlying base object.
func BaseSocketAddress(obj SocketAddresser) *SocketAddress {
	return obj.baseSocketAddress()
}

// NewSocketAddressFromNative creates a Address subclass corresponding to the
// native struct sockaddr native.
//
// The function takes the following parameters:
//
//   - native: pointer to a struct sockaddr.
//   - len: size of the memory location pointed to by native.
//
// The function returns the following values:
//
//   - socketAddress: new Address if native could successfully be converted,
//     otherwise NULL.
func NewSocketAddressFromNative(native unsafe.Pointer, len uint) *SocketAddress {
	var _arg1 C.gpointer        // out
	var _arg2 C.gsize           // out
	var _cret *C.GSocketAddress // in

	_arg1 = (C.gpointer)(unsafe.Pointer(native))
	_arg2 = C.gsize(len)

	_cret = C.g_socket_address_new_from_native(_arg1, _arg2)
	runtime.KeepAlive(native)
	runtime.KeepAlive(len)

	var _socketAddress *SocketAddress // out

	_socketAddress = wrapSocketAddress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketAddress
}

// Family gets the socket family type of address.
//
// The function returns the following values:
//
//   - socketFamily: socket family type of address.
func (address *SocketAddress) Family() SocketFamily {
	var _arg0 *C.GSocketAddress // out
	var _cret C.GSocketFamily   // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_socket_address_get_family(_arg0)
	runtime.KeepAlive(address)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

// NativeSize gets the size of address's native struct sockaddr. You can use
// this to allocate memory to pass to g_socket_address_to_native().
//
// The function returns the following values:
//
//   - gssize: size of the native struct sockaddr that address represents.
func (address *SocketAddress) NativeSize() int {
	var _arg0 *C.GSocketAddress // out
	var _cret C.gssize          // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_socket_address_get_native_size(_arg0)
	runtime.KeepAlive(address)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// ToNative converts a Address to a native struct sockaddr, which can be passed
// to low-level functions like connect() or bind().
//
// If not enough space is available, a G_IO_ERROR_NO_SPACE error is returned. If
// the address type is not known on the system then a G_IO_ERROR_NOT_SUPPORTED
// error is returned.
//
// The function takes the following parameters:
//
//   - dest (optional): pointer to a memory location that will contain the
//     native struct sockaddr.
//   - destlen: size of dest. Must be at least as large as
//     g_socket_address_get_native_size().
func (address *SocketAddress) ToNative(dest unsafe.Pointer, destlen uint) error {
	var _arg0 *C.GSocketAddress // out
	var _arg1 C.gpointer        // out
	var _arg2 C.gsize           // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(dest))
	_arg2 = C.gsize(destlen)

	C.g_socket_address_to_native(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(address)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destlen)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Family gets the socket family type of address.
//
// The function returns the following values:
//
//   - socketFamily: socket family type of address.
func (address *SocketAddress) family() SocketFamily {
	gclass := (*C.GSocketAddressClass)(coreglib.PeekParentClass(address))
	fnarg := gclass.get_family

	var _arg0 *C.GSocketAddress // out
	var _cret C.GSocketFamily   // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C._gotk4_gio2_SocketAddress_virtual_get_family(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(address)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

// nativeSize gets the size of address's native struct sockaddr. You can use
// this to allocate memory to pass to g_socket_address_to_native().
//
// The function returns the following values:
//
//   - gssize: size of the native struct sockaddr that address represents.
func (address *SocketAddress) nativeSize() int {
	gclass := (*C.GSocketAddressClass)(coreglib.PeekParentClass(address))
	fnarg := gclass.get_native_size

	var _arg0 *C.GSocketAddress // out
	var _cret C.gssize          // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C._gotk4_gio2_SocketAddress_virtual_get_native_size(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(address)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// toNative converts a Address to a native struct sockaddr, which can be passed
// to low-level functions like connect() or bind().
//
// If not enough space is available, a G_IO_ERROR_NO_SPACE error is returned. If
// the address type is not known on the system then a G_IO_ERROR_NOT_SUPPORTED
// error is returned.
//
// The function takes the following parameters:
//
//   - dest (optional): pointer to a memory location that will contain the
//     native struct sockaddr.
//   - destlen: size of dest. Must be at least as large as
//     g_socket_address_get_native_size().
func (address *SocketAddress) toNative(dest unsafe.Pointer, destlen uint) error {
	gclass := (*C.GSocketAddressClass)(coreglib.PeekParentClass(address))
	fnarg := gclass.to_native

	var _arg0 *C.GSocketAddress // out
	var _arg1 C.gpointer        // out
	var _arg2 C.gsize           // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(dest))
	_arg2 = C.gsize(destlen)

	C._gotk4_gio2_SocketAddress_virtual_to_native(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(address)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destlen)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SocketAddressEnumeratorOverrides contains methods that are overridable.
type SocketAddressEnumeratorOverrides struct {
	// Next retrieves the next Address from enumerator. Note that
	// this may block for some amount of time. (Eg, a Address may
	// need to do a DNS lookup before it can return an address.) Use
	// g_socket_address_enumerator_next_async() if you need to avoid blocking.
	//
	// If enumerator is expected to yield addresses, but for some reason
	// is unable to (eg, because of a DNS error), then the first call to
	// g_socket_address_enumerator_next() will return an appropriate error in
	// *error. However, if the first call to g_socket_address_enumerator_next()
	// succeeds, then any further internal errors (other than cancellable being
	// triggered) will be ignored.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable object, NULL to ignore.
	//
	// The function returns the following values:
	//
	//   - socketAddress (optional) (owned by the caller), or NULL on error (in
	//     which case *error will be set) or if there are no more addresses.
	Next func(ctx context.Context) (SocketAddresser, error)
	// NextFinish retrieves the result of a completed call
	// to g_socket_address_enumerator_next_async(). See
	// g_socket_address_enumerator_next() for more information about error
	// handling.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - socketAddress (optional) (owned by the caller), or NULL on error (in
	//     which case *error will be set) or if there are no more addresses.
	NextFinish func(result AsyncResulter) (SocketAddresser, error)
}

func defaultSocketAddressEnumeratorOverrides(v *SocketAddressEnumerator) SocketAddressEnumeratorOverrides {
	return SocketAddressEnumeratorOverrides{
		Next:       v.next,
		NextFinish: v.nextFinish,
	}
}

// SocketAddressEnumerator: GSocketAddressEnumerator is an enumerator type for
// gio.SocketAddress instances. It is returned by enumeration functions such as
// gio.SocketConnectable.Enumerate(), which returns a GSocketAddressEnumerator
// to list each gio.SocketAddress which could be used to connect to that
// gio.SocketConnectable.
//
// Enumeration is typically a blocking operation, so the
// asynchronous methods gio.SocketAddressEnumerator.NextAsync() and
// gio.SocketAddressEnumerator.NextFinish() should be used where possible.
//
// Each GSocketAddressEnumerator can only be enumerated once. Once
// gio.SocketAddressEnumerator.Next() has returned NULL, further enumeration
// with that GSocketAddressEnumerator is not possible, and it can be unreffed.
type SocketAddressEnumerator struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketAddressEnumerator)(nil)
)

// SocketAddressEnumeratorrer describes types inherited from class SocketAddressEnumerator.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type SocketAddressEnumeratorrer interface {
	coreglib.Objector
	baseSocketAddressEnumerator() *SocketAddressEnumerator
}

var _ SocketAddressEnumeratorrer = (*SocketAddressEnumerator)(nil)

func init() {
	coreglib.RegisterClassInfo[*SocketAddressEnumerator, *SocketAddressEnumeratorClass, SocketAddressEnumeratorOverrides](
		GTypeSocketAddressEnumerator,
		initSocketAddressEnumeratorClass,
		wrapSocketAddressEnumerator,
		defaultSocketAddressEnumeratorOverrides,
	)
}

func initSocketAddressEnumeratorClass(gclass unsafe.Pointer, overrides SocketAddressEnumeratorOverrides, classInitFunc func(*SocketAddressEnumeratorClass)) {
	pclass := (*C.GSocketAddressEnumeratorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSocketAddressEnumerator))))

	if overrides.Next != nil {
		pclass.next = (*[0]byte)(C._gotk4_gio2_SocketAddressEnumeratorClass_next)
	}

	if overrides.NextFinish != nil {
		pclass.next_finish = (*[0]byte)(C._gotk4_gio2_SocketAddressEnumeratorClass_next_finish)
	}

	if classInitFunc != nil {
		class := (*SocketAddressEnumeratorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketAddressEnumerator(obj *coreglib.Object) *SocketAddressEnumerator {
	return &SocketAddressEnumerator{
		Object: obj,
	}
}

func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
	return wrapSocketAddressEnumerator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (enumerator *SocketAddressEnumerator) baseSocketAddressEnumerator() *SocketAddressEnumerator {
	return enumerator
}

// BaseSocketAddressEnumerator returns the underlying base object.
func BaseSocketAddressEnumerator(obj SocketAddressEnumeratorrer) *SocketAddressEnumerator {
	return obj.baseSocketAddressEnumerator()
}

// Next retrieves the next Address from enumerator. Note that this may block for
// some amount of time. (Eg, a Address may need to do a DNS lookup before it can
// return an address.) Use g_socket_address_enumerator_next_async() if you need
// to avoid blocking.
//
// If enumerator is expected to yield addresses, but for some reason
// is unable to (eg, because of a DNS error), then the first call to
// g_socket_address_enumerator_next() will return an appropriate error in
// *error. However, if the first call to g_socket_address_enumerator_next()
// succeeds, then any further internal errors (other than cancellable being
// triggered) will be ignored.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - socketAddress (optional) (owned by the caller), or NULL on error (in
//     which case *error will be set) or if there are no more addresses.
func (enumerator *SocketAddressEnumerator) Next(ctx context.Context) (SocketAddresser, error) {
	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GCancellable             // out
	var _cret *C.GSocketAddress           // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_socket_address_enumerator_next(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// NextAsync: asynchronously retrieves the next Address from enumerator and then
// calls callback, which must call g_socket_address_enumerator_next_finish() to
// get the result.
//
// It is an error to call this multiple times before the previous callback has
// finished.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - callback (optional) to call when the request is satisfied.
func (enumerator *SocketAddressEnumerator) NextAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GCancellable             // out
	var _arg2 C.GAsyncReadyCallback       // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_address_enumerator_next_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// NextFinish retrieves the result of a completed call
// to g_socket_address_enumerator_next_async(). See
// g_socket_address_enumerator_next() for more information about error handling.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - socketAddress (optional) (owned by the caller), or NULL on error (in
//     which case *error will be set) or if there are no more addresses.
func (enumerator *SocketAddressEnumerator) NextFinish(result AsyncResulter) (SocketAddresser, error) {
	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GAsyncResult             // out
	var _cret *C.GSocketAddress           // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_address_enumerator_next_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// Next retrieves the next Address from enumerator. Note that this may block for
// some amount of time. (Eg, a Address may need to do a DNS lookup before it can
// return an address.) Use g_socket_address_enumerator_next_async() if you need
// to avoid blocking.
//
// If enumerator is expected to yield addresses, but for some reason
// is unable to (eg, because of a DNS error), then the first call to
// g_socket_address_enumerator_next() will return an appropriate error in
// *error. However, if the first call to g_socket_address_enumerator_next()
// succeeds, then any further internal errors (other than cancellable being
// triggered) will be ignored.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - socketAddress (optional) (owned by the caller), or NULL on error (in
//     which case *error will be set) or if there are no more addresses.
func (enumerator *SocketAddressEnumerator) next(ctx context.Context) (SocketAddresser, error) {
	gclass := (*C.GSocketAddressEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.next

	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GCancellable             // out
	var _cret *C.GSocketAddress           // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_SocketAddressEnumerator_virtual_next(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// nextAsync: asynchronously retrieves the next Address from enumerator and then
// calls callback, which must call g_socket_address_enumerator_next_finish() to
// get the result.
//
// It is an error to call this multiple times before the previous callback has
// finished.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - callback (optional) to call when the request is satisfied.
func (enumerator *SocketAddressEnumerator) nextAsync(ctx context.Context, callback AsyncReadyCallback) {
	gclass := (*C.GSocketAddressEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.next_async

	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GCancellable             // out
	var _arg2 C.GAsyncReadyCallback       // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_SocketAddressEnumerator_virtual_next_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// nextFinish retrieves the result of a completed call
// to g_socket_address_enumerator_next_async(). See
// g_socket_address_enumerator_next() for more information about error handling.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - socketAddress (optional) (owned by the caller), or NULL on error (in
//     which case *error will be set) or if there are no more addresses.
func (enumerator *SocketAddressEnumerator) nextFinish(result AsyncResulter) (SocketAddresser, error) {
	gclass := (*C.GSocketAddressEnumeratorClass)(coreglib.PeekParentClass(enumerator))
	fnarg := gclass.next_finish

	var _arg0 *C.GSocketAddressEnumerator // out
	var _arg1 *C.GAsyncResult             // out
	var _cret *C.GSocketAddress           // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.GSocketAddressEnumerator)(unsafe.Pointer(coreglib.InternObject(enumerator).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_SocketAddressEnumerator_virtual_next_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// SocketClientOverrides contains methods that are overridable.
type SocketClientOverrides struct {
	// The function takes the following parameters:
	//
	//   - event
	//   - connectable
	//   - connection
	Event func(event SocketClientEvent, connectable SocketConnectabler, connection IOStreamer)
}

func defaultSocketClientOverrides(v *SocketClient) SocketClientOverrides {
	return SocketClientOverrides{
		Event: v.event,
	}
}

// SocketClient: GSocketClient is a lightweight high-level utility class for
// connecting to a network host using a connection oriented socket type.
//
// You create a GSocketClient object, set any options you want, and then call
// a sync or async connect operation, which returns a gio.SocketConnection
// subclass on success.
//
// The type of the gio.SocketConnection object returned depends on the type of
// the underlying socket that is in use. For instance, for a TCP/IP connection
// it will be a gio.TCPConnection.
//
// As GSocketClient is a lightweight object, you don't need to cache it. You can
// just create a new one any time you need one.
type SocketClient struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketClient)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SocketClient, *SocketClientClass, SocketClientOverrides](
		GTypeSocketClient,
		initSocketClientClass,
		wrapSocketClient,
		defaultSocketClientOverrides,
	)
}

func initSocketClientClass(gclass unsafe.Pointer, overrides SocketClientOverrides, classInitFunc func(*SocketClientClass)) {
	pclass := (*C.GSocketClientClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSocketClient))))

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._gotk4_gio2_SocketClientClass_event)
	}

	if classInitFunc != nil {
		class := (*SocketClientClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketClient(obj *coreglib.Object) *SocketClient {
	return &SocketClient{
		Object: obj,
	}
}

func marshalSocketClient(p uintptr) (interface{}, error) {
	return wrapSocketClient(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEvent is emitted when client's activity on connectable changes state.
// Among other things, this can be used to provide progress information about a
// network connection in the UI. The meanings of the different event values are
// as follows:
//
// - G_SOCKET_CLIENT_RESOLVING: client is about to look up connectable in DNS.
// connection will be NULL.
//
// - G_SOCKET_CLIENT_RESOLVED: client has successfully resolved connectable in
// DNS. connection will be NULL.
//
// - G_SOCKET_CLIENT_CONNECTING: client is about to make a connection
// to a remote host; either a proxy server or the destination server
// itself. connection is the Connection, which is not yet connected.
// Since GLib 2.40, you can access the remote address via
// g_socket_connection_get_remote_address().
//
// - G_SOCKET_CLIENT_CONNECTED: client has successfully connected to a remote
// host. connection is the connected Connection.
//
// - G_SOCKET_CLIENT_PROXY_NEGOTIATING: client is about to negotiate with a
// proxy to get it to connect to connectable. connection is the Connection to
// the proxy server.
//
// - G_SOCKET_CLIENT_PROXY_NEGOTIATED: client has negotiated a connection to
// connectable through a proxy server. connection is the stream returned from
// g_proxy_connect(), which may or may not be a Connection.
//
// - G_SOCKET_CLIENT_TLS_HANDSHAKING: client is about to begin a TLS handshake.
// connection is a ClientConnection.
//
// - G_SOCKET_CLIENT_TLS_HANDSHAKED: client has successfully completed the TLS
// handshake. connection is a ClientConnection.
//
// - G_SOCKET_CLIENT_COMPLETE: client has either successfully connected to
// connectable (in which case connection is the Connection that it will be
// returning to the caller) or has failed (in which case connection is NULL and
// the client is about to return an error).
//
// Each event except G_SOCKET_CLIENT_COMPLETE may be emitted multiple times
// (or not at all) for a given connectable (in particular, if client ends up
// attempting to connect to more than one address). However, if client emits the
// Client::event signal at all for a given connectable, then it will always emit
// it with G_SOCKET_CLIENT_COMPLETE when it is done.
//
// Note that there may be additional ClientEvent values in the future;
// unrecognized event values should be ignored.
func (client *SocketClient) ConnectEvent(f func(event SocketClientEvent, connectable SocketConnectabler, connection IOStreamer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(client, "event", false, unsafe.Pointer(C._gotk4_gio2_SocketClient_ConnectEvent), f)
}

// NewSocketClient creates a new Client with the default options.
//
// The function returns the following values:
//
//   - socketClient: Client. Free the returned object with g_object_unref().
func NewSocketClient() *SocketClient {
	var _cret *C.GSocketClient // in

	_cret = C.g_socket_client_new()

	var _socketClient *SocketClient // out

	_socketClient = wrapSocketClient(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketClient
}

// AddApplicationProxy: enable proxy protocols to be handled by the application.
// When the indicated proxy protocol is returned by the Resolver, Client will
// consider this protocol as supported but will not try to find a #GProxy
// instance to handle handshaking. The application must check for this case by
// calling g_socket_connection_get_remote_address() on the returned Connection,
// and seeing if it's a Address of the appropriate type, to determine whether or
// not it needs to handle the proxy handshaking itself.
//
// This should be used for proxy protocols that are dialects of another protocol
// such as HTTP proxy. It also allows cohabitation of proxy protocols that are
// reused between protocols. A good example is HTTP. It can be used to proxy
// HTTP, FTP and Gopher and can also be use as generic socket proxy through the
// HTTP CONNECT method.
//
// When the proxy is detected as being an application proxy, TLS handshake will
// be skipped. This is required to let the application do the proxy specific
// handshake.
//
// The function takes the following parameters:
//
//   - protocol: proxy protocol.
func (client *SocketClient) AddApplicationProxy(protocol string) {
	var _arg0 *C.GSocketClient // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_socket_client_add_application_proxy(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(protocol)
}

// ConnectSocketClient tries to resolve the connectable and make a network
// connection to it.
//
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
//
// The type of the Connection object returned depends on the type of the
// underlying socket that is used. For instance, for a TCP/IP connection it will
// be a Connection.
//
// The socket created will be the same family as the address
// that the connectable resolves to, unless family is set
// with g_socket_client_set_family() or indirectly via
// g_socket_client_set_local_address(). The socket type defaults to
// G_SOCKET_TYPE_STREAM but can be set with g_socket_client_set_socket_type().
//
// If a local address is specified with g_socket_client_set_local_address() the
// socket will be bound to this address before connecting.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - connectable specifying the remote address.
//
// The function returns the following values:
//
//   - socketConnection on success, NULL on error.
func (client *SocketClient) ConnectSocketClient(ctx context.Context, connectable SocketConnectabler) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GSocketConnectable // out
	var _cret *C.GSocketConnection  // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))

	_cret = C.g_socket_client_connect(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connectable)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectAsync: this is the asynchronous version of g_socket_client_connect().
//
// You may wish to prefer the asynchronous version even in synchronous
// command line programs because, since 2.60, it implements RFC 8305
// (https://tools.ietf.org/html/rfc8305) "Happy Eyeballs" recommendations to
// work around long connection timeouts in networks where IPv6 is broken by
// performing an IPv4 connection simultaneously without waiting for IPv6 to
// time out, which is not supported by the synchronous call. (This is not an API
// guarantee, and may change in the future.)
//
// When the operation is finished callback will be called. You can then call
// g_socket_client_connect_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - connectable specifying the remote address.
//   - callback (optional): ReadyCallback.
func (client *SocketClient) ConnectAsync(ctx context.Context, connectable SocketConnectabler, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketClient      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GSocketConnectable // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_client_connect_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(callback)
}

// ConnectFinish finishes an async connect operation. See
// g_socket_client_connect_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - socketConnection on success, NULL on error.
func (client *SocketClient) ConnectFinish(result AsyncResulter) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_client_connect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectToHost: this is a helper function for g_socket_client_connect().
//
// Attempts to create a TCP connection to the named host.
//
// host_and_port may be in any of a number of recognized formats; an IPv6
// address, an IPv4 address, or a domain name (in which case a DNS lookup
// is performed). Quoting with [] is supported for all address types. A port
// override may be specified in the usual way with a colon. Ports may be given
// as decimal numbers or symbolic names (in which case an /etc/services lookup
// is performed).
//
// If no port override is given in host_and_port then default_port will be used
// as the port number to connect to.
//
// In general, host_and_port is expected to be provided by the user (allowing
// them to give the hostname, and a port override if necessary) and default_port
// is expected to be provided by the application.
//
// In the case that an IP address is given, a single connection attempt is made.
// In the case that a name is given, multiple connection attempts may be made,
// in turn and according to the number of address records in DNS, until a
// connection succeeds.
//
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
//
// In the event of any failure (DNS error, service not found, no hosts
// connectable) NULL is returned and error (if non-NULL) is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostAndPort: name and optionally port of the host to connect to.
//   - defaultPort: default port to connect to.
//
// The function returns the following values:
//
//   - socketConnection on success, NULL on error.
func (client *SocketClient) ConnectToHost(ctx context.Context, hostAndPort string, defaultPort uint16) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg3 *C.GCancellable      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.guint16            // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)

	_cret = C.g_socket_client_connect_to_host(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectToHostAsync: this is the asynchronous version of
// g_socket_client_connect_to_host().
//
// When the operation is finished callback will be called. You can then call
// g_socket_client_connect_to_host_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - hostAndPort: name and optionally the port of the host to connect to.
//   - defaultPort: default port to connect to.
//   - callback (optional): ReadyCallback.
func (client *SocketClient) ConnectToHostAsync(ctx context.Context, hostAndPort string, defaultPort uint16, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketClient      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.guint16             // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_client_connect_to_host_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(callback)
}

// ConnectToHostFinish finishes an async connect operation. See
// g_socket_client_connect_to_host_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - socketConnection on success, NULL on error.
func (client *SocketClient) ConnectToHostFinish(result AsyncResulter) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_client_connect_to_host_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectToService attempts to create a TCP connection to a service.
//
// This call looks up the SRV record for service at domain for the "tcp"
// protocol. It then attempts to connect, in turn, to each of the hosts
// providing the service until either a connection succeeds or there are no
// hosts remaining.
//
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
//
// In the event of any failure (DNS error, service not found, no hosts
// connectable) NULL is returned and error (if non-NULL) is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - domain name.
//   - service: name of the service to connect to.
//
// The function returns the following values:
//
//   - socketConnection if successful, or NULL on error.
func (client *SocketClient) ConnectToService(ctx context.Context, domain, service string) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg3 *C.GCancellable      // out
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_socket_client_connect_to_service(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(service)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectToServiceAsync: this is the asynchronous version of
// g_socket_client_connect_to_service().
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - domain name.
//   - service: name of the service to connect to.
//   - callback (optional): ReadyCallback.
func (client *SocketClient) ConnectToServiceAsync(ctx context.Context, domain, service string, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketClient      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg2))
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_client_connect_to_service_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(service)
	runtime.KeepAlive(callback)
}

// ConnectToServiceFinish finishes an async connect operation. See
// g_socket_client_connect_to_service_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - socketConnection on success, NULL on error.
func (client *SocketClient) ConnectToServiceFinish(result AsyncResulter) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_client_connect_to_service_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectToURI: this is a helper function for g_socket_client_connect().
//
// Attempts to create a TCP connection with a network URI.
//
// uri may be any valid URI containing an "authority" (hostname/port) component.
// If a port is not specified in the URI, default_port will be used. TLS will
// be negotiated if Client:tls is TRUE. (Client does not know to automatically
// assume TLS for certain URI schemes.)
//
// Using this rather than g_socket_client_connect() or
// g_socket_client_connect_to_host() allows Client to determine when to use
// application-specific proxy protocols.
//
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
//
// In the event of any failure (DNS error, service not found, no hosts
// connectable) NULL is returned and error (if non-NULL) is set accordingly.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - uri: network URI.
//   - defaultPort: default port to connect to.
//
// The function returns the following values:
//
//   - socketConnection on success, NULL on error.
func (client *SocketClient) ConnectToURI(ctx context.Context, uri string, defaultPort uint16) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg3 *C.GCancellable      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.guint16            // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)

	_cret = C.g_socket_client_connect_to_uri(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectToURIAsync: this is the asynchronous version of
// g_socket_client_connect_to_uri().
//
// When the operation is finished callback will be called. You can then call
// g_socket_client_connect_to_uri_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - uri: network uri.
//   - defaultPort: default port to connect to.
//   - callback (optional): ReadyCallback.
func (client *SocketClient) ConnectToURIAsync(ctx context.Context, uri string, defaultPort uint16, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketClient      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.guint16             // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_client_connect_to_uri_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(callback)
}

// ConnectToURIFinish finishes an async connect operation. See
// g_socket_client_connect_to_uri_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - socketConnection on success, NULL on error.
func (client *SocketClient) ConnectToURIFinish(result AsyncResulter) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_client_connect_to_uri_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// EnableProxy gets the proxy enable state; see
// g_socket_client_set_enable_proxy().
//
// The function returns the following values:
//
//   - ok: whether proxying is enabled.
func (client *SocketClient) EnableProxy() bool {
	var _arg0 *C.GSocketClient // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_enable_proxy(_arg0)
	runtime.KeepAlive(client)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Family gets the socket family of the socket client.
//
// See g_socket_client_set_family() for details.
//
// The function returns the following values:
//
//   - socketFamily: Family.
func (client *SocketClient) Family() SocketFamily {
	var _arg0 *C.GSocketClient // out
	var _cret C.GSocketFamily  // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_family(_arg0)
	runtime.KeepAlive(client)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

// LocalAddress gets the local address of the socket client.
//
// See g_socket_client_set_local_address() for details.
//
// The function returns the following values:
//
//   - socketAddress (optional) or NULL. Do not free.
func (client *SocketClient) LocalAddress() SocketAddresser {
	var _arg0 *C.GSocketClient  // out
	var _cret *C.GSocketAddress // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_local_address(_arg0)
	runtime.KeepAlive(client)

	var _socketAddress SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// Protocol gets the protocol name type of the socket client.
//
// See g_socket_client_set_protocol() for details.
//
// The function returns the following values:
//
//   - socketProtocol: Protocol.
func (client *SocketClient) Protocol() SocketProtocol {
	var _arg0 *C.GSocketClient  // out
	var _cret C.GSocketProtocol // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_protocol(_arg0)
	runtime.KeepAlive(client)

	var _socketProtocol SocketProtocol // out

	_socketProtocol = SocketProtocol(_cret)

	return _socketProtocol
}

// ProxyResolver gets the Resolver being used by client. Normally, this will be
// the resolver returned by g_proxy_resolver_get_default(), but you can override
// it with g_socket_client_set_proxy_resolver().
//
// The function returns the following values:
//
//   - proxyResolver being used by client.
func (client *SocketClient) ProxyResolver() *ProxyResolver {
	var _arg0 *C.GSocketClient  // out
	var _cret *C.GProxyResolver // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_proxy_resolver(_arg0)
	runtime.KeepAlive(client)

	var _proxyResolver *ProxyResolver // out

	_proxyResolver = wrapProxyResolver(coreglib.Take(unsafe.Pointer(_cret)))

	return _proxyResolver
}

// SocketType gets the socket type of the socket client.
//
// See g_socket_client_set_socket_type() for details.
//
// The function returns the following values:
//
//   - socketType: Family.
func (client *SocketClient) SocketType() SocketType {
	var _arg0 *C.GSocketClient // out
	var _cret C.GSocketType    // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_socket_type(_arg0)
	runtime.KeepAlive(client)

	var _socketType SocketType // out

	_socketType = SocketType(_cret)

	return _socketType
}

// Timeout gets the I/O timeout time for sockets created by client.
//
// See g_socket_client_set_timeout() for details.
//
// The function returns the following values:
//
//   - guint: timeout in seconds.
func (client *SocketClient) Timeout() uint {
	var _arg0 *C.GSocketClient // out
	var _cret C.guint          // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_timeout(_arg0)
	runtime.KeepAlive(client)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TLS gets whether client creates TLS connections. See
// g_socket_client_set_tls() for details.
//
// The function returns the following values:
//
//   - ok: whether client uses TLS.
func (client *SocketClient) TLS() bool {
	var _arg0 *C.GSocketClient // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_tls(_arg0)
	runtime.KeepAlive(client)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TLSValidationFlags gets the TLS validation flags used creating TLS
// connections via client.
//
// This function does not work as originally designed and is impossible to use
// correctly. See Client:tls-validation-flags for more information.
//
// Deprecated: Do not attempt to ignore validation errors.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: TLS validation flags.
func (client *SocketClient) TLSValidationFlags() TLSCertificateFlags {
	var _arg0 *C.GSocketClient       // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_tls_validation_flags(_arg0)
	runtime.KeepAlive(client)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// SetEnableProxy sets whether or not client attempts to make connections via
// a proxy server. When enabled (the default), Client will use a Resolver to
// determine if a proxy protocol such as SOCKS is needed, and automatically do
// the necessary proxy negotiation.
//
// See also g_socket_client_set_proxy_resolver().
//
// The function takes the following parameters:
//
//   - enable: whether to enable proxies.
func (client *SocketClient) SetEnableProxy(enable bool) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.g_socket_client_set_enable_proxy(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(enable)
}

// SetFamily sets the socket family of the socket client. If this is set to
// something other than G_SOCKET_FAMILY_INVALID then the sockets created by this
// object will be of the specified family.
//
// This might be useful for instance if you want to force the local connection
// to be an ipv4 socket, even though the address might be an ipv6 mapped to ipv4
// address.
//
// The function takes the following parameters:
//
//   - family: Family.
func (client *SocketClient) SetFamily(family SocketFamily) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.GSocketFamily  // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.GSocketFamily(family)

	C.g_socket_client_set_family(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(family)
}

// SetLocalAddress sets the local address of the socket client. The sockets
// created by this object will bound to the specified address (if not NULL)
// before connecting.
//
// This is useful if you want to ensure that the local side of the connection is
// on a specific port, or on a specific interface.
//
// The function takes the following parameters:
//
//   - address (optional) or NULL.
func (client *SocketClient) SetLocalAddress(address SocketAddresser) {
	var _arg0 *C.GSocketClient  // out
	var _arg1 *C.GSocketAddress // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	if address != nil {
		_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	}

	C.g_socket_client_set_local_address(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(address)
}

// SetProtocol sets the protocol of the socket client. The sockets created by
// this object will use of the specified protocol.
//
// If protocol is G_SOCKET_PROTOCOL_DEFAULT that means to use the default
// protocol for the socket family and type.
//
// The function takes the following parameters:
//
//   - protocol: Protocol.
func (client *SocketClient) SetProtocol(protocol SocketProtocol) {
	var _arg0 *C.GSocketClient  // out
	var _arg1 C.GSocketProtocol // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.GSocketProtocol(protocol)

	C.g_socket_client_set_protocol(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(protocol)
}

// SetProxyResolver overrides the Resolver used by client. You can call this if
// you want to use specific proxies, rather than using the system default proxy
// settings.
//
// Note that whether or not the proxy resolver is actually used depends on the
// setting of Client:enable-proxy, which is not changed by this function (but
// which is TRUE by default).
//
// The function takes the following parameters:
//
//   - proxyResolver (optional) or NULL for the default.
func (client *SocketClient) SetProxyResolver(proxyResolver ProxyResolverer) {
	var _arg0 *C.GSocketClient  // out
	var _arg1 *C.GProxyResolver // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	if proxyResolver != nil {
		_arg1 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(proxyResolver).Native()))
	}

	C.g_socket_client_set_proxy_resolver(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(proxyResolver)
}

// SetSocketType sets the socket type of the socket client. The sockets created
// by this object will be of the specified type.
//
// It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM,
// as GSocketClient is used for connection oriented services.
//
// The function takes the following parameters:
//
//   - typ: Type.
func (client *SocketClient) SetSocketType(typ SocketType) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.GSocketType    // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.GSocketType(typ)

	C.g_socket_client_set_socket_type(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(typ)
}

// SetTimeout sets the I/O timeout for sockets created by client. timeout is a
// time in seconds, or 0 for no timeout (the default).
//
// The timeout value affects the initial connection attempt as well, so setting
// this may cause calls to g_socket_client_connect(), etc, to fail with
// G_IO_ERROR_TIMED_OUT.
//
// The function takes the following parameters:
//
//   - timeout: timeout.
func (client *SocketClient) SetTimeout(timeout uint) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.guint(timeout)

	C.g_socket_client_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(timeout)
}

// SetTLS sets whether client creates TLS (aka SSL) connections. If tls is TRUE,
// client will wrap its connections in a ClientConnection and perform a TLS
// handshake when connecting.
//
// Note that since Client must return a Connection, but ClientConnection
// is not a Connection, this actually wraps the resulting
// ClientConnection in a WrapperConnection when returning it. You can use
// g_tcp_wrapper_connection_get_base_io_stream() on the return value to extract
// the ClientConnection.
//
// If you need to modify the behavior of the TLS handshake (eg,
// by setting a client-side certificate to use, or connecting to
// the Connection::accept-certificate signal), you can connect to
// client's Client::event signal and wait for it to be emitted with
// G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you a chance to see the
// ClientConnection before the handshake starts.
//
// The function takes the following parameters:
//
//   - tls: whether to use TLS.
func (client *SocketClient) SetTLS(tls bool) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	if tls {
		_arg1 = C.TRUE
	}

	C.g_socket_client_set_tls(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(tls)
}

// SetTLSValidationFlags sets the TLS validation flags used when creating TLS
// connections via client. The default value is G_TLS_CERTIFICATE_VALIDATE_ALL.
//
// This function does not work as originally designed and is impossible to use
// correctly. See Client:tls-validation-flags for more information.
//
// Deprecated: Do not attempt to ignore validation errors.
//
// The function takes the following parameters:
//
//   - flags: validation flags.
func (client *SocketClient) SetTLSValidationFlags(flags TLSCertificateFlags) {
	var _arg0 *C.GSocketClient       // out
	var _arg1 C.GTlsCertificateFlags // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.GTlsCertificateFlags(flags)

	C.g_socket_client_set_tls_validation_flags(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(flags)
}

// The function takes the following parameters:
//
//   - event
//   - connectable
//   - connection
func (client *SocketClient) event(event SocketClientEvent, connectable SocketConnectabler, connection IOStreamer) {
	gclass := (*C.GSocketClientClass)(coreglib.PeekParentClass(client))
	fnarg := gclass.event

	var _arg0 *C.GSocketClient      // out
	var _arg1 C.GSocketClientEvent  // out
	var _arg2 *C.GSocketConnectable // out
	var _arg3 *C.GIOStream          // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.GSocketClientEvent(event)
	_arg2 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(connectable).Native()))
	_arg3 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	C._gotk4_gio2_SocketClient_virtual_event(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(client)
	runtime.KeepAlive(event)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(connection)
}

// SocketConnectionOverrides contains methods that are overridable.
type SocketConnectionOverrides struct {
}

func defaultSocketConnectionOverrides(v *SocketConnection) SocketConnectionOverrides {
	return SocketConnectionOverrides{}
}

// SocketConnection: GSocketConnection is a gio.IOStream for a connected socket.
// They can be created either by gio.SocketClient when connecting to a host,
// or by gio.SocketListener when accepting a new client.
//
// The type of the GSocketConnection object returned from these calls depends on
// the type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a gio.TCPConnection.
//
// Choosing what type of object to construct is done with the socket connection
// factory, and it is possible for third parties to register custom socket
// connection types for specific combination of socket family/type/protocol
// using gio.SocketConnection().FactoryRegisterType.
//
// To close a GSocketConnection, use gio.IOStream.Close(). Closing both
// substreams of the gio.IOStream separately will not close the underlying
// gio.Socket.
type SocketConnection struct {
	_ [0]func() // equal guard
	IOStream
}

var (
	_ IOStreamer = (*SocketConnection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SocketConnection, *SocketConnectionClass, SocketConnectionOverrides](
		GTypeSocketConnection,
		initSocketConnectionClass,
		wrapSocketConnection,
		defaultSocketConnectionOverrides,
	)
}

func initSocketConnectionClass(gclass unsafe.Pointer, overrides SocketConnectionOverrides, classInitFunc func(*SocketConnectionClass)) {
	if classInitFunc != nil {
		class := (*SocketConnectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketConnection(obj *coreglib.Object) *SocketConnection {
	return &SocketConnection{
		IOStream: IOStream{
			Object: obj,
		},
	}
}

func marshalSocketConnection(p uintptr) (interface{}, error) {
	return wrapSocketConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectSocketConnection: connect connection to the specified remote address.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - address specifying the remote address.
func (connection *SocketConnection) ConnectSocketConnection(ctx context.Context, address SocketAddresser) error {
	var _arg0 *C.GSocketConnection // out
	var _arg2 *C.GCancellable      // out
	var _arg1 *C.GSocketAddress    // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	C.g_socket_connection_connect(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ConnectAsync: asynchronously connect connection to the specified remote
// address.
//
// This clears the #GSocket:blocking flag on connection's underlying socket if
// it is currently set.
//
// If #GSocket:timeout is set, the operation will time out and return
// G_IO_ERROR_TIMED_OUT after that period. Otherwise, it will continue
// indefinitely until operating system timeouts (if any) are hit.
//
// Use g_socket_connection_connect_finish() to retrieve the result.
//
// The function takes the following parameters:
//
//   - ctx (optional): GCancellable or NULL.
//   - address specifying the remote address.
//   - callback (optional): ReadyCallback.
func (connection *SocketConnection) ConnectAsync(ctx context.Context, address SocketAddresser, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketConnection  // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GSocketAddress     // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_connection_connect_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// ConnectFinish gets the result of a g_socket_connection_connect_async() call.
//
// The function takes the following parameters:
//
//   - result: Result.
func (connection *SocketConnection) ConnectFinish(result AsyncResulter) error {
	var _arg0 *C.GSocketConnection // out
	var _arg1 *C.GAsyncResult      // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_socket_connection_connect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LocalAddress: try to get the local address of a socket connection.
//
// The function returns the following values:
//
//   - socketAddress or NULL on error. Free the returned object with
//     g_object_unref().
func (connection *SocketConnection) LocalAddress() (SocketAddresser, error) {
	var _arg0 *C.GSocketConnection // out
	var _cret *C.GSocketAddress    // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_socket_connection_get_local_address(_arg0, &_cerr)
	runtime.KeepAlive(connection)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddresser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddresser)
			return ok
		})
		rv, ok := casted.(SocketAddresser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
		}
		_socketAddress = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// RemoteAddress: try to get the remote address of a socket connection.
//
// Since GLib 2.40, when used with g_socket_client_connect()
// or g_socket_client_connect_async(), during emission of
// G_SOCKET_CLIENT_CONNECTING, this function will return the remote address
// that will be used for the connection. This allows applications to print e.g.
// "Connecting to example.com (10.42.77.3)...".
//
// The function returns the following values:
//
//   - socketAddress or NULL on error. Free the returned object with
//     g_object_unref().
func (connection *SocketConnection) RemoteAddress() (SocketAddresser, error) {
	var _arg0 *C.GSocketConnection // out
	var _cret *C.GSocketAddress    // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_socket_connection_get_remote_address(_arg0, &_cerr)
	runtime.KeepAlive(connection)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.SocketAddresser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddresser)
			return ok
		})
		rv, ok := casted.(SocketAddresser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
		}
		_socketAddress = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketAddress, _goerr
}

// Socket gets the underlying #GSocket object of the connection. This can
// be useful if you want to do something unusual on it not supported by the
// Connection APIs.
//
// The function returns the following values:
//
//   - socket or NULL on error.
func (connection *SocketConnection) Socket() *Socket {
	var _arg0 *C.GSocketConnection // out
	var _cret *C.GSocket           // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_socket_connection_get_socket(_arg0)
	runtime.KeepAlive(connection)

	var _socket *Socket // out

	_socket = wrapSocket(coreglib.Take(unsafe.Pointer(_cret)))

	return _socket
}

// IsConnected checks if connection is connected. This is equivalent to calling
// g_socket_is_connected() on connection's underlying #GSocket.
//
// The function returns the following values:
//
//   - ok: whether connection is connected.
func (connection *SocketConnection) IsConnected() bool {
	var _arg0 *C.GSocketConnection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_socket_connection_is_connected(_arg0)
	runtime.KeepAlive(connection)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SocketConnectionFactoryLookupType looks up the #GType to be used when
// creating socket connections on sockets with the specified family, type and
// protocol_id.
//
// If no type is registered, the Connection base type is returned.
//
// The function takes the following parameters:
//
//   - family: Family.
//   - typ: Type.
//   - protocolId: protocol id.
//
// The function returns the following values:
//
//   - gType: #GType.
func SocketConnectionFactoryLookupType(family SocketFamily, typ SocketType, protocolId int) coreglib.Type {
	var _arg1 C.GSocketFamily // out
	var _arg2 C.GSocketType   // out
	var _arg3 C.gint          // out
	var _cret C.GType         // in

	_arg1 = C.GSocketFamily(family)
	_arg2 = C.GSocketType(typ)
	_arg3 = C.gint(protocolId)

	_cret = C.g_socket_connection_factory_lookup_type(_arg1, _arg2, _arg3)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocolId)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// SocketConnectionFactoryRegisterType looks up the #GType to be used when
// creating socket connections on sockets with the specified family, type and
// protocol.
//
// If no type is registered, the Connection base type is returned.
//
// The function takes the following parameters:
//
//   - gType inheriting from G_TYPE_SOCKET_CONNECTION.
//   - family: Family.
//   - typ: Type.
//   - protocol id.
func SocketConnectionFactoryRegisterType(gType coreglib.Type, family SocketFamily, typ SocketType, protocol int) {
	var _arg1 C.GType         // out
	var _arg2 C.GSocketFamily // out
	var _arg3 C.GSocketType   // out
	var _arg4 C.gint          // out

	_arg1 = C.GType(gType)
	_arg2 = C.GSocketFamily(family)
	_arg3 = C.GSocketType(typ)
	_arg4 = C.gint(protocol)

	C.g_socket_connection_factory_register_type(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(gType)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)
}

// SocketControlMessageOverrides contains methods that are overridable.
type SocketControlMessageOverrides struct {
	// Level returns the "level" (i.e. the originating protocol) of the control
	// message. This is often SOL_SOCKET.
	//
	// The function returns the following values:
	//
	//   - gint: integer describing the level.
	Level func() int
	// Size returns the space required for the control message, not including
	// headers or alignment.
	//
	// The function returns the following values:
	//
	//   - gsize: number of bytes required.
	Size func() uint
	// Type gets the protocol specific type of the message.
	Type func() int
	// Serialize converts the data in the message to bytes placed in the
	// message.
	//
	// data is guaranteed to have enough space to fit the size returned by
	// g_socket_control_message_get_size() on this object.
	//
	// The function takes the following parameters:
	//
	//   - data: buffer to write data to.
	Serialize func(data unsafe.Pointer)
}

func defaultSocketControlMessageOverrides(v *SocketControlMessage) SocketControlMessageOverrides {
	return SocketControlMessageOverrides{
		Level:     v.level,
		Size:      v.size,
		Type:      v.typ,
		Serialize: v.serialize,
	}
}

// SocketControlMessage: GSocketControlMessage is a special-purpose utility
// message that can be sent to or received from a gio.Socket. These types of
// messages are often called ancillary data.
//
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
//
// These messages are sent with gio.Socket.SendMessage() and received with
// gio.Socket.ReceiveMessage().
//
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
//
// To extend the set of control messages that can be received, subclass
// this class and implement the deserialize method. Also, make sure your
// class is registered with the gobject.Type type system before calling
// gio.Socket.ReceiveMessage() to read such a message.
type SocketControlMessage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketControlMessage)(nil)
)

// SocketControlMessager describes types inherited from class SocketControlMessage.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type SocketControlMessager interface {
	coreglib.Objector
	baseSocketControlMessage() *SocketControlMessage
}

var _ SocketControlMessager = (*SocketControlMessage)(nil)

func init() {
	coreglib.RegisterClassInfo[*SocketControlMessage, *SocketControlMessageClass, SocketControlMessageOverrides](
		GTypeSocketControlMessage,
		initSocketControlMessageClass,
		wrapSocketControlMessage,
		defaultSocketControlMessageOverrides,
	)
}

func initSocketControlMessageClass(gclass unsafe.Pointer, overrides SocketControlMessageOverrides, classInitFunc func(*SocketControlMessageClass)) {
	pclass := (*C.GSocketControlMessageClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSocketControlMessage))))

	if overrides.Level != nil {
		pclass.get_level = (*[0]byte)(C._gotk4_gio2_SocketControlMessageClass_get_level)
	}

	if overrides.Size != nil {
		pclass.get_size = (*[0]byte)(C._gotk4_gio2_SocketControlMessageClass_get_size)
	}

	if overrides.Type != nil {
		pclass.get_type = (*[0]byte)(C._gotk4_gio2_SocketControlMessageClass_get_type)
	}

	if overrides.Serialize != nil {
		pclass.serialize = (*[0]byte)(C._gotk4_gio2_SocketControlMessageClass_serialize)
	}

	if classInitFunc != nil {
		class := (*SocketControlMessageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketControlMessage(obj *coreglib.Object) *SocketControlMessage {
	return &SocketControlMessage{
		Object: obj,
	}
}

func marshalSocketControlMessage(p uintptr) (interface{}, error) {
	return wrapSocketControlMessage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (message *SocketControlMessage) baseSocketControlMessage() *SocketControlMessage {
	return message
}

// BaseSocketControlMessage returns the underlying base object.
func BaseSocketControlMessage(obj SocketControlMessager) *SocketControlMessage {
	return obj.baseSocketControlMessage()
}

// Level returns the "level" (i.e. the originating protocol) of the control
// message. This is often SOL_SOCKET.
//
// The function returns the following values:
//
//   - gint: integer describing the level.
func (message *SocketControlMessage) Level() int {
	var _arg0 *C.GSocketControlMessage // out
	var _cret C.int                    // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_socket_control_message_get_level(_arg0)
	runtime.KeepAlive(message)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MsgType returns the protocol specific type of the control message. For
// instance, for UNIX fd passing this would be SCM_RIGHTS.
//
// The function returns the following values:
//
//   - gint: integer describing the type of control message.
func (message *SocketControlMessage) MsgType() int {
	var _arg0 *C.GSocketControlMessage // out
	var _cret C.int                    // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_socket_control_message_get_msg_type(_arg0)
	runtime.KeepAlive(message)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Size returns the space required for the control message, not including
// headers or alignment.
//
// The function returns the following values:
//
//   - gsize: number of bytes required.
func (message *SocketControlMessage) Size() uint {
	var _arg0 *C.GSocketControlMessage // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.g_socket_control_message_get_size(_arg0)
	runtime.KeepAlive(message)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Serialize converts the data in the message to bytes placed in the message.
//
// data is guaranteed to have enough space to fit the size returned by
// g_socket_control_message_get_size() on this object.
//
// The function takes the following parameters:
//
//   - data: buffer to write data to.
func (message *SocketControlMessage) Serialize(data unsafe.Pointer) {
	var _arg0 *C.GSocketControlMessage // out
	var _arg1 C.gpointer               // out

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C.g_socket_control_message_serialize(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(data)
}

// Level returns the "level" (i.e. the originating protocol) of the control
// message. This is often SOL_SOCKET.
//
// The function returns the following values:
//
//   - gint: integer describing the level.
func (message *SocketControlMessage) level() int {
	gclass := (*C.GSocketControlMessageClass)(coreglib.PeekParentClass(message))
	fnarg := gclass.get_level

	var _arg0 *C.GSocketControlMessage // out
	var _cret C.int                    // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C._gotk4_gio2_SocketControlMessage_virtual_get_level(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(message)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Size returns the space required for the control message, not including
// headers or alignment.
//
// The function returns the following values:
//
//   - gsize: number of bytes required.
func (message *SocketControlMessage) size() uint {
	gclass := (*C.GSocketControlMessageClass)(coreglib.PeekParentClass(message))
	fnarg := gclass.get_size

	var _arg0 *C.GSocketControlMessage // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C._gotk4_gio2_SocketControlMessage_virtual_get_size(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(message)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Typ gets the protocol specific type of the message.
func (message *SocketControlMessage) typ() int {
	gclass := (*C.GSocketControlMessageClass)(coreglib.PeekParentClass(message))
	fnarg := gclass.get_type

	var _arg0 *C.GSocketControlMessage // out
	var _cret C.int                    // in

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C._gotk4_gio2_SocketControlMessage_virtual_get_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(message)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Serialize converts the data in the message to bytes placed in the message.
//
// data is guaranteed to have enough space to fit the size returned by
// g_socket_control_message_get_size() on this object.
//
// The function takes the following parameters:
//
//   - data: buffer to write data to.
func (message *SocketControlMessage) serialize(data unsafe.Pointer) {
	gclass := (*C.GSocketControlMessageClass)(coreglib.PeekParentClass(message))
	fnarg := gclass.serialize

	var _arg0 *C.GSocketControlMessage // out
	var _arg1 C.gpointer               // out

	_arg0 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C._gotk4_gio2_SocketControlMessage_virtual_serialize(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(data)
}

// SocketControlMessageDeserialize tries to deserialize a socket control message
// of a given level and type. This will ask all known (to GType) subclasses
// of ControlMessage if they can understand this kind of message and if so
// deserialize it into a ControlMessage.
//
// If there is no implementation for this kind of control message, NULL will be
// returned.
//
// The function takes the following parameters:
//
//   - level: socket level.
//   - typ: socket control message type for the given level.
//   - data: pointer to the message data.
//
// The function returns the following values:
//
//   - socketControlMessage (optional): deserialized message or NULL.
func SocketControlMessageDeserialize(level, typ int, data []byte) SocketControlMessager {
	var _arg1 C.int      // out
	var _arg2 C.int      // out
	var _arg4 C.gpointer // out
	var _arg3 C.gsize
	var _cret *C.GSocketControlMessage // in

	_arg1 = C.int(level)
	_arg2 = C.int(typ)
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg4 = (C.gpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.g_socket_control_message_deserialize(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(level)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(data)

	var _socketControlMessage SocketControlMessager // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketControlMessager)
				return ok
			})
			rv, ok := casted.(SocketControlMessager)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketControlMessager")
			}
			_socketControlMessage = rv
		}
	}

	return _socketControlMessage
}

// SocketListenerOverrides contains methods that are overridable.
type SocketListenerOverrides struct {
	// Changed: virtual method called when the set of socket listened to
	// changes.
	Changed func()
	// The function takes the following parameters:
	//
	//   - event
	//   - socket
	Event func(event SocketListenerEvent, socket *Socket)
}

func defaultSocketListenerOverrides(v *SocketListener) SocketListenerOverrides {
	return SocketListenerOverrides{
		Changed: v.changed,
		Event:   v.event,
	}
}

// SocketListener: GSocketListener is an object that keeps track of a set of
// server sockets and helps you accept sockets from any of the socket, either
// sync or async.
//
// Add addresses and ports to listen on using gio.SocketListener.AddAddress()
// and gio.SocketListener.AddInetPort(). These will be listened on until
// gio.SocketListener.Close() is called. Dropping your final reference to the
// GSocketListener will not cause gio.SocketListener.Close() to be called
// implicitly, as some references to the GSocketListener may be held internally.
//
// If you want to implement a network server, also look at gio.SocketService and
// gio.ThreadedSocketService which are subclasses of GSocketListener that make
// this even easier.
type SocketListener struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketListener)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SocketListener, *SocketListenerClass, SocketListenerOverrides](
		GTypeSocketListener,
		initSocketListenerClass,
		wrapSocketListener,
		defaultSocketListenerOverrides,
	)
}

func initSocketListenerClass(gclass unsafe.Pointer, overrides SocketListenerOverrides, classInitFunc func(*SocketListenerClass)) {
	pclass := (*C.GSocketListenerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSocketListener))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gio2_SocketListenerClass_changed)
	}

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._gotk4_gio2_SocketListenerClass_event)
	}

	if classInitFunc != nil {
		class := (*SocketListenerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketListener(obj *coreglib.Object) *SocketListener {
	return &SocketListener{
		Object: obj,
	}
}

func marshalSocketListener(p uintptr) (interface{}, error) {
	return wrapSocketListener(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEvent is emitted when listener's activity on socket changes state.
// Note that when listener is used to listen on both IPv4 and IPv6, a separate
// set of signals will be emitted for each, and the order they happen in is
// undefined.
func (listener *SocketListener) ConnectEvent(f func(event SocketListenerEvent, socket *Socket)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(listener, "event", false, unsafe.Pointer(C._gotk4_gio2_SocketListener_ConnectEvent), f)
}

// NewSocketListener creates a new Listener with no sockets to listen for.
// New listeners can be added with e.g. g_socket_listener_add_address() or
// g_socket_listener_add_inet_port().
//
// The function returns the following values:
//
//   - socketListener: new Listener.
func NewSocketListener() *SocketListener {
	var _cret *C.GSocketListener // in

	_cret = C.g_socket_listener_new()

	var _socketListener *SocketListener // out

	_socketListener = wrapSocketListener(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketListener
}

// Accept blocks waiting for a client to connect to any of the sockets added to
// the listener. Returns a Connection for the socket that was accepted.
//
// If source_object is not NULL it will be filled out with the source object
// specified when the corresponding socket or address was added to the listener.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - sourceObject (optional): location where #GObject pointer will be stored,
//     or NULL.
//   - socketConnection on success, NULL on error.
func (listener *SocketListener) Accept(ctx context.Context) (*coreglib.Object, *SocketConnection, error) {
	var _arg0 *C.GSocketListener   // out
	var _arg2 *C.GCancellable      // out
	var _arg1 *C.GObject           // in
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_socket_listener_accept(_arg0, &_arg1, _arg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(ctx)

	var _sourceObject *coreglib.Object      // out
	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	if _arg1 != nil {
		_sourceObject = coreglib.Take(unsafe.Pointer(_arg1))
	}
	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _sourceObject, _socketConnection, _goerr
}

// AcceptAsync: this is the asynchronous version of g_socket_listener_accept().
//
// When the operation is finished callback will be called. You can then call
// g_socket_listener_accept_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional): ReadyCallback.
func (listener *SocketListener) AcceptAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketListener    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_listener_accept_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// AcceptFinish finishes an async accept operation. See
// g_socket_listener_accept_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - sourceObject (optional): optional #GObject identifying this source.
//   - socketConnection on success, NULL on error.
func (listener *SocketListener) AcceptFinish(result AsyncResulter) (*coreglib.Object, *SocketConnection, error) {
	var _arg0 *C.GSocketListener   // out
	var _arg1 *C.GAsyncResult      // out
	var _arg2 *C.GObject           // in
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_listener_accept_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(result)

	var _sourceObject *coreglib.Object      // out
	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	if _arg2 != nil {
		_sourceObject = coreglib.Take(unsafe.Pointer(_arg2))
	}
	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _sourceObject, _socketConnection, _goerr
}

// AcceptSocket blocks waiting for a client to connect to any of the sockets
// added to the listener. Returns the #GSocket that was accepted.
//
// If you want to accept the high-level Connection, not a #GSocket, which is
// often the case, then you should use g_socket_listener_accept() instead.
//
// If source_object is not NULL it will be filled out with the source object
// specified when the corresponding socket or address was added to the listener.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//   - sourceObject (optional): location where #GObject pointer will be stored,
//     or NULL.
//   - socket on success, NULL on error.
func (listener *SocketListener) AcceptSocket(ctx context.Context) (*coreglib.Object, *Socket, error) {
	var _arg0 *C.GSocketListener // out
	var _arg2 *C.GCancellable    // out
	var _arg1 *C.GObject         // in
	var _cret *C.GSocket         // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_socket_listener_accept_socket(_arg0, &_arg1, _arg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(ctx)

	var _sourceObject *coreglib.Object // out
	var _socket *Socket                // out
	var _goerr error                   // out

	if _arg1 != nil {
		_sourceObject = coreglib.Take(unsafe.Pointer(_arg1))
	}
	_socket = wrapSocket(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _sourceObject, _socket, _goerr
}

// AcceptSocketAsync: this is the asynchronous version of
// g_socket_listener_accept_socket().
//
// When the operation is finished callback will be called. You can then call
// g_socket_listener_accept_socket_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - callback (optional): ReadyCallback.
func (listener *SocketListener) AcceptSocketAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketListener    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_listener_accept_socket_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// AcceptSocketFinish finishes an async accept operation. See
// g_socket_listener_accept_socket_async().
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - sourceObject (optional): optional #GObject identifying this source.
//   - socket on success, NULL on error.
func (listener *SocketListener) AcceptSocketFinish(result AsyncResulter) (*coreglib.Object, *Socket, error) {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GAsyncResult    // out
	var _arg2 *C.GObject         // in
	var _cret *C.GSocket         // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_listener_accept_socket_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(result)

	var _sourceObject *coreglib.Object // out
	var _socket *Socket                // out
	var _goerr error                   // out

	if _arg2 != nil {
		_sourceObject = coreglib.Take(unsafe.Pointer(_arg2))
	}
	_socket = wrapSocket(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _sourceObject, _socket, _goerr
}

// AddAddress creates a socket of type type and protocol protocol, binds it to
// address and adds it to the set of sockets we're accepting sockets from.
//
// Note that adding an IPv6 address, depending on the platform, may or may
// not result in a listener that also accepts IPv4 connections. For more
// deterministic behavior, see g_socket_listener_add_inet_port().
//
// source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
//
// If successful and effective_address is non-NULL then it will be set to
// the address that the binding actually occurred at. This is helpful for
// determining the port number that was used for when requesting a binding to
// port 0 (ie: "any port"). This address, if requested, belongs to the caller
// and must be freed.
//
// Call g_socket_listener_close() to stop listening on address; this will
// not be done automatically when you drop your final reference to listener,
// as references may be held internally.
//
// The function takes the following parameters:
//
//   - address: Address.
//   - typ: Type.
//   - protocol: Protocol.
//   - sourceObject (optional): optional #GObject identifying this source.
//
// The function returns the following values:
//
//   - effectiveAddress (optional): location to store the address that was bound
//     to, or NULL.
func (listener *SocketListener) AddAddress(address SocketAddresser, typ SocketType, protocol SocketProtocol, sourceObject *coreglib.Object) (SocketAddresser, error) {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GSocketAddress  // out
	var _arg2 C.GSocketType      // out
	var _arg3 C.GSocketProtocol  // out
	var _arg4 *C.GObject         // out
	var _arg5 *C.GSocketAddress  // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg2 = C.GSocketType(typ)
	_arg3 = C.GSocketProtocol(protocol)
	if sourceObject != nil {
		_arg4 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))
	}

	C.g_socket_listener_add_address(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(address)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(sourceObject)

	var _effectiveAddress SocketAddresser // out
	var _goerr error                      // out

	if _arg5 != nil {
		{
			objptr := unsafe.Pointer(_arg5)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_effectiveAddress = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _effectiveAddress, _goerr
}

// AddAnyInetPort listens for TCP connections on any available port number for
// both IPv6 and IPv4 (if each is available).
//
// This is useful if you need to have a socket for incoming connections but
// don't care about the specific port number.
//
// source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
//
// The function takes the following parameters:
//
//   - sourceObject (optional): optional #GObject identifying this source.
//
// The function returns the following values:
//
//   - guint16: port number, or 0 in case of failure.
func (listener *SocketListener) AddAnyInetPort(sourceObject *coreglib.Object) (uint16, error) {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GObject         // out
	var _cret C.guint16          // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	if sourceObject != nil {
		_arg1 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))
	}

	_cret = C.g_socket_listener_add_any_inet_port(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(sourceObject)

	var _guint16 uint16 // out
	var _goerr error    // out

	_guint16 = uint16(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint16, _goerr
}

// AddInetPort: helper function for g_socket_listener_add_address() that creates
// a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the specified
// port on all interfaces.
//
// source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
//
// Call g_socket_listener_close() to stop listening on port; this will not
// be done automatically when you drop your final reference to listener,
// as references may be held internally.
//
// The function takes the following parameters:
//
//   - port: IP port number (non-zero).
//   - sourceObject (optional): optional #GObject identifying this source.
func (listener *SocketListener) AddInetPort(port uint16, sourceObject *coreglib.Object) error {
	var _arg0 *C.GSocketListener // out
	var _arg1 C.guint16          // out
	var _arg2 *C.GObject         // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	_arg1 = C.guint16(port)
	if sourceObject != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))
	}

	C.g_socket_listener_add_inet_port(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(port)
	runtime.KeepAlive(sourceObject)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddSocket adds socket to the set of sockets that we try to accept new clients
// from. The socket must be bound to a local address and listened to.
//
// source_object will be passed out in the various calls to accept to identify
// this particular source, which is useful if you're listening on multiple
// addresses and do different things depending on what address is connected to.
//
// The socket will not be automatically closed when the listener is finalized
// unless the listener held the final reference to the socket. Before GLib 2.42,
// the socket was automatically closed on finalization of the listener, even if
// references to it were held elsewhere.
//
// The function takes the following parameters:
//
//   - socket: listening #GSocket.
//   - sourceObject (optional): optional #GObject identifying this source.
func (listener *SocketListener) AddSocket(socket *Socket, sourceObject *coreglib.Object) error {
	var _arg0 *C.GSocketListener // out
	var _arg1 *C.GSocket         // out
	var _arg2 *C.GObject         // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	_arg1 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if sourceObject != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))
	}

	C.g_socket_listener_add_socket(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(sourceObject)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Close closes all the sockets in the listener.
func (listener *SocketListener) Close() {
	var _arg0 *C.GSocketListener // out

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))

	C.g_socket_listener_close(_arg0)
	runtime.KeepAlive(listener)
}

// SetBacklog sets the listen backlog on the sockets in the listener. This must
// be called before adding any sockets, addresses or ports to the Listener (for
// example, by calling g_socket_listener_add_inet_port()) to be effective.
//
// See g_socket_set_listen_backlog() for details.
//
// The function takes the following parameters:
//
//   - listenBacklog: integer.
func (listener *SocketListener) SetBacklog(listenBacklog int) {
	var _arg0 *C.GSocketListener // out
	var _arg1 C.int              // out

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	_arg1 = C.int(listenBacklog)

	C.g_socket_listener_set_backlog(_arg0, _arg1)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(listenBacklog)
}

// Changed: virtual method called when the set of socket listened to changes.
func (listener *SocketListener) changed() {
	gclass := (*C.GSocketListenerClass)(coreglib.PeekParentClass(listener))
	fnarg := gclass.changed

	var _arg0 *C.GSocketListener // out

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))

	C._gotk4_gio2_SocketListener_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(listener)
}

// The function takes the following parameters:
//
//   - event
//   - socket
func (listener *SocketListener) event(event SocketListenerEvent, socket *Socket) {
	gclass := (*C.GSocketListenerClass)(coreglib.PeekParentClass(listener))
	fnarg := gclass.event

	var _arg0 *C.GSocketListener     // out
	var _arg1 C.GSocketListenerEvent // out
	var _arg2 *C.GSocket             // out

	_arg0 = (*C.GSocketListener)(unsafe.Pointer(coreglib.InternObject(listener).Native()))
	_arg1 = C.GSocketListenerEvent(event)
	_arg2 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	C._gotk4_gio2_SocketListener_virtual_event(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(event)
	runtime.KeepAlive(socket)
}

// SocketServiceOverrides contains methods that are overridable.
type SocketServiceOverrides struct {
	// Incoming: signal emitted when new connections are accepted.
	//
	// The function takes the following parameters:
	//
	//   - connection
	//   - sourceObject
	Incoming func(connection *SocketConnection, sourceObject *coreglib.Object) bool
}

func defaultSocketServiceOverrides(v *SocketService) SocketServiceOverrides {
	return SocketServiceOverrides{
		Incoming: v.incoming,
	}
}

// SocketService: GSocketService is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the gio.SocketService::incoming signal is emitted.
//
// A GSocketService is a subclass of gio.SocketListener and you need to add the
// addresses you want to accept connections on with the gio.SocketListener APIs.
//
// There are two options for implementing a network service based
// on GSocketService. The first is to create the service using
// gio.SocketService.New and to connect to the gio.SocketService::incoming
// signal. The second is to subclass GSocketService and override the default
// signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested
// in writing connection handlers that contain blocking code then see
// gio.ThreadedSocketService.
//
// The socket service runs on the main loop of the thread-default context (see
// glib.MainContext.PushThreadDefault()) of the thread it is created in, and is
// not threadsafe in general. However, the calls to start and stop the service
// are thread-safe so these can be used from threads that handle incoming
// clients.
type SocketService struct {
	_ [0]func() // equal guard
	SocketListener
}

var (
	_ coreglib.Objector = (*SocketService)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SocketService, *SocketServiceClass, SocketServiceOverrides](
		GTypeSocketService,
		initSocketServiceClass,
		wrapSocketService,
		defaultSocketServiceOverrides,
	)
}

func initSocketServiceClass(gclass unsafe.Pointer, overrides SocketServiceOverrides, classInitFunc func(*SocketServiceClass)) {
	pclass := (*C.GSocketServiceClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSocketService))))

	if overrides.Incoming != nil {
		pclass.incoming = (*[0]byte)(C._gotk4_gio2_SocketServiceClass_incoming)
	}

	if classInitFunc != nil {
		class := (*SocketServiceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketService(obj *coreglib.Object) *SocketService {
	return &SocketService{
		SocketListener: SocketListener{
			Object: obj,
		},
	}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	return wrapSocketService(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectIncoming signal is emitted when a new incoming connection to service
// needs to be handled. The handler must initiate the handling of connection,
// but may not block; in essence, asynchronous operations must be used.
//
// connection will be unreffed once the signal handler returns, so you need to
// ref it yourself if you are planning to use it.
func (service *SocketService) ConnectIncoming(f func(connection *SocketConnection, sourceObject *coreglib.Object) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(service, "incoming", false, unsafe.Pointer(C._gotk4_gio2_SocketService_ConnectIncoming), f)
}

// NewSocketService creates a new Service with no sockets to listen for.
// New listeners can be added with e.g. g_socket_listener_add_address() or
// g_socket_listener_add_inet_port().
//
// New services are created active, there is no need to call
// g_socket_service_start(), unless g_socket_service_stop() has been called
// before.
//
// The function returns the following values:
//
//   - socketService: new Service.
func NewSocketService() *SocketService {
	var _cret *C.GSocketService // in

	_cret = C.g_socket_service_new()

	var _socketService *SocketService // out

	_socketService = wrapSocketService(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _socketService
}

// IsActive: check whether the service is active or not. An active service
// will accept new clients that connect, while a non-active service will let
// connecting clients queue up until the service is started.
//
// The function returns the following values:
//
//   - ok: TRUE if the service is active, FALSE otherwise.
func (service *SocketService) IsActive() bool {
	var _arg0 *C.GSocketService // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GSocketService)(unsafe.Pointer(coreglib.InternObject(service).Native()))

	_cret = C.g_socket_service_is_active(_arg0)
	runtime.KeepAlive(service)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start restarts the service, i.e. start accepting connections from the added
// sockets when the mainloop runs. This only needs to be called after the
// service has been stopped from g_socket_service_stop().
//
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
func (service *SocketService) Start() {
	var _arg0 *C.GSocketService // out

	_arg0 = (*C.GSocketService)(unsafe.Pointer(coreglib.InternObject(service).Native()))

	C.g_socket_service_start(_arg0)
	runtime.KeepAlive(service)
}

// Stop stops the service, i.e. stops accepting connections from the added
// sockets when the mainloop runs.
//
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
//
// Note that this only stops accepting new connections; it does not close
// the listening sockets, and you can call g_socket_service_start() again
// later to begin listening again. To close the listening sockets, call
// g_socket_listener_close(). (This will happen automatically when the Service
// is finalized.)
//
// This must be called before calling g_socket_listener_close() as the socket
// service will start accepting connections immediately when a new socket is
// added.
func (service *SocketService) Stop() {
	var _arg0 *C.GSocketService // out

	_arg0 = (*C.GSocketService)(unsafe.Pointer(coreglib.InternObject(service).Native()))

	C.g_socket_service_stop(_arg0)
	runtime.KeepAlive(service)
}

// Incoming: signal emitted when new connections are accepted.
//
// The function takes the following parameters:
//
//   - connection
//   - sourceObject
func (service *SocketService) incoming(connection *SocketConnection, sourceObject *coreglib.Object) bool {
	gclass := (*C.GSocketServiceClass)(coreglib.PeekParentClass(service))
	fnarg := gclass.incoming

	var _arg0 *C.GSocketService    // out
	var _arg1 *C.GSocketConnection // out
	var _arg2 *C.GObject           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GSocketService)(unsafe.Pointer(coreglib.InternObject(service).Native()))
	_arg1 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	_cret = C._gotk4_gio2_SocketService_virtual_incoming(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(service)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(sourceObject)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Task: GTask represents and manages a cancellable task.
//
// # Asynchronous operations
//
// The most common usage of GTask is as a gio.AsyncResult, to manage data during
// an asynchronous operation. You call gio.Task.New in the start method,
// followed by gio.Task.SetTaskData() and the like if you need to keep some
// additional data associated with the task, and then pass the task object
// around through your asynchronous operation. Eventually, you will call a
// method such as gio.Task.ReturnPointer() or gio.Task.ReturnError(), which will
// save the value you give it and then invoke the tasks callback function in
// the thread-default main context (see glib.MainContext.PushThreadDefault())
// where it was created (waiting until the next iteration of the main
// loop first, if necessary). The caller will pass the GTask back to the
// operations finish function (as a gio.AsyncResult), and you can use
// gio.Task.PropagatePointer() or the like to extract the return value.
//
// Using GTask requires the thread-default glib.MainContext from when the GTask
// was constructed to be running at least until the task has completed and its
// data has been freed.
//
// If a GTask has been constructed and its callback set, it is an error to not
// call g_task_return_*() on it. GLib will warn at runtime if this happens
// (since 2.76).
//
// Here is an example for using GTask as a gio.AsyncResult:
//
//	typedef struct {
//	  CakeFrostingType frosting;
//	  char *message;
//	} DecorationData;
//
//	static void
//	decoration_data_free (DecorationData *decoration)
//	{
//	  g_free (decoration->message);
//	  g_slice_free (DecorationData, decoration);
//	}
//
//	static void
//	baked_cb (Cake     *cake,
//	          gpointer  user_data)
//	{
//	  GTask *task = user_data;
//	  DecorationData *decoration = g_task_get_task_data (task);
//	  GError *error = NULL;
//
//	  if (cake == NULL)
//	    {
//	      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
//	                               "Go to the supermarket");
//	      g_object_unref (task);
//	      return;
//	    }
//
//	  if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
//	    {
//	      g_object_unref (cake);
//	      // g_task_return_error() takes ownership of error
//	      g_task_return_error (task, error);
//	      g_object_unref (task);
//	      return;
//	    }
//
//	  g_task_return_pointer (task, cake, g_object_unref);
//	  g_object_unref (task);
//	}
//
//	void
//	baker_bake_cake_async (Baker               *self,
//	                       guint                radius,
//	                       CakeFlavor           flavor,
//	                       CakeFrostingType     frosting,
//	                       const char          *message,
//	                       GCancellable        *cancellable,
//	                       GAsyncReadyCallback  callback,
//	                       gpointer             user_data)
//	{
//	  GTask *task;
//	  DecorationData *decoration;
//	  Cake  *cake;
//
//	  task = g_task_new (self, cancellable, callback, user_data);
//	  if (radius < 3)
//	    {
//	      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
//	                               "ucm radius cakes are silly",
//	                               radius);
//	      g_object_unref (task);
//	      return;
//	    }
//
//	  cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
//	  if (cake != NULL)
//	    {
//	      // _baker_get_cached_cake() returns a reffed cake
//	      g_task_return_pointer (task, cake, g_object_unref);
//	      g_object_unref (task);
//	      return;
//	    }
//
//	  decoration = g_slice_new (DecorationData);
//	  decoration->frosting = frosting;
//	  decoration->message = g_strdup (message);
//	  g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);
//
//	  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
//	}
//
//	Cake *
//	baker_bake_cake_finish (Baker         *self,
//	                        GAsyncResult  *result,
//	                        GError       **error)
//	{
//	  g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//	  return g_task_propagate_pointer (G_TASK (result), error);
//	}
//
// # Chained asynchronous operations
//
// GTask also tries to simplify asynchronous operations that internally chain
// together several smaller asynchronous operations. gio.Task.GetCancellable(),
// gio.Task.GetContext(), and gio.Task.GetPriority() allow you to get
// back the tasks gio.Cancellable, glib.MainContext, and I/O priority
// (iface.AsyncResult.html#io-priority) when starting a new subtask, so you
// dont have to keep track of them yourself. gio.Task.AttachSource() simplifies
// the case of waiting for a source to fire (automatically using the correct
// glib.MainContext and priority).
//
// Here is an example for chained asynchronous operations:
//
//	typedef struct {
//	  Cake *cake;
//	  CakeFrostingType frosting;
//	  char *message;
//	} BakingData;
//
//	static void
//	decoration_data_free (BakingData *bd)
//	{
//	  if (bd->cake)
//	    g_object_unref (bd->cake);
//	  g_free (bd->message);
//	  g_slice_free (BakingData, bd);
//	}
//
//	static void
//	decorated_cb (Cake         *cake,
//	              GAsyncResult *result,
//	              gpointer      user_data)
//	{
//	  GTask *task = user_data;
//	  GError *error = NULL;
//
//	  if (!cake_decorate_finish (cake, result, &error))
//	    {
//	      g_object_unref (cake);
//	      g_task_return_error (task, error);
//	      g_object_unref (task);
//	      return;
//	    }
//
//	  // baking_data_free() will drop its ref on the cake, so we have to
//	  // take another here to give to the caller.
//	  g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
//	  g_object_unref (task);
//	}
//
//	static gboolean
//	decorator_ready (gpointer user_data)
//	{
//	  GTask *task = user_data;
//	  BakingData *bd = g_task_get_task_data (task);
//
//	  cake_decorate_async (bd->cake, bd->frosting, bd->message,
//	                       g_task_get_cancellable (task),
//	                       decorated_cb, task);
//
//	  return G_SOURCE_REMOVE;
//	}
//
//	static void
//	baked_cb (Cake     *cake,
//	          gpointer  user_data)
//	{
//	  GTask *task = user_data;
//	  BakingData *bd = g_task_get_task_data (task);
//	  GError *error = NULL;
//
//	  if (cake == NULL)
//	    {
//	      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
//	                               "Go to the supermarket");
//	      g_object_unref (task);
//	      return;
//	    }
//
//	  bd->cake = cake;
//
//	  // Bail out now if the user has already cancelled
//	  if (g_task_return_error_if_cancelled (task))
//	    {
//	      g_object_unref (task);
//	      return;
//	    }
//
//	  if (cake_decorator_available (cake))
//	    decorator_ready (task);
//	  else
//	    {
//	      GSource *source;
//
//	      source = cake_decorator_wait_source_new (cake);
//	      // Attach source to tasks GMainContext and have it call
//	      // decorator_ready() when it is ready.
//	      g_task_attach_source (task, source, decorator_ready);
//	      g_source_unref (source);
//	    }
//	}
//
//	void
//	baker_bake_cake_async (Baker               *self,
//	                       guint                radius,
//	                       CakeFlavor           flavor,
//	                       CakeFrostingType     frosting,
//	                       const char          *message,
//	                       gint                 priority,
//	                       GCancellable        *cancellable,
//	                       GAsyncReadyCallback  callback,
//	                       gpointer             user_data)
//	{
//	  GTask *task;
//	  BakingData *bd;
//
//	  task = g_task_new (self, cancellable, callback, user_data);
//	  g_task_set_priority (task, priority);
//
//	  bd = g_slice_new0 (BakingData);
//	  bd->frosting = frosting;
//	  bd->message = g_strdup (message);
//	  g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
//
//	  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
//	}
//
//	Cake *
//	baker_bake_cake_finish (Baker         *self,
//	                        GAsyncResult  *result,
//	                        GError       **error)
//	{
//	  g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//	  return g_task_propagate_pointer (G_TASK (result), error);
//	}
//
// # Asynchronous operations from synchronous ones
//
// You can use gio.Task.RunInThread() to turn a synchronous operation into
// an asynchronous one, by running it in a thread. When it completes,
// the result will be dispatched to the thread-default main context (see
// glib.MainContext.PushThreadDefault()) where the GTask was created.
//
// Running a task in a thread:
//
//	typedef struct {
//	  guint radius;
//	  CakeFlavor flavor;
//	  CakeFrostingType frosting;
//	  char *message;
//	} CakeData;
//
//	static void
//	cake_data_free (CakeData *cake_data)
//	{
//	  g_free (cake_data->message);
//	  g_slice_free (CakeData, cake_data);
//	}
//
//	static void
//	bake_cake_thread (GTask         *task,
//	                  gpointer       source_object,
//	                  gpointer       task_data,
//	                  GCancellable  *cancellable)
//	{
//	  Baker *self = source_object;
//	  CakeData *cake_data = task_data;
//	  Cake *cake;
//	  GError *error = NULL;
//
//	  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//	                    cake_data->frosting, cake_data->message,
//	                    cancellable, &error);
//	  if (cake)
//	    g_task_return_pointer (task, cake, g_object_unref);
//	  else
//	    g_task_return_error (task, error);
//	}
//
//	void
//	baker_bake_cake_async (Baker               *self,
//	                       guint                radius,
//	                       CakeFlavor           flavor,
//	                       CakeFrostingType     frosting,
//	                       const char          *message,
//	                       GCancellable        *cancellable,
//	                       GAsyncReadyCallback  callback,
//	                       gpointer             user_data)
//	{
//	  CakeData *cake_data;
//	  GTask *task;
//
//	  cake_data = g_slice_new (CakeData);
//	  cake_data->radius = radius;
//	  cake_data->flavor = flavor;
//	  cake_data->frosting = frosting;
//	  cake_data->message = g_strdup (message);
//	  task = g_task_new (self, cancellable, callback, user_data);
//	  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//	  g_task_run_in_thread (task, bake_cake_thread);
//	  g_object_unref (task);
//	}
//
//	Cake *
//	baker_bake_cake_finish (Baker         *self,
//	                        GAsyncResult  *result,
//	                        GError       **error)
//	{
//	  g_return_val_if_fail (g_task_is_valid (result, self), NULL);
//
//	  return g_task_propagate_pointer (G_TASK (result), error);
//	}
//
// # Adding cancellability to uncancellable tasks
//
// Finally, gio.Task.RunInThread() and gio.Task.RunInThreadSync() can
// be used to turn an uncancellable operation into a cancellable one.
// If you call gio.Task.SetReturnOnCancel(), passing TRUE, then if the tasks
// gio.Cancellable is cancelled, it will return control back to the caller
// immediately, while allowing the task thread to continue running in the
// background (and simply discarding its result when it finally does finish).
// Provided that the task thread is careful about how it uses locks and other
// externally-visible resources, this allows you to make GLib-friendly
// asynchronous and cancellable synchronous variants of blocking APIs.
//
// Cancelling a task:
//
//	static void
//	bake_cake_thread (GTask         *task,
//	                  gpointer       source_object,
//	                  gpointer       task_data,
//	                  GCancellable  *cancellable)
//	{
//	  Baker *self = source_object;
//	  CakeData *cake_data = task_data;
//	  Cake *cake;
//	  GError *error = NULL;
//
//	  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//	                    cake_data->frosting, cake_data->message,
//	                    &error);
//	  if (error)
//	    {
//	      g_task_return_error (task, error);
//	      return;
//	    }
//
//	  // If the task has already been cancelled, then we dont want to add
//	  // the cake to the cake cache. Likewise, we dont  want to have the
//	  // task get cancelled in the middle of updating the cache.
//	  // g_task_set_return_on_cancel() will return TRUE here if it managed
//	  // to disable return-on-cancel, or FALSE if the task was cancelled
//	  // before it could.
//	  if (g_task_set_return_on_cancel (task, FALSE))
//	    {
//	      // If the caller cancels at this point, their
//	      // GAsyncReadyCallback wont be invoked until we return,
//	      // so we dont have to worry that this code will run at
//	      // the same time as that code does. But if there were
//	      // other functions that might look at the cake cache,
//	      // then wed probably need a GMutex here as well.
//	      baker_add_cake_to_cache (baker, cake);
//	      g_task_return_pointer (task, cake, g_object_unref);
//	    }
//	}
//
//	void
//	baker_bake_cake_async (Baker               *self,
//	                       guint                radius,
//	                       CakeFlavor           flavor,
//	                       CakeFrostingType     frosting,
//	                       const char          *message,
//	                       GCancellable        *cancellable,
//	                       GAsyncReadyCallback  callback,
//	                       gpointer             user_data)
//	{
//	  CakeData *cake_data;
//	  GTask *task;
//
//	  cake_data = g_slice_new (CakeData);
//
//	  ...
//
//	  task = g_task_new (self, cancellable, callback, user_data);
//	  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//	  g_task_set_return_on_cancel (task, TRUE);
//	  g_task_run_in_thread (task, bake_cake_thread);
//	}
//
//	Cake *
//	baker_bake_cake_sync (Baker               *self,
//	                      guint                radius,
//	                      CakeFlavor           flavor,
//	                      CakeFrostingType     frosting,
//	                      const char          *message,
//	                      GCancellable        *cancellable,
//	                      GError             **error)
//	{
//	  CakeData *cake_data;
//	  GTask *task;
//	  Cake *cake;
//
//	  cake_data = g_slice_new (CakeData);
//
//	  ...
//
//	  task = g_task_new (self, cancellable, NULL, NULL);
//	  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//	  g_task_set_return_on_cancel (task, TRUE);
//	  g_task_run_in_thread_sync (task, bake_cake_thread);
//
//	  cake = g_task_propagate_pointer (task, error);
//	  g_object_unref (task);
//	  return cake;
//	}
//
// # Porting from gio.SimpleAsyncResult
//
// GTasks API attempts to be simpler than gio.SimpleAsyncResults in several
// ways:
//
// - You can save task-specific data with gio.Task.SetTaskData(), and
// retrieve it later with gio.Task.GetTaskData(). This replaces the abuse
// of gio.SimpleAsyncResult.SetOpResGpointer() for the same purpose with
// gio.SimpleAsyncResult.
//
// - In addition to the task data, GTask also keeps track of the priority
// (iface.AsyncResult.html#io-priority), gio.Cancellable, and glib.MainContext
// associated with the task, so tasks that consist of a chain of simpler
// asynchronous operations will have easy access to those values when starting
// each sub-task.
//
// - gio.Task.ReturnErrorIfCancelled() provides simplified handling
// for cancellation. In addition, cancellation overrides any other
// GTask return value by default, like gio.SimpleAsyncResult does when
// gio.SimpleAsyncResult.SetCheckCancellable() is called. (You can use
// gio.Task.SetCheckCancellable() to turn off that behavior.) On the other hand,
// gio.Task.RunInThread() guarantees that it will always run your task_func,
// even if the tasks gio.Cancellable is already cancelled before the
// task gets a chance to run; you can start your task_func with a
// gio.Task.ReturnErrorIfCancelled() check if you need the old behavior.
//
// - The return methods (eg, gio.Task.ReturnPointer()) automatically cause
// the task to be completed as well, and there is no need to worry about the
// complete vs complete in idle distinction. (GTask automatically figures
// out whether the tasks callback can be invoked directly, or if it needs to be
// sent to another glib.MainContext, or delayed until the next iteration of the
// current glib.MainContext.)
//
// - The finish functions for GTask based operations are generally
// much simpler than gio.SimpleAsyncResult ones, normally consisting of
// only a single call to gio.Task.PropagatePointer() or the like. Since
// gio.Task.PropagatePointer() steals the return value from the GTask, it is
// not necessary to juggle pointers around to prevent it from being freed twice.
//
// - With gio.SimpleAsyncResult, it was common to call
// gio.SimpleAsyncResult.PropagateError() from the _finish() wrapper function,
// and have virtual method implementations only deal with successful returns.
// This behavior is deprecated, because it makes it difficult for a subclass
// to chain to a parent classs async methods. Instead, the wrapper function
// should just be a simple wrapper, and the virtual method should call an
// appropriate g_task_propagate_ function. Note that wrapper methods can now use
// gio.AsyncResult.LegacyPropagateError() to do old-style gio.SimpleAsyncResult
// error-returning behavior, and gio.AsyncResult.IsTagged() to check
// if a result is tagged as having come from the _async() wrapper
// function (for short-circuit results, such as when passing 0 to
// gio.InputStream.ReadAsync()).
//
// # Thread-safety considerations
//
// Due to some infelicities in the API design, there is a thread-safety concern
// that users of GTask have to be aware of:
//
// If the main thread drops its last reference to the source object or the task
// data before the task is finalized, then the finalizers of these objects may
// be called on the worker thread.
//
// This is a problem if the finalizers use non-threadsafe API, and can lead to
// hard-to-debug crashes. Possible workarounds include:
//
// - Clear task data in a signal handler for notify::completed
//
// - Keep iterating a main context in the main thread and defer dropping
// the reference to the source object to that main context when the task is
// finalized.
type Task struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncResult
}

var (
	_ coreglib.Objector = (*Task)(nil)
)

func wrapTask(obj *coreglib.Object) *Task {
	return &Task{
		Object: obj,
		AsyncResult: AsyncResult{
			Object: obj,
		},
	}
}

func marshalTask(p uintptr) (interface{}, error) {
	return wrapTask(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTask creates a #GTask acting on source_object, which will eventually
// be used to invoke callback in the current [thread-default main
// context][g-main-context-push-thread-default].
//
// Call this in the "start" method of your asynchronous method, and pass
// the #GTask around throughout the asynchronous operation. You can use
// g_task_set_task_data() to attach task-specific data to the object, which you
// can retrieve later via g_task_get_task_data().
//
// By default, if cancellable is cancelled, then the return value of the
// task will always be G_IO_ERROR_CANCELLED, even if the task had already
// completed before the cancellation. This allows for simplified handling in
// cases where cancellation may imply that other objects that the task depends
// on have been destroyed. If you do not want this behavior, you can use
// g_task_set_check_cancellable() to change it.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable object, NULL to ignore.
//   - sourceObject (optional) that owns this task, or NULL.
//   - callback (optional): ReadyCallback.
//
// The function returns the following values:
//
//   - task: #GTask.
func NewTask(ctx context.Context, sourceObject *coreglib.Object, callback AsyncReadyCallback) *Task {
	var _arg2 *C.GCancellable       // out
	var _arg1 C.gpointer            // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer
	var _cret *C.GTask // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gpointer(unsafe.Pointer(sourceObject.Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	_cret = C.g_task_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(sourceObject)
	runtime.KeepAlive(callback)

	var _task *Task // out

	_task = wrapTask(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _task
}

// Cancellable gets task's #GCancellable.
//
// The function returns the following values:
//
//   - cancellable (optional) task's #GCancellable.
func (task *Task) Cancellable() *Cancellable {
	var _arg0 *C.GTask        // out
	var _cret *C.GCancellable // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_cancellable(_arg0)
	runtime.KeepAlive(task)

	var _cancellable *Cancellable // out

	if _cret != nil {
		_cancellable = wrapCancellable(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _cancellable
}

// CheckCancellable gets task's check-cancellable flag. See
// g_task_set_check_cancellable() for more details.
func (task *Task) CheckCancellable() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_check_cancellable(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Completed gets the value of #GTask:completed. This changes from FALSE to TRUE
// after the tasks callback is invoked, and will return FALSE if called from
// inside the callback.
//
// The function returns the following values:
//
//   - ok: TRUE if the task has completed, FALSE otherwise.
func (task *Task) Completed() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_completed(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Context gets the Context that task will return its result
// in (that is, the context that was the [thread-default main
// context][g-main-context-push-thread-default] at the point when task was
// created).
//
// This will always return a non-NULL value, even if the task's context is the
// default Context.
//
// The function returns the following values:
//
//   - mainContext task's Context.
func (task *Task) Context() *glib.MainContext {
	var _arg0 *C.GTask        // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_context(_arg0)
	runtime.KeepAlive(task)

	var _mainContext *glib.MainContext // out

	_mainContext = (*glib.MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_main_context_unref((*C.GMainContext)(intern.C))
		},
	)

	return _mainContext
}

// Name gets tasks name. See g_task_set_name().
//
// The function returns the following values:
//
//   - utf8 (optional) tasks name, or NULL.
func (task *Task) Name() string {
	var _arg0 *C.GTask // out
	var _cret *C.gchar // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_name(_arg0)
	runtime.KeepAlive(task)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Priority gets task's priority.
//
// The function returns the following values:
//
//   - gint task's priority.
func (task *Task) Priority() int {
	var _arg0 *C.GTask // out
	var _cret C.gint   // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_priority(_arg0)
	runtime.KeepAlive(task)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ReturnOnCancel gets task's return-on-cancel flag. See
// g_task_set_return_on_cancel() for more details.
func (task *Task) ReturnOnCancel() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_return_on_cancel(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SourceObject gets the source object from task. Like
// g_async_result_get_source_object(), but does not ref the object.
//
// The function returns the following values:
//
//   - object (optional) task's source object, or NULL.
func (task *Task) SourceObject() *coreglib.Object {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_source_object(_arg0)
	runtime.KeepAlive(task)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// SourceTag gets task's source tag. See g_task_set_source_tag().
//
// The function returns the following values:
//
//   - gpointer (optional) task's source tag.
func (task *Task) SourceTag() unsafe.Pointer {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_source_tag(_arg0)
	runtime.KeepAlive(task)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// TaskData gets task's task_data.
//
// The function returns the following values:
//
//   - gpointer (optional) task's task_data.
func (task *Task) TaskData() unsafe.Pointer {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_get_task_data(_arg0)
	runtime.KeepAlive(task)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// HadError tests if task resulted in an error.
//
// The function returns the following values:
//
//   - ok: TRUE if the task resulted in an error, FALSE otherwise.
func (task *Task) HadError() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_had_error(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PropagateBoolean gets the result of task as a #gboolean.
//
// If the task resulted in an error, or was cancelled, then this will instead
// return FALSE and set error.
//
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
func (task *Task) PropagateBoolean() error {
	var _arg0 *C.GTask  // out
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	C.g_task_propagate_boolean(_arg0, &_cerr)
	runtime.KeepAlive(task)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PropagateInt gets the result of task as an integer (#gssize).
//
// If the task resulted in an error, or was cancelled, then this will instead
// return -1 and set error.
//
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
//
// The function returns the following values:
//
//   - gssize: task result, or -1 on error.
func (task *Task) PropagateInt() (int, error) {
	var _arg0 *C.GTask  // out
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_propagate_int(_arg0, &_cerr)
	runtime.KeepAlive(task)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// PropagatePointer gets the result of task as a pointer, and transfers
// ownership of that value to the caller.
//
// If the task resulted in an error, or was cancelled, then this will instead
// return NULL and set error.
//
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
//
// The function returns the following values:
//
//   - gpointer (optional): task result, or NULL on error.
func (task *Task) PropagatePointer() (unsafe.Pointer, error) {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_propagate_pointer(_arg0, &_cerr)
	runtime.KeepAlive(task)

	var _gpointer unsafe.Pointer // out
	var _goerr error             // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gpointer, _goerr
}

// PropagateValue gets the result of task as a #GValue, and transfers ownership
// of that value to the caller. As with g_task_return_value(), this is a generic
// low-level method; g_task_propagate_pointer() and the like will usually be
// more useful for C code.
//
// If the task resulted in an error, or was cancelled, then this will instead
// set error and return FALSE.
//
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
//
// The function returns the following values:
//
//   - value: return location for the #GValue.
func (task *Task) PropagateValue() (coreglib.Value, error) {
	var _arg0 *C.GTask  // out
	var _arg1 C.GValue  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	C.g_task_propagate_value(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(task)

	var _value coreglib.Value // out
	var _goerr error          // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// ReturnBoolean sets task's result to result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
//
// The function takes the following parameters:
//
//   - result result of a task function.
func (task *Task) ReturnBoolean(result bool) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if result {
		_arg1 = C.TRUE
	}

	C.g_task_return_boolean(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// ReturnError sets task's result to error (which task assumes ownership of)
// and completes the task (see g_task_return_pointer() for more discussion of
// exactly what this means).
//
// Note that since the task takes ownership of error, and since the task may be
// completed before returning from g_task_return_error(), you cannot assume that
// error is still valid after calling this. Call g_error_copy() on the error if
// you need to keep a local copy as well.
//
// See also gio.Task.ReturnNewError(), gio.Task.ReturnNewErrorLiteral().
//
// The function takes the following parameters:
//
//   - err result of a task function.
func (task *Task) ReturnError(err error) {
	var _arg0 *C.GTask  // out
	var _arg1 *C.GError // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	C.g_task_return_error(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(err)
}

// ReturnErrorIfCancelled checks if task's #GCancellable has been cancelled,
// and if so, sets task's error accordingly and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
//
// The function returns the following values:
//
//   - ok: TRUE if task has been cancelled, FALSE if not.
func (task *Task) ReturnErrorIfCancelled() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.g_task_return_error_if_cancelled(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReturnInt sets task's result to result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
//
// The function takes the following parameters:
//
//   - result: integer (#gssize) result of a task function.
func (task *Task) ReturnInt(result int) {
	var _arg0 *C.GTask // out
	var _arg1 C.gssize // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	_arg1 = C.gssize(result)

	C.g_task_return_int(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// ReturnNewErrorLiteral sets tasks result to a new glib.Error created from
// domain, code, message and completes the task.
//
// See gio.Task.ReturnPointer() for more discussion of exactly what completing
// the task means.
//
// See also gio.Task.ReturnNewError().
//
// The function takes the following parameters:
//
//   - domain: #GQuark.
//   - code: error code.
//   - message: error message.
func (task *Task) ReturnNewErrorLiteral(domain glib.Quark, code int, message string) {
	var _arg0 *C.GTask // out
	var _arg1 C.GQuark // out
	var _arg2 C.gint   // out
	var _arg3 *C.char  // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	_arg1 = C.GQuark(domain)
	_arg2 = C.gint(code)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_task_return_new_error_literal(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(task)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(message)
}

// ReturnValue sets task's result to result (by copying it) and completes the
// task.
//
// If result is NULL then a #GValue of type G_TYPE_POINTER with a value of NULL
// will be used for the result.
//
// This is a very generic low-level method intended primarily for use by
// language bindings; for C code, g_task_return_pointer() and the like will
// normally be much easier to use.
//
// The function takes the following parameters:
//
//   - result (optional) result of a task function.
func (task *Task) ReturnValue(result *coreglib.Value) {
	var _arg0 *C.GTask  // out
	var _arg1 *C.GValue // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if result != nil {
		_arg1 = (*C.GValue)(unsafe.Pointer(result.Native()))
	}

	C.g_task_return_value(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// SetCheckCancellable sets or clears task's check-cancellable flag.
// If this is TRUE (the default), then g_task_propagate_pointer(), etc,
// and g_task_had_error() will check the task's #GCancellable first, and if
// it has been cancelled, then they will consider the task to have returned an
// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
// other error or return value the task may have had.
//
// If check_cancellable is FALSE, then the #GTask will not check the
// cancellable itself, and it is up to task's owner to do this (eg, via
// g_task_return_error_if_cancelled()).
//
// If you are using g_task_set_return_on_cancel() as well, then you must leave
// check-cancellable set TRUE.
//
// The function takes the following parameters:
//
//   - checkCancellable: whether #GTask will check the state of its
//     #GCancellable for you.
func (task *Task) SetCheckCancellable(checkCancellable bool) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if checkCancellable {
		_arg1 = C.TRUE
	}

	C.g_task_set_check_cancellable(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(checkCancellable)
}

// SetName sets tasks name, used in debugging and profiling. The name defaults
// to NULL.
//
// The task name should describe in a human readable way what the task does.
// For example, Open file or Connect to network host. It is used to set the
// name of the #GSource used for idle completion of the task.
//
// This function may only be called before the task is first used in a thread
// other than the one it was constructed in. It is called automatically by
// g_task_set_source_tag() if not called already.
//
// The function takes the following parameters:
//
//   - name (optional): human readable name for the task, or NULL to unset it.
func (task *Task) SetName(name string) {
	var _arg0 *C.GTask // out
	var _arg1 *C.gchar // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_task_set_name(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(name)
}

// SetPriority sets task's priority. If you do not call this, it will default to
// G_PRIORITY_DEFAULT.
//
// This will affect the priority of #GSources created with
// g_task_attach_source() and the scheduling of tasks run in threads, and can
// also be explicitly retrieved later via g_task_get_priority().
//
// The function takes the following parameters:
//
//   - priority: priority (iface.AsyncResult.html#io-priority) of the request.
func (task *Task) SetPriority(priority int) {
	var _arg0 *C.GTask // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	_arg1 = C.gint(priority)

	C.g_task_set_priority(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(priority)
}

// SetReturnOnCancel sets or clears task's return-on-cancel flag.
// This is only meaningful for tasks run via g_task_run_in_thread() or
// g_task_run_in_thread_sync().
//
// If return_on_cancel is TRUE, then cancelling task's #GCancellable will
// immediately cause it to return, as though the task's ThreadFunc had called
// g_task_return_error_if_cancelled() and then returned.
//
// This allows you to create a cancellable wrapper around an uninterruptible
// function. The ThreadFunc just needs to be careful that it does not modify
// any externally-visible state after it has been cancelled. To do that,
// the thread should call g_task_set_return_on_cancel() again to (atomically)
// set return-on-cancel FALSE before making externally-visible changes;
// if the task gets cancelled before the return-on-cancel flag could be changed,
// g_task_set_return_on_cancel() will indicate this by returning FALSE.
//
// You can disable and re-enable this flag multiple times if you wish.
// If the task's #GCancellable is cancelled while return-on-cancel is FALSE,
// then calling g_task_set_return_on_cancel() to set it TRUE again will cause
// the task to be cancelled at that point.
//
// If the task's #GCancellable is already cancelled before you call
// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc will
// still be run (for consistency), but the task will also be completed right
// away.
//
// The function takes the following parameters:
//
//   - returnOnCancel: whether the task returns automatically when it is
//     cancelled.
//
// The function returns the following values:
//
//   - ok: TRUE if task's return-on-cancel flag was changed to match
//     return_on_cancel. FALSE if task has already been cancelled.
func (task *Task) SetReturnOnCancel(returnOnCancel bool) bool {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if returnOnCancel {
		_arg1 = C.TRUE
	}

	_cret = C.g_task_set_return_on_cancel(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(returnOnCancel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSourceTag sets task's source tag.
//
// You can use this to tag a task return value with a particular pointer
// (usually a pointer to the function doing the tagging) and then later check it
// using g_task_get_source_tag() (or g_async_result_is_tagged()) in the task's
// "finish" function, to figure out if the response came from a particular
// place.
//
// A macro wrapper around this function will automatically set the tasks name
// to the string form of source_tag if its not already set, for convenience.
//
// The function takes the following parameters:
//
//   - sourceTag (optional): opaque pointer indicating the source of this task.
func (task *Task) SetSourceTag(sourceTag unsafe.Pointer) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(sourceTag))

	C.g_task_set_source_tag(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(sourceTag)
}

// SetStaticName sets tasks name, used in debugging and profiling.
//
// This is a variant of g_task_set_name() that avoids copying name.
//
// The function takes the following parameters:
//
//   - name (optional): human readable name for the task. Must be a string
//     literal.
func (task *Task) SetStaticName(name string) {
	var _arg0 *C.GTask // out
	var _arg1 *C.gchar // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_task_set_static_name(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(name)
}

// TaskIsValid checks that result is a #GTask, and that source_object is its
// source object (or that source_object is NULL and result has no source
// object). This can be used in g_return_if_fail() checks.
//
// The function takes the following parameters:
//
//   - result: Result.
//   - sourceObject (optional): source object expected to be associated with the
//     task.
//
// The function returns the following values:
//
//   - ok: TRUE if result and source_object are valid, FALSE if not.
func TaskIsValid(result AsyncResulter, sourceObject *coreglib.Object) bool {
	var _arg1 C.gpointer // out
	var _arg2 C.gpointer // out
	var _cret C.gboolean // in

	_arg1 = *(*C.gpointer)(unsafe.Pointer(coreglib.InternObject(result).Native()))
	_arg2 = C.gpointer(unsafe.Pointer(sourceObject.Native()))

	_cret = C.g_task_is_valid(_arg1, _arg2)
	runtime.KeepAlive(result)
	runtime.KeepAlive(sourceObject)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TaskReportError creates a #GTask and then immediately calls
// g_task_return_error() on it. Use this in the wrapper function of an
// asynchronous method when you want to avoid even calling the virtual method.
// You can then use g_async_result_is_tagged() in the finish method wrapper to
// check if the result there is tagged as having been created by the wrapper
// method, and deal with it appropriately if so.
//
// See also g_task_report_new_error().
//
// The function takes the following parameters:
//
//   - sourceObject (optional) that owns this task, or NULL.
//   - callback (optional): ReadyCallback.
//   - sourceTag (optional): opaque pointer indicating the source of this task.
//   - err: error to report.
func TaskReportError(sourceObject *coreglib.Object, callback AsyncReadyCallback, sourceTag unsafe.Pointer, err error) {
	var _arg1 C.gpointer            // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer
	var _arg4 C.gpointer // out
	var _arg5 *C.GError  // out

	_arg1 = C.gpointer(unsafe.Pointer(sourceObject.Native()))
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(sourceTag))
	if err != nil {
		_arg5 = (*C.GError)(gerror.New(err))
	}

	C.g_task_report_error(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(sourceObject)
	runtime.KeepAlive(callback)
	runtime.KeepAlive(sourceTag)
	runtime.KeepAlive(err)
}

// TCPConnectionOverrides contains methods that are overridable.
type TCPConnectionOverrides struct {
}

func defaultTCPConnectionOverrides(v *TCPConnection) TCPConnectionOverrides {
	return TCPConnectionOverrides{}
}

// TCPConnection: this is the subclass of gio.SocketConnection that is created
// for TCP/IP sockets.
type TCPConnection struct {
	_ [0]func() // equal guard
	SocketConnection
}

var (
	_ IOStreamer = (*TCPConnection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TCPConnection, *TCPConnectionClass, TCPConnectionOverrides](
		GTypeTCPConnection,
		initTCPConnectionClass,
		wrapTCPConnection,
		defaultTCPConnectionOverrides,
	)
}

func initTCPConnectionClass(gclass unsafe.Pointer, overrides TCPConnectionOverrides, classInitFunc func(*TCPConnectionClass)) {
	if classInitFunc != nil {
		class := (*TCPConnectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTCPConnection(obj *coreglib.Object) *TCPConnection {
	return &TCPConnection{
		SocketConnection: SocketConnection{
			IOStream: IOStream{
				Object: obj,
			},
		},
	}
}

func marshalTCPConnection(p uintptr) (interface{}, error) {
	return wrapTCPConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GracefulDisconnect checks if graceful disconnects are used. See
// g_tcp_connection_set_graceful_disconnect().
//
// The function returns the following values:
//
//   - ok: TRUE if graceful disconnect is used on close, FALSE otherwise.
func (connection *TCPConnection) GracefulDisconnect() bool {
	var _arg0 *C.GTcpConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTcpConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_tcp_connection_get_graceful_disconnect(_arg0)
	runtime.KeepAlive(connection)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetGracefulDisconnect: this enables graceful disconnects on close. A graceful
// disconnect means that we signal the receiving end that the connection
// is terminated and wait for it to close the connection before closing the
// connection.
//
// A graceful disconnect means that we can be sure that we successfully sent all
// the outstanding data to the other end, or get an error reported. However,
// it also means we have to wait for all the data to reach the other side and
// for it to acknowledge this by closing the socket, which may take a while.
// For this reason it is disabled by default.
//
// The function takes the following parameters:
//
//   - gracefulDisconnect: whether to do graceful disconnects or not.
func (connection *TCPConnection) SetGracefulDisconnect(gracefulDisconnect bool) {
	var _arg0 *C.GTcpConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTcpConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	if gracefulDisconnect {
		_arg1 = C.TRUE
	}

	C.g_tcp_connection_set_graceful_disconnect(_arg0, _arg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(gracefulDisconnect)
}

// TCPWrapperConnectionOverrides contains methods that are overridable.
type TCPWrapperConnectionOverrides struct {
}

func defaultTCPWrapperConnectionOverrides(v *TCPWrapperConnection) TCPWrapperConnectionOverrides {
	return TCPWrapperConnectionOverrides{}
}

// TCPWrapperConnection: GTcpWrapperConnection can be used to wrap a
// gio.IOStream that is based on a gio.Socket, but which is not actually a
// gio.SocketConnection. This is used by gio.SocketClient so that it can always
// return a gio.SocketConnection, even when the connection it has actually
// created is not directly a gio.SocketConnection.
type TCPWrapperConnection struct {
	_ [0]func() // equal guard
	TCPConnection
}

var (
	_ IOStreamer = (*TCPWrapperConnection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TCPWrapperConnection, *TCPWrapperConnectionClass, TCPWrapperConnectionOverrides](
		GTypeTCPWrapperConnection,
		initTCPWrapperConnectionClass,
		wrapTCPWrapperConnection,
		defaultTCPWrapperConnectionOverrides,
	)
}

func initTCPWrapperConnectionClass(gclass unsafe.Pointer, overrides TCPWrapperConnectionOverrides, classInitFunc func(*TCPWrapperConnectionClass)) {
	if classInitFunc != nil {
		class := (*TCPWrapperConnectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTCPWrapperConnection(obj *coreglib.Object) *TCPWrapperConnection {
	return &TCPWrapperConnection{
		TCPConnection: TCPConnection{
			SocketConnection: SocketConnection{
				IOStream: IOStream{
					Object: obj,
				},
			},
		},
	}
}

func marshalTCPWrapperConnection(p uintptr) (interface{}, error) {
	return wrapTCPWrapperConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTCPWrapperConnection wraps base_io_stream and socket together as a
// Connection.
//
// The function takes the following parameters:
//
//   - baseIoStream to wrap.
//   - socket associated with base_io_stream.
//
// The function returns the following values:
//
//   - tcpWrapperConnection: new Connection.
func NewTCPWrapperConnection(baseIoStream IOStreamer, socket *Socket) *TCPWrapperConnection {
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GSocket           // out
	var _cret *C.GSocketConnection // in

	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(baseIoStream).Native()))
	_arg2 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_tcp_wrapper_connection_new(_arg1, _arg2)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(socket)

	var _tcpWrapperConnection *TCPWrapperConnection // out

	_tcpWrapperConnection = wrapTCPWrapperConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _tcpWrapperConnection
}

// BaseIOStream gets conn's base OStream.
//
// The function returns the following values:
//
//   - ioStream conn's base OStream.
func (conn *TCPWrapperConnection) BaseIOStream() IOStreamer {
	var _arg0 *C.GTcpWrapperConnection // out
	var _cret *C.GIOStream             // in

	_arg0 = (*C.GTcpWrapperConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tcp_wrapper_connection_get_base_io_stream(_arg0)
	runtime.KeepAlive(conn)

	var _ioStream IOStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IOStreamer)
			return ok
		})
		rv, ok := casted.(IOStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.IOStreamer")
		}
		_ioStream = rv
	}

	return _ioStream
}

// TestDBus: helper class for testing code which uses D-Bus without touching the
// users session bus.
//
// Note that GTestDBus modifies the users environment, calling setenv()
// (man:setenv(3)). This is not thread-safe, so all GTestDBus calls should be
// completed before threads are spawned, or should have appropriate locking to
// ensure no access conflicts to environment variables shared between GTestDBus
// and other threads.
//
// # Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// dont activate D-Bus services that are not yet installed into the target
// system. The GTestDBus object makes this easier for us by taking care of
// the lower level tasks such as running a private D-Bus daemon and looking up
// uninstalled services in customizable locations, typically in your source code
// tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a services subdirectory of your tests directory is a
// good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as my-server.service.in in the services
// directory and have it processed by configure.
//
//	[D-BUS Service]
//	Name=org.gtk.GDBus.Examples.ObjectManager
//	Exec=abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//	-DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
// Once you have a service definition file which is local to your source tree,
// you can proceed to set up a GTest fixture using the GTestDBus scaffolding.
//
// An example of a test fixture for D-Bus services
// can be found here: gdbus-test-fixture.c
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may
// need some additional modifications to your test case fixture. For example;
// if your service uses gio.Settings and installs a schema then it is important
// that your test service not load the schema in the ordinary installed location
// (chances are that your service and schema files are not yet installed,
// or worse; there is an older version of the schema file sitting in the install
// location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by GTestDBus
// and then in turn inherited by any services the D-Bus daemon activates,
// using the setup routine for your fixture is a practical place to help sandbox
// your runtime environment. For the rather typical GSettings case we can work
// around this by setting GSETTINGS_SCHEMA_DIR to the in tree directory holding
// your schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//	all-am:
//	        $(GLIB_COMPILE_SCHEMAS) .
//
//	CLEANFILES += gschemas.compiled.
type TestDBus struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TestDBus)(nil)
)

func wrapTestDBus(obj *coreglib.Object) *TestDBus {
	return &TestDBus{
		Object: obj,
	}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	return wrapTestDBus(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTestDBus: create a new DBus object.
//
// The function takes the following parameters:
//
//   - flags: DBusFlags.
//
// The function returns the following values:
//
//   - testDBus: new DBus.
func NewTestDBus(flags TestDBusFlags) *TestDBus {
	var _arg1 C.GTestDBusFlags // out
	var _cret *C.GTestDBus     // in

	_arg1 = C.GTestDBusFlags(flags)

	_cret = C.g_test_dbus_new(_arg1)
	runtime.KeepAlive(flags)

	var _testDBus *TestDBus // out

	_testDBus = wrapTestDBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testDBus
}

// AddServiceDir: add a path where dbus-daemon will look up .service files.
// This can't be called after g_test_dbus_up().
//
// The function takes the following parameters:
//
//   - path to a directory containing .service files.
func (self *TestDBus) AddServiceDir(path string) {
	var _arg0 *C.GTestDBus // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_test_dbus_add_service_dir(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(path)
}

// Down: stop the session bus started by g_test_dbus_up().
//
// This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
// to be destroyed. This is done to ensure that the next unit test won't get a
// leaked singleton from this test.
func (self *TestDBus) Down() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.g_test_dbus_down(_arg0)
	runtime.KeepAlive(self)
}

// BusAddress: get the address on which dbus-daemon is running. If
// g_test_dbus_up() has not been called yet, NULL is returned. This can be used
// with g_dbus_connection_new_for_address().
//
// The function returns the following values:
//
//   - utf8 (optional) address of the bus, or NULL.
func (self *TestDBus) BusAddress() string {
	var _arg0 *C.GTestDBus // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.g_test_dbus_get_bus_address(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Flags: get the flags of the DBus object.
//
// The function returns the following values:
//
//   - testDBusFlags: value of DBus:flags property.
func (self *TestDBus) Flags() TestDBusFlags {
	var _arg0 *C.GTestDBus     // out
	var _cret C.GTestDBusFlags // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.g_test_dbus_get_flags(_arg0)
	runtime.KeepAlive(self)

	var _testDBusFlags TestDBusFlags // out

	_testDBusFlags = TestDBusFlags(_cret)

	return _testDBusFlags
}

// Stop the session bus started by g_test_dbus_up().
//
// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests wanting
// to verify behaviour after the session bus has been stopped can use this
// function but should still call g_test_dbus_down() when done.
func (self *TestDBus) Stop() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.g_test_dbus_stop(_arg0)
	runtime.KeepAlive(self)
}

// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
// call, it is safe for unit tests to start sending messages on the session bus.
//
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
//
// If this function is called from unit test's main(), then g_test_dbus_down()
// must be called after g_test_run().
func (self *TestDBus) Up() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.g_test_dbus_up(_arg0)
	runtime.KeepAlive(self)
}

// TestDBusUnset: unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to
// ensure the test won't use user's session bus.
//
// This is useful for unit tests that want to verify behaviour when no session
// bus is running. It is not necessary to call this if unit test already calls
// g_test_dbus_up() before acquiring the session bus.
func TestDBusUnset() {
	C.g_test_dbus_unset()
}

// ThemedIcon: GThemedIcon is an implementation of gio.Icon that supports icon
// themes.
//
// GThemedIcon contains a list of all of the icons present in an icon theme,
// so that icons can be looked up quickly. GThemedIcon does not provide
// actual pixmaps for icons, just the icon names. Ideally something like
// gtk.IconTheme.ChooseIcon() should be used to resolve the list of names so
// that fallback icons work nicely with themes that inherit other themes.
type ThemedIcon struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Icon
}

var (
	_ coreglib.Objector = (*ThemedIcon)(nil)
)

func wrapThemedIcon(obj *coreglib.Object) *ThemedIcon {
	return &ThemedIcon{
		Object: obj,
		Icon: Icon{
			Object: obj,
		},
	}
}

func marshalThemedIcon(p uintptr) (interface{}, error) {
	return wrapThemedIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewThemedIcon creates a new themed icon for iconname.
//
// The function takes the following parameters:
//
//   - iconname: string containing an icon name.
//
// The function returns the following values:
//
//   - themedIcon: new Icon.
func NewThemedIcon(iconname string) *ThemedIcon {
	var _arg1 *C.char  // out
	var _cret *C.GIcon // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_themed_icon_new(_arg1)
	runtime.KeepAlive(iconname)

	var _themedIcon *ThemedIcon // out

	_themedIcon = wrapThemedIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _themedIcon
}

// NewThemedIconFromNames creates a new themed icon for iconnames.
//
// The function takes the following parameters:
//
//   - iconnames: array of strings containing icon names.
//
// The function returns the following values:
//
//   - themedIcon: new Icon.
func NewThemedIconFromNames(iconnames []string) *ThemedIcon {
	var _arg1 **C.char // out
	var _arg2 C.int
	var _cret *C.GIcon // in

	_arg2 = (C.int)(len(iconnames))
	_arg1 = (**C.char)(C.calloc(C.size_t(len(iconnames)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.char)(_arg1), len(iconnames))
		for i := range iconnames {
			out[i] = (*C.char)(unsafe.Pointer(C.CString(iconnames[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_themed_icon_new_from_names(_arg1, _arg2)
	runtime.KeepAlive(iconnames)

	var _themedIcon *ThemedIcon // out

	_themedIcon = wrapThemedIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _themedIcon
}

// NewThemedIconWithDefaultFallbacks creates a new themed icon for iconname, and
// all the names that can be created by shortening iconname at '-' characters.
//
// In the following example, icon1 and icon2 are equivalent:
//
//	const char *names[] = {
//	  "gnome-dev-cdrom-audio",
//	  "gnome-dev-cdrom",
//	  "gnome-dev",
//	  "gnome"
//	};
//
//	icon1 = g_themed_icon_new_from_names (names, 4);
//	icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");.
//
// The function takes the following parameters:
//
//   - iconname: string containing an icon name.
//
// The function returns the following values:
//
//   - themedIcon: new Icon.
func NewThemedIconWithDefaultFallbacks(iconname string) *ThemedIcon {
	var _arg1 *C.char  // out
	var _cret *C.GIcon // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_themed_icon_new_with_default_fallbacks(_arg1)
	runtime.KeepAlive(iconname)

	var _themedIcon *ThemedIcon // out

	_themedIcon = wrapThemedIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _themedIcon
}

// AppendName: append a name to the list of icons from within icon.
//
// Note that doing so invalidates the hash computed by prior calls to
// g_icon_hash().
//
// The function takes the following parameters:
//
//   - iconname: name of icon to append to list of icons from within icon.
func (icon *ThemedIcon) AppendName(iconname string) {
	var _arg0 *C.GThemedIcon // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GThemedIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_themed_icon_append_name(_arg0, _arg1)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(iconname)
}

// Names gets the names of icons from within icon.
//
// The function returns the following values:
//
//   - utf8s: list of icon names.
func (icon *ThemedIcon) Names() []string {
	var _arg0 *C.GThemedIcon // out
	var _cret **C.gchar      // in

	_arg0 = (*C.GThemedIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_themed_icon_get_names(_arg0)
	runtime.KeepAlive(icon)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// PrependName: prepend a name to the list of icons from within icon.
//
// Note that doing so invalidates the hash computed by prior calls to
// g_icon_hash().
//
// The function takes the following parameters:
//
//   - iconname: name of icon to prepend to list of icons from within icon.
func (icon *ThemedIcon) PrependName(iconname string) {
	var _arg0 *C.GThemedIcon // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GThemedIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_themed_icon_prepend_name(_arg0, _arg1)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(iconname)
}

// ThreadedResolver is an implementation of #GResolver which calls the libc
// lookup functions in threads to allow them to run asynchronously.
type ThreadedResolver struct {
	_ [0]func() // equal guard
	Resolver
}

var (
	_ Resolverer = (*ThreadedResolver)(nil)
)

func wrapThreadedResolver(obj *coreglib.Object) *ThreadedResolver {
	return &ThreadedResolver{
		Resolver: Resolver{
			Object: obj,
		},
	}
}

// ThreadedSocketServiceOverrides contains methods that are overridable.
type ThreadedSocketServiceOverrides struct {
	// The function takes the following parameters:
	//
	//   - connection
	//   - sourceObject
	Run func(connection *SocketConnection, sourceObject *coreglib.Object) bool
}

func defaultThreadedSocketServiceOverrides(v *ThreadedSocketService) ThreadedSocketServiceOverrides {
	return ThreadedSocketServiceOverrides{
		Run: v.run,
	}
}

// ThreadedSocketService: GThreadedSocketService is a simple subclass
// of gio.SocketService that handles incoming connections by creating
// a worker thread and dispatching the connection to it by emitting the
// gio.ThreadedSocketService::run signal in the new thread.
//
// The signal handler may perform blocking I/O and need not return until the
// connection is closed.
//
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the gio.SocketService from accepting new connections when all threads
// are busy.
//
// As with gio.SocketService, you may connect to gio.ThreadedSocketService::run,
// or subclass and override the default handler.
type ThreadedSocketService struct {
	_ [0]func() // equal guard
	SocketService
}

var (
	_ coreglib.Objector = (*ThreadedSocketService)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ThreadedSocketService, *ThreadedSocketServiceClass, ThreadedSocketServiceOverrides](
		GTypeThreadedSocketService,
		initThreadedSocketServiceClass,
		wrapThreadedSocketService,
		defaultThreadedSocketServiceOverrides,
	)
}

func initThreadedSocketServiceClass(gclass unsafe.Pointer, overrides ThreadedSocketServiceOverrides, classInitFunc func(*ThreadedSocketServiceClass)) {
	pclass := (*C.GThreadedSocketServiceClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeThreadedSocketService))))

	if overrides.Run != nil {
		pclass.run = (*[0]byte)(C._gotk4_gio2_ThreadedSocketServiceClass_run)
	}

	if classInitFunc != nil {
		class := (*ThreadedSocketServiceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapThreadedSocketService(obj *coreglib.Object) *ThreadedSocketService {
	return &ThreadedSocketService{
		SocketService: SocketService{
			SocketListener: SocketListener{
				Object: obj,
			},
		},
	}
}

func marshalThreadedSocketService(p uintptr) (interface{}, error) {
	return wrapThreadedSocketService(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRun signal is emitted in a worker thread in response to an incoming
// connection. This thread is dedicated to handling connection and may perform
// blocking IO. The signal handler need not return until the connection is
// closed.
func (v *ThreadedSocketService) ConnectRun(f func(connection *SocketConnection, sourceObject *coreglib.Object) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "run", false, unsafe.Pointer(C._gotk4_gio2_ThreadedSocketService_ConnectRun), f)
}

// NewThreadedSocketService creates a new SocketService with no listeners.
// Listeners must be added with one of the Listener "add" methods.
//
// The function takes the following parameters:
//
//   - maxThreads: maximal number of threads to execute concurrently handling
//     incoming clients, -1 means no limit.
//
// The function returns the following values:
//
//   - threadedSocketService: new Service.
func NewThreadedSocketService(maxThreads int) *ThreadedSocketService {
	var _arg1 C.int             // out
	var _cret *C.GSocketService // in

	_arg1 = C.int(maxThreads)

	_cret = C.g_threaded_socket_service_new(_arg1)
	runtime.KeepAlive(maxThreads)

	var _threadedSocketService *ThreadedSocketService // out

	_threadedSocketService = wrapThreadedSocketService(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _threadedSocketService
}

// The function takes the following parameters:
//
//   - connection
//   - sourceObject
func (service *ThreadedSocketService) run(connection *SocketConnection, sourceObject *coreglib.Object) bool {
	gclass := (*C.GThreadedSocketServiceClass)(coreglib.PeekParentClass(service))
	fnarg := gclass.run

	var _arg0 *C.GThreadedSocketService // out
	var _arg1 *C.GSocketConnection      // out
	var _arg2 *C.GObject                // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GThreadedSocketService)(unsafe.Pointer(coreglib.InternObject(service).Native()))
	_arg1 = (*C.GSocketConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	_cret = C._gotk4_gio2_ThreadedSocketService_virtual_run(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(service)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(sourceObject)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TLSCertificateOverrides contains methods that are overridable.
type TLSCertificateOverrides struct {
	// Verify: this verifies cert and returns a set of CertificateFlags
	// indicating any problems found with it. This can be used to verify a
	// certificate outside the context of making a connection, or to check a
	// certificate against a CA that is not part of the system CA database.
	//
	// If cert is valid, G_TLS_CERTIFICATE_NO_FLAGS is returned.
	//
	// If identity is not NULL, cert's name(s) will be compared against it,
	// and G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it
	// does not match. If identity is NULL, that bit will never be set in the
	// return value.
	//
	// If trusted_ca is not NULL, then cert (or one of the certificates in its
	// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will
	// be set in the return value. If trusted_ca is NULL, that bit will never be
	// set in the return value.
	//
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee that
	// all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would be
	// incorrect to mask G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
	// certificates, because this could potentially be the only error flag set
	// even if other problems exist with the certificate.
	//
	// Because TLS session context is not used, Certificate may not perform
	// as many checks on the certificates as Connection would. For example,
	// certificate constraints may not be honored, and revocation checks may
	// not be performed. The best way to verify TLS certificates used by a TLS
	// connection is to let Connection handle the verification.
	//
	// The function takes the following parameters:
	//
	//   - identity (optional): expected peer identity.
	//   - trustedCa (optional): certificate of a trusted authority.
	//
	// The function returns the following values:
	//
	//   - tlsCertificateFlags: appropriate CertificateFlags.
	Verify func(identity SocketConnectabler, trustedCa TLSCertificater) TLSCertificateFlags
}

func defaultTLSCertificateOverrides(v *TLSCertificate) TLSCertificateOverrides {
	return TLSCertificateOverrides{
		Verify: v.verify,
	}
}

// TLSCertificate: certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate received
// by a client from a server), or the combination of a certificate and a private
// key (which is needed when acting as a gio.TLSServerConnection).
type TLSCertificate struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TLSCertificate)(nil)
)

// TLSCertificater describes types inherited from class TLSCertificate.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type TLSCertificater interface {
	coreglib.Objector
	baseTLSCertificate() *TLSCertificate
}

var _ TLSCertificater = (*TLSCertificate)(nil)

func init() {
	coreglib.RegisterClassInfo[*TLSCertificate, *TLSCertificateClass, TLSCertificateOverrides](
		GTypeTLSCertificate,
		initTLSCertificateClass,
		wrapTLSCertificate,
		defaultTLSCertificateOverrides,
	)
}

func initTLSCertificateClass(gclass unsafe.Pointer, overrides TLSCertificateOverrides, classInitFunc func(*TLSCertificateClass)) {
	pclass := (*C.GTlsCertificateClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTLSCertificate))))

	if overrides.Verify != nil {
		pclass.verify = (*[0]byte)(C._gotk4_gio2_TlsCertificateClass_verify)
	}

	if classInitFunc != nil {
		class := (*TLSCertificateClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTLSCertificate(obj *coreglib.Object) *TLSCertificate {
	return &TLSCertificate{
		Object: obj,
	}
}

func marshalTLSCertificate(p uintptr) (interface{}, error) {
	return wrapTLSCertificate(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (cert *TLSCertificate) baseTLSCertificate() *TLSCertificate {
	return cert
}

// BaseTLSCertificate returns the underlying base object.
func BaseTLSCertificate(obj TLSCertificater) *TLSCertificate {
	return obj.baseTLSCertificate()
}

// NewTLSCertificateFromFile creates a Certificate from the data in file.
//
// As of 2.72, if the filename ends in .p12 or .pfx the data is loaded
// by g_tls_certificate_new_from_pkcs12() otherwise it is loaded by
// g_tls_certificate_new_from_pem(). See those functions for exact details.
//
// If file cannot be read or parsed, the function will return NULL and set
// error.
//
// The function takes the following parameters:
//
//   - file containing a certificate to import.
//
// The function returns the following values:
//
//   - tlsCertificate: new certificate, or NULL on error.
func NewTLSCertificateFromFile(file string) (*TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_tls_certificate_new_from_file(_arg1, &_cerr)
	runtime.KeepAlive(file)

	var _tlsCertificate *TLSCertificate // out
	var _goerr error                    // out

	_tlsCertificate = wrapTLSCertificate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromFileWithPassword creates a Certificate from the data in
// file.
//
// If file cannot be read or parsed, the function will return NULL and set
// error.
//
// Any unknown file types will error with G_IO_ERROR_NOT_SUPPORTED.
// Currently only .p12 and .pfx files are supported. See
// g_tls_certificate_new_from_pkcs12() for more details.
//
// The function takes the following parameters:
//
//   - file containing a certificate to import.
//   - password for PKCS #12 files.
//
// The function returns the following values:
//
//   - tlsCertificate: new certificate, or NULL on error.
func NewTLSCertificateFromFileWithPassword(file, password string) (*TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_tls_certificate_new_from_file_with_password(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(password)

	var _tlsCertificate *TLSCertificate // out
	var _goerr error                    // out

	_tlsCertificate = wrapTLSCertificate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromFiles creates a Certificate from the PEM-encoded
// data in cert_file and key_file. The returned certificate will be the first
// certificate found in cert_file. As of GLib 2.44, if cert_file contains more
// certificates it will try to load a certificate chain. All certificates will
// be verified in the order found (top-level certificate should be the last one
// in the file) and the Certificate:issuer property of each certificate will be
// set accordingly if the verification succeeds. If any certificate in the chain
// cannot be verified, the first certificate in the file will still be returned.
//
// If either file cannot be read or parsed, the function will return NULL and
// set error. Otherwise, this behaves like g_tls_certificate_new_from_pem().
//
// The function takes the following parameters:
//
//   - certFile: file containing one or more PEM-encoded certificates to import.
//   - keyFile: file containing a PEM-encoded private key to import.
//
// The function returns the following values:
//
//   - tlsCertificate: new certificate, or NULL on error.
func NewTLSCertificateFromFiles(certFile, keyFile string) (*TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(certFile)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(keyFile)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_tls_certificate_new_from_files(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(certFile)
	runtime.KeepAlive(keyFile)

	var _tlsCertificate *TLSCertificate // out
	var _goerr error                    // out

	_tlsCertificate = wrapTLSCertificate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromPem creates a Certificate from the PEM-encoded
// data in data. If data includes both a certificate and a private key,
// then the returned certificate will include the private key data as well.
// (See the Certificate:private-key-pem property for information about supported
// formats.)
//
// The returned certificate will be the first certificate found in data.
// As of GLib 2.44, if data contains more certificates it will try to load
// a certificate chain. All certificates will be verified in the order
// found (top-level certificate should be the last one in the file) and the
// Certificate:issuer property of each certificate will be set accordingly
// if the verification succeeds. If any certificate in the chain cannot be
// verified, the first certificate in the file will still be returned.
//
// The function takes the following parameters:
//
//   - data: PEM-encoded certificate data.
//
// The function returns the following values:
//
//   - tlsCertificate: new certificate, or NULL if data is invalid.
func NewTLSCertificateFromPem(data string) (*TLSCertificate, error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg2 = (C.gssize)(len(data))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(data) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(data)), data)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_tls_certificate_new_from_pem(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(data)

	var _tlsCertificate *TLSCertificate // out
	var _goerr error                    // out

	_tlsCertificate = wrapTLSCertificate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromPKCS11URIs creates a Certificate from a PKCS \#11
// (https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
// URI.
//
// An example pkcs11_uri would be
// pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01
//
// Where the tokens layout is:
//
//	Object 0:
//	  URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=private20key;type=private
//	  Type: Private key (RSA-2048)
//	  ID: 01
//
//	Object 1:
//	  URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=Certificate20for20Authentication;type=cert
//	  Type: X.509 Certificate (RSA-2048)
//	  ID: 01
//
// In this case the certificate and private key would both be detected and used
// as expected. pkcs_uri may also just reference an X.509 certificate object and
// then optionally private_key_pkcs11_uri allows using a private key exposed
// under a different URI.
//
// Note that the private key is not accessed until usage and may fail or require
// a PIN later.
//
// The function takes the following parameters:
//
//   - pkcs11Uri: PKCS \#11 URI.
//   - privateKeyPkcs11Uri (optional): PKCS \#11 URI.
//
// The function returns the following values:
//
//   - tlsCertificate: new certificate, or NULL on error.
func NewTLSCertificateFromPKCS11URIs(pkcs11Uri, privateKeyPkcs11Uri string) (*TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pkcs11Uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if privateKeyPkcs11Uri != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(privateKeyPkcs11Uri)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_tls_certificate_new_from_pkcs11_uris(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(pkcs11Uri)
	runtime.KeepAlive(privateKeyPkcs11Uri)

	var _tlsCertificate *TLSCertificate // out
	var _goerr error                    // out

	_tlsCertificate = wrapTLSCertificate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// NewTLSCertificateFromPKCS12 creates a Certificate from the data in data.
// It must contain a certificate and matching private key.
//
// If extra certificates are included they will be verified as a chain and the
// Certificate:issuer property will be set. All other data will be ignored.
//
// You can pass as single password for all of the data which will be used both
// for the PKCS #12 container as well as encrypted private keys. If decryption
// fails it will error with G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.
//
// This constructor requires support in the current Backend. If support is
// missing it will error with G_IO_ERROR_NOT_SUPPORTED.
//
// Other parsing failures will error with G_TLS_ERROR_BAD_CERTIFICATE.
//
// The function takes the following parameters:
//
//   - data: DER-encoded PKCS #12 format certificate data.
//   - password (optional): optional password for encrypted certificate data.
//
// The function returns the following values:
//
//   - tlsCertificate: new certificate, or NULL if data is invalid.
func NewTLSCertificateFromPKCS12(data []byte, password string) (*TLSCertificate, error) {
	var _arg1 *C.guint8 // out
	var _arg2 C.gsize
	var _arg3 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg2 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	if password != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_tls_certificate_new_from_pkcs12(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(data)
	runtime.KeepAlive(password)

	var _tlsCertificate *TLSCertificate // out
	var _goerr error                    // out

	_tlsCertificate = wrapTLSCertificate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// Issuer gets the Certificate representing cert's issuer, if known.
//
// The function returns the following values:
//
//   - tlsCertificate (optional): certificate of cert's issuer, or NULL if cert
//     is self-signed or signed with an unknown certificate.
func (cert *TLSCertificate) Issuer() TLSCertificater {
	var _arg0 *C.GTlsCertificate // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(cert).Native()))

	_cret = C.g_tls_certificate_get_issuer(_arg0)
	runtime.KeepAlive(cert)

	var _tlsCertificate TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// IssuerName returns the issuer name from the certificate.
//
// The function returns the following values:
//
//   - utf8 (optional): issuer name, or NULL if it's not available.
func (cert *TLSCertificate) IssuerName() string {
	var _arg0 *C.GTlsCertificate // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(cert).Native()))

	_cret = C.g_tls_certificate_get_issuer_name(_arg0)
	runtime.KeepAlive(cert)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// NotValidAfter returns the time at which the certificate became or will become
// invalid.
//
// The function returns the following values:
//
//   - dateTime (optional): not-valid-after date, or NULL if it's not available.
func (cert *TLSCertificate) NotValidAfter() *glib.DateTime {
	var _arg0 *C.GTlsCertificate // out
	var _cret *C.GDateTime       // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(cert).Native()))

	_cret = C.g_tls_certificate_get_not_valid_after(_arg0)
	runtime.KeepAlive(cert)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NotValidBefore returns the time at which the certificate became or will
// become valid.
//
// The function returns the following values:
//
//   - dateTime (optional): not-valid-before date, or NULL if it's not
//     available.
func (cert *TLSCertificate) NotValidBefore() *glib.DateTime {
	var _arg0 *C.GTlsCertificate // out
	var _cret *C.GDateTime       // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(cert).Native()))

	_cret = C.g_tls_certificate_get_not_valid_before(_arg0)
	runtime.KeepAlive(cert)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// SubjectName returns the subject name from the certificate.
//
// The function returns the following values:
//
//   - utf8 (optional): subject name, or NULL if it's not available.
func (cert *TLSCertificate) SubjectName() string {
	var _arg0 *C.GTlsCertificate // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(cert).Native()))

	_cret = C.g_tls_certificate_get_subject_name(_arg0)
	runtime.KeepAlive(cert)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// IsSame: check if two Certificate objects represent the same certificate.
// The raw DER byte data of the two certificates are checked for equality.
// This has the effect that two certificates may compare equal even if their
// Certificate:issuer, Certificate:private-key, or Certificate:private-key-pem
// properties differ.
//
// The function takes the following parameters:
//
//   - certTwo: second certificate to compare.
//
// The function returns the following values:
//
//   - ok: whether the same or not.
func (certOne *TLSCertificate) IsSame(certTwo TLSCertificater) bool {
	var _arg0 *C.GTlsCertificate // out
	var _arg1 *C.GTlsCertificate // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certOne).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certTwo).Native()))

	_cret = C.g_tls_certificate_is_same(_arg0, _arg1)
	runtime.KeepAlive(certOne)
	runtime.KeepAlive(certTwo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Verify: this verifies cert and returns a set of CertificateFlags indicating
// any problems found with it. This can be used to verify a certificate outside
// the context of making a connection, or to check a certificate against a CA
// that is not part of the system CA database.
//
// If cert is valid, G_TLS_CERTIFICATE_NO_FLAGS is returned.
//
// If identity is not NULL, cert's name(s) will be compared against it, and
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it does not
// match. If identity is NULL, that bit will never be set in the return value.
//
// If trusted_ca is not NULL, then cert (or one of the certificates in its
// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will be set
// in the return value. If trusted_ca is NULL, that bit will never be set in the
// return value.
//
// GLib guarantees that if certificate verification fails, at least one error
// will be set in the return value, but it does not guarantee that all possible
// errors will be set. Accordingly, you may not safely decide to ignore any
// particular type of error. For example, it would be incorrect to mask
// G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates, because
// this could potentially be the only error flag set even if other problems
// exist with the certificate.
//
// Because TLS session context is not used, Certificate may not perform as many
// checks on the certificates as Connection would. For example, certificate
// constraints may not be honored, and revocation checks may not be performed.
// The best way to verify TLS certificates used by a TLS connection is to let
// Connection handle the verification.
//
// The function takes the following parameters:
//
//   - identity (optional): expected peer identity.
//   - trustedCa (optional): certificate of a trusted authority.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: appropriate CertificateFlags.
func (cert *TLSCertificate) Verify(identity SocketConnectabler, trustedCa TLSCertificater) TLSCertificateFlags {
	var _arg0 *C.GTlsCertificate     // out
	var _arg1 *C.GSocketConnectable  // out
	var _arg2 *C.GTlsCertificate     // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(cert).Native()))
	if identity != nil {
		_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))
	}
	if trustedCa != nil {
		_arg2 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(trustedCa).Native()))
	}

	_cret = C.g_tls_certificate_verify(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cert)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(trustedCa)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// Verify: this verifies cert and returns a set of CertificateFlags indicating
// any problems found with it. This can be used to verify a certificate outside
// the context of making a connection, or to check a certificate against a CA
// that is not part of the system CA database.
//
// If cert is valid, G_TLS_CERTIFICATE_NO_FLAGS is returned.
//
// If identity is not NULL, cert's name(s) will be compared against it, and
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it does not
// match. If identity is NULL, that bit will never be set in the return value.
//
// If trusted_ca is not NULL, then cert (or one of the certificates in its
// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will be set
// in the return value. If trusted_ca is NULL, that bit will never be set in the
// return value.
//
// GLib guarantees that if certificate verification fails, at least one error
// will be set in the return value, but it does not guarantee that all possible
// errors will be set. Accordingly, you may not safely decide to ignore any
// particular type of error. For example, it would be incorrect to mask
// G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates, because
// this could potentially be the only error flag set even if other problems
// exist with the certificate.
//
// Because TLS session context is not used, Certificate may not perform as many
// checks on the certificates as Connection would. For example, certificate
// constraints may not be honored, and revocation checks may not be performed.
// The best way to verify TLS certificates used by a TLS connection is to let
// Connection handle the verification.
//
// The function takes the following parameters:
//
//   - identity (optional): expected peer identity.
//   - trustedCa (optional): certificate of a trusted authority.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: appropriate CertificateFlags.
func (cert *TLSCertificate) verify(identity SocketConnectabler, trustedCa TLSCertificater) TLSCertificateFlags {
	gclass := (*C.GTlsCertificateClass)(coreglib.PeekParentClass(cert))
	fnarg := gclass.verify

	var _arg0 *C.GTlsCertificate     // out
	var _arg1 *C.GSocketConnectable  // out
	var _arg2 *C.GTlsCertificate     // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(cert).Native()))
	if identity != nil {
		_arg1 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))
	}
	if trustedCa != nil {
		_arg2 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(trustedCa).Native()))
	}

	_cret = C._gotk4_gio2_TLSCertificate_virtual_verify(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(cert)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(trustedCa)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// TLSCertificateListNewFromFile creates one or more Certificates from the
// PEM-encoded data in file. If file cannot be read or parsed, the function
// will return NULL and set error. If file does not contain any PEM-encoded
// certificates, this will return an empty list and not set error.
//
// The function takes the following parameters:
//
//   - file containing PEM-encoded certificates to import.
//
// The function returns the following values:
//
//   - list: a #GList containing Certificate objects. You must free the list and
//     its contents when you are done with it.
func TLSCertificateListNewFromFile(file string) ([]TLSCertificater, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.GList  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_tls_certificate_list_new_from_file(_arg1, &_cerr)
	runtime.KeepAlive(file)

	var _list []TLSCertificater // out
	var _goerr error            // out

	_list = make([]TLSCertificater, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GTlsCertificate)(v)
		var dst TLSCertificater // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.TLSCertificater is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// TLSConnectionOverrides contains methods that are overridable.
type TLSConnectionOverrides struct {
	// AcceptCertificate: check whether to accept a certificate.
	//
	// The function takes the following parameters:
	//
	//   - peerCert
	//   - errors
	AcceptCertificate func(peerCert TLSCertificater, errors TLSCertificateFlags) bool
	// BindingData: retrieve TLS channel binding data (Since: 2.66).
	//
	// The function takes the following parameters:
	//
	//   - typ
	//   - data
	BindingData func(typ TLSChannelBindingType, data []byte) error
	// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	//
	// If the peer did not use the ALPN extension, or did not advertise
	// a protocol that matched one of conn's protocols, or the TLS
	// backend does not support ALPN, then this will be NULL. See
	// g_tls_connection_set_advertised_protocols().
	//
	// The function returns the following values:
	//
	//   - utf8 (optional): negotiated protocol, or NULL.
	NegotiatedProtocol func() string
	// Handshake attempts a TLS handshake on conn.
	//
	// On the client side, it is never necessary to call this method; although
	// the connection needs to perform a handshake after connecting (or after
	// sending a "STARTTLS"-type command), Connection will handle this for you
	// automatically when you try to send or receive data on the connection.
	// You can call g_tls_connection_handshake() manually if you want to
	// know whether the initial handshake succeeded or failed (as opposed to
	// just immediately trying to use conn to read or write, in which case,
	// if it fails, it may not be possible to tell if it failed before or
	// after completing the handshake), but beware that servers may reject
	// client authentication after the handshake has completed, so a successful
	// handshake does not indicate the connection will be usable.
	//
	// Likewise, on the server side, although a handshake is necessary at the
	// beginning of the communication, you do not need to call this function
	// explicitly unless you want clearer error reporting.
	//
	// Previously, calling g_tls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was deprecated
	// in GLib 2.60 because rehandshaking was removed from the TLS protocol
	// in TLS 1.3. Since GLib 2.64, calling this function after the initial
	// handshake will no longer do anything.
	//
	// When using a Connection created by Client, the Client performs the
	// initial handshake, so calling this function manually is not recommended.
	//
	// Connection::accept_certificate may be emitted during the handshake.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	Handshake func(ctx context.Context) error
	// HandshakeFinish: finish an asynchronous TLS handshake operation.
	// See g_tls_connection_handshake() for more information.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	HandshakeFinish func(result AsyncResulter) error
}

func defaultTLSConnectionOverrides(v *TLSConnection) TLSConnectionOverrides {
	return TLSConnectionOverrides{
		AcceptCertificate:  v.acceptCertificate,
		BindingData:        v.bindingData,
		NegotiatedProtocol: v.negotiatedProtocol,
		Handshake:          v.handshake,
		HandshakeFinish:    v.handshakeFinish,
	}
}

// TLSConnection: GTlsConnection is the base TLS connection class type,
// which wraps a gio.IOStream and provides TLS encryption on top of it. Its
// subclasses, gio.TLSClientConnection and gio.TLSServerConnection, implement
// client-side and server-side TLS, respectively.
//
// For DTLS (Datagram TLS) support, see gio.DTLSConnection.
type TLSConnection struct {
	_ [0]func() // equal guard
	IOStream
}

var (
	_ IOStreamer = (*TLSConnection)(nil)
)

// TLSConnectioner describes types inherited from class TLSConnection.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type TLSConnectioner interface {
	coreglib.Objector
	baseTLSConnection() *TLSConnection
}

var _ TLSConnectioner = (*TLSConnection)(nil)

func init() {
	coreglib.RegisterClassInfo[*TLSConnection, *TLSConnectionClass, TLSConnectionOverrides](
		GTypeTLSConnection,
		initTLSConnectionClass,
		wrapTLSConnection,
		defaultTLSConnectionOverrides,
	)
}

func initTLSConnectionClass(gclass unsafe.Pointer, overrides TLSConnectionOverrides, classInitFunc func(*TLSConnectionClass)) {
	pclass := (*C.GTlsConnectionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTLSConnection))))

	if overrides.AcceptCertificate != nil {
		pclass.accept_certificate = (*[0]byte)(C._gotk4_gio2_TlsConnectionClass_accept_certificate)
	}

	if overrides.BindingData != nil {
		pclass.get_binding_data = (*[0]byte)(C._gotk4_gio2_TlsConnectionClass_get_binding_data)
	}

	if overrides.NegotiatedProtocol != nil {
		pclass.get_negotiated_protocol = (*[0]byte)(C._gotk4_gio2_TlsConnectionClass_get_negotiated_protocol)
	}

	if overrides.Handshake != nil {
		pclass.handshake = (*[0]byte)(C._gotk4_gio2_TlsConnectionClass_handshake)
	}

	if overrides.HandshakeFinish != nil {
		pclass.handshake_finish = (*[0]byte)(C._gotk4_gio2_TlsConnectionClass_handshake_finish)
	}

	if classInitFunc != nil {
		class := (*TLSConnectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTLSConnection(obj *coreglib.Object) *TLSConnection {
	return &TLSConnection{
		IOStream: IOStream{
			Object: obj,
		},
	}
}

func marshalTLSConnection(p uintptr) (interface{}, error) {
	return wrapTLSConnection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (conn *TLSConnection) baseTLSConnection() *TLSConnection {
	return conn
}

// BaseTLSConnection returns the underlying base object.
func BaseTLSConnection(obj TLSConnectioner) *TLSConnection {
	return obj.baseTLSConnection()
}

// ConnectAcceptCertificate is emitted during the TLS handshake after the peer
// certificate has been received. You can examine peer_cert's certification path
// by calling g_tls_certificate_get_issuer() on it.
//
// For a client-side connection, peer_cert is the server's certificate,
// and the signal will only be emitted if the certificate was not acceptable
// according to conn's ClientConnection:validation_flags. If you would like
// the certificate to be accepted despite errors, return TRUE from the signal
// handler. Otherwise, if no handler accepts the certificate, the handshake will
// fail with G_TLS_ERROR_BAD_CERTIFICATE.
//
// GLib guarantees that if certificate verification fails, this signal will
// be emitted with at least one error will be set in errors, but it does not
// guarantee that all possible errors will be set. Accordingly, you may not
// safely decide to ignore any particular type of error. For example, it would
// be incorrect to ignore G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
// certificates, because this could potentially be the only error flag set even
// if other problems exist with the certificate.
//
// For a server-side connection, peer_cert is the certificate
// presented by the client, if this was requested via the server's
// ServerConnection:authentication_mode. On the server side, the signal is
// always emitted when the client presents a certificate, and the certificate
// will only be accepted if a handler returns TRUE.
//
// Note that if this signal is emitted as part of asynchronous I/O in the
// main thread, then you should not attempt to interact with the user before
// returning from the signal handler. If you want to let the user decide whether
// or not to accept the certificate, you would have to return FALSE from the
// signal handler on the first attempt, and then after the connection attempt
// returns a G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user,
// and if the user decides to accept the certificate, remember that fact, create
// a new connection, and return TRUE from the signal handler the next time.
//
// If you are doing I/O in another thread, you do not need to worry about this,
// and can simply block in the signal handler until the UI thread returns an
// answer.
func (conn *TLSConnection) ConnectAcceptCertificate(f func(peerCert TLSCertificater, errors TLSCertificateFlags) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(conn, "accept-certificate", false, unsafe.Pointer(C._gotk4_gio2_TlsConnection_ConnectAcceptCertificate), f)
}

// EmitAcceptCertificate: used by Connection implementations to emit the
// Connection::accept-certificate signal.
//
// The function takes the following parameters:
//
//   - peerCert peer's Certificate.
//   - errors problems with peer_cert.
//
// The function returns the following values:
//
//   - ok: TRUE if one of the signal handlers has returned TRUE to accept
//     peer_cert.
func (conn *TLSConnection) EmitAcceptCertificate(peerCert TLSCertificater, errors TLSCertificateFlags) bool {
	var _arg0 *C.GTlsConnection      // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(peerCert).Native()))
	_arg2 = C.GTlsCertificateFlags(errors)

	_cret = C.g_tls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Certificate gets conn's certificate, as set by
// g_tls_connection_set_certificate().
//
// The function returns the following values:
//
//   - tlsCertificate (optional) conn's certificate, or NULL.
func (conn *TLSConnection) Certificate() TLSCertificater {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_certificate(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificate TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// ChannelBindingData: query the TLS backend for TLS channel binding data of
// type for conn.
//
// This call retrieves TLS channel binding data as specified
// in RFC 5056 (https://tools.ietf.org/html/rfc5056), RFC 5929
// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding
// data is returned in data. The data is resized by the callee using
// Array buffer management and will be freed when the data is destroyed by
// g_byte_array_unref(). If data is NULL, it will only check whether TLS
// backend is able to fetch the data (e.g. whether type is supported by the
// TLS backend). It does not guarantee that the data will be available though.
// That could happen if TLS connection does not support type or the binding data
// is not available yet due to additional negotiation or input required.
//
// The function takes the following parameters:
//
//   - typ type of data to fetch.
//
// The function returns the following values:
//
//   - data (optional) is filled with the binding data, or NULL.
func (conn *TLSConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
	var _arg0 *C.GTlsConnection        // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 C.GByteArray             // in
	var _cerr *C.GError                // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsChannelBindingType(typ)

	C.g_tls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(typ)

	var _data []byte // out
	var _goerr error // out

	_data = make([]byte, _arg2.len)
	copy(_data, unsafe.Slice((*byte)(_arg2.data), _arg2.len))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _data, _goerr
}

// CiphersuiteName returns the name of the current TLS ciphersuite, or NULL if
// the connection has not handshaked or has been closed. Beware that the TLS
// backend may use any of multiple different naming conventions, because OpenSSL
// and GnuTLS have their own ciphersuite naming conventions that are different
// from each other and different from the standard, IANA- registered ciphersuite
// names. The ciphersuite name is intended to be displayed to the user for
// informative purposes only, and parsing it is not recommended.
//
// The function returns the following values:
//
//   - utf8 (optional): name of the current TLS ciphersuite, or NULL.
func (conn *TLSConnection) CiphersuiteName() string {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_ciphersuite_name(_arg0)
	runtime.KeepAlive(conn)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Database gets the certificate database that conn uses to verify peer
// certificates. See g_tls_connection_set_database().
//
// The function returns the following values:
//
//   - tlsDatabase (optional): certificate database that conn uses or NULL.
func (conn *TLSConnection) Database() TLSDatabaser {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.GTlsDatabase   // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_database(_arg0)
	runtime.KeepAlive(conn)

	var _tlsDatabase TLSDatabaser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSDatabaser)
				return ok
			})
			rv, ok := casted.(TLSDatabaser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
			}
			_tlsDatabase = rv
		}
	}

	return _tlsDatabase
}

// Interaction: get the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords. If NULL is
// returned, then no user interaction will occur for this connection.
//
// The function returns the following values:
//
//   - tlsInteraction (optional): interaction object.
func (conn *TLSConnection) Interaction() *TLSInteraction {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_interaction(_arg0)
	runtime.KeepAlive(conn)

	var _tlsInteraction *TLSInteraction // out

	if _cret != nil {
		_tlsInteraction = wrapTLSInteraction(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _tlsInteraction
}

// NegotiatedProtocol gets the name of the application-layer protocol negotiated
// during the handshake.
//
// If the peer did not use the ALPN extension, or did not advertise
// a protocol that matched one of conn's protocols, or the TLS
// backend does not support ALPN, then this will be NULL. See
// g_tls_connection_set_advertised_protocols().
//
// The function returns the following values:
//
//   - utf8 (optional): negotiated protocol, or NULL.
func (conn *TLSConnection) NegotiatedProtocol() string {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_negotiated_protocol(_arg0)
	runtime.KeepAlive(conn)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PeerCertificate gets conn's peer's certificate after the handshake
// has completed or failed. (It is not set during the emission of
// Connection::accept-certificate.).
//
// The function returns the following values:
//
//   - tlsCertificate (optional) conn's peer's certificate, or NULL.
func (conn *TLSConnection) PeerCertificate() TLSCertificater {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_peer_certificate(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificate TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// PeerCertificateErrors gets the errors associated with validating conn's
// peer's certificate, after the handshake has completed or failed. (It is not
// set during the emission of Connection::accept-certificate.)
//
// See Connection:peer-certificate-errors for more information.
//
// The function returns the following values:
//
//   - tlsCertificateFlags conn's peer's certificate errors.
func (conn *TLSConnection) PeerCertificateErrors() TLSCertificateFlags {
	var _arg0 *C.GTlsConnection      // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_peer_certificate_errors(_arg0)
	runtime.KeepAlive(conn)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// ProtocolVersion returns the current TLS protocol version, which may be
// G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or has
// been closed, or if the TLS backend has implemented a protocol version that is
// not a recognized ProtocolVersion.
//
// The function returns the following values:
//
//   - tlsProtocolVersion: current TLS protocol version.
func (conn *TLSConnection) ProtocolVersion() TLSProtocolVersion {
	var _arg0 *C.GTlsConnection     // out
	var _cret C.GTlsProtocolVersion // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_protocol_version(_arg0)
	runtime.KeepAlive(conn)

	var _tlsProtocolVersion TLSProtocolVersion // out

	_tlsProtocolVersion = TLSProtocolVersion(_cret)

	return _tlsProtocolVersion
}

// RehandshakeMode gets conn rehandshaking mode. See
// g_tls_connection_set_rehandshake_mode() for details.
//
// Deprecated: Changing the rehandshake mode is no longer required for
// compatibility. Also, rehandshaking has been removed from the TLS protocol in
// TLS 1.3.
//
// The function returns the following values:
//
//   - tlsRehandshakeMode: G_TLS_REHANDSHAKE_SAFELY.
func (conn *TLSConnection) RehandshakeMode() TLSRehandshakeMode {
	var _arg0 *C.GTlsConnection     // out
	var _cret C.GTlsRehandshakeMode // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_rehandshake_mode(_arg0)
	runtime.KeepAlive(conn)

	var _tlsRehandshakeMode TLSRehandshakeMode // out

	_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

	return _tlsRehandshakeMode
}

// RequireCloseNotify tests whether or not conn expects a proper
// TLS close notification when the connection is closed. See
// g_tls_connection_set_require_close_notify() for details.
//
// The function returns the following values:
//
//   - ok: TRUE if conn requires a proper TLS close notification.
func (conn *TLSConnection) RequireCloseNotify() bool {
	var _arg0 *C.GTlsConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_require_close_notify(_arg0)
	runtime.KeepAlive(conn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseSystemCertDB gets whether conn uses the system certificate database to
// verify peer certificates. See g_tls_connection_set_use_system_certdb().
//
// Deprecated: Use g_tls_connection_get_database() instead.
//
// The function returns the following values:
//
//   - ok: whether conn uses the system certificate database.
func (conn *TLSConnection) UseSystemCertDB() bool {
	var _arg0 *C.GTlsConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_use_system_certdb(_arg0)
	runtime.KeepAlive(conn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Handshake attempts a TLS handshake on conn.
//
// On the client side, it is never necessary to call this method; although the
// connection needs to perform a handshake after connecting (or after sending a
// "STARTTLS"-type command), Connection will handle this for you automatically
// when you try to send or receive data on the connection. You can call
// g_tls_connection_handshake() manually if you want to know whether the initial
// handshake succeeded or failed (as opposed to just immediately trying to use
// conn to read or write, in which case, if it fails, it may not be possible to
// tell if it failed before or after completing the handshake), but beware that
// servers may reject client authentication after the handshake has completed,
// so a successful handshake does not indicate the connection will be usable.
//
// Likewise, on the server side, although a handshake is necessary at the
// beginning of the communication, you do not need to call this function
// explicitly unless you want clearer error reporting.
//
// Previously, calling g_tls_connection_handshake() after the initial handshake
// would trigger a rehandshake; however, this usage was deprecated in GLib
// 2.60 because rehandshaking was removed from the TLS protocol in TLS 1.3.
// Since GLib 2.64, calling this function after the initial handshake will no
// longer do anything.
//
// When using a Connection created by Client, the Client performs the initial
// handshake, so calling this function manually is not recommended.
//
// Connection::accept_certificate may be emitted during the handshake.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (conn *TLSConnection) Handshake(ctx context.Context) error {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GCancellable   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_tls_connection_handshake(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// HandshakeAsync: asynchronously performs a TLS handshake on conn. See
// g_tls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the handshake is complete.
func (conn *TLSConnection) HandshakeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GTlsConnection     // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_tls_connection_handshake_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// HandshakeFinish: finish an asynchronous TLS handshake operation. See
// g_tls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - result: Result.
func (conn *TLSConnection) HandshakeFinish(result AsyncResulter) error {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GAsyncResult   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_tls_connection_handshake_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAdvertisedProtocols sets the list of application-layer protocols
// to advertise that the caller is willing to speak on this connection.
// The Application-Layer Protocol Negotiation (ALPN) extension will
// be used to negotiate a compatible protocol with the peer; use
// g_tls_connection_get_negotiated_protocol() to find the negotiated protocol
// after the handshake. Specifying NULL for the the value of protocols will
// disable ALPN negotiation.
//
// See IANA TLS ALPN Protocol IDs
// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
//
// The function takes the following parameters:
//
//   - protocols (optional): NULL-terminated array of ALPN protocol names (eg,
//     "http/1.1", "h2"), or NULL.
func (conn *TLSConnection) SetAdvertisedProtocols(protocols []string) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 **C.gchar         // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(protocols) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(protocols)+1)
			var zero *C.gchar
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.g_tls_connection_set_advertised_protocols(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(protocols)
}

// SetCertificate: this sets the certificate that conn will present to its peer
// during the TLS handshake. For a ServerConnection, it is mandatory to set
// this, and that will normally be done at construct time.
//
// For a ClientConnection, this is optional. If a handshake fails with
// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
// certificate, and if you try connecting again, you should call this method
// first. You can call g_tls_client_connection_get_accepted_cas() on the failed
// connection to get a list of Certificate Authorities that the server will
// accept certificates from.
//
// (It is also possible that a server will allow the connection with or
// without a certificate; in that case, if you don't provide a certificate,
// you can tell that the server requested one by the fact that
// g_tls_client_connection_get_accepted_cas() will return non-NULL.).
//
// The function takes the following parameters:
//
//   - certificate to use for conn.
func (conn *TLSConnection) SetCertificate(certificate TLSCertificater) {
	var _arg0 *C.GTlsConnection  // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))

	C.g_tls_connection_set_certificate(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(certificate)
}

// SetDatabase sets the certificate database that is used to verify
// peer certificates. This is set to the default database by default.
// See g_tls_backend_get_default_database(). If set to NULL, then peer
// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA
// error (meaning Connection::accept-certificate will always be
// emitted on client-side connections, unless that bit is not set in
// ClientConnection:validation-flags).
//
// There are nonintuitive security implications when using a non-default
// database. See Connection:database for details.
//
// The function takes the following parameters:
//
//   - database (optional): Database.
func (conn *TLSConnection) SetDatabase(database TLSDatabaser) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GTlsDatabase   // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if database != nil {
		_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(database).Native()))
	}

	C.g_tls_connection_set_database(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(database)
}

// SetInteraction: set the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords.
//
// The interaction argument will normally be a derived subclass of Interaction.
// NULL can also be provided if no user interaction should occur for this
// connection.
//
// The function takes the following parameters:
//
//   - interaction (optional) object, or NULL.
func (conn *TLSConnection) SetInteraction(interaction *TLSInteraction) {
	var _arg0 *C.GTlsConnection  // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if interaction != nil {
		_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}

	C.g_tls_connection_set_interaction(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(interaction)
}

// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
// longer supported and will have no effect. With TLS 1.3, rehandshaking has
// been removed from the TLS protocol, replaced by separate post-handshake
// authentication and rekey operations.
//
// Deprecated: Changing the rehandshake mode is no longer required for
// compatibility. Also, rehandshaking has been removed from the TLS protocol in
// TLS 1.3.
//
// The function takes the following parameters:
//
//   - mode: rehandshaking mode.
func (conn *TLSConnection) SetRehandshakeMode(mode TLSRehandshakeMode) {
	var _arg0 *C.GTlsConnection     // out
	var _arg1 C.GTlsRehandshakeMode // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsRehandshakeMode(mode)

	C.g_tls_connection_set_rehandshake_mode(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(mode)
}

// SetRequireCloseNotify sets whether or not conn expects a proper TLS close
// notification before the connection is closed. If this is TRUE (the default),
// then conn will expect to receive a TLS close notification from its peer
// before the connection is closed, and will return a G_TLS_ERROR_EOF error if
// the connection is closed without proper notification (since this may indicate
// a network error, or man-in-the-middle attack).
//
// In some protocols, the application will know whether or not the
// connection was closed cleanly based on application-level data
// (because the application-level data includes a length field,
// or is somehow self-delimiting); in this case, the close notify is
// redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
// in TLS 1.0 it is technically an error, but often done anyway.) You can
// use g_tls_connection_set_require_close_notify() to tell conn to allow an
// "unannounced" connection close, in which case the close will show up as a
// 0-length read, as in a non-TLS Connection, and it is up to the application to
// check that the data has been fully received.
//
// Note that this only affects the behavior when the peer closes the connection;
// when the application calls g_io_stream_close() itself on conn, this will
// send a close notification regardless of the setting of this property.
// If you explicitly want to do an unclean close, you can close conn's
// Connection:base-io-stream rather than closing conn itself, but note that this
// may only be done when no other operations are pending on conn or the base I/O
// stream.
//
// The function takes the following parameters:
//
//   - requireCloseNotify: whether or not to require close notification.
func (conn *TLSConnection) SetRequireCloseNotify(requireCloseNotify bool) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if requireCloseNotify {
		_arg1 = C.TRUE
	}

	C.g_tls_connection_set_require_close_notify(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(requireCloseNotify)
}

// SetUseSystemCertDB sets whether conn uses the system certificate
// database to verify peer certificates. This is TRUE by default.
// If set to FALSE, then peer certificate validation will always set the
// G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning Connection::accept-certificate
// will always be emitted on client-side connections, unless that bit is not set
// in ClientConnection:validation-flags).
//
// Deprecated: Use g_tls_connection_set_database() instead.
//
// The function takes the following parameters:
//
//   - useSystemCertdb: whether to use the system certificate database.
func (conn *TLSConnection) SetUseSystemCertDB(useSystemCertdb bool) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if useSystemCertdb {
		_arg1 = C.TRUE
	}

	C.g_tls_connection_set_use_system_certdb(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(useSystemCertdb)
}

// acceptCertificate: check whether to accept a certificate.
//
// The function takes the following parameters:
//
//   - peerCert
//   - errors
func (connection *TLSConnection) acceptCertificate(peerCert TLSCertificater, errors TLSCertificateFlags) bool {
	gclass := (*C.GTlsConnectionClass)(coreglib.PeekParentClass(connection))
	fnarg := gclass.accept_certificate

	var _arg0 *C.GTlsConnection      // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(peerCert).Native()))
	_arg2 = C.GTlsCertificateFlags(errors)

	_cret = C._gotk4_gio2_TLSConnection_virtual_accept_certificate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// bindingData: retrieve TLS channel binding data (Since: 2.66).
//
// The function takes the following parameters:
//
//   - typ
//   - data
func (conn *TLSConnection) bindingData(typ TLSChannelBindingType, data []byte) error {
	gclass := (*C.GTlsConnectionClass)(coreglib.PeekParentClass(conn))
	fnarg := gclass.get_binding_data

	var _arg0 *C.GTlsConnection        // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 *C.GByteArray            // out
	var _cerr *C.GError                // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsChannelBindingType(typ)
	_arg2 = C.g_byte_array_sized_new(C.guint(len(data)))
	if len(data) > 0 {
		_arg2 = C.g_byte_array_append(_arg2, (*C.guint8)(&data[0]), C.guint(len(data)))
	}
	defer C.g_byte_array_unref(_arg2)

	C._gotk4_gio2_TLSConnection_virtual_get_binding_data(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// negotiatedProtocol gets the name of the application-layer protocol negotiated
// during the handshake.
//
// If the peer did not use the ALPN extension, or did not advertise
// a protocol that matched one of conn's protocols, or the TLS
// backend does not support ALPN, then this will be NULL. See
// g_tls_connection_set_advertised_protocols().
//
// The function returns the following values:
//
//   - utf8 (optional): negotiated protocol, or NULL.
func (conn *TLSConnection) negotiatedProtocol() string {
	gclass := (*C.GTlsConnectionClass)(coreglib.PeekParentClass(conn))
	fnarg := gclass.get_negotiated_protocol

	var _arg0 *C.GTlsConnection // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C._gotk4_gio2_TLSConnection_virtual_get_negotiated_protocol(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(conn)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Handshake attempts a TLS handshake on conn.
//
// On the client side, it is never necessary to call this method; although the
// connection needs to perform a handshake after connecting (or after sending a
// "STARTTLS"-type command), Connection will handle this for you automatically
// when you try to send or receive data on the connection. You can call
// g_tls_connection_handshake() manually if you want to know whether the initial
// handshake succeeded or failed (as opposed to just immediately trying to use
// conn to read or write, in which case, if it fails, it may not be possible to
// tell if it failed before or after completing the handshake), but beware that
// servers may reject client authentication after the handshake has completed,
// so a successful handshake does not indicate the connection will be usable.
//
// Likewise, on the server side, although a handshake is necessary at the
// beginning of the communication, you do not need to call this function
// explicitly unless you want clearer error reporting.
//
// Previously, calling g_tls_connection_handshake() after the initial handshake
// would trigger a rehandshake; however, this usage was deprecated in GLib
// 2.60 because rehandshaking was removed from the TLS protocol in TLS 1.3.
// Since GLib 2.64, calling this function after the initial handshake will no
// longer do anything.
//
// When using a Connection created by Client, the Client performs the initial
// handshake, so calling this function manually is not recommended.
//
// Connection::accept_certificate may be emitted during the handshake.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
func (conn *TLSConnection) handshake(ctx context.Context) error {
	gclass := (*C.GTlsConnectionClass)(coreglib.PeekParentClass(conn))
	fnarg := gclass.handshake

	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GCancellable   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C._gotk4_gio2_TLSConnection_virtual_handshake(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// handshakeAsync: asynchronously performs a TLS handshake on conn. See
// g_tls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - ioPriority: [I/O priority][io-priority] of the request.
//   - callback (optional) to call when the handshake is complete.
func (conn *TLSConnection) handshakeAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GTlsConnectionClass)(coreglib.PeekParentClass(conn))
	fnarg := gclass.handshake_async

	var _arg0 *C.GTlsConnection     // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_TLSConnection_virtual_handshake_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// handshakeFinish: finish an asynchronous TLS handshake operation. See
// g_tls_connection_handshake() for more information.
//
// The function takes the following parameters:
//
//   - result: Result.
func (conn *TLSConnection) handshakeFinish(result AsyncResulter) error {
	gclass := (*C.GTlsConnectionClass)(coreglib.PeekParentClass(conn))
	fnarg := gclass.handshake_finish

	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GAsyncResult   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_TLSConnection_virtual_handshake_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// TLSDatabaseOverrides contains methods that are overridable.
type TLSDatabaseOverrides struct {
	// CreateCertificateHandle: create a handle string for the certificate.
	// The database will only be able to create a handle for certificates that
	// originate from the database. In cases where the database cannot create a
	// handle for a certificate, NULL will be returned.
	//
	// This handle should be stable across various instances of the application,
	// and between applications. If a certificate is modified in the database,
	// then it is not guaranteed that this handle will continue to point to it.
	//
	// The function takes the following parameters:
	//
	//   - certificate for which to create a handle.
	//
	// The function returns the following values:
	//
	//   - utf8 (optional): newly allocated string containing the handle.
	CreateCertificateHandle func(certificate TLSCertificater) string
	// LookupCertificateForHandle: look up a certificate by its handle.
	//
	// The handle should have been created by calling
	// g_tls_database_create_certificate_handle() on a Database object of
	// the same TLS backend. The handle is designed to remain valid across
	// instantiations of the database.
	//
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then NULL will be returned.
	//
	// This function can block, use
	// g_tls_database_lookup_certificate_for_handle_async() to perform the
	// lookup operation asynchronously.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - handle: certificate handle.
	//   - interaction (optional): used to interact with the user if necessary.
	//   - flags flags which affect the lookup.
	//
	// The function returns the following values:
	//
	//   - tlsCertificate (optional): newly allocated Certificate, or NULL.
	//     Use g_object_unref() to release the certificate.
	LookupCertificateForHandle func(ctx context.Context, handle string, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) (TLSCertificater, error)
	// LookupCertificateForHandleFinish: finish an
	// asynchronous lookup of a certificate by its handle. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	//
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then NULL will be returned.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - tlsCertificate: newly allocated Certificate object. Use
	//     g_object_unref() to release the certificate.
	LookupCertificateForHandleFinish func(result AsyncResulter) (TLSCertificater, error)
	// LookupCertificateIssuer: look up the issuer of certificate in the
	// database. The Certificate:issuer property of certificate is not modified,
	// and the two certificates are not hooked into a chain.
	//
	// This function can block. Use
	// g_tls_database_lookup_certificate_issuer_async() to perform the lookup
	// operation asynchronously.
	//
	// Beware this function cannot be used to build certification paths.
	// The issuer certificate returned by this function may not be the
	// same as the certificate that would actually be used to construct a
	// valid certification path during certificate verification. RFC 4158
	// (https://datatracker.ietf.org/doc/html/rfc4158) explains why an issuer
	// certificate cannot be naively assumed to be part of the the certification
	// path (though GLib's TLS backends may not follow the path building
	// strategies outlined in this RFC). Due to the complexity of certification
	// path building, GLib does not provide any way to know which certification
	// path will actually be used when verifying a TLS certificate. Accordingly,
	// this function cannot be used to make security-related decisions. Only
	// GLib itself should make security decisions about TLS certificates.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - certificate: Certificate.
	//   - interaction (optional): used to interact with the user if necessary.
	//   - flags which affect the lookup operation.
	//
	// The function returns the following values:
	//
	//   - tlsCertificate: newly allocated issuer Certificate, or NULL.
	//     Use g_object_unref() to release the certificate.
	LookupCertificateIssuer func(ctx context.Context, certificate TLSCertificater, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) (TLSCertificater, error)
	// LookupCertificateIssuerFinish: finish an asynchronous lookup issuer
	// operation. See g_tls_database_lookup_certificate_issuer() for more
	// information.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - tlsCertificate: newly allocated issuer Certificate, or NULL.
	//     Use g_object_unref() to release the certificate.
	LookupCertificateIssuerFinish func(result AsyncResulter) (TLSCertificater, error)
	// LookupCertificatesIssuedBy: look up certificates issued by this issuer in
	// the database.
	//
	// This function can block, use
	// g_tls_database_lookup_certificates_issued_by_async() to perform the
	// lookup operation asynchronously.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - issuerRawDn which holds the DER encoded issuer DN.
	//   - interaction (optional): used to interact with the user if necessary.
	//   - flags flags which affect the lookup operation.
	//
	// The function returns the following values:
	//
	//   - list: newly allocated list of Certificate objects. Use
	//     g_object_unref() on each certificate, and g_list_free() on the
	//     release the list.
	LookupCertificatesIssuedBy func(ctx context.Context, issuerRawDn []byte, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) ([]TLSCertificater, error)
	// LookupCertificatesIssuedByFinish: finish an asynchronous lookup of
	// certificates. See g_tls_database_lookup_certificates_issued_by() for more
	// information.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - list: newly allocated list of Certificate objects. Use
	//     g_object_unref() on each certificate, and g_list_free() on the
	//     release the list.
	LookupCertificatesIssuedByFinish func(result AsyncResulter) ([]TLSCertificater, error)
	// VerifyChain determines the validity of a certificate chain, outside the
	// context of a TLS session.
	//
	// chain is a chain of Certificate objects each pointing to the next
	// certificate in the chain by its Certificate:issuer property.
	//
	// purpose describes the purpose (or usage) for which the
	// certificate is being used. Typically purpose will be set to
	// G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the
	// certificate is being used to authenticate a server (and we are acting as
	// the client).
	//
	// The identity is used to ensure the server certificate is valid for the
	// expected peer identity. If the identity does not match the certificate,
	// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value.
	// If identity is NULL, that bit will never be set in the return value. The
	// peer identity may also be used to check for pinned certificates (trust
	// exceptions) in the database. These may override the normal verification
	// process on a host-by-host basis.
	//
	// Currently there are no flags, and G_TLS_DATABASE_VERIFY_NONE should be
	// used.
	//
	// If chain is found to be valid, then the return value will be 0. If chain
	// is found to be invalid, then the return value will indicate at least one
	// problem found. If the function is unable to determine whether chain is
	// valid (for example, because cancellable is triggered before it completes)
	// then the return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and error
	// will be set accordingly. error is not set when chain is successfully
	// analyzed but found to be invalid.
	//
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee that
	// all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would be
	// incorrect to mask G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
	// certificates, because this could potentially be the only error flag set
	// even if other problems exist with the certificate.
	//
	// Prior to GLib 2.48, GLib's default TLS backend modified chain to
	// represent the certification path built by Database during certificate
	// verification by adjusting the Certificate:issuer property of each
	// certificate in chain. Since GLib 2.48, this no longer occurs, so you
	// cannot rely on Certificate:issuer to represent the actual certification
	// path used during certificate verification.
	//
	// Because TLS session context is not used, Database may not perform
	// as many checks on the certificates as Connection would. For example,
	// certificate constraints may not be honored, and revocation checks may
	// not be performed. The best way to verify TLS certificates used by a TLS
	// connection is to let Connection handle the verification.
	//
	// The TLS backend may attempt to look up and add missing certificates
	// to the chain. This may involve HTTP requests to download missing
	// certificates.
	//
	// This function can block. Use g_tls_database_verify_chain_async() to
	// perform the verification operation asynchronously.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional) or NULL.
	//   - chain: Certificate chain.
	//   - purpose that this certificate chain will be used for.
	//   - identity (optional): expected peer identity.
	//   - interaction (optional): used to interact with the user if necessary.
	//   - flags: additional verify flags.
	//
	// The function returns the following values:
	//
	//   - tlsCertificateFlags: appropriate CertificateFlags which represents
	//     the result of verification.
	VerifyChain func(ctx context.Context, chain TLSCertificater, purpose string, identity SocketConnectabler, interaction *TLSInteraction, flags TLSDatabaseVerifyFlags) (TLSCertificateFlags, error)
	// VerifyChainFinish: finish an asynchronous verify chain operation.
	// See g_tls_database_verify_chain() for more information.
	//
	// If chain is found to be valid, then the return value will be 0. If chain
	// is found to be invalid, then the return value will indicate the problems
	// found. If the function is unable to determine whether chain is valid or
	// not (eg, because cancellable is triggered before it completes) then the
	// return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and error will be
	// set accordingly. error is not set when chain is successfully analyzed but
	// found to be invalid.
	//
	// The function takes the following parameters:
	//
	//   - result: Result.
	//
	// The function returns the following values:
	//
	//   - tlsCertificateFlags: appropriate CertificateFlags which represents
	//     the result of verification.
	VerifyChainFinish func(result AsyncResulter) (TLSCertificateFlags, error)
}

func defaultTLSDatabaseOverrides(v *TLSDatabase) TLSDatabaseOverrides {
	return TLSDatabaseOverrides{
		CreateCertificateHandle:          v.createCertificateHandle,
		LookupCertificateForHandle:       v.lookupCertificateForHandle,
		LookupCertificateForHandleFinish: v.lookupCertificateForHandleFinish,
		LookupCertificateIssuer:          v.lookupCertificateIssuer,
		LookupCertificateIssuerFinish:    v.lookupCertificateIssuerFinish,
		LookupCertificatesIssuedBy:       v.lookupCertificatesIssuedBy,
		LookupCertificatesIssuedByFinish: v.lookupCertificatesIssuedByFinish,
		VerifyChain:                      v.verifyChain,
		VerifyChainFinish:                v.verifyChainFinish,
	}
}

// TLSDatabase: GTlsDatabase is used to look up certificates and other
// information from a certificate or key store. It is an abstract base class
// which TLS library specific subtypes override.
//
// A GTlsDatabase may be accessed from multiple threads by the TLS backend.
// All implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with GTlsDatabase.
// It is used internally by gio.TLSConnection.
type TLSDatabase struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TLSDatabase)(nil)
)

// TLSDatabaser describes types inherited from class TLSDatabase.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type TLSDatabaser interface {
	coreglib.Objector
	baseTLSDatabase() *TLSDatabase
}

var _ TLSDatabaser = (*TLSDatabase)(nil)

func init() {
	coreglib.RegisterClassInfo[*TLSDatabase, *TLSDatabaseClass, TLSDatabaseOverrides](
		GTypeTLSDatabase,
		initTLSDatabaseClass,
		wrapTLSDatabase,
		defaultTLSDatabaseOverrides,
	)
}

func initTLSDatabaseClass(gclass unsafe.Pointer, overrides TLSDatabaseOverrides, classInitFunc func(*TLSDatabaseClass)) {
	pclass := (*C.GTlsDatabaseClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTLSDatabase))))

	if overrides.CreateCertificateHandle != nil {
		pclass.create_certificate_handle = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_create_certificate_handle)
	}

	if overrides.LookupCertificateForHandle != nil {
		pclass.lookup_certificate_for_handle = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_lookup_certificate_for_handle)
	}

	if overrides.LookupCertificateForHandleFinish != nil {
		pclass.lookup_certificate_for_handle_finish = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_lookup_certificate_for_handle_finish)
	}

	if overrides.LookupCertificateIssuer != nil {
		pclass.lookup_certificate_issuer = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_lookup_certificate_issuer)
	}

	if overrides.LookupCertificateIssuerFinish != nil {
		pclass.lookup_certificate_issuer_finish = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_lookup_certificate_issuer_finish)
	}

	if overrides.LookupCertificatesIssuedBy != nil {
		pclass.lookup_certificates_issued_by = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_lookup_certificates_issued_by)
	}

	if overrides.LookupCertificatesIssuedByFinish != nil {
		pclass.lookup_certificates_issued_by_finish = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_lookup_certificates_issued_by_finish)
	}

	if overrides.VerifyChain != nil {
		pclass.verify_chain = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_verify_chain)
	}

	if overrides.VerifyChainFinish != nil {
		pclass.verify_chain_finish = (*[0]byte)(C._gotk4_gio2_TlsDatabaseClass_verify_chain_finish)
	}

	if classInitFunc != nil {
		class := (*TLSDatabaseClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTLSDatabase(obj *coreglib.Object) *TLSDatabase {
	return &TLSDatabase{
		Object: obj,
	}
}

func marshalTLSDatabase(p uintptr) (interface{}, error) {
	return wrapTLSDatabase(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *TLSDatabase) baseTLSDatabase() *TLSDatabase {
	return self
}

// BaseTLSDatabase returns the underlying base object.
func BaseTLSDatabase(obj TLSDatabaser) *TLSDatabase {
	return obj.baseTLSDatabase()
}

// CreateCertificateHandle: create a handle string for the certificate. The
// database will only be able to create a handle for certificates that originate
// from the database. In cases where the database cannot create a handle for a
// certificate, NULL will be returned.
//
// This handle should be stable across various instances of the application,
// and between applications. If a certificate is modified in the database,
// then it is not guaranteed that this handle will continue to point to it.
//
// The function takes the following parameters:
//
//   - certificate for which to create a handle.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing the handle.
func (self *TLSDatabase) CreateCertificateHandle(certificate TLSCertificater) string {
	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GTlsCertificate // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))

	_cret = C.g_tls_database_create_certificate_handle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// LookupCertificateForHandle: look up a certificate by its handle.
//
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a Database object of the same
// TLS backend. The handle is designed to remain valid across instantiations of
// the database.
//
// If the handle is no longer valid, or does not point to a certificate in this
// database, then NULL will be returned.
//
// This function can block, use
// g_tls_database_lookup_certificate_for_handle_async() to perform the lookup
// operation asynchronously.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - handle: certificate handle.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup.
//
// The function returns the following values:
//
//   - tlsCertificate (optional): newly allocated Certificate, or NULL.
//     Use g_object_unref() to release the certificate.
func (self *TLSDatabase) LookupCertificateForHandle(ctx context.Context, handle string, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) (TLSCertificater, error) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _cret *C.GTlsCertificate        // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(_arg1))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)

	_cret = C.g_tls_database_lookup_certificate_for_handle(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// LookupCertificateForHandleAsync: asynchronously look up a certificate by its
// handle in the database. See g_tls_database_lookup_certificate_for_handle()
// for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - handle: certificate handle.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) LookupCertificateForHandleAsync(ctx context.Context, handle string, interaction *TLSInteraction, flags TLSDatabaseLookupFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg5 C.GAsyncReadyCallback     // out
	var _arg6 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(_arg1))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_tls_database_lookup_certificate_for_handle_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// LookupCertificateForHandleFinish: finish an asynchronous lookup of a
// certificate by its handle. See g_tls_database_lookup_certificate_for_handle()
// for more information.
//
// If the handle is no longer valid, or does not point to a certificate in this
// database, then NULL will be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - tlsCertificate: newly allocated Certificate object. Use g_object_unref()
//     to release the certificate.
func (self *TLSDatabase) LookupCertificateForHandleFinish(result AsyncResulter) (TLSCertificater, error) {
	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_tls_database_lookup_certificate_for_handle_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_tlsCertificate = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// LookupCertificateIssuer: look up the issuer of certificate in the database.
// The Certificate:issuer property of certificate is not modified, and the two
// certificates are not hooked into a chain.
//
// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
// to perform the lookup operation asynchronously.
//
// Beware this function cannot be used to build certification paths.
// The issuer certificate returned by this function may not be the
// same as the certificate that would actually be used to construct a
// valid certification path during certificate verification. RFC 4158
// (https://datatracker.ietf.org/doc/html/rfc4158) explains why an issuer
// certificate cannot be naively assumed to be part of the the certification
// path (though GLib's TLS backends may not follow the path building strategies
// outlined in this RFC). Due to the complexity of certification path building,
// GLib does not provide any way to know which certification path will actually
// be used when verifying a TLS certificate. Accordingly, this function cannot
// be used to make security-related decisions. Only GLib itself should make
// security decisions about TLS certificates.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - certificate: Certificate.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags which affect the lookup operation.
//
// The function returns the following values:
//
//   - tlsCertificate: newly allocated issuer Certificate, or NULL. Use
//     g_object_unref() to release the certificate.
func (self *TLSDatabase) LookupCertificateIssuer(ctx context.Context, certificate TLSCertificater, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) (TLSCertificater, error) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _cret *C.GTlsCertificate        // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)

	_cret = C.g_tls_database_lookup_certificate_issuer(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_tlsCertificate = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// LookupCertificateIssuerAsync: asynchronously look up the issuer of
// certificate in the database. See g_tls_database_lookup_certificate_issuer()
// for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - certificate: Certificate.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags which affect the lookup operation.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) LookupCertificateIssuerAsync(ctx context.Context, certificate TLSCertificater, interaction *TLSInteraction, flags TLSDatabaseLookupFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg5 C.GAsyncReadyCallback     // out
	var _arg6 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_tls_database_lookup_certificate_issuer_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// LookupCertificateIssuerFinish: finish an asynchronous lookup issuer
// operation. See g_tls_database_lookup_certificate_issuer() for more
// information.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - tlsCertificate: newly allocated issuer Certificate, or NULL. Use
//     g_object_unref() to release the certificate.
func (self *TLSDatabase) LookupCertificateIssuerFinish(result AsyncResulter) (TLSCertificater, error) {
	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_tls_database_lookup_certificate_issuer_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_tlsCertificate = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// LookupCertificatesIssuedBy: look up certificates issued by this issuer in the
// database.
//
// This function can block, use
// g_tls_database_lookup_certificates_issued_by_async() to perform the lookup
// operation asynchronously.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - issuerRawDn which holds the DER encoded issuer DN.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup operation.
//
// The function returns the following values:
//
//   - list: newly allocated list of Certificate objects. Use g_object_unref()
//     on each certificate, and g_list_free() on the release the list.
func (self *TLSDatabase) LookupCertificatesIssuedBy(ctx context.Context, issuerRawDn []byte, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) ([]TLSCertificater, error) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GByteArray             // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _cret *C.GList                  // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.g_byte_array_sized_new(C.guint(len(issuerRawDn)))
	if len(issuerRawDn) > 0 {
		_arg1 = C.g_byte_array_append(_arg1, (*C.guint8)(&issuerRawDn[0]), C.guint(len(issuerRawDn)))
	}
	defer C.g_byte_array_unref(_arg1)
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)

	_cret = C.g_tls_database_lookup_certificates_issued_by(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(issuerRawDn)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _list []TLSCertificater // out
	var _goerr error            // out

	_list = make([]TLSCertificater, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GTlsCertificate)(v)
		var dst TLSCertificater // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.TLSCertificater is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupCertificatesIssuedByAsync: asynchronously look up
// certificates issued by this issuer in the database. See
// g_tls_database_lookup_certificates_issued_by() for more information.
//
// The database may choose to hold a reference to the issuer byte array for
// the duration of this asynchronous operation. The byte array should not be
// modified during this time.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - issuerRawDn which holds the DER encoded issuer DN.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup operation.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) LookupCertificatesIssuedByAsync(ctx context.Context, issuerRawDn []byte, interaction *TLSInteraction, flags TLSDatabaseLookupFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GByteArray             // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg5 C.GAsyncReadyCallback     // out
	var _arg6 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.g_byte_array_sized_new(C.guint(len(issuerRawDn)))
	if len(issuerRawDn) > 0 {
		_arg1 = C.g_byte_array_append(_arg1, (*C.guint8)(&issuerRawDn[0]), C.guint(len(issuerRawDn)))
	}
	defer C.g_byte_array_unref(_arg1)
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_tls_database_lookup_certificates_issued_by_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(issuerRawDn)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// LookupCertificatesIssuedByFinish: finish an asynchronous lookup of
// certificates. See g_tls_database_lookup_certificates_issued_by() for more
// information.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list: newly allocated list of Certificate objects. Use g_object_unref()
//     on each certificate, and g_list_free() on the release the list.
func (self *TLSDatabase) LookupCertificatesIssuedByFinish(result AsyncResulter) ([]TLSCertificater, error) {
	var _arg0 *C.GTlsDatabase // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_tls_database_lookup_certificates_issued_by_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _list []TLSCertificater // out
	var _goerr error            // out

	_list = make([]TLSCertificater, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GTlsCertificate)(v)
		var dst TLSCertificater // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.TLSCertificater is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// VerifyChain determines the validity of a certificate chain, outside the
// context of a TLS session.
//
// chain is a chain of Certificate objects each pointing to the next certificate
// in the chain by its Certificate:issuer property.
//
// purpose describes the purpose (or usage) for which the
// certificate is being used. Typically purpose will be set to
// G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the certificate
// is being used to authenticate a server (and we are acting as the client).
//
// The identity is used to ensure the server certificate is valid for the
// expected peer identity. If the identity does not match the certificate,
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value. If identity
// is NULL, that bit will never be set in the return value. The peer identity
// may also be used to check for pinned certificates (trust exceptions) in
// the database. These may override the normal verification process on a
// host-by-host basis.
//
// Currently there are no flags, and G_TLS_DATABASE_VERIFY_NONE should be used.
//
// If chain is found to be valid, then the return value will be 0. If chain
// is found to be invalid, then the return value will indicate at least one
// problem found. If the function is unable to determine whether chain is valid
// (for example, because cancellable is triggered before it completes) then the
// return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and error will be set
// accordingly. error is not set when chain is successfully analyzed but found
// to be invalid.
//
// GLib guarantees that if certificate verification fails, at least one error
// will be set in the return value, but it does not guarantee that all possible
// errors will be set. Accordingly, you may not safely decide to ignore any
// particular type of error. For example, it would be incorrect to mask
// G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates, because
// this could potentially be the only error flag set even if other problems
// exist with the certificate.
//
// Prior to GLib 2.48, GLib's default TLS backend modified chain to represent
// the certification path built by Database during certificate verification by
// adjusting the Certificate:issuer property of each certificate in chain. Since
// GLib 2.48, this no longer occurs, so you cannot rely on Certificate:issuer to
// represent the actual certification path used during certificate verification.
//
// Because TLS session context is not used, Database may not perform as many
// checks on the certificates as Connection would. For example, certificate
// constraints may not be honored, and revocation checks may not be performed.
// The best way to verify TLS certificates used by a TLS connection is to let
// Connection handle the verification.
//
// The TLS backend may attempt to look up and add missing certificates to the
// chain. This may involve HTTP requests to download missing certificates.
//
// This function can block. Use g_tls_database_verify_chain_async() to perform
// the verification operation asynchronously.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - chain: Certificate chain.
//   - purpose that this certificate chain will be used for.
//   - identity (optional): expected peer identity.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags: additional verify flags.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: appropriate CertificateFlags which represents the
//     result of verification.
func (self *TLSDatabase) VerifyChain(ctx context.Context, chain TLSCertificater, purpose string, identity SocketConnectabler, interaction *TLSInteraction, flags TLSDatabaseVerifyFlags) (TLSCertificateFlags, error) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg6 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.gchar                  // out
	var _arg3 *C.GSocketConnectable     // out
	var _arg4 *C.GTlsInteraction        // out
	var _arg5 C.GTlsDatabaseVerifyFlags // out
	var _cret C.GTlsCertificateFlags    // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(chain).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(_arg2))
	if identity != nil {
		_arg3 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))
	}
	if interaction != nil {
		_arg4 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg5 = C.GTlsDatabaseVerifyFlags(flags)

	_cret = C.g_tls_database_verify_chain(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _tlsCertificateFlags TLSCertificateFlags // out
	var _goerr error                             // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificateFlags, _goerr
}

// VerifyChainAsync: asynchronously determines the validity of a certificate
// chain after looking up and adding any missing certificates to the chain.
// See g_tls_database_verify_chain() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - chain: Certificate chain.
//   - purpose that this certificate chain will be used for.
//   - identity (optional): expected peer identity.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags: additional verify flags.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) VerifyChainAsync(ctx context.Context, chain TLSCertificater, purpose string, identity SocketConnectabler, interaction *TLSInteraction, flags TLSDatabaseVerifyFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GTlsDatabase           // out
	var _arg6 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.gchar                  // out
	var _arg3 *C.GSocketConnectable     // out
	var _arg4 *C.GTlsInteraction        // out
	var _arg5 C.GTlsDatabaseVerifyFlags // out
	var _arg7 C.GAsyncReadyCallback     // out
	var _arg8 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(chain).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(_arg2))
	if identity != nil {
		_arg3 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))
	}
	if interaction != nil {
		_arg4 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg5 = C.GTlsDatabaseVerifyFlags(flags)
	if callback != nil {
		_arg7 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg8 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_tls_database_verify_chain_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// VerifyChainFinish: finish an asynchronous verify chain operation. See
// g_tls_database_verify_chain() for more information.
//
// If chain is found to be valid, then the return value will be 0. If chain is
// found to be invalid, then the return value will indicate the problems found.
// If the function is unable to determine whether chain is valid or not (eg,
// because cancellable is triggered before it completes) then the return value
// will be G_TLS_CERTIFICATE_GENERIC_ERROR and error will be set accordingly.
// error is not set when chain is successfully analyzed but found to be invalid.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: appropriate CertificateFlags which represents the
//     result of verification.
func (self *TLSDatabase) VerifyChainFinish(result AsyncResulter) (TLSCertificateFlags, error) {
	var _arg0 *C.GTlsDatabase        // out
	var _arg1 *C.GAsyncResult        // out
	var _cret C.GTlsCertificateFlags // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_tls_database_verify_chain_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _tlsCertificateFlags TLSCertificateFlags // out
	var _goerr error                             // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificateFlags, _goerr
}

// createCertificateHandle: create a handle string for the certificate. The
// database will only be able to create a handle for certificates that originate
// from the database. In cases where the database cannot create a handle for a
// certificate, NULL will be returned.
//
// This handle should be stable across various instances of the application,
// and between applications. If a certificate is modified in the database,
// then it is not guaranteed that this handle will continue to point to it.
//
// The function takes the following parameters:
//
//   - certificate for which to create a handle.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing the handle.
func (self *TLSDatabase) createCertificateHandle(certificate TLSCertificater) string {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.create_certificate_handle

	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GTlsCertificate // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))

	_cret = C._gotk4_gio2_TLSDatabase_virtual_create_certificate_handle(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// lookupCertificateForHandle: look up a certificate by its handle.
//
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a Database object of the same
// TLS backend. The handle is designed to remain valid across instantiations of
// the database.
//
// If the handle is no longer valid, or does not point to a certificate in this
// database, then NULL will be returned.
//
// This function can block, use
// g_tls_database_lookup_certificate_for_handle_async() to perform the lookup
// operation asynchronously.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - handle: certificate handle.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup.
//
// The function returns the following values:
//
//   - tlsCertificate (optional): newly allocated Certificate, or NULL.
//     Use g_object_unref() to release the certificate.
func (self *TLSDatabase) lookupCertificateForHandle(ctx context.Context, handle string, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) (TLSCertificater, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificate_for_handle

	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _cret *C.GTlsCertificate        // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(_arg1))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)

	_cret = C._gotk4_gio2_TLSDatabase_virtual_lookup_certificate_for_handle(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// lookupCertificateForHandleAsync: asynchronously look up a certificate by its
// handle in the database. See g_tls_database_lookup_certificate_for_handle()
// for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - handle: certificate handle.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) lookupCertificateForHandleAsync(ctx context.Context, handle string, interaction *TLSInteraction, flags TLSDatabaseLookupFlags, callback AsyncReadyCallback) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificate_for_handle_async

	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg5 C.GAsyncReadyCallback     // out
	var _arg6 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(_arg1))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_TLSDatabase_virtual_lookup_certificate_for_handle_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// lookupCertificateForHandleFinish: finish an asynchronous lookup of a
// certificate by its handle. See g_tls_database_lookup_certificate_for_handle()
// for more information.
//
// If the handle is no longer valid, or does not point to a certificate in this
// database, then NULL will be returned.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - tlsCertificate: newly allocated Certificate object. Use g_object_unref()
//     to release the certificate.
func (self *TLSDatabase) lookupCertificateForHandleFinish(result AsyncResulter) (TLSCertificater, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificate_for_handle_finish

	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_TLSDatabase_virtual_lookup_certificate_for_handle_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_tlsCertificate = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// lookupCertificateIssuer: look up the issuer of certificate in the database.
// The Certificate:issuer property of certificate is not modified, and the two
// certificates are not hooked into a chain.
//
// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
// to perform the lookup operation asynchronously.
//
// Beware this function cannot be used to build certification paths.
// The issuer certificate returned by this function may not be the
// same as the certificate that would actually be used to construct a
// valid certification path during certificate verification. RFC 4158
// (https://datatracker.ietf.org/doc/html/rfc4158) explains why an issuer
// certificate cannot be naively assumed to be part of the the certification
// path (though GLib's TLS backends may not follow the path building strategies
// outlined in this RFC). Due to the complexity of certification path building,
// GLib does not provide any way to know which certification path will actually
// be used when verifying a TLS certificate. Accordingly, this function cannot
// be used to make security-related decisions. Only GLib itself should make
// security decisions about TLS certificates.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - certificate: Certificate.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags which affect the lookup operation.
//
// The function returns the following values:
//
//   - tlsCertificate: newly allocated issuer Certificate, or NULL. Use
//     g_object_unref() to release the certificate.
func (self *TLSDatabase) lookupCertificateIssuer(ctx context.Context, certificate TLSCertificater, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) (TLSCertificater, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificate_issuer

	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _cret *C.GTlsCertificate        // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)

	_cret = C._gotk4_gio2_TLSDatabase_virtual_lookup_certificate_issuer(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_tlsCertificate = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// lookupCertificateIssuerAsync: asynchronously look up the issuer of
// certificate in the database. See g_tls_database_lookup_certificate_issuer()
// for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - certificate: Certificate.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags which affect the lookup operation.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) lookupCertificateIssuerAsync(ctx context.Context, certificate TLSCertificater, interaction *TLSInteraction, flags TLSDatabaseLookupFlags, callback AsyncReadyCallback) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificate_issuer_async

	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg5 C.GAsyncReadyCallback     // out
	var _arg6 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_TLSDatabase_virtual_lookup_certificate_issuer_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// lookupCertificateIssuerFinish: finish an asynchronous lookup issuer
// operation. See g_tls_database_lookup_certificate_issuer() for more
// information.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - tlsCertificate: newly allocated issuer Certificate, or NULL. Use
//     g_object_unref() to release the certificate.
func (self *TLSDatabase) lookupCertificateIssuerFinish(result AsyncResulter) (TLSCertificater, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificate_issuer_finish

	var _arg0 *C.GTlsDatabase    // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_TLSDatabase_virtual_lookup_certificate_issuer_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _tlsCertificate TLSCertificater // out
	var _goerr error                    // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TLSCertificater)
			return ok
		})
		rv, ok := casted.(TLSCertificater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
		}
		_tlsCertificate = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// lookupCertificatesIssuedBy: look up certificates issued by this issuer in the
// database.
//
// This function can block, use
// g_tls_database_lookup_certificates_issued_by_async() to perform the lookup
// operation asynchronously.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - issuerRawDn which holds the DER encoded issuer DN.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup operation.
//
// The function returns the following values:
//
//   - list: newly allocated list of Certificate objects. Use g_object_unref()
//     on each certificate, and g_list_free() on the release the list.
func (self *TLSDatabase) lookupCertificatesIssuedBy(ctx context.Context, issuerRawDn []byte, interaction *TLSInteraction, flags TLSDatabaseLookupFlags) ([]TLSCertificater, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificates_issued_by

	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GByteArray             // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _cret *C.GList                  // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.g_byte_array_sized_new(C.guint(len(issuerRawDn)))
	if len(issuerRawDn) > 0 {
		_arg1 = C.g_byte_array_append(_arg1, (*C.guint8)(&issuerRawDn[0]), C.guint(len(issuerRawDn)))
	}
	defer C.g_byte_array_unref(_arg1)
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)

	_cret = C._gotk4_gio2_TLSDatabase_virtual_lookup_certificates_issued_by(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(issuerRawDn)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _list []TLSCertificater // out
	var _goerr error            // out

	_list = make([]TLSCertificater, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GTlsCertificate)(v)
		var dst TLSCertificater // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.TLSCertificater is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupCertificatesIssuedByAsync: asynchronously look up
// certificates issued by this issuer in the database. See
// g_tls_database_lookup_certificates_issued_by() for more information.
//
// The database may choose to hold a reference to the issuer byte array for
// the duration of this asynchronous operation. The byte array should not be
// modified during this time.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - issuerRawDn which holds the DER encoded issuer DN.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags flags which affect the lookup operation.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) lookupCertificatesIssuedByAsync(ctx context.Context, issuerRawDn []byte, interaction *TLSInteraction, flags TLSDatabaseLookupFlags, callback AsyncReadyCallback) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificates_issued_by_async

	var _arg0 *C.GTlsDatabase           // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GByteArray             // out
	var _arg2 *C.GTlsInteraction        // out
	var _arg3 C.GTlsDatabaseLookupFlags // out
	var _arg5 C.GAsyncReadyCallback     // out
	var _arg6 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.g_byte_array_sized_new(C.guint(len(issuerRawDn)))
	if len(issuerRawDn) > 0 {
		_arg1 = C.g_byte_array_append(_arg1, (*C.guint8)(&issuerRawDn[0]), C.guint(len(issuerRawDn)))
	}
	defer C.g_byte_array_unref(_arg1)
	if interaction != nil {
		_arg2 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg3 = C.GTlsDatabaseLookupFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_TLSDatabase_virtual_lookup_certificates_issued_by_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(issuerRawDn)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// lookupCertificatesIssuedByFinish: finish an asynchronous lookup of
// certificates. See g_tls_database_lookup_certificates_issued_by() for more
// information.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - list: newly allocated list of Certificate objects. Use g_object_unref()
//     on each certificate, and g_list_free() on the release the list.
func (self *TLSDatabase) lookupCertificatesIssuedByFinish(result AsyncResulter) ([]TLSCertificater, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.lookup_certificates_issued_by_finish

	var _arg0 *C.GTlsDatabase // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_TLSDatabase_virtual_lookup_certificates_issued_by_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _list []TLSCertificater // out
	var _goerr error            // out

	_list = make([]TLSCertificater, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GTlsCertificate)(v)
		var dst TLSCertificater // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.TLSCertificater is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSCertificater)
				return ok
			})
			rv, ok := casted.(TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// verifyChain determines the validity of a certificate chain, outside the
// context of a TLS session.
//
// chain is a chain of Certificate objects each pointing to the next certificate
// in the chain by its Certificate:issuer property.
//
// purpose describes the purpose (or usage) for which the
// certificate is being used. Typically purpose will be set to
// G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the certificate
// is being used to authenticate a server (and we are acting as the client).
//
// The identity is used to ensure the server certificate is valid for the
// expected peer identity. If the identity does not match the certificate,
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value. If identity
// is NULL, that bit will never be set in the return value. The peer identity
// may also be used to check for pinned certificates (trust exceptions) in
// the database. These may override the normal verification process on a
// host-by-host basis.
//
// Currently there are no flags, and G_TLS_DATABASE_VERIFY_NONE should be used.
//
// If chain is found to be valid, then the return value will be 0. If chain
// is found to be invalid, then the return value will indicate at least one
// problem found. If the function is unable to determine whether chain is valid
// (for example, because cancellable is triggered before it completes) then the
// return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and error will be set
// accordingly. error is not set when chain is successfully analyzed but found
// to be invalid.
//
// GLib guarantees that if certificate verification fails, at least one error
// will be set in the return value, but it does not guarantee that all possible
// errors will be set. Accordingly, you may not safely decide to ignore any
// particular type of error. For example, it would be incorrect to mask
// G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates, because
// this could potentially be the only error flag set even if other problems
// exist with the certificate.
//
// Prior to GLib 2.48, GLib's default TLS backend modified chain to represent
// the certification path built by Database during certificate verification by
// adjusting the Certificate:issuer property of each certificate in chain. Since
// GLib 2.48, this no longer occurs, so you cannot rely on Certificate:issuer to
// represent the actual certification path used during certificate verification.
//
// Because TLS session context is not used, Database may not perform as many
// checks on the certificates as Connection would. For example, certificate
// constraints may not be honored, and revocation checks may not be performed.
// The best way to verify TLS certificates used by a TLS connection is to let
// Connection handle the verification.
//
// The TLS backend may attempt to look up and add missing certificates to the
// chain. This may involve HTTP requests to download missing certificates.
//
// This function can block. Use g_tls_database_verify_chain_async() to perform
// the verification operation asynchronously.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - chain: Certificate chain.
//   - purpose that this certificate chain will be used for.
//   - identity (optional): expected peer identity.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags: additional verify flags.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: appropriate CertificateFlags which represents the
//     result of verification.
func (self *TLSDatabase) verifyChain(ctx context.Context, chain TLSCertificater, purpose string, identity SocketConnectabler, interaction *TLSInteraction, flags TLSDatabaseVerifyFlags) (TLSCertificateFlags, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.verify_chain

	var _arg0 *C.GTlsDatabase           // out
	var _arg6 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.gchar                  // out
	var _arg3 *C.GSocketConnectable     // out
	var _arg4 *C.GTlsInteraction        // out
	var _arg5 C.GTlsDatabaseVerifyFlags // out
	var _cret C.GTlsCertificateFlags    // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(chain).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(_arg2))
	if identity != nil {
		_arg3 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))
	}
	if interaction != nil {
		_arg4 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg5 = C.GTlsDatabaseVerifyFlags(flags)

	_cret = C._gotk4_gio2_TLSDatabase_virtual_verify_chain(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)

	var _tlsCertificateFlags TLSCertificateFlags // out
	var _goerr error                             // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificateFlags, _goerr
}

// verifyChainAsync: asynchronously determines the validity of a certificate
// chain after looking up and adding any missing certificates to the chain.
// See g_tls_database_verify_chain() for more information.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - chain: Certificate chain.
//   - purpose that this certificate chain will be used for.
//   - identity (optional): expected peer identity.
//   - interaction (optional): used to interact with the user if necessary.
//   - flags: additional verify flags.
//   - callback (optional) to call when the operation completes.
func (self *TLSDatabase) verifyChainAsync(ctx context.Context, chain TLSCertificater, purpose string, identity SocketConnectabler, interaction *TLSInteraction, flags TLSDatabaseVerifyFlags, callback AsyncReadyCallback) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.verify_chain_async

	var _arg0 *C.GTlsDatabase           // out
	var _arg6 *C.GCancellable           // out
	var _arg1 *C.GTlsCertificate        // out
	var _arg2 *C.gchar                  // out
	var _arg3 *C.GSocketConnectable     // out
	var _arg4 *C.GTlsInteraction        // out
	var _arg5 C.GTlsDatabaseVerifyFlags // out
	var _arg7 C.GAsyncReadyCallback     // out
	var _arg8 C.gpointer

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(chain).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(_arg2))
	if identity != nil {
		_arg3 = (*C.GSocketConnectable)(unsafe.Pointer(coreglib.InternObject(identity).Native()))
	}
	if interaction != nil {
		_arg4 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}
	_arg5 = C.GTlsDatabaseVerifyFlags(flags)
	if callback != nil {
		_arg7 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg8 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_TLSDatabase_virtual_verify_chain_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// verifyChainFinish: finish an asynchronous verify chain operation. See
// g_tls_database_verify_chain() for more information.
//
// If chain is found to be valid, then the return value will be 0. If chain is
// found to be invalid, then the return value will indicate the problems found.
// If the function is unable to determine whether chain is valid or not (eg,
// because cancellable is triggered before it completes) then the return value
// will be G_TLS_CERTIFICATE_GENERIC_ERROR and error will be set accordingly.
// error is not set when chain is successfully analyzed but found to be invalid.
//
// The function takes the following parameters:
//
//   - result: Result.
//
// The function returns the following values:
//
//   - tlsCertificateFlags: appropriate CertificateFlags which represents the
//     result of verification.
func (self *TLSDatabase) verifyChainFinish(result AsyncResulter) (TLSCertificateFlags, error) {
	gclass := (*C.GTlsDatabaseClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.verify_chain_finish

	var _arg0 *C.GTlsDatabase        // out
	var _arg1 *C.GAsyncResult        // out
	var _cret C.GTlsCertificateFlags // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_TLSDatabase_virtual_verify_chain_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _tlsCertificateFlags TLSCertificateFlags // out
	var _goerr error                             // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificateFlags, _goerr
}

// TLSInteractionOverrides contains methods that are overridable.
type TLSInteractionOverrides struct {
	// AskPassword: run synchronous interaction to ask the user for a password.
	// In general, g_tls_interaction_invoke_ask_password() should be used
	// instead of this function.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The password value will
	// be filled in and then callback will be called. Alternatively the user may
	// abort this password request, which will usually abort the TLS connection.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable cancellation object.
	//   - password: Password object.
	//
	// The function returns the following values:
	//
	//   - tlsInteractionResult status of the ask password interaction.
	AskPassword func(ctx context.Context, password *TLSPassword) (TLSInteractionResult, error)
	// AskPasswordFinish: complete an ask password user interaction request.
	// This should be once the g_tls_interaction_ask_password_async() completion
	// callback is called.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Password passed to
	// g_tls_interaction_ask_password() will have its password filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code.
	//
	// The function takes the following parameters:
	//
	//   - result passed to the callback.
	//
	// The function returns the following values:
	//
	//   - tlsInteractionResult status of the ask password interaction.
	AskPasswordFinish func(result AsyncResulter) (TLSInteractionResult, error)
	// RequestCertificate: run synchronous interaction to ask the user
	// to choose a certificate to use with the connection. In general,
	// g_tls_interaction_invoke_request_certificate() should be used instead of
	// this function.
	//
	// Derived subclasses usually implement a certificate selector,
	// although they may also choose to provide a certificate from elsewhere.
	// Alternatively the user may abort this certificate request, which will
	// usually abort the TLS connection.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Connection
	// passed to g_tls_interaction_request_certificate() will have had its
	// Connection:certificate filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	//
	// The function takes the following parameters:
	//
	//   - ctx (optional): optional #GCancellable cancellation object.
	//   - connection: Connection object.
	//   - flags providing more information about the request.
	//
	// The function returns the following values:
	//
	//   - tlsInteractionResult status of the request certificate interaction.
	RequestCertificate func(ctx context.Context, connection TLSConnectioner, flags TLSCertificateRequestFlags) (TLSInteractionResult, error)
	// RequestCertificateFinish: complete a request certificate
	// user interaction request. This should be once the
	// g_tls_interaction_request_certificate_async() completion callback is
	// called.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed
	// to g_tls_interaction_request_certificate_async() will have had its
	// Connection:certificate filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code.
	//
	// The function takes the following parameters:
	//
	//   - result passed to the callback.
	//
	// The function returns the following values:
	//
	//   - tlsInteractionResult status of the request certificate interaction.
	RequestCertificateFinish func(result AsyncResulter) (TLSInteractionResult, error)
}

func defaultTLSInteractionOverrides(v *TLSInteraction) TLSInteractionOverrides {
	return TLSInteractionOverrides{
		AskPassword:              v.askPassword,
		AskPasswordFinish:        v.askPasswordFinish,
		RequestCertificate:       v.requestCertificate,
		RequestCertificateFinish: v.requestCertificateFinish,
	}
}

// TLSInteraction: GTlsInteraction provides a mechanism for the TLS connection
// and database code to interact with the user. It can be used to ask the user
// for passwords.
//
// To use a GTlsInteraction with a TLS connection use
// gio.TLSConnection.SetInteraction().
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// gio.TLSInteraction.InvokeAskPassword() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop and not
// in the current thread, if the current thread is not running the main loop.
//
// Derived classes can choose to implement whichever interactions methods
// theyd like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TLSInteraction struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TLSInteraction)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TLSInteraction, *TLSInteractionClass, TLSInteractionOverrides](
		GTypeTLSInteraction,
		initTLSInteractionClass,
		wrapTLSInteraction,
		defaultTLSInteractionOverrides,
	)
}

func initTLSInteractionClass(gclass unsafe.Pointer, overrides TLSInteractionOverrides, classInitFunc func(*TLSInteractionClass)) {
	pclass := (*C.GTlsInteractionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTLSInteraction))))

	if overrides.AskPassword != nil {
		pclass.ask_password = (*[0]byte)(C._gotk4_gio2_TlsInteractionClass_ask_password)
	}

	if overrides.AskPasswordFinish != nil {
		pclass.ask_password_finish = (*[0]byte)(C._gotk4_gio2_TlsInteractionClass_ask_password_finish)
	}

	if overrides.RequestCertificate != nil {
		pclass.request_certificate = (*[0]byte)(C._gotk4_gio2_TlsInteractionClass_request_certificate)
	}

	if overrides.RequestCertificateFinish != nil {
		pclass.request_certificate_finish = (*[0]byte)(C._gotk4_gio2_TlsInteractionClass_request_certificate_finish)
	}

	if classInitFunc != nil {
		class := (*TLSInteractionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTLSInteraction(obj *coreglib.Object) *TLSInteraction {
	return &TLSInteraction{
		Object: obj,
	}
}

func marshalTLSInteraction(p uintptr) (interface{}, error) {
	return wrapTLSInteraction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AskPassword: run synchronous interaction to ask the user for a password.
// In general, g_tls_interaction_invoke_ask_password() should be used instead of
// this function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The password value will be
// filled in and then callback will be called. Alternatively the user may abort
// this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - password: Password object.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the ask password interaction.
func (interaction *TLSInteraction) AskPassword(ctx context.Context, password *TLSPassword) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg2 *C.GCancellable         // out
	var _arg1 *C.GTlsPassword         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C.g_tls_interaction_ask_password(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(password)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// AskPasswordAsync: run asynchronous interaction to ask the user for a
// password. In general, g_tls_interaction_invoke_ask_password() should be used
// instead of this function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The password value will be
// filled in and then callback will be called. Alternatively the user may abort
// this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// Certain implementations may not support immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - password: Password object.
//   - callback (optional) will be called when the interaction completes.
func (interaction *TLSInteraction) AskPasswordAsync(ctx context.Context, password *TLSPassword, callback AsyncReadyCallback) {
	var _arg0 *C.GTlsInteraction    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GTlsPassword       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_tls_interaction_ask_password_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(password)
	runtime.KeepAlive(callback)
}

// AskPasswordFinish: complete an ask password user interaction request. This
// should be once the g_tls_interaction_ask_password_async() completion callback
// is called.
//
// If G_TLS_INTERACTION_HANDLED is returned, then the Password passed to
// g_tls_interaction_ask_password() will have its password filled in.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code.
//
// The function takes the following parameters:
//
//   - result passed to the callback.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the ask password interaction.
func (interaction *TLSInteraction) AskPasswordFinish(result AsyncResulter) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_tls_interaction_ask_password_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// InvokeAskPassword: invoke the interaction to ask the user for a password. It
// invokes this interaction in the main loop, specifically the Context returned
// by g_main_context_get_thread_default() when the interaction is created. This
// is called by called by Connection or Database to ask the user for a password.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The password value will be
// filled in and then callback will be called. Alternatively the user may abort
// this password request, which will usually abort the TLS connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - password: Password object.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the ask password interaction.
func (interaction *TLSInteraction) InvokeAskPassword(ctx context.Context, password *TLSPassword) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg2 *C.GCancellable         // out
	var _arg1 *C.GTlsPassword         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C.g_tls_interaction_invoke_ask_password(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(password)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// InvokeRequestCertificate: invoke the interaction to ask the user
// to choose a certificate to use with the connection. It invokes this
// interaction in the main loop, specifically the Context returned by
// g_main_context_get_thread_default() when the interaction is created. This is
// called by called by Connection when the peer requests a certificate during
// the handshake.
//
// Derived subclasses usually implement a certificate selector, although they
// may also choose to provide a certificate from elsewhere. Alternatively the
// user may abort this certificate request, which may or may not abort the TLS
// connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - connection: Connection object.
//   - flags providing more information about the request.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the certificate request interaction.
func (interaction *TLSInteraction) InvokeRequestCertificate(ctx context.Context, connection TLSConnectioner, flags TLSCertificateRequestFlags) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction            // out
	var _arg3 *C.GCancellable               // out
	var _arg1 *C.GTlsConnection             // out
	var _arg2 C.GTlsCertificateRequestFlags // out
	var _cret C.GTlsInteractionResult       // in
	var _cerr *C.GError                     // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = C.GTlsCertificateRequestFlags(flags)

	_cret = C.g_tls_interaction_invoke_request_certificate(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// RequestCertificate: run synchronous interaction to ask the user
// to choose a certificate to use with the connection. In general,
// g_tls_interaction_invoke_request_certificate() should be used instead of this
// function.
//
// Derived subclasses usually implement a certificate selector, although they
// may also choose to provide a certificate from elsewhere. Alternatively the
// user may abort this certificate request, which will usually abort the TLS
// connection.
//
// If G_TLS_INTERACTION_HANDLED is returned, then the Connection
// passed to g_tls_interaction_request_certificate() will have had its
// Connection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - connection: Connection object.
//   - flags providing more information about the request.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the request certificate interaction.
func (interaction *TLSInteraction) RequestCertificate(ctx context.Context, connection TLSConnectioner, flags TLSCertificateRequestFlags) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction            // out
	var _arg3 *C.GCancellable               // out
	var _arg1 *C.GTlsConnection             // out
	var _arg2 C.GTlsCertificateRequestFlags // out
	var _cret C.GTlsInteractionResult       // in
	var _cerr *C.GError                     // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = C.GTlsCertificateRequestFlags(flags)

	_cret = C.g_tls_interaction_request_certificate(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// RequestCertificateAsync: run asynchronous interaction to ask the
// user for a certificate to use with the connection. In general,
// g_tls_interaction_invoke_request_certificate() should be used instead of this
// function.
//
// Derived subclasses usually implement a certificate selector, although they
// may also choose to provide a certificate from elsewhere. callback will be
// called when the operation completes. Alternatively the user may abort this
// certificate request, which will usually abort the TLS connection.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - connection: Connection object.
//   - flags providing more information about the request.
//   - callback (optional) will be called when the interaction completes.
func (interaction *TLSInteraction) RequestCertificateAsync(ctx context.Context, connection TLSConnectioner, flags TLSCertificateRequestFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GTlsInteraction            // out
	var _arg3 *C.GCancellable               // out
	var _arg1 *C.GTlsConnection             // out
	var _arg2 C.GTlsCertificateRequestFlags // out
	var _arg4 C.GAsyncReadyCallback         // out
	var _arg5 C.gpointer

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = C.GTlsCertificateRequestFlags(flags)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_tls_interaction_request_certificate_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// RequestCertificateFinish: complete a request certificate
// user interaction request. This should be once the
// g_tls_interaction_request_certificate_async() completion callback is called.
//
// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed
// to g_tls_interaction_request_certificate_async() will have had its
// Connection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code.
//
// The function takes the following parameters:
//
//   - result passed to the callback.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the request certificate interaction.
func (interaction *TLSInteraction) RequestCertificateFinish(result AsyncResulter) (TLSInteractionResult, error) {
	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_tls_interaction_request_certificate_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// askPassword: run synchronous interaction to ask the user for a password.
// In general, g_tls_interaction_invoke_ask_password() should be used instead of
// this function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The password value will be
// filled in and then callback will be called. Alternatively the user may abort
// this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - password: Password object.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the ask password interaction.
func (interaction *TLSInteraction) askPassword(ctx context.Context, password *TLSPassword) (TLSInteractionResult, error) {
	gclass := (*C.GTlsInteractionClass)(coreglib.PeekParentClass(interaction))
	fnarg := gclass.ask_password

	var _arg0 *C.GTlsInteraction      // out
	var _arg2 *C.GCancellable         // out
	var _arg1 *C.GTlsPassword         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C._gotk4_gio2_TLSInteraction_virtual_ask_password(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(password)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// askPasswordAsync: run asynchronous interaction to ask the user for a
// password. In general, g_tls_interaction_invoke_ask_password() should be used
// instead of this function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The password value will be
// filled in and then callback will be called. Alternatively the user may abort
// this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// Certain implementations may not support immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - password: Password object.
//   - callback (optional) will be called when the interaction completes.
func (interaction *TLSInteraction) askPasswordAsync(ctx context.Context, password *TLSPassword, callback AsyncReadyCallback) {
	gclass := (*C.GTlsInteractionClass)(coreglib.PeekParentClass(interaction))
	fnarg := gclass.ask_password_async

	var _arg0 *C.GTlsInteraction    // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GTlsPassword       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_TLSInteraction_virtual_ask_password_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(password)
	runtime.KeepAlive(callback)
}

// askPasswordFinish: complete an ask password user interaction request. This
// should be once the g_tls_interaction_ask_password_async() completion callback
// is called.
//
// If G_TLS_INTERACTION_HANDLED is returned, then the Password passed to
// g_tls_interaction_ask_password() will have its password filled in.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code.
//
// The function takes the following parameters:
//
//   - result passed to the callback.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the ask password interaction.
func (interaction *TLSInteraction) askPasswordFinish(result AsyncResulter) (TLSInteractionResult, error) {
	gclass := (*C.GTlsInteractionClass)(coreglib.PeekParentClass(interaction))
	fnarg := gclass.ask_password_finish

	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_TLSInteraction_virtual_ask_password_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// requestCertificate: run synchronous interaction to ask the user
// to choose a certificate to use with the connection. In general,
// g_tls_interaction_invoke_request_certificate() should be used instead of this
// function.
//
// Derived subclasses usually implement a certificate selector, although they
// may also choose to provide a certificate from elsewhere. Alternatively the
// user may abort this certificate request, which will usually abort the TLS
// connection.
//
// If G_TLS_INTERACTION_HANDLED is returned, then the Connection
// passed to g_tls_interaction_request_certificate() will have had its
// Connection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains
// a G_IO_ERROR_CANCELLED error code. Certain implementations may not support
// immediate cancellation.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - connection: Connection object.
//   - flags providing more information about the request.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the request certificate interaction.
func (interaction *TLSInteraction) requestCertificate(ctx context.Context, connection TLSConnectioner, flags TLSCertificateRequestFlags) (TLSInteractionResult, error) {
	gclass := (*C.GTlsInteractionClass)(coreglib.PeekParentClass(interaction))
	fnarg := gclass.request_certificate

	var _arg0 *C.GTlsInteraction            // out
	var _arg3 *C.GCancellable               // out
	var _arg1 *C.GTlsConnection             // out
	var _arg2 C.GTlsCertificateRequestFlags // out
	var _cret C.GTlsInteractionResult       // in
	var _cerr *C.GError                     // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = C.GTlsCertificateRequestFlags(flags)

	_cret = C._gotk4_gio2_TLSInteraction_virtual_request_certificate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// requestCertificateAsync: run asynchronous interaction to ask the
// user for a certificate to use with the connection. In general,
// g_tls_interaction_invoke_request_certificate() should be used instead of this
// function.
//
// Derived subclasses usually implement a certificate selector, although they
// may also choose to provide a certificate from elsewhere. callback will be
// called when the operation completes. Alternatively the user may abort this
// certificate request, which will usually abort the TLS connection.
//
// The function takes the following parameters:
//
//   - ctx (optional): optional #GCancellable cancellation object.
//   - connection: Connection object.
//   - flags providing more information about the request.
//   - callback (optional) will be called when the interaction completes.
func (interaction *TLSInteraction) requestCertificateAsync(ctx context.Context, connection TLSConnectioner, flags TLSCertificateRequestFlags, callback AsyncReadyCallback) {
	gclass := (*C.GTlsInteractionClass)(coreglib.PeekParentClass(interaction))
	fnarg := gclass.request_certificate_async

	var _arg0 *C.GTlsInteraction            // out
	var _arg3 *C.GCancellable               // out
	var _arg1 *C.GTlsConnection             // out
	var _arg2 C.GTlsCertificateRequestFlags // out
	var _arg4 C.GAsyncReadyCallback         // out
	var _arg5 C.gpointer

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = C.GTlsCertificateRequestFlags(flags)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_TLSInteraction_virtual_request_certificate_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// requestCertificateFinish: complete a request certificate
// user interaction request. This should be once the
// g_tls_interaction_request_certificate_async() completion callback is called.
//
// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed
// to g_tls_interaction_request_certificate_async() will have had its
// Connection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the user
// then G_TLS_INTERACTION_FAILED will be returned with an error that contains a
// G_IO_ERROR_CANCELLED error code.
//
// The function takes the following parameters:
//
//   - result passed to the callback.
//
// The function returns the following values:
//
//   - tlsInteractionResult status of the request certificate interaction.
func (interaction *TLSInteraction) requestCertificateFinish(result AsyncResulter) (TLSInteractionResult, error) {
	gclass := (*C.GTlsInteractionClass)(coreglib.PeekParentClass(interaction))
	fnarg := gclass.request_certificate_finish

	var _arg0 *C.GTlsInteraction      // out
	var _arg1 *C.GAsyncResult         // out
	var _cret C.GTlsInteractionResult // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_TLSInteraction_virtual_request_certificate_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var _tlsInteractionResult TLSInteractionResult // out
	var _goerr error                               // out

	_tlsInteractionResult = TLSInteractionResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsInteractionResult, _goerr
}

// TLSPasswordOverrides contains methods that are overridable.
type TLSPasswordOverrides struct {
	// DefaultWarning: virtual method for g_tls_password_get_warning() if no
	// value has been set using g_tls_password_set_warning().
	DefaultWarning func() string
	// Value: get the password value. If length is not NULL then it will be
	// filled in with the length of the password value. (Note that the password
	// value is not nul-terminated, so you can only pass NULL for length in
	// contexts where you know the password will have a certain fixed length.).
	//
	// The function returns the following values:
	//
	//   - guint8s: password value (owned by the password object).
	Value func() []byte
}

func defaultTLSPasswordOverrides(v *TLSPassword) TLSPasswordOverrides {
	return TLSPasswordOverrides{
		DefaultWarning: v.defaultWarning,
		Value:          v.value,
	}
}

// TLSPassword: abstract interface representing a password used in TLS. Often
// used in user interaction such as unlocking a key storage token.
type TLSPassword struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TLSPassword)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TLSPassword, *TLSPasswordClass, TLSPasswordOverrides](
		GTypeTLSPassword,
		initTLSPasswordClass,
		wrapTLSPassword,
		defaultTLSPasswordOverrides,
	)
}

func initTLSPasswordClass(gclass unsafe.Pointer, overrides TLSPasswordOverrides, classInitFunc func(*TLSPasswordClass)) {
	pclass := (*C.GTlsPasswordClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTLSPassword))))

	if overrides.DefaultWarning != nil {
		pclass.get_default_warning = (*[0]byte)(C._gotk4_gio2_TlsPasswordClass_get_default_warning)
	}

	if overrides.Value != nil {
		pclass.get_value = (*[0]byte)(C._gotk4_gio2_TlsPasswordClass_get_value)
	}

	if classInitFunc != nil {
		class := (*TLSPasswordClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTLSPassword(obj *coreglib.Object) *TLSPassword {
	return &TLSPassword{
		Object: obj,
	}
}

func marshalTLSPassword(p uintptr) (interface{}, error) {
	return wrapTLSPassword(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTLSPassword: create a new Password object.
//
// The function takes the following parameters:
//
//   - flags: password flags.
//   - description of what the password is for.
//
// The function returns the following values:
//
//   - tlsPassword: newly allocated password object.
func NewTLSPassword(flags TLSPasswordFlags, description string) *TLSPassword {
	var _arg1 C.GTlsPasswordFlags // out
	var _arg2 *C.gchar            // out
	var _cret *C.GTlsPassword     // in

	_arg1 = C.GTlsPasswordFlags(flags)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_tls_password_new(_arg1, _arg2)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(description)

	var _tlsPassword *TLSPassword // out

	_tlsPassword = wrapTLSPassword(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _tlsPassword
}

// Description: get a description string about what the password will be used
// for.
//
// The function returns the following values:
//
//   - utf8: description of the password.
func (password *TLSPassword) Description() string {
	var _arg0 *C.GTlsPassword // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C.g_tls_password_get_description(_arg0)
	runtime.KeepAlive(password)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Flags: get flags about the password.
//
// The function returns the following values:
//
//   - tlsPasswordFlags flags about the password.
func (password *TLSPassword) Flags() TLSPasswordFlags {
	var _arg0 *C.GTlsPassword     // out
	var _cret C.GTlsPasswordFlags // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C.g_tls_password_get_flags(_arg0)
	runtime.KeepAlive(password)

	var _tlsPasswordFlags TLSPasswordFlags // out

	_tlsPasswordFlags = TLSPasswordFlags(_cret)

	return _tlsPasswordFlags
}

// Value: get the password value. If length is not NULL then it will be filled
// in with the length of the password value. (Note that the password value is
// not nul-terminated, so you can only pass NULL for length in contexts where
// you know the password will have a certain fixed length.).
//
// The function returns the following values:
//
//   - guint8s: password value (owned by the password object).
func (password *TLSPassword) Value() []byte {
	var _arg0 *C.GTlsPassword // out
	var _cret *C.guchar       // in
	var _arg1 C.gsize         // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C.g_tls_password_get_value(_arg0, &_arg1)
	runtime.KeepAlive(password)

	var _guint8s []byte // out

	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// Warning: get a user readable translated warning. Usually this
// warning is a representation of the password flags returned from
// g_tls_password_get_flags().
//
// The function returns the following values:
//
//   - utf8: warning.
func (password *TLSPassword) Warning() string {
	var _arg0 *C.GTlsPassword // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C.g_tls_password_get_warning(_arg0)
	runtime.KeepAlive(password)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetDescription: set a description string about what the password will be used
// for.
//
// The function takes the following parameters:
//
//   - description of the password.
func (password *TLSPassword) SetDescription(description string) {
	var _arg0 *C.GTlsPassword // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_tls_password_set_description(_arg0, _arg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(description)
}

// SetFlags: set flags about the password.
//
// The function takes the following parameters:
//
//   - flags about the password.
func (password *TLSPassword) SetFlags(flags TLSPasswordFlags) {
	var _arg0 *C.GTlsPassword     // out
	var _arg1 C.GTlsPasswordFlags // out

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))
	_arg1 = C.GTlsPasswordFlags(flags)

	C.g_tls_password_set_flags(_arg0, _arg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(flags)
}

// SetValue: set the value for this password. The value will be copied by the
// password object.
//
// Specify the length, for a non-nul-terminated password. Pass -1 as length if
// using a nul-terminated password, and length will be calculated automatically.
// (Note that the terminating nul is not considered part of the password in this
// case.).
//
// The function takes the following parameters:
//
//   - value: new password value.
func (password *TLSPassword) SetValue(value []byte) {
	var _arg0 *C.GTlsPassword // out
	var _arg1 *C.guchar       // out
	var _arg2 C.gssize

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))
	_arg2 = (C.gssize)(len(value))
	if len(value) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&value[0]))
	}

	C.g_tls_password_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(password)
	runtime.KeepAlive(value)
}

// SetWarning: set a user readable translated warning. Usually this
// warning is a representation of the password flags returned from
// g_tls_password_get_flags().
//
// The function takes the following parameters:
//
//   - warning: user readable warning.
func (password *TLSPassword) SetWarning(warning string) {
	var _arg0 *C.GTlsPassword // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(warning)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_tls_password_set_warning(_arg0, _arg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(warning)
}

// defaultWarning: virtual method for g_tls_password_get_warning() if no value
// has been set using g_tls_password_set_warning().
func (password *TLSPassword) defaultWarning() string {
	gclass := (*C.GTlsPasswordClass)(coreglib.PeekParentClass(password))
	fnarg := gclass.get_default_warning

	var _arg0 *C.GTlsPassword // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C._gotk4_gio2_TLSPassword_virtual_get_default_warning(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(password)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Value: get the password value. If length is not NULL then it will be filled
// in with the length of the password value. (Note that the password value is
// not nul-terminated, so you can only pass NULL for length in contexts where
// you know the password will have a certain fixed length.).
//
// The function returns the following values:
//
//   - guint8s: password value (owned by the password object).
func (password *TLSPassword) value() []byte {
	gclass := (*C.GTlsPasswordClass)(coreglib.PeekParentClass(password))
	fnarg := gclass.get_value

	var _arg0 *C.GTlsPassword // out
	var _cret *C.guchar       // in
	var _arg1 C.gsize         // in

	_arg0 = (*C.GTlsPassword)(unsafe.Pointer(coreglib.InternObject(password).Native()))

	_cret = C._gotk4_gio2_TLSPassword_virtual_get_value(unsafe.Pointer(fnarg), _arg0, &_arg1)
	runtime.KeepAlive(password)

	var _guint8s []byte // out

	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// VFSOverrides contains methods that are overridable.
type VFSOverrides struct {
	AddWritableNamespaces func(list *FileAttributeInfoList)
	// FileForPath gets a #GFile for path.
	//
	// The function takes the following parameters:
	//
	//   - path: string containing a VFS path.
	//
	// The function returns the following values:
	//
	//   - file: #GFile. Free the returned object with g_object_unref().
	FileForPath func(path string) *File
	// FileForURI gets a #GFile for uri.
	//
	// This operation never fails, but the returned object might not support
	// any I/O operation if the URI is malformed or if the URI scheme is not
	// supported.
	//
	// The function takes the following parameters:
	//
	//   - uri: string containing a URI.
	//
	// The function returns the following values:
	//
	//   - file: #GFile. Free the returned object with g_object_unref().
	FileForURI func(uri string) *File
	// SupportedURISchemes gets a list of URI schemes supported by vfs.
	//
	// The function returns the following values:
	//
	//   - utf8s: NULL-terminated array of strings. The returned array belongs
	//     to GIO and must not be freed or modified.
	SupportedURISchemes func() []string
	// IsActive checks if the VFS is active.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if construction of the vfs was successful and it is now
	//     active.
	IsActive func() bool
	// The function takes the following parameters:
	//
	//   - source
	//   - dest
	LocalFileMoved   func(source, dest string)
	LocalFileRemoved func(filename string)
	// The function takes the following parameters:
	//
	//   - ctx (optional)
	//   - filename
	//   - info
	//   - flags
	LocalFileSetAttributes func(ctx context.Context, filename string, info *FileInfo, flags FileQueryInfoFlags) error
	// ParseName: this operation never fails, but the returned object might
	// not support any I/O operations if the parse_name cannot be parsed by the
	// #GVfs module.
	//
	// The function takes the following parameters:
	//
	//   - parseName: string to be parsed by the VFS module.
	//
	// The function returns the following values:
	//
	//   - file for the given parse_name. Free the returned object with
	//     g_object_unref().
	ParseName func(parseName string) *File
}

func defaultVFSOverrides(v *VFS) VFSOverrides {
	return VFSOverrides{
		AddWritableNamespaces:  v.addWritableNamespaces,
		FileForPath:            v.fileForPath,
		FileForURI:             v.fileForURI,
		SupportedURISchemes:    v.supportedURISchemes,
		IsActive:               v.isActive,
		LocalFileMoved:         v.localFileMoved,
		LocalFileRemoved:       v.localFileRemoved,
		LocalFileSetAttributes: v.localFileSetAttributes,
		ParseName:              v.parseName,
	}
}

// VFS: entry point for using GIO functionality.
type VFS struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*VFS)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*VFS, *VFSClass, VFSOverrides](
		GTypeVFS,
		initVFSClass,
		wrapVFS,
		defaultVFSOverrides,
	)
}

func initVFSClass(gclass unsafe.Pointer, overrides VFSOverrides, classInitFunc func(*VFSClass)) {
	pclass := (*C.GVfsClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVFS))))

	if overrides.AddWritableNamespaces != nil {
		pclass.add_writable_namespaces = (*[0]byte)(C._gotk4_gio2_VfsClass_add_writable_namespaces)
	}

	if overrides.FileForPath != nil {
		pclass.get_file_for_path = (*[0]byte)(C._gotk4_gio2_VfsClass_get_file_for_path)
	}

	if overrides.FileForURI != nil {
		pclass.get_file_for_uri = (*[0]byte)(C._gotk4_gio2_VfsClass_get_file_for_uri)
	}

	if overrides.SupportedURISchemes != nil {
		pclass.get_supported_uri_schemes = (*[0]byte)(C._gotk4_gio2_VfsClass_get_supported_uri_schemes)
	}

	if overrides.IsActive != nil {
		pclass.is_active = (*[0]byte)(C._gotk4_gio2_VfsClass_is_active)
	}

	if overrides.LocalFileMoved != nil {
		pclass.local_file_moved = (*[0]byte)(C._gotk4_gio2_VfsClass_local_file_moved)
	}

	if overrides.LocalFileRemoved != nil {
		pclass.local_file_removed = (*[0]byte)(C._gotk4_gio2_VfsClass_local_file_removed)
	}

	if overrides.LocalFileSetAttributes != nil {
		pclass.local_file_set_attributes = (*[0]byte)(C._gotk4_gio2_VfsClass_local_file_set_attributes)
	}

	if overrides.ParseName != nil {
		pclass.parse_name = (*[0]byte)(C._gotk4_gio2_VfsClass_parse_name)
	}

	if classInitFunc != nil {
		class := (*VFSClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVFS(obj *coreglib.Object) *VFS {
	return &VFS{
		Object: obj,
	}
}

func marshalVFS(p uintptr) (interface{}, error) {
	return wrapVFS(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FileForPath gets a #GFile for path.
//
// The function takes the following parameters:
//
//   - path: string containing a VFS path.
//
// The function returns the following values:
//
//   - file: #GFile. Free the returned object with g_object_unref().
func (vfs *VFS) FileForPath(path string) *File {
	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_get_file_for_path(_arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(path)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// FileForURI gets a #GFile for uri.
//
// This operation never fails, but the returned object might not support any I/O
// operation if the URI is malformed or if the URI scheme is not supported.
//
// The function takes the following parameters:
//
//   - uri: string containing a URI.
//
// The function returns the following values:
//
//   - file: #GFile. Free the returned object with g_object_unref().
func (vfs *VFS) FileForURI(uri string) *File {
	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_get_file_for_uri(_arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(uri)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// SupportedURISchemes gets a list of URI schemes supported by vfs.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings. The returned array belongs to
//     GIO and must not be freed or modified.
func (vfs *VFS) SupportedURISchemes() []string {
	var _arg0 *C.GVfs   // out
	var _cret **C.gchar // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))

	_cret = C.g_vfs_get_supported_uri_schemes(_arg0)
	runtime.KeepAlive(vfs)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// IsActive checks if the VFS is active.
//
// The function returns the following values:
//
//   - ok: TRUE if construction of the vfs was successful and it is now active.
func (vfs *VFS) IsActive() bool {
	var _arg0 *C.GVfs    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))

	_cret = C.g_vfs_is_active(_arg0)
	runtime.KeepAlive(vfs)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseName: this operation never fails, but the returned object might not
// support any I/O operations if the parse_name cannot be parsed by the #GVfs
// module.
//
// The function takes the following parameters:
//
//   - parseName: string to be parsed by the VFS module.
//
// The function returns the following values:
//
//   - file for the given parse_name. Free the returned object with
//     g_object_unref().
func (vfs *VFS) ParseName(parseName string) *File {
	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_parse_name(_arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(parseName)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// RegisterURIScheme registers uri_func and parse_name_func as the #GFile URI
// and parse name lookup functions for URIs with a scheme matching scheme. Note
// that scheme is registered only within the running application, as opposed to
// desktop-wide as it happens with GVfs backends.
//
// When a #GFile is requested with an URI containing scheme (e.g. through
// g_file_new_for_uri()), uri_func will be called to allow a custom constructor.
// The implementation of uri_func should not be blocking, and must not call
// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
//
// When g_file_parse_name() is called with a parse name obtained from such file,
// parse_name_func will be called to allow the #GFile to be created again.
// In that case, it's responsibility of parse_name_func to make sure the
// parse name matches what the custom #GFile implementation returned when
// g_file_get_parse_name() was previously called. The implementation
// of parse_name_func should not be blocking, and must not call
// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
//
// It's an error to call this function twice with the same scheme. To unregister
// a custom URI scheme, use g_vfs_unregister_uri_scheme().
//
// The function takes the following parameters:
//
//   - scheme: URI scheme, e.g. "http".
//   - uriFunc (optional): FileLookupFunc.
//   - parseNameFunc (optional): FileLookupFunc.
//
// The function returns the following values:
//
//   - ok: TRUE if scheme was successfully registered, or FALSE if a handler for
//     scheme already exists.
func (vfs *VFS) RegisterURIScheme(scheme string, uriFunc, parseNameFunc VFSFileLookupFunc) bool {
	var _arg0 *C.GVfs              // out
	var _arg1 *C.char              // out
	var _arg2 C.GVfsFileLookupFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _arg5 C.GVfsFileLookupFunc // out
	var _arg6 C.gpointer
	var _arg7 C.GDestroyNotify
	var _cret C.gboolean // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg1))
	if uriFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_VFSFileLookupFunc)
		_arg3 = C.gpointer(gbox.Assign(uriFunc))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}
	if parseNameFunc != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_VFSFileLookupFunc)
		_arg6 = C.gpointer(gbox.Assign(parseNameFunc))
		_arg7 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.g_vfs_register_uri_scheme(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(uriFunc)
	runtime.KeepAlive(parseNameFunc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnregisterURIScheme unregisters the URI handler for scheme previously
// registered with g_vfs_register_uri_scheme().
//
// The function takes the following parameters:
//
//   - scheme: URI scheme, e.g. "http".
//
// The function returns the following values:
//
//   - ok: TRUE if scheme was successfully unregistered, or FALSE if a handler
//     for scheme does not exist.
func (vfs *VFS) UnregisterURIScheme(scheme string) bool {
	var _arg0 *C.GVfs    // out
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_vfs_unregister_uri_scheme(_arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(scheme)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (vfs *VFS) addWritableNamespaces(list *FileAttributeInfoList) {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.add_writable_namespaces

	var _arg0 *C.GVfs                   // out
	var _arg1 *C.GFileAttributeInfoList // out

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.GFileAttributeInfoList)(gextras.StructNative(unsafe.Pointer(list)))

	C._gotk4_gio2_VFS_virtual_add_writable_namespaces(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(list)
}

// fileForPath gets a #GFile for path.
//
// The function takes the following parameters:
//
//   - path: string containing a VFS path.
//
// The function returns the following values:
//
//   - file: #GFile. Free the returned object with g_object_unref().
func (vfs *VFS) fileForPath(path string) *File {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.get_file_for_path

	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_VFS_virtual_get_file_for_path(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(path)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// fileForURI gets a #GFile for uri.
//
// This operation never fails, but the returned object might not support any I/O
// operation if the URI is malformed or if the URI scheme is not supported.
//
// The function takes the following parameters:
//
//   - uri: string containing a URI.
//
// The function returns the following values:
//
//   - file: #GFile. Free the returned object with g_object_unref().
func (vfs *VFS) fileForURI(uri string) *File {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.get_file_for_uri

	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_VFS_virtual_get_file_for_uri(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(uri)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// supportedURISchemes gets a list of URI schemes supported by vfs.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings. The returned array belongs to
//     GIO and must not be freed or modified.
func (vfs *VFS) supportedURISchemes() []string {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.get_supported_uri_schemes

	var _arg0 *C.GVfs   // out
	var _cret **C.gchar // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))

	_cret = C._gotk4_gio2_VFS_virtual_get_supported_uri_schemes(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(vfs)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// isActive checks if the VFS is active.
//
// The function returns the following values:
//
//   - ok: TRUE if construction of the vfs was successful and it is now active.
func (vfs *VFS) isActive() bool {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.is_active

	var _arg0 *C.GVfs    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))

	_cret = C._gotk4_gio2_VFS_virtual_is_active(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(vfs)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - source
//   - dest
func (vfs *VFS) localFileMoved(source, dest string) {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.local_file_moved

	var _arg0 *C.GVfs // out
	var _arg1 *C.char // out
	var _arg2 *C.char // out

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gio2_VFS_virtual_local_file_moved(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(source)
	runtime.KeepAlive(dest)
}

func (vfs *VFS) localFileRemoved(filename string) {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.local_file_removed

	var _arg0 *C.GVfs // out
	var _arg1 *C.char // out

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_VFS_virtual_local_file_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(filename)
}

// The function takes the following parameters:
//
//   - ctx (optional)
//   - filename
//   - info
//   - flags
func (vfs *VFS) localFileSetAttributes(ctx context.Context, filename string, info *FileInfo, flags FileQueryInfoFlags) error {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.local_file_set_attributes

	var _arg0 *C.GVfs               // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 *C.GFileInfo          // out
	var _arg3 C.GFileQueryInfoFlags // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg3 = C.GFileQueryInfoFlags(flags)

	C._gotk4_gio2_VFS_virtual_local_file_set_attributes(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// parseName: this operation never fails, but the returned object might not
// support any I/O operations if the parse_name cannot be parsed by the #GVfs
// module.
//
// The function takes the following parameters:
//
//   - parseName: string to be parsed by the VFS module.
//
// The function returns the following values:
//
//   - file for the given parse_name. Free the returned object with
//     g_object_unref().
func (vfs *VFS) parseName(parseName string) *File {
	gclass := (*C.GVfsClass)(coreglib.PeekParentClass(vfs))
	fnarg := gclass.parse_name

	var _arg0 *C.GVfs  // out
	var _arg1 *C.char  // out
	var _cret *C.GFile // in

	_arg0 = (*C.GVfs)(unsafe.Pointer(coreglib.InternObject(vfs).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_VFS_virtual_parse_name(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(parseName)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _file
}

// VFSGetDefault gets the default #GVfs for the system.
//
// The function returns the following values:
//
//   - vfs which will be the local file system #GVfs if no other implementation
//     is available.
func VFSGetDefault() *VFS {
	var _cret *C.GVfs // in

	_cret = C.g_vfs_get_default()

	var _vfs *VFS // out

	_vfs = wrapVFS(coreglib.Take(unsafe.Pointer(_cret)))

	return _vfs
}

// VFSGetLocal gets the local #GVfs for the system.
//
// The function returns the following values:
//
//   - vfs: #GVfs.
func VFSGetLocal() *VFS {
	var _cret *C.GVfs // in

	_cret = C.g_vfs_get_local()

	var _vfs *VFS // out

	_vfs = wrapVFS(coreglib.Take(unsafe.Pointer(_cret)))

	return _vfs
}

// VolumeMonitorOverrides contains methods that are overridable.
type VolumeMonitorOverrides struct {
	DriveChanged      func(drive Driver)
	DriveConnected    func(drive Driver)
	DriveDisconnected func(drive Driver)
	DriveEjectButton  func(drive Driver)
	DriveStopButton   func(drive Driver)
	// ConnectedDrives gets a list of drives connected to the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//   - list of connected #GDrive objects.
	ConnectedDrives func() []*Drive
	// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//   - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//   - mount (optional) or NULL if no such mount is available. Free the
	//     returned object with g_object_unref().
	MountForUUID func(uuid string) *Mount
	// Mounts gets a list of the mounts on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//   - list of #GMount objects.
	Mounts func() []*Mount
	// VolumeForUUID finds a #GVolume object by its UUID (see
	// g_volume_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//   - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//   - volume (optional) or NULL if no such volume is available. Free the
	//     returned object with g_object_unref().
	VolumeForUUID func(uuid string) *Volume
	// Volumes gets a list of the volumes on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//   - list of #GVolume objects.
	Volumes         func() []*Volume
	MountAdded      func(mount Mounter)
	MountChanged    func(mount Mounter)
	MountPreUnmount func(mount Mounter)
	MountRemoved    func(mount Mounter)
	VolumeAdded     func(volume Volumer)
	VolumeChanged   func(volume Volumer)
	VolumeRemoved   func(volume Volumer)
}

func defaultVolumeMonitorOverrides(v *VolumeMonitor) VolumeMonitorOverrides {
	return VolumeMonitorOverrides{
		DriveChanged:      v.driveChanged,
		DriveConnected:    v.driveConnected,
		DriveDisconnected: v.driveDisconnected,
		DriveEjectButton:  v.driveEjectButton,
		DriveStopButton:   v.driveStopButton,
		ConnectedDrives:   v.connectedDrives,
		MountForUUID:      v.mountForUUID,
		Mounts:            v.mounts,
		VolumeForUUID:     v.volumeForUUID,
		Volumes:           v.volumes,
		MountAdded:        v.mountAdded,
		MountChanged:      v.mountChanged,
		MountPreUnmount:   v.mountPreUnmount,
		MountRemoved:      v.mountRemoved,
		VolumeAdded:       v.volumeAdded,
		VolumeChanged:     v.volumeChanged,
		VolumeRemoved:     v.volumeRemoved,
	}
}

// VolumeMonitor: GVolumeMonitor is for listing the user interesting devices and
// volumes on the computer. In other words, what a file selector or file manager
// would show in a sidebar.
//
// GVolumeMonitor is not thread-default-context aware (see
// glib.MainContext.PushThreadDefault()), and so should not be used other than
// from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*VolumeMonitor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*VolumeMonitor, *VolumeMonitorClass, VolumeMonitorOverrides](
		GTypeVolumeMonitor,
		initVolumeMonitorClass,
		wrapVolumeMonitor,
		defaultVolumeMonitorOverrides,
	)
}

func initVolumeMonitorClass(gclass unsafe.Pointer, overrides VolumeMonitorOverrides, classInitFunc func(*VolumeMonitorClass)) {
	pclass := (*C.GVolumeMonitorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVolumeMonitor))))

	if overrides.DriveChanged != nil {
		pclass.drive_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_changed)
	}

	if overrides.DriveConnected != nil {
		pclass.drive_connected = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_connected)
	}

	if overrides.DriveDisconnected != nil {
		pclass.drive_disconnected = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_disconnected)
	}

	if overrides.DriveEjectButton != nil {
		pclass.drive_eject_button = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_eject_button)
	}

	if overrides.DriveStopButton != nil {
		pclass.drive_stop_button = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_stop_button)
	}

	if overrides.ConnectedDrives != nil {
		pclass.get_connected_drives = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_connected_drives)
	}

	if overrides.MountForUUID != nil {
		pclass.get_mount_for_uuid = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid)
	}

	if overrides.Mounts != nil {
		pclass.get_mounts = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_mounts)
	}

	if overrides.VolumeForUUID != nil {
		pclass.get_volume_for_uuid = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid)
	}

	if overrides.Volumes != nil {
		pclass.get_volumes = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_volumes)
	}

	if overrides.MountAdded != nil {
		pclass.mount_added = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_added)
	}

	if overrides.MountChanged != nil {
		pclass.mount_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_changed)
	}

	if overrides.MountPreUnmount != nil {
		pclass.mount_pre_unmount = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_pre_unmount)
	}

	if overrides.MountRemoved != nil {
		pclass.mount_removed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_removed)
	}

	if overrides.VolumeAdded != nil {
		pclass.volume_added = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_added)
	}

	if overrides.VolumeChanged != nil {
		pclass.volume_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_changed)
	}

	if overrides.VolumeRemoved != nil {
		pclass.volume_removed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_removed)
	}

	if classInitFunc != nil {
		class := (*VolumeMonitorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVolumeMonitor(obj *coreglib.Object) *VolumeMonitor {
	return &VolumeMonitor{
		Object: obj,
	}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	return wrapVolumeMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDriveChanged is emitted when a drive changes.
func (volumeMonitor *VolumeMonitor) ConnectDriveChanged(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveChanged), f)
}

// ConnectDriveConnected is emitted when a drive is connected to the system.
func (volumeMonitor *VolumeMonitor) ConnectDriveConnected(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-connected", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveConnected), f)
}

// ConnectDriveDisconnected is emitted when a drive is disconnected from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectDriveDisconnected(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-disconnected", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected), f)
}

// ConnectDriveEjectButton is emitted when the eject button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveEjectButton(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-eject-button", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton), f)
}

// ConnectDriveStopButton is emitted when the stop button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveStopButton(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-stop-button", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveStopButton), f)
}

// ConnectMountAdded is emitted when a mount is added.
func (volumeMonitor *VolumeMonitor) ConnectMountAdded(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-added", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountAdded), f)
}

// ConnectMountChanged is emitted when a mount changes.
func (volumeMonitor *VolumeMonitor) ConnectMountChanged(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountChanged), f)
}

// ConnectMountPreUnmount: may be emitted when a mount is about to be removed.
//
// This signal depends on the backend and is only emitted if GIO was used to
// unmount.
func (volumeMonitor *VolumeMonitor) ConnectMountPreUnmount(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-pre-unmount", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount), f)
}

// ConnectMountRemoved is emitted when a mount is removed.
func (volumeMonitor *VolumeMonitor) ConnectMountRemoved(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-removed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountRemoved), f)
}

// ConnectVolumeAdded is emitted when a mountable volume is added to the system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeAdded(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-added", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeAdded), f)
}

// ConnectVolumeChanged is emitted when mountable volume is changed.
func (volumeMonitor *VolumeMonitor) ConnectVolumeChanged(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeChanged), f)
}

// ConnectVolumeRemoved is emitted when a mountable volume is removed from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeRemoved(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-removed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved), f)
}

// ConnectedDrives gets a list of drives connected to the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list of connected #GDrive objects.
func (volumeMonitor *VolumeMonitor) ConnectedDrives() []*Drive {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_connected_drives(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Drive // out

	_list = make([]*Drive, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDrive)(v)
		var dst *Drive // out
		dst = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
//
// The function takes the following parameters:
//
//   - uuid: UUID to look for.
//
// The function returns the following values:
//
//   - mount (optional) or NULL if no such mount is available. Free the returned
//     object with g_object_unref().
func (volumeMonitor *VolumeMonitor) MountForUUID(uuid string) *Mount {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GMount         // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_mount_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _mount *Mount // out

	if _cret != nil {
		_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _mount
}

// Mounts gets a list of the mounts on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list of #GMount objects.
func (volumeMonitor *VolumeMonitor) Mounts() []*Mount {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_mounts(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Mount // out

	_list = make([]*Mount, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GMount)(v)
		var dst *Mount // out
		dst = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// VolumeForUUID finds a #GVolume object by its UUID (see g_volume_get_uuid()).
//
// The function takes the following parameters:
//
//   - uuid: UUID to look for.
//
// The function returns the following values:
//
//   - volume (optional) or NULL if no such volume is available. Free the
//     returned object with g_object_unref().
func (volumeMonitor *VolumeMonitor) VolumeForUUID(uuid string) *Volume {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GVolume        // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_volume_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _volume *Volume // out

	if _cret != nil {
		_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _volume
}

// Volumes gets a list of the volumes on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list of #GVolume objects.
func (volumeMonitor *VolumeMonitor) Volumes() []*Volume {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_volumes(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Volume // out

	_list = make([]*Volume, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst *Volume // out
		dst = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

func (volumeMonitor *VolumeMonitor) driveChanged(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_changed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

func (volumeMonitor *VolumeMonitor) driveConnected(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_connected

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_connected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

func (volumeMonitor *VolumeMonitor) driveDisconnected(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_disconnected

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_disconnected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

func (volumeMonitor *VolumeMonitor) driveEjectButton(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_eject_button

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_eject_button(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

func (volumeMonitor *VolumeMonitor) driveStopButton(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_stop_button

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_stop_button(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// connectedDrives gets a list of drives connected to the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list of connected #GDrive objects.
func (volumeMonitor *VolumeMonitor) connectedDrives() []*Drive {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_connected_drives

	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_connected_drives(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Drive // out

	_list = make([]*Drive, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDrive)(v)
		var dst *Drive // out
		dst = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// mountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
//
// The function takes the following parameters:
//
//   - uuid: UUID to look for.
//
// The function returns the following values:
//
//   - mount (optional) or NULL if no such mount is available. Free the returned
//     object with g_object_unref().
func (volumeMonitor *VolumeMonitor) mountForUUID(uuid string) *Mount {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_mount_for_uuid

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GMount         // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_mount_for_uuid(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _mount *Mount // out

	if _cret != nil {
		_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _mount
}

// Mounts gets a list of the mounts on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list of #GMount objects.
func (volumeMonitor *VolumeMonitor) mounts() []*Mount {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_mounts

	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_mounts(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Mount // out

	_list = make([]*Mount, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GMount)(v)
		var dst *Mount // out
		dst = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// volumeForUUID finds a #GVolume object by its UUID (see g_volume_get_uuid()).
//
// The function takes the following parameters:
//
//   - uuid: UUID to look for.
//
// The function returns the following values:
//
//   - volume (optional) or NULL if no such volume is available. Free the
//     returned object with g_object_unref().
func (volumeMonitor *VolumeMonitor) volumeForUUID(uuid string) *Volume {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_volume_for_uuid

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GVolume        // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_volume_for_uuid(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _volume *Volume // out

	if _cret != nil {
		_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _volume
}

// Volumes gets a list of the volumes on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//   - list of #GVolume objects.
func (volumeMonitor *VolumeMonitor) volumes() []*Volume {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_volumes

	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_volumes(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Volume // out

	_list = make([]*Volume, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst *Volume // out
		dst = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

func (volumeMonitor *VolumeMonitor) mountAdded(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_added

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

func (volumeMonitor *VolumeMonitor) mountChanged(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_changed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

func (volumeMonitor *VolumeMonitor) mountPreUnmount(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_pre_unmount

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_pre_unmount(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

func (volumeMonitor *VolumeMonitor) mountRemoved(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_removed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

func (volumeMonitor *VolumeMonitor) volumeAdded(volume Volumer) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.volume_added

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GVolume        // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_volume_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

func (volumeMonitor *VolumeMonitor) volumeChanged(volume Volumer) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.volume_changed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GVolume        // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_volume_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

func (volumeMonitor *VolumeMonitor) volumeRemoved(volume Volumer) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.volume_removed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GVolume        // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_volume_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// VolumeMonitorAdoptOrphanMount: this function should be called by any
// Monitor implementation when a new #GMount object is created that is not
// associated with a #GVolume object. It must be called just before emitting the
// mount_added signal.
//
// If the return value is not NULL, the caller must associate the returned
// #GVolume object with the #GMount. This involves returning it in its
// g_mount_get_volume() implementation. The caller must also listen for the
// "removed" signal on the returned object and give up its reference when
// handling that signal
//
// Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
// the implementor must take a reference to mount and return it in its
// g_volume_get_mount() implemented. Also, the implementor must listen for the
// "unmounted" signal on mount and give up its reference upon handling that
// signal.
//
// There are two main use cases for this function.
//
// One is when implementing a user space file system driver that reads blocks
// of a block device that is already represented by the native volume monitor
// (for example a CD Audio file system driver). Such a driver will generate its
// own #GMount object that needs to be associated with the #GVolume object that
// represents the volume.
//
// The other is for implementing a Monitor whose sole purpose is to return
// #GVolume objects representing entries in the users "favorite servers" list or
// similar.
//
// Deprecated: Instead of using this function, Monitor implementations should
// instead create shadow mounts with the URI of the mount they intend to adopt.
// See the proxy volume monitor in gvfs for an example of this. Also see
// g_mount_is_shadowed(), g_mount_shadow() and g_mount_unshadow() functions.
//
// The function takes the following parameters:
//
//   - mount object to find a parent for.
//
// The function returns the following values:
//
//   - volume object that is the parent for mount or NULL if no wants to adopt
//     the #GMount.
func VolumeMonitorAdoptOrphanMount(mount Mounter) *Volume {
	var _arg1 *C.GMount  // out
	var _cret *C.GVolume // in

	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_volume_monitor_adopt_orphan_mount(_arg1)
	runtime.KeepAlive(mount)

	var _volume *Volume // out

	_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _volume
}

// VolumeMonitorGet gets the volume monitor used by gio.
//
// The function returns the following values:
//
//   - volumeMonitor: reference to the Monitor used by gio. Call
//     g_object_unref() when done with it.
func VolumeMonitorGet() *VolumeMonitor {
	var _cret *C.GVolumeMonitor // in

	_cret = C.g_volume_monitor_get()

	var _volumeMonitor *VolumeMonitor // out

	_volumeMonitor = wrapVolumeMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _volumeMonitor
}

// ZlibCompressorOverrides contains methods that are overridable.
type ZlibCompressorOverrides struct {
}

func defaultZlibCompressorOverrides(v *ZlibCompressor) ZlibCompressorOverrides {
	return ZlibCompressorOverrides{}
}

// ZlibCompressor: GZlibCompressor is an implementation of gio.Converter that
// compresses data using zlib.
type ZlibCompressor struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Converter
}

var (
	_ coreglib.Objector = (*ZlibCompressor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ZlibCompressor, *ZlibCompressorClass, ZlibCompressorOverrides](
		GTypeZlibCompressor,
		initZlibCompressorClass,
		wrapZlibCompressor,
		defaultZlibCompressorOverrides,
	)
}

func initZlibCompressorClass(gclass unsafe.Pointer, overrides ZlibCompressorOverrides, classInitFunc func(*ZlibCompressorClass)) {
	if classInitFunc != nil {
		class := (*ZlibCompressorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapZlibCompressor(obj *coreglib.Object) *ZlibCompressor {
	return &ZlibCompressor{
		Object: obj,
		Converter: Converter{
			Object: obj,
		},
	}
}

func marshalZlibCompressor(p uintptr) (interface{}, error) {
	return wrapZlibCompressor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewZlibCompressor creates a new Compressor.
//
// The function takes the following parameters:
//
//   - format to use for the compressed data.
//   - level: compression level (0-9), -1 for default.
//
// The function returns the following values:
//
//   - zlibCompressor: new Compressor.
func NewZlibCompressor(format ZlibCompressorFormat, level int) *ZlibCompressor {
	var _arg1 C.GZlibCompressorFormat // out
	var _arg2 C.int                   // out
	var _cret *C.GZlibCompressor      // in

	_arg1 = C.GZlibCompressorFormat(format)
	_arg2 = C.int(level)

	_cret = C.g_zlib_compressor_new(_arg1, _arg2)
	runtime.KeepAlive(format)
	runtime.KeepAlive(level)

	var _zlibCompressor *ZlibCompressor // out

	_zlibCompressor = wrapZlibCompressor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _zlibCompressor
}

// FileInfo returns the Compressor:file-info property.
//
// The function returns the following values:
//
//   - fileInfo (optional) or NULL.
func (compressor *ZlibCompressor) FileInfo() *FileInfo {
	var _arg0 *C.GZlibCompressor // out
	var _cret *C.GFileInfo       // in

	_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(coreglib.InternObject(compressor).Native()))

	_cret = C.g_zlib_compressor_get_file_info(_arg0)
	runtime.KeepAlive(compressor)

	var _fileInfo *FileInfo // out

	if _cret != nil {
		_fileInfo = wrapFileInfo(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _fileInfo
}

// SetFileInfo sets file_info in compressor. If non-NULL, and compressor's
// Compressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP, it will be
// used to set the file name and modification time in the GZIP header of the
// compressed data.
//
// Note: it is an error to call this function while a compression is in
// progress; it may only be called immediately after creation of compressor,
// or after resetting it with g_converter_reset().
//
// The function takes the following parameters:
//
//   - fileInfo (optional): Info.
func (compressor *ZlibCompressor) SetFileInfo(fileInfo *FileInfo) {
	var _arg0 *C.GZlibCompressor // out
	var _arg1 *C.GFileInfo       // out

	_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(coreglib.InternObject(compressor).Native()))
	if fileInfo != nil {
		_arg1 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(fileInfo).Native()))
	}

	C.g_zlib_compressor_set_file_info(_arg0, _arg1)
	runtime.KeepAlive(compressor)
	runtime.KeepAlive(fileInfo)
}

// ZlibDecompressorOverrides contains methods that are overridable.
type ZlibDecompressorOverrides struct {
}

func defaultZlibDecompressorOverrides(v *ZlibDecompressor) ZlibDecompressorOverrides {
	return ZlibDecompressorOverrides{}
}

// ZlibDecompressor: GZlibDecompressor is an implementation of gio.Converter
// that decompresses data compressed with zlib.
type ZlibDecompressor struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Converter
}

var (
	_ coreglib.Objector = (*ZlibDecompressor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ZlibDecompressor, *ZlibDecompressorClass, ZlibDecompressorOverrides](
		GTypeZlibDecompressor,
		initZlibDecompressorClass,
		wrapZlibDecompressor,
		defaultZlibDecompressorOverrides,
	)
}

func initZlibDecompressorClass(gclass unsafe.Pointer, overrides ZlibDecompressorOverrides, classInitFunc func(*ZlibDecompressorClass)) {
	if classInitFunc != nil {
		class := (*ZlibDecompressorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapZlibDecompressor(obj *coreglib.Object) *ZlibDecompressor {
	return &ZlibDecompressor{
		Object: obj,
		Converter: Converter{
			Object: obj,
		},
	}
}

func marshalZlibDecompressor(p uintptr) (interface{}, error) {
	return wrapZlibDecompressor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewZlibDecompressor creates a new Decompressor.
//
// The function takes the following parameters:
//
//   - format to use for the compressed data.
//
// The function returns the following values:
//
//   - zlibDecompressor: new Decompressor.
func NewZlibDecompressor(format ZlibCompressorFormat) *ZlibDecompressor {
	var _arg1 C.GZlibCompressorFormat // out
	var _cret *C.GZlibDecompressor    // in

	_arg1 = C.GZlibCompressorFormat(format)

	_cret = C.g_zlib_decompressor_new(_arg1)
	runtime.KeepAlive(format)

	var _zlibDecompressor *ZlibDecompressor // out

	_zlibDecompressor = wrapZlibDecompressor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _zlibDecompressor
}

// FileInfo retrieves the Info constructed from the GZIP header data of
// compressed data processed by compressor, or NULL if decompressor's
// Decompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP, or the
// header data was not fully processed yet, or it not present in the data stream
// at all.
//
// The function returns the following values:
//
//   - fileInfo (optional) or NULL.
func (decompressor *ZlibDecompressor) FileInfo() *FileInfo {
	var _arg0 *C.GZlibDecompressor // out
	var _cret *C.GFileInfo         // in

	_arg0 = (*C.GZlibDecompressor)(unsafe.Pointer(coreglib.InternObject(decompressor).Native()))

	_cret = C.g_zlib_decompressor_get_file_info(_arg0)
	runtime.KeepAlive(decompressor)

	var _fileInfo *FileInfo // out

	if _cret != nil {
		_fileInfo = wrapFileInfo(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _fileInfo
}

// ActionEntry: this struct defines a single action. It is for use with
// g_action_map_add_action_entries().
//
// The order of the items in the structure are intended to reflect frequency
// of use. It is permissible to use an incomplete initialiser in order to
// leave some of the later values as NULL. All values after name are optional.
// Additional optional fields may be added in the future.
//
// See g_action_map_add_action_entries() for an example.
//
// An instance of this type is always passed by reference.
type ActionEntry struct {
	*actionEntry
}

// actionEntry is the struct that's finalized.
type actionEntry struct {
	native *C.GActionEntry
}

// Name: name of the action.
func (a *ActionEntry) Name() string {
	valptr := &a.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ParameterType: type of the parameter that must be passed to the activate
// function for this action, given as a single GVariant type string (or NULL for
// no parameter).
func (a *ActionEntry) ParameterType() string {
	valptr := &a.native.parameter_type
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// State: initial state for this action, given in [GVariant text
// format][gvariant-text]. The state is parsed with no extra type information,
// so type tags must be added to the string if they are necessary. Stateless
// actions should give NULL here.
func (a *ActionEntry) State() string {
	valptr := &a.native.state
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ActionGroupInterface: virtual function table for Group.
//
// An instance of this type is always passed by reference.
type ActionGroupInterface struct {
	*actionGroupInterface
}

// actionGroupInterface is the struct that's finalized.
type actionGroupInterface struct {
	native *C.GActionGroupInterface
}

// ActionInterface: virtual function table for gio.Action.
//
// An instance of this type is always passed by reference.
type ActionInterface struct {
	*actionInterface
}

// actionInterface is the struct that's finalized.
type actionInterface struct {
	native *C.GActionInterface
}

// ActionMapInterface: virtual function table for Map.
//
// An instance of this type is always passed by reference.
type ActionMapInterface struct {
	*actionMapInterface
}

// actionMapInterface is the struct that's finalized.
type actionMapInterface struct {
	native *C.GActionMapInterface
}

// AppInfoIface: application Information interface, for operating system
// portability.
//
// An instance of this type is always passed by reference.
type AppInfoIface struct {
	*appInfoIface
}

// appInfoIface is the struct that's finalized.
type appInfoIface struct {
	native *C.GAppInfoIface
}

// AppLaunchContextClass: instance of this type is always passed by reference.
type AppLaunchContextClass struct {
	*appLaunchContextClass
}

// appLaunchContextClass is the struct that's finalized.
type appLaunchContextClass struct {
	native *C.GAppLaunchContextClass
}

// ApplicationClass: virtual function table for #GApplication.
//
// An instance of this type is always passed by reference.
type ApplicationClass struct {
	*applicationClass
}

// applicationClass is the struct that's finalized.
type applicationClass struct {
	native *C.GApplicationClass
}

// ApplicationCommandLineClass private data only.
//
// An instance of this type is always passed by reference.
type ApplicationCommandLineClass struct {
	*applicationCommandLineClass
}

// applicationCommandLineClass is the struct that's finalized.
type applicationCommandLineClass struct {
	native *C.GApplicationCommandLineClass
}

// AsyncInitableIface provides an interface for asynchronous initializing object
// such that initialization may fail.
//
// An instance of this type is always passed by reference.
type AsyncInitableIface struct {
	*asyncInitableIface
}

// asyncInitableIface is the struct that's finalized.
type asyncInitableIface struct {
	native *C.GAsyncInitableIface
}

// AsyncResultIface: interface definition for Result.
//
// An instance of this type is always passed by reference.
type AsyncResultIface struct {
	*asyncResultIface
}

// asyncResultIface is the struct that's finalized.
type asyncResultIface struct {
	native *C.GAsyncResultIface
}

// BufferedInputStreamClass: instance of this type is always passed by
// reference.
type BufferedInputStreamClass struct {
	*bufferedInputStreamClass
}

// bufferedInputStreamClass is the struct that's finalized.
type bufferedInputStreamClass struct {
	native *C.GBufferedInputStreamClass
}

func (b *BufferedInputStreamClass) ParentClass() *FilterInputStreamClass {
	valptr := &b.native.parent_class
	var _v *FilterInputStreamClass // out
	_v = (*FilterInputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// BufferedOutputStreamClass: instance of this type is always passed by
// reference.
type BufferedOutputStreamClass struct {
	*bufferedOutputStreamClass
}

// bufferedOutputStreamClass is the struct that's finalized.
type bufferedOutputStreamClass struct {
	native *C.GBufferedOutputStreamClass
}

func (b *BufferedOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	valptr := &b.native.parent_class
	var _v *FilterOutputStreamClass // out
	_v = (*FilterOutputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CancellableClass: instance of this type is always passed by reference.
type CancellableClass struct {
	*cancellableClass
}

// cancellableClass is the struct that's finalized.
type cancellableClass struct {
	native *C.GCancellableClass
}

// CharsetConverterClass: instance of this type is always passed by reference.
type CharsetConverterClass struct {
	*charsetConverterClass
}

// charsetConverterClass is the struct that's finalized.
type charsetConverterClass struct {
	native *C.GCharsetConverterClass
}

// ConverterIface provides an interface for converting data from one type to
// another type. The conversion can be stateful and may fail at any place.
//
// An instance of this type is always passed by reference.
type ConverterIface struct {
	*converterIface
}

// converterIface is the struct that's finalized.
type converterIface struct {
	native *C.GConverterIface
}

// ConverterInputStreamClass: instance of this type is always passed by
// reference.
type ConverterInputStreamClass struct {
	*converterInputStreamClass
}

// converterInputStreamClass is the struct that's finalized.
type converterInputStreamClass struct {
	native *C.GConverterInputStreamClass
}

func (c *ConverterInputStreamClass) ParentClass() *FilterInputStreamClass {
	valptr := &c.native.parent_class
	var _v *FilterInputStreamClass // out
	_v = (*FilterInputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ConverterOutputStreamClass: instance of this type is always passed by
// reference.
type ConverterOutputStreamClass struct {
	*converterOutputStreamClass
}

// converterOutputStreamClass is the struct that's finalized.
type converterOutputStreamClass struct {
	native *C.GConverterOutputStreamClass
}

func (c *ConverterOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	valptr := &c.native.parent_class
	var _v *FilterOutputStreamClass // out
	_v = (*FilterOutputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DBusAnnotationInfo: information about an annotation.
//
// An instance of this type is always passed by reference.
type DBusAnnotationInfo struct {
	*dBusAnnotationInfo
}

// dBusAnnotationInfo is the struct that's finalized.
type dBusAnnotationInfo struct {
	native *C.GDBusAnnotationInfo
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusAnnotationInfo{&dBusAnnotationInfo{(*C.GDBusAnnotationInfo)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusAnnotationInfo) RefCount() int {
	valptr := &d.native.ref_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Key: name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
func (d *DBusAnnotationInfo) Key() string {
	valptr := &d.native.key
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Value: value of the annotation.
func (d *DBusAnnotationInfo) Value() string {
	valptr := &d.native.value
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusAnnotationInfo) Annotations() []*DBusAnnotationInfo {
	valptr := &d.native.annotations
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.GDBusAnnotationInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusAnnotationInfo) SetRefCount(refCount int) {
	valptr := &d.native.ref_count
	*valptr = C.gint(refCount)
}

// DBusAnnotationInfoLookup looks up the value of an annotation.
//
// The cost of this function is O(n) in number of annotations.
//
// The function takes the following parameters:
//
//   - annotations (optional): NULL-terminated array of annotations or NULL.
//   - name of the annotation to look up.
//
// The function returns the following values:
//
//   - utf8 (optional): value or NULL if not found. Do not free, it is owned by
//     annotations.
func DBusAnnotationInfoLookup(annotations []*DBusAnnotationInfo, name string) string {
	var _arg1 **C.GDBusAnnotationInfo // out
	var _arg2 *C.gchar                // out
	var _cret *C.gchar                // in

	if annotations != nil {
		{
			_arg1 = (**C.GDBusAnnotationInfo)(C.calloc(C.size_t((len(annotations) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
			defer C.free(unsafe.Pointer(_arg1))
			{
				out := unsafe.Slice(_arg1, len(annotations)+1)
				var zero *C.GDBusAnnotationInfo
				out[len(annotations)] = zero
				for i := range annotations {
					out[i] = (*C.GDBusAnnotationInfo)(gextras.StructNative(unsafe.Pointer(annotations[i])))
				}
			}
		}
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_annotation_info_lookup(_arg1, _arg2)
	runtime.KeepAlive(annotations)
	runtime.KeepAlive(name)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DBusArgInfo: information about an argument for a method or a signal.
//
// An instance of this type is always passed by reference.
type DBusArgInfo struct {
	*dBusArgInfo
}

// dBusArgInfo is the struct that's finalized.
type dBusArgInfo struct {
	native *C.GDBusArgInfo
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusArgInfo{&dBusArgInfo{(*C.GDBusArgInfo)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusArgInfo) RefCount() int {
	valptr := &d.native.ref_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name of the argument, e.g. unix_user_id.
func (d *DBusArgInfo) Name() string {
	valptr := &d.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Signature d-Bus signature of the argument (a single complete type).
func (d *DBusArgInfo) Signature() string {
	valptr := &d.native.signature
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusArgInfo) Annotations() []*DBusAnnotationInfo {
	valptr := &d.native.annotations
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.GDBusAnnotationInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusArgInfo) SetRefCount(refCount int) {
	valptr := &d.native.ref_count
	*valptr = C.gint(refCount)
}

// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
//
// An instance of this type is always passed by reference.
type DBusErrorEntry struct {
	*dBusErrorEntry
}

// dBusErrorEntry is the struct that's finalized.
type dBusErrorEntry struct {
	native *C.GDBusErrorEntry
}

// ErrorCode: error code.
func (d *DBusErrorEntry) ErrorCode() int {
	valptr := &d.native.error_code
	var _v int // out
	_v = int(*valptr)
	return _v
}

// DBusErrorName d-Bus error name to associate with error_code.
func (d *DBusErrorEntry) DBusErrorName() string {
	valptr := &d.native.dbus_error_name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ErrorCode: error code.
func (d *DBusErrorEntry) SetErrorCode(errorCode int) {
	valptr := &d.native.error_code
	*valptr = C.gint(errorCode)
}

// DBusInterfaceIface: base type for D-Bus interfaces.
//
// An instance of this type is always passed by reference.
type DBusInterfaceIface struct {
	*dBusInterfaceIface
}

// dBusInterfaceIface is the struct that's finalized.
type dBusInterfaceIface struct {
	native *C.GDBusInterfaceIface
}

// DBusInterfaceInfo: information about a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusInterfaceInfo struct {
	*dBusInterfaceInfo
}

// dBusInterfaceInfo is the struct that's finalized.
type dBusInterfaceInfo struct {
	native *C.GDBusInterfaceInfo
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusInterfaceInfo{&dBusInterfaceInfo{(*C.GDBusInterfaceInfo)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusInterfaceInfo) RefCount() int {
	valptr := &d.native.ref_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name: name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
func (d *DBusInterfaceInfo) Name() string {
	valptr := &d.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Methods: pointer to a NULL-terminated array of pointers to BusMethodInfo
// structures or NULL if there are no methods.
func (d *DBusInterfaceInfo) Methods() []*DBusMethodInfo {
	valptr := &d.native.methods
	var _v []*DBusMethodInfo // out
	{
		var i int
		var z *C.GDBusMethodInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusMethodInfo, i)
		for i := range src {
			_v[i] = (*DBusMethodInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_method_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// Signals: pointer to a NULL-terminated array of pointers to BusSignalInfo
// structures or NULL if there are no signals.
func (d *DBusInterfaceInfo) Signals() []*DBusSignalInfo {
	valptr := &d.native.signals
	var _v []*DBusSignalInfo // out
	{
		var i int
		var z *C.GDBusSignalInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusSignalInfo, i)
		for i := range src {
			_v[i] = (*DBusSignalInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_signal_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_signal_info_unref((*C.GDBusSignalInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// Properties: pointer to a NULL-terminated array of pointers to BusPropertyInfo
// structures or NULL if there are no properties.
func (d *DBusInterfaceInfo) Properties() []*DBusPropertyInfo {
	valptr := &d.native.properties
	var _v []*DBusPropertyInfo // out
	{
		var i int
		var z *C.GDBusPropertyInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusPropertyInfo, i)
		for i := range src {
			_v[i] = (*DBusPropertyInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_property_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusInterfaceInfo) Annotations() []*DBusAnnotationInfo {
	valptr := &d.native.annotations
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.GDBusAnnotationInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusInterfaceInfo) SetRefCount(refCount int) {
	valptr := &d.native.ref_count
	*valptr = C.gint(refCount)
}

// CacheBuild builds a lookup-cache to speed up
// g_dbus_interface_info_lookup_method(), g_dbus_interface_info_lookup_signal()
// and g_dbus_interface_info_lookup_property().
//
// If this has already been called with info, the existing cache is used and its
// use count is increased.
//
// Note that info cannot be modified until g_dbus_interface_info_cache_release()
// is called.
func (info *DBusInterfaceInfo) CacheBuild() {
	var _arg0 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))

	C.g_dbus_interface_info_cache_build(_arg0)
	runtime.KeepAlive(info)
}

// CacheRelease decrements the usage count for the cache for info built by
// g_dbus_interface_info_cache_build() (if any) and frees the resources used by
// the cache if the usage count drops to zero.
func (info *DBusInterfaceInfo) CacheRelease() {
	var _arg0 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))

	C.g_dbus_interface_info_cache_release(_arg0)
	runtime.KeepAlive(info)
}

// LookupMethod looks up information about a method.
//
// The cost of this function is O(n) in number of methods unless
// g_dbus_interface_info_cache_build() has been used on info.
//
// The function takes the following parameters:
//
//   - name d-Bus method name (typically in CamelCase).
//
// The function returns the following values:
//
//   - dBusMethodInfo (optional) or NULL if not found. Do not free, it is owned
//     by info.
func (info *DBusInterfaceInfo) LookupMethod(name string) *DBusMethodInfo {
	var _arg0 *C.GDBusInterfaceInfo // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusMethodInfo    // in

	_arg0 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_interface_info_lookup_method(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusMethodInfo *DBusMethodInfo // out

	if _cret != nil {
		_dBusMethodInfo = (*DBusMethodInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_method_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusMethodInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(intern.C))
			},
		)
	}

	return _dBusMethodInfo
}

// LookupProperty looks up information about a property.
//
// The cost of this function is O(n) in number of properties unless
// g_dbus_interface_info_cache_build() has been used on info.
//
// The function takes the following parameters:
//
//   - name d-Bus property name (typically in CamelCase).
//
// The function returns the following values:
//
//   - dBusPropertyInfo (optional) or NULL if not found. Do not free, it is
//     owned by info.
func (info *DBusInterfaceInfo) LookupProperty(name string) *DBusPropertyInfo {
	var _arg0 *C.GDBusInterfaceInfo // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusPropertyInfo  // in

	_arg0 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_interface_info_lookup_property(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	if _cret != nil {
		_dBusPropertyInfo = (*DBusPropertyInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_property_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusPropertyInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(intern.C))
			},
		)
	}

	return _dBusPropertyInfo
}

// LookupSignal looks up information about a signal.
//
// The cost of this function is O(n) in number of signals unless
// g_dbus_interface_info_cache_build() has been used on info.
//
// The function takes the following parameters:
//
//   - name d-Bus signal name (typically in CamelCase).
//
// The function returns the following values:
//
//   - dBusSignalInfo (optional) or NULL if not found. Do not free, it is owned
//     by info.
func (info *DBusInterfaceInfo) LookupSignal(name string) *DBusSignalInfo {
	var _arg0 *C.GDBusInterfaceInfo // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusSignalInfo    // in

	_arg0 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_interface_info_lookup_signal(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusSignalInfo *DBusSignalInfo // out

	if _cret != nil {
		_dBusSignalInfo = (*DBusSignalInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_signal_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusSignalInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_signal_info_unref((*C.GDBusSignalInfo)(intern.C))
			},
		)
	}

	return _dBusSignalInfo
}

// DBusInterfaceSkeletonClass class structure for BusInterfaceSkeleton.
//
// An instance of this type is always passed by reference.
type DBusInterfaceSkeletonClass struct {
	*dBusInterfaceSkeletonClass
}

// dBusInterfaceSkeletonClass is the struct that's finalized.
type dBusInterfaceSkeletonClass struct {
	native *C.GDBusInterfaceSkeletonClass
}

// DBusInterfaceVTable: virtual table for handling properties and method calls
// for a D-Bus interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give NULL as your get_property() or set_property() function.
// The D-Bus call will be directed to your method_call function, with the
// provided interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the BusMethodInvocation object passed to the method_call()
// function is transferred to your handler; you must call one of the methods of
// BusMethodInvocation to return a reply (possibly empty), or an error. These
// functions also take ownership of the passed-in invocation object, so unless
// the invocation object has otherwise been referenced, it will be then be
// freed. Calling one of these functions may be done within your method_call()
// implementation but it also can be done at a later point to handle the method
// asynchronously.
//
// The usual checks on the validity of the calls is performed. For Get calls,
// an error is automatically returned if the property does not exist or the
// permissions do not allow access. The same checks are performed for Set calls,
// and the provided value is also checked for being the correct type.
//
// For both Get and Set calls, the BusMethodInvocation passed to the method_call
// handler can be queried with g_dbus_method_invocation_get_property_info() to
// get a pointer to the BusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info,
// you must ensure that you either provide a non-NULL get_property()
// function or provide implementations of both the Get and GetAll methods on
// org.freedesktop.DBus.Properties interface in your method_call function.
// Note that the required return type of the Get call is (v), not the type of
// the property. GetAll expects a return value of type a{sv}.
//
// If you have writable properties specified in your interface info, you must
// ensure that you either provide a non-NULL set_property() function or provide
// an implementation of the Set call. If implementing the call, you must return
// the value of type G_VARIANT_TYPE_UNIT.
//
// An instance of this type is always passed by reference.
type DBusInterfaceVTable struct {
	*dBusInterfaceVTable
}

// dBusInterfaceVTable is the struct that's finalized.
type dBusInterfaceVTable struct {
	native *C.GDBusInterfaceVTable
}

// DBusMethodInfo: information about a method on an D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusMethodInfo struct {
	*dBusMethodInfo
}

// dBusMethodInfo is the struct that's finalized.
type dBusMethodInfo struct {
	native *C.GDBusMethodInfo
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusMethodInfo{&dBusMethodInfo{(*C.GDBusMethodInfo)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusMethodInfo) RefCount() int {
	valptr := &d.native.ref_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name: name of the D-Bus method, e.g. RequestName.
func (d *DBusMethodInfo) Name() string {
	valptr := &d.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// InArgs: pointer to a NULL-terminated array of pointers to BusArgInfo
// structures or NULL if there are no in arguments.
func (d *DBusMethodInfo) InArgs() []*DBusArgInfo {
	valptr := &d.native.in_args
	var _v []*DBusArgInfo // out
	{
		var i int
		var z *C.GDBusArgInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusArgInfo, i)
		for i := range src {
			_v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_arg_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_arg_info_unref((*C.GDBusArgInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// OutArgs: pointer to a NULL-terminated array of pointers to BusArgInfo
// structures or NULL if there are no out arguments.
func (d *DBusMethodInfo) OutArgs() []*DBusArgInfo {
	valptr := &d.native.out_args
	var _v []*DBusArgInfo // out
	{
		var i int
		var z *C.GDBusArgInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusArgInfo, i)
		for i := range src {
			_v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_arg_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_arg_info_unref((*C.GDBusArgInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusMethodInfo) Annotations() []*DBusAnnotationInfo {
	valptr := &d.native.annotations
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.GDBusAnnotationInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusMethodInfo) SetRefCount(refCount int) {
	valptr := &d.native.ref_count
	*valptr = C.gint(refCount)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
//
// An instance of this type is always passed by reference.
type DBusNodeInfo struct {
	*dBusNodeInfo
}

// dBusNodeInfo is the struct that's finalized.
type dBusNodeInfo struct {
	native *C.GDBusNodeInfo
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusNodeInfo{&dBusNodeInfo{(*C.GDBusNodeInfo)(b)}}, nil
}

// NewDBusNodeInfoForXML constructs a struct DBusNodeInfo.
func NewDBusNodeInfoForXML(xmlData string) (*DBusNodeInfo, error) {
	var _arg1 *C.gchar         // out
	var _cret *C.GDBusNodeInfo // in
	var _cerr *C.GError        // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(xmlData)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_node_info_new_for_xml(_arg1, &_cerr)
	runtime.KeepAlive(xmlData)

	var _dBusNodeInfo *DBusNodeInfo // out
	var _goerr error                // out

	_dBusNodeInfo = (*DBusNodeInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dBusNodeInfo)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_dbus_node_info_unref((*C.GDBusNodeInfo)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusNodeInfo, _goerr
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusNodeInfo) RefCount() int {
	valptr := &d.native.ref_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Path: path of the node or NULL if omitted. Note that this may be a relative
// path. See the D-Bus specification for more details.
func (d *DBusNodeInfo) Path() string {
	valptr := &d.native.path
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Interfaces: pointer to a NULL-terminated array of pointers to
// BusInterfaceInfo structures or NULL if there are no interfaces.
func (d *DBusNodeInfo) Interfaces() []*DBusInterfaceInfo {
	valptr := &d.native.interfaces
	var _v []*DBusInterfaceInfo // out
	{
		var i int
		var z *C.GDBusInterfaceInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusInterfaceInfo, i)
		for i := range src {
			_v[i] = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_interface_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// Nodes: pointer to a NULL-terminated array of pointers to BusNodeInfo
// structures or NULL if there are no nodes.
func (d *DBusNodeInfo) Nodes() []*DBusNodeInfo {
	valptr := &d.native.nodes
	var _v []*DBusNodeInfo // out
	{
		var i int
		var z *C.GDBusNodeInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusNodeInfo, i)
		for i := range src {
			_v[i] = (*DBusNodeInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_node_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_node_info_unref((*C.GDBusNodeInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusNodeInfo) Annotations() []*DBusAnnotationInfo {
	valptr := &d.native.annotations
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.GDBusAnnotationInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusNodeInfo) SetRefCount(refCount int) {
	valptr := &d.native.ref_count
	*valptr = C.gint(refCount)
}

// LookupInterface looks up information about an interface.
//
// The cost of this function is O(n) in number of interfaces.
//
// The function takes the following parameters:
//
//   - name d-Bus interface name.
//
// The function returns the following values:
//
//   - dBusInterfaceInfo (optional) or NULL if not found. Do not free, it is
//     owned by info.
func (info *DBusNodeInfo) LookupInterface(name string) *DBusInterfaceInfo {
	var _arg0 *C.GDBusNodeInfo      // out
	var _arg1 *C.gchar              // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusNodeInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_node_info_lookup_interface(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	if _cret != nil {
		_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_interface_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
			},
		)
	}

	return _dBusInterfaceInfo
}

// DBusObjectIface: base object type for D-Bus objects.
//
// An instance of this type is always passed by reference.
type DBusObjectIface struct {
	*dBusObjectIface
}

// dBusObjectIface is the struct that's finalized.
type dBusObjectIface struct {
	native *C.GDBusObjectIface
}

// DBusObjectManagerClientClass class structure for BusObjectManagerClient.
//
// An instance of this type is always passed by reference.
type DBusObjectManagerClientClass struct {
	*dBusObjectManagerClientClass
}

// dBusObjectManagerClientClass is the struct that's finalized.
type dBusObjectManagerClientClass struct {
	native *C.GDBusObjectManagerClientClass
}

// DBusObjectManagerIface: base type for D-Bus object managers.
//
// An instance of this type is always passed by reference.
type DBusObjectManagerIface struct {
	*dBusObjectManagerIface
}

// dBusObjectManagerIface is the struct that's finalized.
type dBusObjectManagerIface struct {
	native *C.GDBusObjectManagerIface
}

// DBusObjectManagerServerClass class structure for BusObjectManagerServer.
//
// An instance of this type is always passed by reference.
type DBusObjectManagerServerClass struct {
	*dBusObjectManagerServerClass
}

// dBusObjectManagerServerClass is the struct that's finalized.
type dBusObjectManagerServerClass struct {
	native *C.GDBusObjectManagerServerClass
}

// DBusObjectProxyClass class structure for BusObjectProxy.
//
// An instance of this type is always passed by reference.
type DBusObjectProxyClass struct {
	*dBusObjectProxyClass
}

// dBusObjectProxyClass is the struct that's finalized.
type dBusObjectProxyClass struct {
	native *C.GDBusObjectProxyClass
}

// DBusObjectSkeletonClass class structure for BusObjectSkeleton.
//
// An instance of this type is always passed by reference.
type DBusObjectSkeletonClass struct {
	*dBusObjectSkeletonClass
}

// dBusObjectSkeletonClass is the struct that's finalized.
type dBusObjectSkeletonClass struct {
	native *C.GDBusObjectSkeletonClass
}

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusPropertyInfo struct {
	*dBusPropertyInfo
}

// dBusPropertyInfo is the struct that's finalized.
type dBusPropertyInfo struct {
	native *C.GDBusPropertyInfo
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusPropertyInfo{&dBusPropertyInfo{(*C.GDBusPropertyInfo)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusPropertyInfo) RefCount() int {
	valptr := &d.native.ref_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name: name of the D-Bus property, e.g. "SupportedFilesystems".
func (d *DBusPropertyInfo) Name() string {
	valptr := &d.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Signature d-Bus signature of the property (a single complete type).
func (d *DBusPropertyInfo) Signature() string {
	valptr := &d.native.signature
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Flags access control flags for the property.
func (d *DBusPropertyInfo) Flags() DBusPropertyInfoFlags {
	valptr := &d.native.flags
	var _v DBusPropertyInfoFlags // out
	_v = DBusPropertyInfoFlags(*valptr)
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusPropertyInfo) Annotations() []*DBusAnnotationInfo {
	valptr := &d.native.annotations
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.GDBusAnnotationInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusPropertyInfo) SetRefCount(refCount int) {
	valptr := &d.native.ref_count
	*valptr = C.gint(refCount)
}

// DBusProxyClass class structure for BusProxy.
//
// An instance of this type is always passed by reference.
type DBusProxyClass struct {
	*dBusProxyClass
}

// dBusProxyClass is the struct that's finalized.
type dBusProxyClass struct {
	native *C.GDBusProxyClass
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusSignalInfo struct {
	*dBusSignalInfo
}

// dBusSignalInfo is the struct that's finalized.
type dBusSignalInfo struct {
	native *C.GDBusSignalInfo
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusSignalInfo{&dBusSignalInfo{(*C.GDBusSignalInfo)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusSignalInfo) RefCount() int {
	valptr := &d.native.ref_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name: name of the D-Bus signal, e.g. "NameOwnerChanged".
func (d *DBusSignalInfo) Name() string {
	valptr := &d.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Args: pointer to a NULL-terminated array of pointers to BusArgInfo structures
// or NULL if there are no arguments.
func (d *DBusSignalInfo) Args() []*DBusArgInfo {
	valptr := &d.native.args
	var _v []*DBusArgInfo // out
	{
		var i int
		var z *C.GDBusArgInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusArgInfo, i)
		for i := range src {
			_v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_arg_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_arg_info_unref((*C.GDBusArgInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusSignalInfo) Annotations() []*DBusAnnotationInfo {
	valptr := &d.native.annotations
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.GDBusAnnotationInfo
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusSignalInfo) SetRefCount(refCount int) {
	valptr := &d.native.ref_count
	*valptr = C.gint(refCount)
}

// DBusSubtreeVTable: virtual table for handling subtrees registered with
// g_dbus_connection_register_subtree().
//
// An instance of this type is always passed by reference.
type DBusSubtreeVTable struct {
	*dBusSubtreeVTable
}

// dBusSubtreeVTable is the struct that's finalized.
type dBusSubtreeVTable struct {
	native *C.GDBusSubtreeVTable
}

// DataInputStreamClass: instance of this type is always passed by reference.
type DataInputStreamClass struct {
	*dataInputStreamClass
}

// dataInputStreamClass is the struct that's finalized.
type dataInputStreamClass struct {
	native *C.GDataInputStreamClass
}

func (d *DataInputStreamClass) ParentClass() *BufferedInputStreamClass {
	valptr := &d.native.parent_class
	var _v *BufferedInputStreamClass // out
	_v = (*BufferedInputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DataOutputStreamClass: instance of this type is always passed by reference.
type DataOutputStreamClass struct {
	*dataOutputStreamClass
}

// dataOutputStreamClass is the struct that's finalized.
type dataOutputStreamClass struct {
	native *C.GDataOutputStreamClass
}

func (d *DataOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	valptr := &d.native.parent_class
	var _v *FilterOutputStreamClass // out
	_v = (*FilterOutputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DatagramBasedInterface provides an interface for socket-like objects which
// have datagram semantics, following the Berkeley sockets API. The interface
// methods are thin wrappers around the corresponding virtual methods, and no
// pre-processing of inputs is implemented  so implementations of this API must
// handle all functionality documented in the interface methods.
//
// An instance of this type is always passed by reference.
type DatagramBasedInterface struct {
	*datagramBasedInterface
}

// datagramBasedInterface is the struct that's finalized.
type datagramBasedInterface struct {
	native *C.GDatagramBasedInterface
}

// DebugControllerDBusClass: virtual function table for ControllerDBus.
//
// An instance of this type is always passed by reference.
type DebugControllerDBusClass struct {
	*debugControllerDBusClass
}

// debugControllerDBusClass is the struct that's finalized.
type debugControllerDBusClass struct {
	native *C.GDebugControllerDBusClass
}

func (d *DebugControllerDBusClass) Padding() [12]unsafe.Pointer {
	valptr := &d.native.padding
	var _v [12]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 12; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// DebugControllerInterface: virtual function table for Controller.
//
// An instance of this type is always passed by reference.
type DebugControllerInterface struct {
	*debugControllerInterface
}

// debugControllerInterface is the struct that's finalized.
type debugControllerInterface struct {
	native *C.GDebugControllerInterface
}

// DriveIface: interface for creating #GDrive implementations.
//
// An instance of this type is always passed by reference.
type DriveIface struct {
	*driveIface
}

// driveIface is the struct that's finalized.
type driveIface struct {
	native *C.GDriveIface
}

// DTLSClientConnectionInterface: vtable for a ClientConnection implementation.
//
// An instance of this type is always passed by reference.
type DTLSClientConnectionInterface struct {
	*dtlsClientConnectionInterface
}

// dtlsClientConnectionInterface is the struct that's finalized.
type dtlsClientConnectionInterface struct {
	native *C.GDtlsClientConnectionInterface
}

// DTLSConnectionInterface: virtual method table for a Connection
// implementation.
//
// An instance of this type is always passed by reference.
type DTLSConnectionInterface struct {
	*dtlsConnectionInterface
}

// dtlsConnectionInterface is the struct that's finalized.
type dtlsConnectionInterface struct {
	native *C.GDtlsConnectionInterface
}

// DTLSServerConnectionInterface: vtable for a ServerConnection implementation.
//
// An instance of this type is always passed by reference.
type DTLSServerConnectionInterface struct {
	*dtlsServerConnectionInterface
}

// dtlsServerConnectionInterface is the struct that's finalized.
type dtlsServerConnectionInterface struct {
	native *C.GDtlsServerConnectionInterface
}

// EmblemedIconClass: instance of this type is always passed by reference.
type EmblemedIconClass struct {
	*emblemedIconClass
}

// emblemedIconClass is the struct that's finalized.
type emblemedIconClass struct {
	native *C.GEmblemedIconClass
}

// FileAttributeInfo: information about a specific attribute.
//
// An instance of this type is always passed by reference.
type FileAttributeInfo struct {
	*fileAttributeInfo
}

// fileAttributeInfo is the struct that's finalized.
type fileAttributeInfo struct {
	native *C.GFileAttributeInfo
}

// Name: name of the attribute.
func (f *FileAttributeInfo) Name() string {
	valptr := &f.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Type type of the attribute.
func (f *FileAttributeInfo) Type() FileAttributeType {
	valptr := &f.native._type
	var _v FileAttributeType // out
	_v = FileAttributeType(*valptr)
	return _v
}

// Flags: set of AttributeInfoFlags.
func (f *FileAttributeInfo) Flags() FileAttributeInfoFlags {
	valptr := &f.native.flags
	var _v FileAttributeInfoFlags // out
	_v = FileAttributeInfoFlags(*valptr)
	return _v
}

// FileAttributeInfoList acts as a lightweight registry for possible valid file
// attributes. The registry stores Key-Value pair formats as AttributeInfos.
//
// An instance of this type is always passed by reference.
type FileAttributeInfoList struct {
	*fileAttributeInfoList
}

// fileAttributeInfoList is the struct that's finalized.
type fileAttributeInfoList struct {
	native *C.GFileAttributeInfoList
}

func marshalFileAttributeInfoList(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FileAttributeInfoList{&fileAttributeInfoList{(*C.GFileAttributeInfoList)(b)}}, nil
}

// NewFileAttributeInfoList constructs a struct FileAttributeInfoList.
func NewFileAttributeInfoList() *FileAttributeInfoList {
	var _cret *C.GFileAttributeInfoList // in

	_cret = C.g_file_attribute_info_list_new()

	var _fileAttributeInfoList *FileAttributeInfoList // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_info_list_unref((*C.GFileAttributeInfoList)(intern.C))
		},
	)

	return _fileAttributeInfoList
}

// Infos: array of AttributeInfos.
func (f *FileAttributeInfoList) Infos() *FileAttributeInfo {
	valptr := &f.native.infos
	var _v *FileAttributeInfo // out
	_v = (*FileAttributeInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// NInfos: number of values in the array.
func (f *FileAttributeInfoList) NInfos() int {
	valptr := &f.native.n_infos
	var _v int // out
	_v = int(*valptr)
	return _v
}

// NInfos: number of values in the array.
func (f *FileAttributeInfoList) SetNInfos(nInfos int) {
	valptr := &f.native.n_infos
	*valptr = C.int(nInfos)
}

// Add adds a new attribute with name to the list, setting its type and flags.
//
// The function takes the following parameters:
//
//   - name of the attribute to add.
//   - typ for the attribute.
//   - flags for the attribute.
func (list *FileAttributeInfoList) Add(name string, typ FileAttributeType, flags FileAttributeInfoFlags) {
	var _arg0 *C.GFileAttributeInfoList // out
	var _arg1 *C.char                   // out
	var _arg2 C.GFileAttributeType      // out
	var _arg3 C.GFileAttributeInfoFlags // out

	_arg0 = (*C.GFileAttributeInfoList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeType(typ)
	_arg3 = C.GFileAttributeInfoFlags(flags)

	C.g_file_attribute_info_list_add(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)
}

// Dup makes a duplicate of a file attribute info list.
//
// The function returns the following values:
//
//   - fileAttributeInfoList: copy of the given list.
func (list *FileAttributeInfoList) Dup() *FileAttributeInfoList {
	var _arg0 *C.GFileAttributeInfoList // out
	var _cret *C.GFileAttributeInfoList // in

	_arg0 = (*C.GFileAttributeInfoList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.g_file_attribute_info_list_dup(_arg0)
	runtime.KeepAlive(list)

	var _fileAttributeInfoList *FileAttributeInfoList // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_info_list_unref((*C.GFileAttributeInfoList)(intern.C))
		},
	)

	return _fileAttributeInfoList
}

// Lookup gets the file attribute with the name name from list.
//
// The function takes the following parameters:
//
//   - name of the attribute to look up.
//
// The function returns the following values:
//
//   - fileAttributeInfo for the name, or NULL if an attribute isn't found.
func (list *FileAttributeInfoList) Lookup(name string) *FileAttributeInfo {
	var _arg0 *C.GFileAttributeInfoList // out
	var _arg1 *C.char                   // out
	var _cret *C.GFileAttributeInfo     // in

	_arg0 = (*C.GFileAttributeInfoList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_info_list_lookup(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)

	var _fileAttributeInfo *FileAttributeInfo // out

	_fileAttributeInfo = (*FileAttributeInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _fileAttributeInfo
}

// FileAttributeMatcher determines if a string matches a file attribute.
//
// An instance of this type is always passed by reference.
type FileAttributeMatcher struct {
	*fileAttributeMatcher
}

// fileAttributeMatcher is the struct that's finalized.
type fileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FileAttributeMatcher{&fileAttributeMatcher{(*C.GFileAttributeMatcher)(b)}}, nil
}

// NewFileAttributeMatcher constructs a struct FileAttributeMatcher.
func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
	var _arg1 *C.char                  // out
	var _cret *C.GFileAttributeMatcher // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_new(_arg1)
	runtime.KeepAlive(attributes)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	_fileAttributeMatcher = (*FileAttributeMatcher)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeMatcher)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_matcher_unref((*C.GFileAttributeMatcher)(intern.C))
		},
	)

	return _fileAttributeMatcher
}

// EnumerateNamespace checks if the matcher will match all of the keys in a
// given namespace. This will always return TRUE if a wildcard character is in
// use (e.g. if matcher was created with "standard::*" and ns is "standard",
// or if matcher was created using "*" and namespace is anything.)
//
// TODO: this is awkwardly worded.
//
// The function takes the following parameters:
//
//   - ns: string containing a file attribute namespace.
//
// The function returns the following values:
//
//   - ok: TRUE if the matcher matches all of the entries in the given ns,
//     FALSE otherwise.
func (matcher *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(ns)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_enumerate_namespace(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(ns)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnumerateNext gets the next matched attribute from a AttributeMatcher.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the next attribute or, NULL if no more
//     attribute exist.
func (matcher *FileAttributeMatcher) EnumerateNext() string {
	var _arg0 *C.GFileAttributeMatcher // out
	var _cret *C.char                  // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))

	_cret = C.g_file_attribute_matcher_enumerate_next(_arg0)
	runtime.KeepAlive(matcher)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Matches checks if an attribute will be matched by an attribute matcher.
// If the matcher was created with the "*" matching string, this function will
// always return TRUE.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - ok: TRUE if attribute matches matcher. FALSE otherwise.
func (matcher *FileAttributeMatcher) Matches(attribute string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_matches(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchesOnly checks if an attribute matcher only matches a given attribute.
// Always returns FALSE if "*" was used when creating the matcher.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - ok: TRUE if the matcher only matches attribute. FALSE otherwise.
func (matcher *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_matches_only(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Subtract subtracts all attributes of subtract from matcher and returns a
// matcher that supports those attributes.
//
// Note that currently it is not possible to remove a single attribute when the
// matcher matches the whole namespace - or remove a namespace or attribute
// when the matcher matches everything. This is a limitation of the current
// implementation, but may be fixed in the future.
//
// The function takes the following parameters:
//
//   - subtract (optional): matcher to subtract.
//
// The function returns the following values:
//
//   - fileAttributeMatcher (optional): file attribute matcher matching all
//     attributes of matcher that are not matched by subtract.
func (matcher *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.GFileAttributeMatcher // out
	var _cret *C.GFileAttributeMatcher // in

	if matcher != nil {
		_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	}
	if subtract != nil {
		_arg1 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(subtract)))
	}

	_cret = C.g_file_attribute_matcher_subtract(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(subtract)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	if _cret != nil {
		_fileAttributeMatcher = (*FileAttributeMatcher)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fileAttributeMatcher)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_file_attribute_matcher_unref((*C.GFileAttributeMatcher)(intern.C))
			},
		)
	}

	return _fileAttributeMatcher
}

// String prints what the matcher is matching against. The format will be equal
// to the format passed to g_file_attribute_matcher_new(). The output however,
// might not be identical, as the matcher may decide to use a different order or
// omit needless parts.
//
// The function returns the following values:
//
//   - utf8: string describing the attributes the matcher matches against or
//     NULL if matcher was NULL.
func (matcher *FileAttributeMatcher) String() string {
	var _arg0 *C.GFileAttributeMatcher // out
	var _cret *C.char                  // in

	if matcher != nil {
		_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	}

	_cret = C.g_file_attribute_matcher_to_string(_arg0)
	runtime.KeepAlive(matcher)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FileEnumeratorClass: instance of this type is always passed by reference.
type FileEnumeratorClass struct {
	*fileEnumeratorClass
}

// fileEnumeratorClass is the struct that's finalized.
type fileEnumeratorClass struct {
	native *C.GFileEnumeratorClass
}

// FileIOStreamClass: instance of this type is always passed by reference.
type FileIOStreamClass struct {
	*fileIOStreamClass
}

// fileIOStreamClass is the struct that's finalized.
type fileIOStreamClass struct {
	native *C.GFileIOStreamClass
}

func (f *FileIOStreamClass) ParentClass() *IOStreamClass {
	valptr := &f.native.parent_class
	var _v *IOStreamClass // out
	_v = (*IOStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FileIface: interface for writing VFS file handles.
//
// An instance of this type is always passed by reference.
type FileIface struct {
	*fileIface
}

// fileIface is the struct that's finalized.
type fileIface struct {
	native *C.GFileIface
}

// SupportsThreadContexts: boolean that indicates whether the #GFile
// implementation supports thread-default contexts. Since 2.22.
func (f *FileIface) SupportsThreadContexts() bool {
	valptr := &f.native.supports_thread_contexts
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// FileInputStreamClass: instance of this type is always passed by reference.
type FileInputStreamClass struct {
	*fileInputStreamClass
}

// fileInputStreamClass is the struct that's finalized.
type fileInputStreamClass struct {
	native *C.GFileInputStreamClass
}

func (f *FileInputStreamClass) ParentClass() *InputStreamClass {
	valptr := &f.native.parent_class
	var _v *InputStreamClass // out
	_v = (*InputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FileMonitorClass: instance of this type is always passed by reference.
type FileMonitorClass struct {
	*fileMonitorClass
}

// fileMonitorClass is the struct that's finalized.
type fileMonitorClass struct {
	native *C.GFileMonitorClass
}

// FileOutputStreamClass: instance of this type is always passed by reference.
type FileOutputStreamClass struct {
	*fileOutputStreamClass
}

// fileOutputStreamClass is the struct that's finalized.
type fileOutputStreamClass struct {
	native *C.GFileOutputStreamClass
}

func (f *FileOutputStreamClass) ParentClass() *OutputStreamClass {
	valptr := &f.native.parent_class
	var _v *OutputStreamClass // out
	_v = (*OutputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FilenameCompleterClass: instance of this type is always passed by reference.
type FilenameCompleterClass struct {
	*filenameCompleterClass
}

// filenameCompleterClass is the struct that's finalized.
type filenameCompleterClass struct {
	native *C.GFilenameCompleterClass
}

// FilterInputStreamClass: instance of this type is always passed by reference.
type FilterInputStreamClass struct {
	*filterInputStreamClass
}

// filterInputStreamClass is the struct that's finalized.
type filterInputStreamClass struct {
	native *C.GFilterInputStreamClass
}

func (f *FilterInputStreamClass) ParentClass() *InputStreamClass {
	valptr := &f.native.parent_class
	var _v *InputStreamClass // out
	_v = (*InputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FilterOutputStreamClass: instance of this type is always passed by reference.
type FilterOutputStreamClass struct {
	*filterOutputStreamClass
}

// filterOutputStreamClass is the struct that's finalized.
type filterOutputStreamClass struct {
	native *C.GFilterOutputStreamClass
}

func (f *FilterOutputStreamClass) ParentClass() *OutputStreamClass {
	valptr := &f.native.parent_class
	var _v *OutputStreamClass // out
	_v = (*OutputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// IOStreamClass: instance of this type is always passed by reference.
type IOStreamClass struct {
	*ioStreamClass
}

// ioStreamClass is the struct that's finalized.
type ioStreamClass struct {
	native *C.GIOStreamClass
}

// IconIface is used to implement GIcon types for various different systems.
// See Icon and Icon for examples of how to implement this interface.
//
// An instance of this type is always passed by reference.
type IconIface struct {
	*iconIface
}

// iconIface is the struct that's finalized.
type iconIface struct {
	native *C.GIconIface
}

// InetAddressClass: instance of this type is always passed by reference.
type InetAddressClass struct {
	*inetAddressClass
}

// inetAddressClass is the struct that's finalized.
type inetAddressClass struct {
	native *C.GInetAddressClass
}

// InetAddressMaskClass: instance of this type is always passed by reference.
type InetAddressMaskClass struct {
	*inetAddressMaskClass
}

// inetAddressMaskClass is the struct that's finalized.
type inetAddressMaskClass struct {
	native *C.GInetAddressMaskClass
}

// InetSocketAddressClass: instance of this type is always passed by reference.
type InetSocketAddressClass struct {
	*inetSocketAddressClass
}

// inetSocketAddressClass is the struct that's finalized.
type inetSocketAddressClass struct {
	native *C.GInetSocketAddressClass
}

func (i *InetSocketAddressClass) ParentClass() *SocketAddressClass {
	valptr := &i.native.parent_class
	var _v *SocketAddressClass // out
	_v = (*SocketAddressClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// InitableIface provides an interface for initializing object such that
// initialization may fail.
//
// An instance of this type is always passed by reference.
type InitableIface struct {
	*initableIface
}

// initableIface is the struct that's finalized.
type initableIface struct {
	native *C.GInitableIface
}

// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set bytes_received to the total number of bytes received
// across all Vectors.
//
// This structure closely mirrors struct mmsghdr and struct msghdr from the
// POSIX sockets API (see man 2 recvmmsg).
//
// If address is non-NULL then it is set to the source address the message was
// received from, and the caller must free it afterwards.
//
// If control_messages is non-NULL then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. num_control_messages is set to the number of elements in this
// array, which may be zero.
//
// Flags relevant to this message will be returned in flags. For example,
// MSG_EOR or MSG_TRUNC.
//
// An instance of this type is always passed by reference.
type InputMessage struct {
	*inputMessage
}

// inputMessage is the struct that's finalized.
type inputMessage struct {
	native *C.GInputMessage
}

// InputStreamClass: instance of this type is always passed by reference.
type InputStreamClass struct {
	*inputStreamClass
}

// inputStreamClass is the struct that's finalized.
type inputStreamClass struct {
	native *C.GInputStreamClass
}

// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
//
// An instance of this type is always passed by reference.
type InputVector struct {
	*inputVector
}

// inputVector is the struct that's finalized.
type inputVector struct {
	native *C.GInputVector
}

// Buffer: pointer to a buffer where data will be written.
func (i *InputVector) Buffer() unsafe.Pointer {
	valptr := &i.native.buffer
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Size: available size in buffer.
func (i *InputVector) Size() uint {
	valptr := &i.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Size: available size in buffer.
func (i *InputVector) SetSize(size uint) {
	valptr := &i.native.size
	*valptr = C.gsize(size)
}

// ListModelInterface: virtual function table for Model.
//
// An instance of this type is always passed by reference.
type ListModelInterface struct {
	*listModelInterface
}

// listModelInterface is the struct that's finalized.
type listModelInterface struct {
	native *C.GListModelInterface
}

// ListStoreClass: instance of this type is always passed by reference.
type ListStoreClass struct {
	*listStoreClass
}

// listStoreClass is the struct that's finalized.
type listStoreClass struct {
	native *C.GListStoreClass
}

// LoadableIconIface: interface for icons that can be loaded as a stream.
//
// An instance of this type is always passed by reference.
type LoadableIconIface struct {
	*loadableIconIface
}

// loadableIconIface is the struct that's finalized.
type loadableIconIface struct {
	native *C.GLoadableIconIface
}

// MemoryInputStreamClass: instance of this type is always passed by reference.
type MemoryInputStreamClass struct {
	*memoryInputStreamClass
}

// memoryInputStreamClass is the struct that's finalized.
type memoryInputStreamClass struct {
	native *C.GMemoryInputStreamClass
}

func (m *MemoryInputStreamClass) ParentClass() *InputStreamClass {
	valptr := &m.native.parent_class
	var _v *InputStreamClass // out
	_v = (*InputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MemoryMonitorInterface: virtual function table for Monitor.
//
// An instance of this type is always passed by reference.
type MemoryMonitorInterface struct {
	*memoryMonitorInterface
}

// memoryMonitorInterface is the struct that's finalized.
type memoryMonitorInterface struct {
	native *C.GMemoryMonitorInterface
}

// MemoryOutputStreamClass: instance of this type is always passed by reference.
type MemoryOutputStreamClass struct {
	*memoryOutputStreamClass
}

// memoryOutputStreamClass is the struct that's finalized.
type memoryOutputStreamClass struct {
	native *C.GMemoryOutputStreamClass
}

func (m *MemoryOutputStreamClass) ParentClass() *OutputStreamClass {
	valptr := &m.native.parent_class
	var _v *OutputStreamClass // out
	_v = (*OutputStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MenuAttributeIterClass: instance of this type is always passed by reference.
type MenuAttributeIterClass struct {
	*menuAttributeIterClass
}

// menuAttributeIterClass is the struct that's finalized.
type menuAttributeIterClass struct {
	native *C.GMenuAttributeIterClass
}

// MenuLinkIterClass: instance of this type is always passed by reference.
type MenuLinkIterClass struct {
	*menuLinkIterClass
}

// menuLinkIterClass is the struct that's finalized.
type menuLinkIterClass struct {
	native *C.GMenuLinkIterClass
}

// MenuModelClass: instance of this type is always passed by reference.
type MenuModelClass struct {
	*menuModelClass
}

// menuModelClass is the struct that's finalized.
type menuModelClass struct {
	native *C.GMenuModelClass
}

// MountIface: interface for implementing operations for mounts.
//
// An instance of this type is always passed by reference.
type MountIface struct {
	*mountIface
}

// mountIface is the struct that's finalized.
type mountIface struct {
	native *C.GMountIface
}

// MountOperationClass: instance of this type is always passed by reference.
type MountOperationClass struct {
	*mountOperationClass
}

// mountOperationClass is the struct that's finalized.
type mountOperationClass struct {
	native *C.GMountOperationClass
}

// NativeSocketAddressClass: instance of this type is always passed by
// reference.
type NativeSocketAddressClass struct {
	*nativeSocketAddressClass
}

// nativeSocketAddressClass is the struct that's finalized.
type nativeSocketAddressClass struct {
	native *C.GNativeSocketAddressClass
}

func (n *NativeSocketAddressClass) ParentClass() *SocketAddressClass {
	valptr := &n.native.parent_class
	var _v *SocketAddressClass // out
	_v = (*SocketAddressClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// NativeVolumeMonitorClass: instance of this type is always passed by
// reference.
type NativeVolumeMonitorClass struct {
	*nativeVolumeMonitorClass
}

// nativeVolumeMonitorClass is the struct that's finalized.
type nativeVolumeMonitorClass struct {
	native *C.GNativeVolumeMonitorClass
}

func (n *NativeVolumeMonitorClass) ParentClass() *VolumeMonitorClass {
	valptr := &n.native.parent_class
	var _v *VolumeMonitorClass // out
	_v = (*VolumeMonitorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// NetworkAddressClass: instance of this type is always passed by reference.
type NetworkAddressClass struct {
	*networkAddressClass
}

// networkAddressClass is the struct that's finalized.
type networkAddressClass struct {
	native *C.GNetworkAddressClass
}

// NetworkMonitorInterface: virtual function table for Monitor.
//
// An instance of this type is always passed by reference.
type NetworkMonitorInterface struct {
	*networkMonitorInterface
}

// networkMonitorInterface is the struct that's finalized.
type networkMonitorInterface struct {
	native *C.GNetworkMonitorInterface
}

// NetworkServiceClass: instance of this type is always passed by reference.
type NetworkServiceClass struct {
	*networkServiceClass
}

// networkServiceClass is the struct that's finalized.
type networkServiceClass struct {
	native *C.GNetworkServiceClass
}

// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array
// of Vectors and the operation will use all the buffers as if they were one
// buffer.
//
// If address is NULL then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
//
// An instance of this type is always passed by reference.
type OutputMessage struct {
	*outputMessage
}

// outputMessage is the struct that's finalized.
type outputMessage struct {
	native *C.GOutputMessage
}

// OutputStreamClass: instance of this type is always passed by reference.
type OutputStreamClass struct {
	*outputStreamClass
}

// outputStreamClass is the struct that's finalized.
type outputStreamClass struct {
	native *C.GOutputStreamClass
}

// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
//
// An instance of this type is always passed by reference.
type OutputVector struct {
	*outputVector
}

// outputVector is the struct that's finalized.
type outputVector struct {
	native *C.GOutputVector
}

// Buffer: pointer to a buffer of data to read.
func (o *OutputVector) Buffer() unsafe.Pointer {
	valptr := &o.native.buffer
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Size: size of buffer.
func (o *OutputVector) Size() uint {
	valptr := &o.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Size: size of buffer.
func (o *OutputVector) SetSize(size uint) {
	valptr := &o.native.size
	*valptr = C.gsize(size)
}

// PermissionClass: instance of this type is always passed by reference.
type PermissionClass struct {
	*permissionClass
}

// permissionClass is the struct that's finalized.
type permissionClass struct {
	native *C.GPermissionClass
}

func (p *PermissionClass) Reserved() [16]unsafe.Pointer {
	valptr := &p.native.reserved
	var _v [16]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 16; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// PollableInputStreamInterface: interface for pollable input streams.
//
// The default implementation of can_poll always returns TRUE.
//
// The default implementation of read_nonblocking calls
// g_pollable_input_stream_is_readable(), and then calls g_input_stream_read()
// if it returns TRUE. This means you only need to override it if it is possible
// that your is_readable implementation may return TRUE when the stream is not
// actually readable.
//
// An instance of this type is always passed by reference.
type PollableInputStreamInterface struct {
	*pollableInputStreamInterface
}

// pollableInputStreamInterface is the struct that's finalized.
type pollableInputStreamInterface struct {
	native *C.GPollableInputStreamInterface
}

// PollableOutputStreamInterface: interface for pollable output streams.
//
// The default implementation of can_poll always returns TRUE.
//
// The default implementation of write_nonblocking calls
// g_pollable_output_stream_is_writable(), and then calls
// g_output_stream_write() if it returns TRUE. This means you only need to
// override it if it is possible that your is_writable implementation may return
// TRUE when the stream is not actually writable.
//
// The default implementation of writev_nonblocking calls
// g_pollable_output_stream_write_nonblocking() for each vector, and converts
// its return value and error (if set) to a Return. You should override
// this where possible to avoid having to allocate a #GError to return
// G_IO_ERROR_WOULD_BLOCK.
//
// An instance of this type is always passed by reference.
type PollableOutputStreamInterface struct {
	*pollableOutputStreamInterface
}

// pollableOutputStreamInterface is the struct that's finalized.
type pollableOutputStreamInterface struct {
	native *C.GPollableOutputStreamInterface
}

// PowerProfileMonitorInterface: virtual function table for ProfileMonitor.
//
// An instance of this type is always passed by reference.
type PowerProfileMonitorInterface struct {
	*powerProfileMonitorInterface
}

// powerProfileMonitorInterface is the struct that's finalized.
type powerProfileMonitorInterface struct {
	native *C.GPowerProfileMonitorInterface
}

// ProxyAddressClass class structure for Address.
//
// An instance of this type is always passed by reference.
type ProxyAddressClass struct {
	*proxyAddressClass
}

// proxyAddressClass is the struct that's finalized.
type proxyAddressClass struct {
	native *C.GProxyAddressClass
}

func (p *ProxyAddressClass) ParentClass() *InetSocketAddressClass {
	valptr := &p.native.parent_class
	var _v *InetSocketAddressClass // out
	_v = (*InetSocketAddressClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ProxyAddressEnumeratorClass class structure for AddressEnumerator.
//
// An instance of this type is always passed by reference.
type ProxyAddressEnumeratorClass struct {
	*proxyAddressEnumeratorClass
}

// proxyAddressEnumeratorClass is the struct that's finalized.
type proxyAddressEnumeratorClass struct {
	native *C.GProxyAddressEnumeratorClass
}

// ProxyInterface provides an interface for handling proxy connection and
// payload.
//
// An instance of this type is always passed by reference.
type ProxyInterface struct {
	*proxyInterface
}

// proxyInterface is the struct that's finalized.
type proxyInterface struct {
	native *C.GProxyInterface
}

// ProxyResolverInterface: virtual function table for Resolver.
//
// An instance of this type is always passed by reference.
type ProxyResolverInterface struct {
	*proxyResolverInterface
}

// proxyResolverInterface is the struct that's finalized.
type proxyResolverInterface struct {
	native *C.GProxyResolverInterface
}

// RemoteActionGroupInterface: virtual function table for ActionGroup.
//
// An instance of this type is always passed by reference.
type RemoteActionGroupInterface struct {
	*remoteActionGroupInterface
}

// remoteActionGroupInterface is the struct that's finalized.
type remoteActionGroupInterface struct {
	native *C.GRemoteActionGroupInterface
}

// ResolverClass: instance of this type is always passed by reference.
type ResolverClass struct {
	*resolverClass
}

// resolverClass is the struct that's finalized.
type resolverClass struct {
	native *C.GResolverClass
}

// Resource applications and libraries often contain binary or textual data
// that is really part of the application, rather than user data. For instance
// GtkBuilder (https://docs.gtk.org/gtk4/class.Builder.html) .ui files,
// splashscreen images, gio.Menu markup XML, CSS files, icons, etc. These are
// often shipped as files in $datadir/appname, or manually included as literal
// strings in the code.
//
// The GResource API and the glib-compile-resources
// (glib-compile-resources.html) program provide a convenient and efficient
// alternative to this which has some nice properties. You maintain the files as
// normal files, so its easy to edit them, but during the build the files are
// combined into a binary bundle that is linked into the executable. This means
// that loading the resource files are efficient (as they are already in memory,
// shared with other instances) and simple (no need to check for things like
// I/O errors or locate the files in the filesystem). It also makes it easier to
// create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the preprocess attribute to a comma-separated list of preprocessing options.
// The only options currently supported are:
//
//   - xml-stripblanks which will use the xmllint (man:xmllint(1)) command
//     to strip ignorable whitespace from the XML file. For this to work, the
//     XMLLINT environment variable must be set to the full path to the xmllint
//     executable, or xmllint must be in the PATH; otherwise the preprocessing
//     step is skipped.
//
//   - to-pixdata (deprecated since gdk-pixbuf 2.32) which will use the
//     gdk-pixbuf-pixdata command to convert images to the GdkPixdata
//     (https://docs.gtk.org/gdk-pixbuf/class.Pixdata.html) format,
//     which allows you to create pixbufs directly using the data inside
//     the resource file, rather than an (uncompressed) copy of it.
//     For this, the gdk-pixbuf-pixdata program must be in the PATH, or the
//     GDK_PIXBUF_PIXDATA environment variable must be set to the full path to
//     the gdk-pixbuf-pixdata executable; otherwise the resource compiler will
//     abort. to-pixdata has been deprecated since gdk-pixbuf 2.32, as GResource
//     supports embedding modern image formats just as well. Instead of using
//     it, embed a PNG or SVG file in your GResource.
//
//   - json-stripblanks which will use the json-glib-format
//     (man:json-glib-format(1)) command to strip ignorable whitespace from
//     the JSON file. For this to work, the JSON_GLIB_FORMAT environment
//     variable must be set to the full path to the json-glib-format executable,
//     or it must be in the PATH; otherwise the preprocessing step is skipped.
//     In addition, at least version 1.6 of json-glib-format is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given prefix and the filename from the file element.
// The alias attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the glib-compile-resources
// (glib-compile-resources.html) program which takes an XML file that describes
// the bundle, and a set of files that the XML references. These are combined
// into a binary resource bundle.
//
// An example resource description:
//
//	<?xml version="1.0" encoding="UTF-8"?>
//	<gresources>
//	  <gresource prefix="/org/gtk/Example">
//	    <file>data/splashscreen.png</file>
//	    <file compressed="true">dialog.ui</file>
//	    <file preprocess="xml-stripblanks">menumarkup.xml</file>
//	    <file alias="example.css">data/example.css</file>
//	  </gresource>
//	</gresources>
//
// This will create a resource bundle with the following files:
//
//	/org/gtk/Example/data/splashscreen.png
//	/org/gtk/Example/dialog.ui
//	/org/gtk/Example/menumarkup.xml
//	/org/gtk/Example/example.css
//
// Note that all resources in the process share the same namespace, so use
// Java-style path prefixes (like in the above example) to avoid conflicts.
//
// You can then use glib-compile-resources (glib-compile-resources.html)
// to compile the XML to a binary bundle that you can load with
// gio.Resource().Load. However, its more common to use the --generate-source
// and --generate-header arguments to create a source file and header to
// link directly into your application. This will generate get_resource(),
// register_resource() and unregister_resource() functions,
// prefixed by the --c-name argument passed to glib-compile-resources
// (glib-compile-resources.html). get_resource() returns the generated GResource
// object. The register and unregister functions register the resource so its
// files can be accessed using gio.ResourcesLookupData().
//
// Once a GResource has been created and registered all the data in
// it can be accessed globally in the process by using API calls like
// gio.ResourcesOpenStream() to stream the data or gio.ResourcesLookupData()
// to get a direct pointer to the data. You can also use URIs like
// resource:///org/gtk/Example/data/splashscreen.png with gio.File to access the
// resource data.
//
// Some higher-level APIs, such as GtkApplication
// (https://docs.gtk.org/gtk4/class.Application.html), will automatically
// load resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the
// compiler support for constructor and destructor functions (where available)
// to automatically create and register the GResource on startup or library load
// time. If you pass --manual-register, two functions to register/unregister the
// resource are created instead. This requires an explicit initialization call
// in your application/library, but it works on all platforms, even on the minor
// ones where constructors are not supported. (Constructor support is available
// for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g.
// a library, so if you are unloading libraries during runtime you need to be
// very careful with keeping around pointers to data from a resource, as this
// goes away when the library is unloaded. However, in practice this is not
// generally a problem, since most resource accesses are for your own resources,
// and resource data is often used once, during parsing, and then released.
//
// # Overlays
//
// When debugging a program or testing a change to an installed version,
// it is often useful to be able to replace resources in the program or library,
// without recompiling, for debugging or quick hacking and testing purposes.
// Since GLib 2.50, it is possible to use the G_RESOURCE_OVERLAYS environment
// variable to selectively overlay resources with replacements from the
// filesystem. It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions
// to perform during resource lookups. It is ignored when running in a setuid
// process.
//
// A substitution has the form
//
//	/org/gtk/libgtk=/home/desrt/gtk-overlay
//
// The part before the = is the resource subpath for which the overlay applies.
// The part after is a filesystem path which contains files and subdirectories
// as you would like to be loaded as resources with the equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path /org/gtk/libgtk/ui/gtkdialog.ui then GResource would check
// the filesystem path /home/desrt/gtk-overlay/ui/gtkdialog.ui. If a file was
// found there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the =. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
//
// An instance of this type is always passed by reference.
type Resource struct {
	*resource
}

// resource is the struct that's finalized.
type resource struct {
	native *C.GResource
}

func marshalResource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Resource{&resource{(*C.GResource)(b)}}, nil
}

// NewResourceFromData constructs a struct Resource.
func NewResourceFromData(data *glib.Bytes) (*Resource, error) {
	var _arg1 *C.GBytes    // out
	var _cret *C.GResource // in
	var _cerr *C.GError    // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.g_resource_new_from_data(_arg1, &_cerr)
	runtime.KeepAlive(data)

	var _resource *Resource // out
	var _goerr error        // out

	_resource = (*Resource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_resource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_resource_unref((*C.GResource)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _resource, _goerr
}

// EnumerateChildren returns all the names of children at the specified path in
// the resource. The return result is a NULL terminated list of strings which
// should be released with g_strfreev().
//
// If path is invalid or does not exist in the #GResource,
// G_RESOURCE_ERROR_NOT_FOUND will be returned.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - utf8s: array of constant strings.
func (resource *Resource) EnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret **C.char               // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resource_enumerate_children(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// Info looks for a file at the specified path in the resource and if found
// returns information about it.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - size (optional): location to place the length of the contents of the
//     file, or NULL if the length is not needed.
//   - flags (optional): location to place the flags about the file, or NULL if
//     the length is not needed.
func (resource *Resource) Info(path string, lookupFlags ResourceLookupFlags) (uint, uint32, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _arg3 C.gsize                // in
	var _arg4 C.guint32              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	C.g_resource_get_info(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _size uint    // out
	var _flags uint32 // out
	var _goerr error  // out

	_size = uint(_arg3)
	_flags = uint32(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _size, _flags, _goerr
}

// LookupData looks for a file at the specified path in the resource and returns
// a #GBytes that lets you directly access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - bytes or NULL on error. Free the returned object with g_bytes_unref().
func (resource *Resource) LookupData(path string, lookupFlags ResourceLookupFlags) (*glib.Bytes, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GBytes              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resource_lookup_data(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// OpenStream looks for a file at the specified path in the resource and returns
// a Stream that lets you read the data.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//   - path: pathname inside the resource.
//   - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//   - inputStream or NULL on error. Free the returned object with
//     g_object_unref().
func (resource *Resource) OpenStream(path string, lookupFlags ResourceLookupFlags) (InputStreamer, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GInputStream        // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resource_open_stream(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _inputStream InputStreamer // out
	var _goerr error               // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// ResourceLoad loads a binary resource bundle and creates a #GResource
// representation of it, allowing you to query it for data.
//
// If you want to use this resource in the global resource namespace you need to
// register it with g_resources_register().
//
// If filename is empty or the data in it is corrupt, G_RESOURCE_ERROR_INTERNAL
// will be returned. If filename doesnt exist, or there is an error in reading
// it, an error from g_mapped_file_new() will be returned.
//
// The function takes the following parameters:
//
//   - filename: path of a filename to load, in the GLib filename encoding.
//
// The function returns the following values:
//
//   - resource: new #GResource, or NULL on error.
func ResourceLoad(filename string) (*Resource, error) {
	var _arg1 *C.gchar     // out
	var _cret *C.GResource // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_resource_load(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _resource *Resource // out
	var _goerr error        // out

	_resource = (*Resource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_resource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_resource_unref((*C.GResource)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _resource, _goerr
}

// SeekableIface provides an interface for implementing seekable functionality
// on I/O Streams.
//
// An instance of this type is always passed by reference.
type SeekableIface struct {
	*seekableIface
}

// seekableIface is the struct that's finalized.
type seekableIface struct {
	native *C.GSeekableIface
}

// SettingsClass: instance of this type is always passed by reference.
type SettingsClass struct {
	*settingsClass
}

// settingsClass is the struct that's finalized.
type settingsClass struct {
	native *C.GSettingsClass
}

func (s *SettingsClass) Padding() [20]unsafe.Pointer {
	valptr := &s.native.padding
	var _v [20]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 20; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// SettingsSchema: gio.SettingsSchemaSource and GSettingsSchema APIs provide a
// mechanism for advanced control over the loading of schemas and a mechanism
// for introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// gio.SettingsSchemaSource provides a mechanism for dealing with this by
// allowing the creation of a new schema source from which schemas can be
// acquired. This schema source can then become part of the metadata associated
// with the plugin and queried whenever the plugin requires access to some
// settings.
//
// Consider the following example:
//
//	typedef struct
//	{
//	   
//	   GSettingsSchemaSource *schema_source;
//	   
//	} Plugin;
//
//	Plugin *
//	initialise_plugin (const gchar *dir)
//	{
//	  Plugin *plugin;
//
//	  
//
//	  plugin->schema_source =
//	    g_settings_schema_source_new_from_directory (dir,
//	      g_settings_schema_source_get_default (), FALSE, NULL);
//
//	  
//
//	  return plugin;
//	}
//
//	
//
//	GSettings *
//	plugin_get_settings (Plugin      *plugin,
//	                     const gchar *schema_id)
//	{
//	  GSettingsSchema *schema;
//
//	  if (schema_id == NULL)
//	    schema_id = plugin->identifier;
//
//	  schema = g_settings_schema_source_lookup (plugin->schema_source,
//	                                            schema_id, FALSE);
//
//	  if (schema == NULL)
//	    {
//	       disable the plugin or abort, etc 
//	    }
//
//	  return g_settings_new_full (schema, NULL, NULL);
//	}
//
// The code above shows how hooks should be added to the code that initialises
// (or enables) the plugin to create the schema source and how an API can be
// added to the plugin system to provide a convenient way for the plugin to
// access its settings, using the schemas that it ships.
//
// From the standpoint of the plugin, it would need to ensure that it ships a
// gschemas.compiled file as part of itself, and then simply do the following:
//
//	{
//	  GSettings *settings;
//	  gint some_value;
//
//	  settings = plugin_get_settings (self, NULL);
//	  some_value = g_settings_get_int (settings, "some-value");
//	  
//	}
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
//
// An instance of this type is always passed by reference.
type SettingsSchema struct {
	*settingsSchema
}

// settingsSchema is the struct that's finalized.
type settingsSchema struct {
	native *C.GSettingsSchema
}

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SettingsSchema{&settingsSchema{(*C.GSettingsSchema)(b)}}, nil
}

// ID: get the ID of schema.
//
// The function returns the following values:
//
//   - utf8: ID.
func (schema *SettingsSchema) ID() string {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GSettingsSchema)(gextras.StructNative(unsafe.Pointer(schema)))

	_cret = C.g_settings_schema_get_id(_arg0)
	runtime.KeepAlive(schema)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Key gets the key named name from schema.
//
// It is a programmer error to request a key that does not exist. See
// g_settings_schema_list_keys().
//
// The function takes the following parameters:
//
//   - name of a key.
//
// The function returns the following values:
//
//   - settingsSchemaKey for name.
func (schema *SettingsSchema) Key(name string) *SettingsSchemaKey {
	var _arg0 *C.GSettingsSchema    // out
	var _arg1 *C.gchar              // out
	var _cret *C.GSettingsSchemaKey // in

	_arg0 = (*C.GSettingsSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_schema_get_key(_arg0, _arg1)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(name)

	var _settingsSchemaKey *SettingsSchemaKey // out

	_settingsSchemaKey = (*SettingsSchemaKey)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_settingsSchemaKey)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_settings_schema_key_unref((*C.GSettingsSchemaKey)(intern.C))
		},
	)

	return _settingsSchemaKey
}

// Path gets the path associated with schema, or NULL.
//
// Schemas may be single-instance or relocatable. Single-instance schemas
// correspond to exactly one set of keys in the backend database: those located
// at the path returned by this function.
//
// Relocatable schemas can be referenced by other schemas and can therefore
// describe multiple sets of keys at different locations. For relocatable
// schemas, this function will return NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): path of the schema, or NULL.
func (schema *SettingsSchema) Path() string {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GSettingsSchema)(gextras.StructNative(unsafe.Pointer(schema)))

	_cret = C.g_settings_schema_get_path(_arg0)
	runtime.KeepAlive(schema)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// HasKey checks if schema has a key named name.
//
// The function takes the following parameters:
//
//   - name of a key.
//
// The function returns the following values:
//
//   - ok: TRUE if such a key exists.
func (schema *SettingsSchema) HasKey(name string) bool {
	var _arg0 *C.GSettingsSchema // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GSettingsSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_schema_has_key(_arg0, _arg1)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListChildren gets the list of children in schema.
//
// You should free the return value with g_strfreev() when you are done with it.
//
// The function returns the following values:
//
//   - utf8s: list of the children on settings, in no defined order.
func (schema *SettingsSchema) ListChildren() []string {
	var _arg0 *C.GSettingsSchema // out
	var _cret **C.gchar          // in

	_arg0 = (*C.GSettingsSchema)(gextras.StructNative(unsafe.Pointer(schema)))

	_cret = C.g_settings_schema_list_children(_arg0)
	runtime.KeepAlive(schema)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ListKeys introspects the list of keys on schema.
//
// You should probably not be calling this function from "normal" code (since
// you should already know what keys are in your schema). This function is
// intended for introspection reasons.
//
// The function returns the following values:
//
//   - utf8s: list of the keys on schema, in no defined order.
func (schema *SettingsSchema) ListKeys() []string {
	var _arg0 *C.GSettingsSchema // out
	var _cret **C.gchar          // in

	_arg0 = (*C.GSettingsSchema)(gextras.StructNative(unsafe.Pointer(schema)))

	_cret = C.g_settings_schema_list_keys(_arg0)
	runtime.KeepAlive(schema)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// SettingsSchemaKey is an opaque data structure and can only be accessed using
// the following functions.
//
// An instance of this type is always passed by reference.
type SettingsSchemaKey struct {
	*settingsSchemaKey
}

// settingsSchemaKey is the struct that's finalized.
type settingsSchemaKey struct {
	native *C.GSettingsSchemaKey
}

func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SettingsSchemaKey{&settingsSchemaKey{(*C.GSettingsSchemaKey)(b)}}, nil
}

// DefaultValue gets the default value for key.
//
// Note that this is the default value according to the schema. System
// administrator defaults and lockdown are not visible via this API.
//
// The function returns the following values:
//
//   - variant: default value for the key.
func (key *SettingsSchemaKey) DefaultValue() *glib.Variant {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GSettingsSchemaKey)(gextras.StructNative(unsafe.Pointer(key)))

	_cret = C.g_settings_schema_key_get_default_value(_arg0)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Description gets the description for key.
//
// If no description has been provided in the schema for key, returns NULL.
//
// The description can be one sentence to several paragraphs in length.
// Paragraphs are delimited with a double newline. Descriptions can be
// translated and the value returned from this function is is the current
// locale.
//
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
//
// The function returns the following values:
//
//   - utf8 (optional): description for key, or NULL.
func (key *SettingsSchemaKey) Description() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(gextras.StructNative(unsafe.Pointer(key)))

	_cret = C.g_settings_schema_key_get_description(_arg0)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name gets the name of key.
//
// The function returns the following values:
//
//   - utf8: name of key.
func (key *SettingsSchemaKey) Name() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(gextras.StructNative(unsafe.Pointer(key)))

	_cret = C.g_settings_schema_key_get_name(_arg0)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Range queries the range of a key.
//
// This function will return a #GVariant that fully describes the range of
// values that are valid for key.
//
// The type of #GVariant returned is (sv). The string describes the type of
// range restriction in effect. The type and meaning of the value contained in
// the variant depends on the string.
//
// If the string is 'type' then the variant contains an empty array. The element
// type of that empty array is the expected type of value and all values of that
// type are valid.
//
// If the string is 'enum' then the variant contains an array enumerating the
// possible values. Each item in the array is a possible valid value and no
// other values are valid.
//
// If the string is 'flags' then the variant contains an array. Each item in the
// array is a value that may appear zero or one times in an array to be used as
// the value for this key. For example, if the variant contained the array ['x',
// 'y'] then the valid values for the key would be [], ['x'], ['y'], ['x',
// 'y'] and ['y', 'x'].
//
// Finally, if the string is 'range' then the variant contains a pair of
// like-typed values -- the minimum and maximum permissible values for this key.
//
// This information should not be used by normal programs. It is considered to
// be a hint for introspection purposes. Normal programs should already know
// what is permitted by their own schema. The format may change in any way in
// the future -- but particularly, new forms may be added to the possibilities
// described above.
//
// You should free the returned value with g_variant_unref() when it is no
// longer needed.
//
// The function returns the following values:
//
//   - variant describing the range.
func (key *SettingsSchemaKey) Range() *glib.Variant {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GSettingsSchemaKey)(gextras.StructNative(unsafe.Pointer(key)))

	_cret = C.g_settings_schema_key_get_range(_arg0)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Summary gets the summary for key.
//
// If no summary has been provided in the schema for key, returns NULL.
//
// The summary is a short description of the purpose of the key; usually one
// short sentence. Summaries can be translated and the value returned from this
// function is is the current locale.
//
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
//
// The function returns the following values:
//
//   - utf8 (optional): summary for key, or NULL.
func (key *SettingsSchemaKey) Summary() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(gextras.StructNative(unsafe.Pointer(key)))

	_cret = C.g_settings_schema_key_get_summary(_arg0)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ValueType gets the Type of key.
//
// The function returns the following values:
//
//   - variantType: type of key.
func (key *SettingsSchemaKey) ValueType() *glib.VariantType {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariantType       // in

	_arg0 = (*C.GSettingsSchemaKey)(gextras.StructNative(unsafe.Pointer(key)))

	_cret = C.g_settings_schema_key_get_value_type(_arg0)
	runtime.KeepAlive(key)

	var _variantType *glib.VariantType // out

	_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

// RangeCheck checks if the given value is within the permitted range for key.
//
// It is a programmer error if value is not of the correct type  you must check
// for this first.
//
// The function takes the following parameters:
//
//   - value to check.
//
// The function returns the following values:
//
//   - ok: TRUE if value is valid for key.
func (key *SettingsSchemaKey) RangeCheck(value *glib.Variant) bool {
	var _arg0 *C.GSettingsSchemaKey // out
	var _arg1 *C.GVariant           // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GSettingsSchemaKey)(gextras.StructNative(unsafe.Pointer(key)))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_settings_schema_key_range_check(_arg0, _arg1)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
//
// An instance of this type is always passed by reference.
type SettingsSchemaSource struct {
	*settingsSchemaSource
}

// settingsSchemaSource is the struct that's finalized.
type settingsSchemaSource struct {
	native *C.GSettingsSchemaSource
}

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SettingsSchemaSource{&settingsSchemaSource{(*C.GSettingsSchemaSource)(b)}}, nil
}

// NewSettingsSchemaSourceFromDirectory constructs a struct SettingsSchemaSource.
func NewSettingsSchemaSourceFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) (*SettingsSchemaSource, error) {
	var _arg1 *C.gchar                 // out
	var _arg2 *C.GSettingsSchemaSource // out
	var _arg3 C.gboolean               // out
	var _cret *C.GSettingsSchemaSource // in
	var _cerr *C.GError                // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))
	defer C.free(unsafe.Pointer(_arg1))
	if parent != nil {
		_arg2 = (*C.GSettingsSchemaSource)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	if trusted {
		_arg3 = C.TRUE
	}

	_cret = C.g_settings_schema_source_new_from_directory(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(directory)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(trusted)

	var _settingsSchemaSource *SettingsSchemaSource // out
	var _goerr error                                // out

	_settingsSchemaSource = (*SettingsSchemaSource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_settingsSchemaSource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_settings_schema_source_unref((*C.GSettingsSchemaSource)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _settingsSchemaSource, _goerr
}

// ListSchemas lists the schemas in a given source.
//
// If recursive is TRUE then include parent sources. If FALSE then only include
// the schemas from one source (ie: one directory). You probably want TRUE.
//
// Non-relocatable schemas are those for which you can call
// g_settings_new(). Relocatable schemas are those for which you must use
// g_settings_new_with_path().
//
// Do not call this function from normal programs. This is designed for use by
// database editors, commandline tools, etc.
//
// The function takes the following parameters:
//
//   - recursive: if we should recurse.
//
// The function returns the following values:
//
//   - nonRelocatable: the list of non-relocatable schemas, in no defined order.
//   - relocatable: list of relocatable schemas, in no defined order.
func (source *SettingsSchemaSource) ListSchemas(recursive bool) (nonRelocatable []string, relocatable []string) {
	var _arg0 *C.GSettingsSchemaSource // out
	var _arg1 C.gboolean               // out
	var _arg2 **C.gchar                // in
	var _arg3 **C.gchar                // in

	_arg0 = (*C.GSettingsSchemaSource)(gextras.StructNative(unsafe.Pointer(source)))
	if recursive {
		_arg1 = C.TRUE
	}

	C.g_settings_schema_source_list_schemas(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(source)
	runtime.KeepAlive(recursive)

	var _nonRelocatable []string // out
	var _relocatable []string    // out

	defer C.free(unsafe.Pointer(_arg2))
	{
		var i int
		var z *C.gchar
		for p := _arg2; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_arg2, i)
		_nonRelocatable = make([]string, i)
		for i := range src {
			_nonRelocatable[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	defer C.free(unsafe.Pointer(_arg3))
	{
		var i int
		var z *C.gchar
		for p := _arg3; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_arg3, i)
		_relocatable = make([]string, i)
		for i := range src {
			_relocatable[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _nonRelocatable, _relocatable
}

// Lookup looks up a schema with the identifier schema_id in source.
//
// This function is not required for normal uses of #GSettings but it may
// be useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If the schema isn't found directly in source and recursive is TRUE then the
// parent sources will also be checked.
//
// If the schema isn't found, NULL is returned.
//
// The function takes the following parameters:
//
//   - schemaId: schema ID.
//   - recursive: TRUE if the lookup should be recursive.
//
// The function returns the following values:
//
//   - settingsSchema (optional): new Schema.
func (source *SettingsSchemaSource) Lookup(schemaId string, recursive bool) *SettingsSchema {
	var _arg0 *C.GSettingsSchemaSource // out
	var _arg1 *C.gchar                 // out
	var _arg2 C.gboolean               // out
	var _cret *C.GSettingsSchema       // in

	_arg0 = (*C.GSettingsSchemaSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(_arg1))
	if recursive {
		_arg2 = C.TRUE
	}

	_cret = C.g_settings_schema_source_lookup(_arg0, _arg1, _arg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(schemaId)
	runtime.KeepAlive(recursive)

	var _settingsSchema *SettingsSchema // out

	if _cret != nil {
		_settingsSchema = (*SettingsSchema)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_settingsSchema)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_settings_schema_unref((*C.GSettingsSchema)(intern.C))
			},
		)
	}

	return _settingsSchema
}

// SettingsSchemaSourceGetDefault gets the default system schema source.
//
// This function is not required for normal uses of #GSettings but it may
// be useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If no schemas are installed, NULL will be returned.
//
// The returned source may actually consist of multiple schema sources
// from different directories, depending on which directories were given
// in XDG_DATA_DIRS and GSETTINGS_SCHEMA_DIR. For this reason, all lookups
// performed against the default source should probably be done recursively.
//
// The function returns the following values:
//
//   - settingsSchemaSource (optional): default schema source.
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource {
	var _cret *C.GSettingsSchemaSource // in

	_cret = C.g_settings_schema_source_get_default()

	var _settingsSchemaSource *SettingsSchemaSource // out

	if _cret != nil {
		_settingsSchemaSource = (*SettingsSchemaSource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_settings_schema_source_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_settingsSchemaSource)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_settings_schema_source_unref((*C.GSettingsSchemaSource)(intern.C))
			},
		)
	}

	return _settingsSchemaSource
}

// SimpleActionGroupClass: instance of this type is always passed by reference.
type SimpleActionGroupClass struct {
	*simpleActionGroupClass
}

// simpleActionGroupClass is the struct that's finalized.
type simpleActionGroupClass struct {
	native *C.GSimpleActionGroupClass
}

// SimpleProxyResolverClass: instance of this type is always passed by
// reference.
type SimpleProxyResolverClass struct {
	*simpleProxyResolverClass
}

// simpleProxyResolverClass is the struct that's finalized.
type simpleProxyResolverClass struct {
	native *C.GSimpleProxyResolverClass
}

// SocketAddressClass: instance of this type is always passed by reference.
type SocketAddressClass struct {
	*socketAddressClass
}

// socketAddressClass is the struct that's finalized.
type socketAddressClass struct {
	native *C.GSocketAddressClass
}

// SocketAddressEnumeratorClass class structure for AddressEnumerator.
//
// An instance of this type is always passed by reference.
type SocketAddressEnumeratorClass struct {
	*socketAddressEnumeratorClass
}

// socketAddressEnumeratorClass is the struct that's finalized.
type socketAddressEnumeratorClass struct {
	native *C.GSocketAddressEnumeratorClass
}

// SocketClass: instance of this type is always passed by reference.
type SocketClass struct {
	*socketClass
}

// socketClass is the struct that's finalized.
type socketClass struct {
	native *C.GSocketClass
}

// SocketClientClass: instance of this type is always passed by reference.
type SocketClientClass struct {
	*socketClientClass
}

// socketClientClass is the struct that's finalized.
type socketClientClass struct {
	native *C.GSocketClientClass
}

// SocketConnectableIface provides an interface for returning a
// AddressEnumerator and AddressEnumerator
//
// An instance of this type is always passed by reference.
type SocketConnectableIface struct {
	*socketConnectableIface
}

// socketConnectableIface is the struct that's finalized.
type socketConnectableIface struct {
	native *C.GSocketConnectableIface
}

// SocketConnectionClass: instance of this type is always passed by reference.
type SocketConnectionClass struct {
	*socketConnectionClass
}

// socketConnectionClass is the struct that's finalized.
type socketConnectionClass struct {
	native *C.GSocketConnectionClass
}

func (s *SocketConnectionClass) ParentClass() *IOStreamClass {
	valptr := &s.native.parent_class
	var _v *IOStreamClass // out
	_v = (*IOStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SocketControlMessageClass class structure for ControlMessage.
//
// An instance of this type is always passed by reference.
type SocketControlMessageClass struct {
	*socketControlMessageClass
}

// socketControlMessageClass is the struct that's finalized.
type socketControlMessageClass struct {
	native *C.GSocketControlMessageClass
}

// SocketListenerClass class structure for Listener.
//
// An instance of this type is always passed by reference.
type SocketListenerClass struct {
	*socketListenerClass
}

// socketListenerClass is the struct that's finalized.
type socketListenerClass struct {
	native *C.GSocketListenerClass
}

// SocketServiceClass class structure for Service.
//
// An instance of this type is always passed by reference.
type SocketServiceClass struct {
	*socketServiceClass
}

// socketServiceClass is the struct that's finalized.
type socketServiceClass struct {
	native *C.GSocketServiceClass
}

func (s *SocketServiceClass) ParentClass() *SocketListenerClass {
	valptr := &s.native.parent_class
	var _v *SocketListenerClass // out
	_v = (*SocketListenerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SrvTarget: single target host/port that a network service is running on.
//
// SRV (service) records are used by some network protocols to provide
// service-specific aliasing and load-balancing. For example, XMPP (Jabber) uses
// SRV records to locate the XMPP server for a domain; rather than connecting
// directly to example.com or assuming a specific server hostname like
// xmpp.example.com, an XMPP client would look up the xmpp-client SRV record
// for example.com, and then connect to whatever host was pointed to by that
// record.
//
// You can use gio.Resolver.LookupService() or gio.Resolver.LookupServiceAsync()
// to find the GSrvTargets for a given service. However, if you are simply
// planning to connect to the remote service, you can use gio.NetworkServices
// gio.SocketConnectable interface and not need to worry about GSrvTarget at
// all.
//
// An instance of this type is always passed by reference.
type SrvTarget struct {
	*srvTarget
}

// srvTarget is the struct that's finalized.
type srvTarget struct {
	native *C.GSrvTarget
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SrvTarget{&srvTarget{(*C.GSrvTarget)(b)}}, nil
}

// NewSrvTarget constructs a struct SrvTarget.
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	var _arg1 *C.gchar      // out
	var _arg2 C.guint16     // out
	var _arg3 C.guint16     // out
	var _arg4 C.guint16     // out
	var _cret *C.GSrvTarget // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(port)
	_arg3 = C.guint16(priority)
	_arg4 = C.guint16(weight)

	_cret = C.g_srv_target_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(weight)

	var _srvTarget *SrvTarget // out

	_srvTarget = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_srvTarget)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_srv_target_free((*C.GSrvTarget)(intern.C))
		},
	)

	return _srvTarget
}

// Copy copies target.
//
// The function returns the following values:
//
//   - srvTarget: copy of target.
func (target *SrvTarget) Copy() *SrvTarget {
	var _arg0 *C.GSrvTarget // out
	var _cret *C.GSrvTarget // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_copy(_arg0)
	runtime.KeepAlive(target)

	var _srvTarget *SrvTarget // out

	_srvTarget = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_srvTarget)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_srv_target_free((*C.GSrvTarget)(intern.C))
		},
	)

	return _srvTarget
}

// Hostname gets target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to check if it
// contains encoded Unicode segments, and use g_hostname_to_unicode() to convert
// it if it does.).
//
// The function returns the following values:
//
//   - utf8 target's hostname.
func (target *SrvTarget) Hostname() string {
	var _arg0 *C.GSrvTarget // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_hostname(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Port gets target's port.
//
// The function returns the following values:
//
//   - guint16 target's port.
func (target *SrvTarget) Port() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_port(_arg0)
	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Priority gets target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in RFC 2782.
//
// The function returns the following values:
//
//   - guint16 target's priority.
func (target *SrvTarget) Priority() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_priority(_arg0)
	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Weight gets target's weight. You should not need to look at this; #GResolver
// already sorts the targets according to the algorithm in RFC 2782.
//
// The function returns the following values:
//
//   - guint16 target's weight.
func (target *SrvTarget) Weight() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_weight(_arg0)
	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// StaticResource is an opaque data structure and can only be accessed using the
// following functions.
//
// An instance of this type is always passed by reference.
type StaticResource struct {
	*staticResource
}

// staticResource is the struct that's finalized.
type staticResource struct {
	native *C.GStaticResource
}

// Fini: finalized a GResource initialized by g_static_resource_init().
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (staticResource *StaticResource) Fini() {
	var _arg0 *C.GStaticResource // out

	_arg0 = (*C.GStaticResource)(gextras.StructNative(unsafe.Pointer(staticResource)))

	C.g_static_resource_fini(_arg0)
	runtime.KeepAlive(staticResource)
}

// Resource gets the GResource that was registered by a call to
// g_static_resource_init().
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
//
// The function returns the following values:
//
//   - resource: #GResource.
func (staticResource *StaticResource) Resource() *Resource {
	var _arg0 *C.GStaticResource // out
	var _cret *C.GResource       // in

	_arg0 = (*C.GStaticResource)(gextras.StructNative(unsafe.Pointer(staticResource)))

	_cret = C.g_static_resource_get_resource(_arg0)
	runtime.KeepAlive(staticResource)

	var _resource *Resource // out

	_resource = (*Resource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_resource_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_resource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_resource_unref((*C.GResource)(intern.C))
		},
	)

	return _resource
}

// Init initializes a GResource from static data using a GStaticResource.
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (staticResource *StaticResource) Init() {
	var _arg0 *C.GStaticResource // out

	_arg0 = (*C.GStaticResource)(gextras.StructNative(unsafe.Pointer(staticResource)))

	C.g_static_resource_init(_arg0)
	runtime.KeepAlive(staticResource)
}

// TCPConnectionClass: instance of this type is always passed by reference.
type TCPConnectionClass struct {
	*tcpConnectionClass
}

// tcpConnectionClass is the struct that's finalized.
type tcpConnectionClass struct {
	native *C.GTcpConnectionClass
}

func (t *TCPConnectionClass) ParentClass() *SocketConnectionClass {
	valptr := &t.native.parent_class
	var _v *SocketConnectionClass // out
	_v = (*SocketConnectionClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TCPWrapperConnectionClass: instance of this type is always passed by
// reference.
type TCPWrapperConnectionClass struct {
	*tcpWrapperConnectionClass
}

// tcpWrapperConnectionClass is the struct that's finalized.
type tcpWrapperConnectionClass struct {
	native *C.GTcpWrapperConnectionClass
}

func (t *TCPWrapperConnectionClass) ParentClass() *TCPConnectionClass {
	valptr := &t.native.parent_class
	var _v *TCPConnectionClass // out
	_v = (*TCPConnectionClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ThreadedSocketServiceClass: instance of this type is always passed by
// reference.
type ThreadedSocketServiceClass struct {
	*threadedSocketServiceClass
}

// threadedSocketServiceClass is the struct that's finalized.
type threadedSocketServiceClass struct {
	native *C.GThreadedSocketServiceClass
}

func (t *ThreadedSocketServiceClass) ParentClass() *SocketServiceClass {
	valptr := &t.native.parent_class
	var _v *SocketServiceClass // out
	_v = (*SocketServiceClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TLSBackendInterface provides an interface for describing TLS-related types.
//
// An instance of this type is always passed by reference.
type TLSBackendInterface struct {
	*tlsBackendInterface
}

// tlsBackendInterface is the struct that's finalized.
type tlsBackendInterface struct {
	native *C.GTlsBackendInterface
}

// TLSCertificateClass: instance of this type is always passed by reference.
type TLSCertificateClass struct {
	*tlsCertificateClass
}

// tlsCertificateClass is the struct that's finalized.
type tlsCertificateClass struct {
	native *C.GTlsCertificateClass
}

// TLSClientConnectionInterface: vtable for a ClientConnection implementation.
//
// An instance of this type is always passed by reference.
type TLSClientConnectionInterface struct {
	*tlsClientConnectionInterface
}

// tlsClientConnectionInterface is the struct that's finalized.
type tlsClientConnectionInterface struct {
	native *C.GTlsClientConnectionInterface
}

// TLSConnectionClass class structure for the Connection type.
//
// An instance of this type is always passed by reference.
type TLSConnectionClass struct {
	*tlsConnectionClass
}

// tlsConnectionClass is the struct that's finalized.
type tlsConnectionClass struct {
	native *C.GTlsConnectionClass
}

// ParentClass: parent class.
func (t *TLSConnectionClass) ParentClass() *IOStreamClass {
	valptr := &t.native.parent_class
	var _v *IOStreamClass // out
	_v = (*IOStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TLSDatabaseClass class for Database. Derived classes should implement
// the various virtual methods. _async and _finish methods have a default
// implementation that runs the corresponding sync method in a thread.
//
// An instance of this type is always passed by reference.
type TLSDatabaseClass struct {
	*tlsDatabaseClass
}

// tlsDatabaseClass is the struct that's finalized.
type tlsDatabaseClass struct {
	native *C.GTlsDatabaseClass
}

// TLSFileDatabaseInterface provides an interface for FileDatabase
// implementations.
//
// An instance of this type is always passed by reference.
type TLSFileDatabaseInterface struct {
	*tlsFileDatabaseInterface
}

// tlsFileDatabaseInterface is the struct that's finalized.
type tlsFileDatabaseInterface struct {
	native *C.GTlsFileDatabaseInterface
}

// TLSInteractionClass class for Interaction. Derived classes implement the
// various virtual interaction methods to handle TLS interactions.
//
// Derived classes can choose to implement whichever interactions methods
// they'd like to support by overriding those virtual methods in their class
// initialization function. If a derived class implements an async method,
// it must also implement the corresponding finish method.
//
// The synchronous interaction methods should implement to display modal
// dialogs, and the asynchronous methods to display modeless dialogs.
//
// If the user cancels an interaction, then the result should be
// G_TLS_INTERACTION_FAILED and the error should be set with a domain of
// G_IO_ERROR and code of G_IO_ERROR_CANCELLED.
//
// An instance of this type is always passed by reference.
type TLSInteractionClass struct {
	*tlsInteractionClass
}

// tlsInteractionClass is the struct that's finalized.
type tlsInteractionClass struct {
	native *C.GTlsInteractionClass
}

// TLSPasswordClass class structure for Password.
//
// An instance of this type is always passed by reference.
type TLSPasswordClass struct {
	*tlsPasswordClass
}

// tlsPasswordClass is the struct that's finalized.
type tlsPasswordClass struct {
	native *C.GTlsPasswordClass
}

// TLSServerConnectionInterface: vtable for a ServerConnection implementation.
//
// An instance of this type is always passed by reference.
type TLSServerConnectionInterface struct {
	*tlsServerConnectionInterface
}

// tlsServerConnectionInterface is the struct that's finalized.
type tlsServerConnectionInterface struct {
	native *C.GTlsServerConnectionInterface
}

// VFSClass: instance of this type is always passed by reference.
type VFSClass struct {
	*vfsClass
}

// vfsClass is the struct that's finalized.
type vfsClass struct {
	native *C.GVfsClass
}

// VolumeIface: interface for implementing operations for mountable volumes.
//
// An instance of this type is always passed by reference.
type VolumeIface struct {
	*volumeIface
}

// volumeIface is the struct that's finalized.
type volumeIface struct {
	native *C.GVolumeIface
}

// VolumeMonitorClass: instance of this type is always passed by reference.
type VolumeMonitorClass struct {
	*volumeMonitorClass
}

// volumeMonitorClass is the struct that's finalized.
type volumeMonitorClass struct {
	native *C.GVolumeMonitorClass
}

// ZlibCompressorClass: instance of this type is always passed by reference.
type ZlibCompressorClass struct {
	*zlibCompressorClass
}

// zlibCompressorClass is the struct that's finalized.
type zlibCompressorClass struct {
	native *C.GZlibCompressorClass
}

// ZlibDecompressorClass: instance of this type is always passed by reference.
type ZlibDecompressorClass struct {
	*zlibDecompressorClass
}

// zlibDecompressorClass is the struct that's finalized.
type zlibDecompressorClass struct {
	native *C.GZlibDecompressorClass
}
