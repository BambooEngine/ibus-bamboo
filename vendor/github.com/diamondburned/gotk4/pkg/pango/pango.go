// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <pango/pango.h>
// extern void _gotk4_pango1_RendererClass_prepare_run(PangoRenderer*, PangoLayoutRun*);
// extern void _gotk4_pango1_RendererClass_part_changed(PangoRenderer*, PangoRenderPart);
// extern void _gotk4_pango1_RendererClass_end(PangoRenderer*);
// extern void _gotk4_pango1_RendererClass_draw_trapezoid(PangoRenderer*, PangoRenderPart, double, double, double, double, double, double);
// extern void _gotk4_pango1_RendererClass_draw_shape(PangoRenderer*, PangoAttrShape*, int, int);
// extern void _gotk4_pango1_RendererClass_draw_rectangle(PangoRenderer*, PangoRenderPart, int, int, int, int);
// extern void _gotk4_pango1_RendererClass_draw_glyphs(PangoRenderer*, PangoFont*, PangoGlyphString*, int, int);
// extern void _gotk4_pango1_RendererClass_draw_glyph_item(PangoRenderer*, char*, PangoGlyphItem*, int, int);
// extern void _gotk4_pango1_RendererClass_draw_glyph(PangoRenderer*, PangoFont*, PangoGlyph, double, double);
// extern void _gotk4_pango1_RendererClass_draw_error_underline(PangoRenderer*, int, int, int, int);
// extern void _gotk4_pango1_RendererClass_begin(PangoRenderer*);
// extern void _gotk4_pango1_FontMapClass_list_families(PangoFontMap*, PangoFontFamily***, int*);
// extern void _gotk4_pango1_FontMapClass_changed(PangoFontMap*);
// extern void _gotk4_pango1_FontFamilyClass_list_faces(PangoFontFamily*, PangoFontFace***, int*);
// extern void _gotk4_pango1_FontFaceClass_list_sizes(PangoFontFace*, int**, int*);
// extern void _gotk4_pango1_FontClass_get_glyph_extents(PangoFont*, PangoGlyph, PangoRectangle*, PangoRectangle*);
// extern guint _gotk4_pango1_FontMapClass_get_serial(PangoFontMap*);
// extern gboolean _gotk4_pango1_FontsetForEachFunc(PangoFontset*, PangoFont*, gpointer);
// extern gboolean _gotk4_pango1_FontFamilyClass_is_variable(PangoFontFamily*);
// extern gboolean _gotk4_pango1_FontFamilyClass_is_monospace(PangoFontFamily*);
// extern gboolean _gotk4_pango1_FontFaceClass_is_synthesized(PangoFontFace*);
// extern gboolean _gotk4_pango1_AttrFilterFunc(PangoAttribute*, gpointer);
// extern char* _gotk4_pango1_FontFamilyClass_get_name(PangoFontFamily*);
// extern char* _gotk4_pango1_FontFaceClass_get_face_name(PangoFontFace*);
// extern PangoLanguage* _gotk4_pango1_FontsetClass_get_language(PangoFontset*);
// extern PangoFontset* _gotk4_pango1_FontMapClass_load_fontset(PangoFontMap*, PangoContext*, PangoFontDescription*, PangoLanguage*);
// extern PangoFontMetrics* _gotk4_pango1_FontsetClass_get_metrics(PangoFontset*);
// extern PangoFontMetrics* _gotk4_pango1_FontClass_get_metrics(PangoFont*, PangoLanguage*);
// extern PangoFontMap* _gotk4_pango1_FontClass_get_font_map(PangoFont*);
// extern PangoFontFamily* _gotk4_pango1_FontMapClass_get_family(PangoFontMap*, char*);
// extern PangoFontFamily* _gotk4_pango1_FontFaceClass_get_family(PangoFontFace*);
// extern PangoFontFace* _gotk4_pango1_FontFamilyClass_get_face(PangoFontFamily*, char*);
// extern PangoFontDescription* _gotk4_pango1_FontFaceClass_describe(PangoFontFace*);
// extern PangoFontDescription* _gotk4_pango1_FontClass_describe_absolute(PangoFont*);
// extern PangoFontDescription* _gotk4_pango1_FontClass_describe(PangoFont*);
// extern PangoFont* _gotk4_pango1_FontsetClass_get_font(PangoFontset*, guint);
// extern PangoFont* _gotk4_pango1_FontMapClass_load_font(PangoFontMap*, PangoContext*, PangoFontDescription*);
// extern PangoCoverage* _gotk4_pango1_FontClass_get_coverage(PangoFont*, PangoLanguage*);
// PangoCoverage* _gotk4_pango1_Font_virtual_get_coverage(void* fnptr, PangoFont* arg0, PangoLanguage* arg1) {
//   return ((PangoCoverage* (*)(PangoFont*, PangoLanguage*))(fnptr))(arg0, arg1);
// };
// PangoFont* _gotk4_pango1_FontMap_virtual_load_font(void* fnptr, PangoFontMap* arg0, PangoContext* arg1, PangoFontDescription* arg2) {
//   return ((PangoFont* (*)(PangoFontMap*, PangoContext*, PangoFontDescription*))(fnptr))(arg0, arg1, arg2);
// };
// PangoFont* _gotk4_pango1_Fontset_virtual_get_font(void* fnptr, PangoFontset* arg0, guint arg1) {
//   return ((PangoFont* (*)(PangoFontset*, guint))(fnptr))(arg0, arg1);
// };
// PangoFontDescription* _gotk4_pango1_FontFace_virtual_describe(void* fnptr, PangoFontFace* arg0) {
//   return ((PangoFontDescription* (*)(PangoFontFace*))(fnptr))(arg0);
// };
// PangoFontDescription* _gotk4_pango1_Font_virtual_describe(void* fnptr, PangoFont* arg0) {
//   return ((PangoFontDescription* (*)(PangoFont*))(fnptr))(arg0);
// };
// PangoFontDescription* _gotk4_pango1_Font_virtual_describe_absolute(void* fnptr, PangoFont* arg0) {
//   return ((PangoFontDescription* (*)(PangoFont*))(fnptr))(arg0);
// };
// PangoFontFace* _gotk4_pango1_FontFamily_virtual_get_face(void* fnptr, PangoFontFamily* arg0, char* arg1) {
//   return ((PangoFontFace* (*)(PangoFontFamily*, char*))(fnptr))(arg0, arg1);
// };
// PangoFontFamily* _gotk4_pango1_FontFace_virtual_get_family(void* fnptr, PangoFontFace* arg0) {
//   return ((PangoFontFamily* (*)(PangoFontFace*))(fnptr))(arg0);
// };
// PangoFontFamily* _gotk4_pango1_FontMap_virtual_get_family(void* fnptr, PangoFontMap* arg0, char* arg1) {
//   return ((PangoFontFamily* (*)(PangoFontMap*, char*))(fnptr))(arg0, arg1);
// };
// PangoFontMap* _gotk4_pango1_Font_virtual_get_font_map(void* fnptr, PangoFont* arg0) {
//   return ((PangoFontMap* (*)(PangoFont*))(fnptr))(arg0);
// };
// PangoFontMetrics* _gotk4_pango1_Font_virtual_get_metrics(void* fnptr, PangoFont* arg0, PangoLanguage* arg1) {
//   return ((PangoFontMetrics* (*)(PangoFont*, PangoLanguage*))(fnptr))(arg0, arg1);
// };
// PangoFontMetrics* _gotk4_pango1_Fontset_virtual_get_metrics(void* fnptr, PangoFontset* arg0) {
//   return ((PangoFontMetrics* (*)(PangoFontset*))(fnptr))(arg0);
// };
// PangoFontset* _gotk4_pango1_FontMap_virtual_load_fontset(void* fnptr, PangoFontMap* arg0, PangoContext* arg1, PangoFontDescription* arg2, PangoLanguage* arg3) {
//   return ((PangoFontset* (*)(PangoFontMap*, PangoContext*, PangoFontDescription*, PangoLanguage*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// PangoLanguage* _gotk4_pango1_Fontset_virtual_get_language(void* fnptr, PangoFontset* arg0) {
//   return ((PangoLanguage* (*)(PangoFontset*))(fnptr))(arg0);
// };
// char* _gotk4_pango1_FontFace_virtual_get_face_name(void* fnptr, PangoFontFace* arg0) {
//   return ((char* (*)(PangoFontFace*))(fnptr))(arg0);
// };
// char* _gotk4_pango1_FontFamily_virtual_get_name(void* fnptr, PangoFontFamily* arg0) {
//   return ((char* (*)(PangoFontFamily*))(fnptr))(arg0);
// };
// gboolean _gotk4_pango1_FontFace_virtual_is_synthesized(void* fnptr, PangoFontFace* arg0) {
//   return ((gboolean (*)(PangoFontFace*))(fnptr))(arg0);
// };
// gboolean _gotk4_pango1_FontFamily_virtual_is_monospace(void* fnptr, PangoFontFamily* arg0) {
//   return ((gboolean (*)(PangoFontFamily*))(fnptr))(arg0);
// };
// gboolean _gotk4_pango1_FontFamily_virtual_is_variable(void* fnptr, PangoFontFamily* arg0) {
//   return ((gboolean (*)(PangoFontFamily*))(fnptr))(arg0);
// };
// guint _gotk4_pango1_FontMap_virtual_get_serial(void* fnptr, PangoFontMap* arg0) {
//   return ((guint (*)(PangoFontMap*))(fnptr))(arg0);
// };
// void _gotk4_pango1_FontFace_virtual_list_sizes(void* fnptr, PangoFontFace* arg0, int** arg1, int* arg2) {
//   ((void (*)(PangoFontFace*, int**, int*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_pango1_FontFamily_virtual_list_faces(void* fnptr, PangoFontFamily* arg0, PangoFontFace*** arg1, int* arg2) {
//   ((void (*)(PangoFontFamily*, PangoFontFace***, int*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_pango1_FontMap_virtual_changed(void* fnptr, PangoFontMap* arg0) {
//   ((void (*)(PangoFontMap*))(fnptr))(arg0);
// };
// void _gotk4_pango1_FontMap_virtual_list_families(void* fnptr, PangoFontMap* arg0, PangoFontFamily*** arg1, int* arg2) {
//   ((void (*)(PangoFontMap*, PangoFontFamily***, int*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_pango1_Font_virtual_get_glyph_extents(void* fnptr, PangoFont* arg0, PangoGlyph arg1, PangoRectangle* arg2, PangoRectangle* arg3) {
//   ((void (*)(PangoFont*, PangoGlyph, PangoRectangle*, PangoRectangle*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_pango1_Fontset_virtual_foreach(void* fnptr, PangoFontset* arg0, PangoFontsetForeachFunc arg1, gpointer arg2) {
//   ((void (*)(PangoFontset*, PangoFontsetForeachFunc, gpointer))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_pango1_Renderer_virtual_begin(void* fnptr, PangoRenderer* arg0) {
//   ((void (*)(PangoRenderer*))(fnptr))(arg0);
// };
// void _gotk4_pango1_Renderer_virtual_draw_error_underline(void* fnptr, PangoRenderer* arg0, int arg1, int arg2, int arg3, int arg4) {
//   ((void (*)(PangoRenderer*, int, int, int, int))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_pango1_Renderer_virtual_draw_glyph(void* fnptr, PangoRenderer* arg0, PangoFont* arg1, PangoGlyph arg2, double arg3, double arg4) {
//   ((void (*)(PangoRenderer*, PangoFont*, PangoGlyph, double, double))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_pango1_Renderer_virtual_draw_glyph_item(void* fnptr, PangoRenderer* arg0, char* arg1, PangoGlyphItem* arg2, int arg3, int arg4) {
//   ((void (*)(PangoRenderer*, char*, PangoGlyphItem*, int, int))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_pango1_Renderer_virtual_draw_glyphs(void* fnptr, PangoRenderer* arg0, PangoFont* arg1, PangoGlyphString* arg2, int arg3, int arg4) {
//   ((void (*)(PangoRenderer*, PangoFont*, PangoGlyphString*, int, int))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_pango1_Renderer_virtual_draw_rectangle(void* fnptr, PangoRenderer* arg0, PangoRenderPart arg1, int arg2, int arg3, int arg4, int arg5) {
//   ((void (*)(PangoRenderer*, PangoRenderPart, int, int, int, int))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_pango1_Renderer_virtual_draw_shape(void* fnptr, PangoRenderer* arg0, PangoAttrShape* arg1, int arg2, int arg3) {
//   ((void (*)(PangoRenderer*, PangoAttrShape*, int, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_pango1_Renderer_virtual_draw_trapezoid(void* fnptr, PangoRenderer* arg0, PangoRenderPart arg1, double arg2, double arg3, double arg4, double arg5, double arg6, double arg7) {
//   ((void (*)(PangoRenderer*, PangoRenderPart, double, double, double, double, double, double))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
// };
// void _gotk4_pango1_Renderer_virtual_end(void* fnptr, PangoRenderer* arg0) {
//   ((void (*)(PangoRenderer*))(fnptr))(arg0);
// };
// void _gotk4_pango1_Renderer_virtual_part_changed(void* fnptr, PangoRenderer* arg0, PangoRenderPart arg1) {
//   ((void (*)(PangoRenderer*, PangoRenderPart))(fnptr))(arg0, arg1);
// };
// void _gotk4_pango1_Renderer_virtual_prepare_run(void* fnptr, PangoRenderer* arg0, PangoLayoutRun* arg1) {
//   ((void (*)(PangoRenderer*, PangoLayoutRun*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeAlignment              = coreglib.Type(C.pango_alignment_get_type())
	GTypeAttrType               = coreglib.Type(C.pango_attr_type_get_type())
	GTypeBaselineShift          = coreglib.Type(C.pango_baseline_shift_get_type())
	GTypeBidiType               = coreglib.Type(C.pango_bidi_type_get_type())
	GTypeCoverageLevel          = coreglib.Type(C.pango_coverage_level_get_type())
	GTypeDirection              = coreglib.Type(C.pango_direction_get_type())
	GTypeEllipsizeMode          = coreglib.Type(C.pango_ellipsize_mode_get_type())
	GTypeFontScale              = coreglib.Type(C.pango_font_scale_get_type())
	GTypeGravity                = coreglib.Type(C.pango_gravity_get_type())
	GTypeGravityHint            = coreglib.Type(C.pango_gravity_hint_get_type())
	GTypeLayoutDeserializeError = coreglib.Type(C.pango_layout_deserialize_error_get_type())
	GTypeOverline               = coreglib.Type(C.pango_overline_get_type())
	GTypeRenderPart             = coreglib.Type(C.pango_render_part_get_type())
	GTypeScript                 = coreglib.Type(C.pango_script_get_type())
	GTypeStretch                = coreglib.Type(C.pango_stretch_get_type())
	GTypeStyle                  = coreglib.Type(C.pango_style_get_type())
	GTypeTabAlign               = coreglib.Type(C.pango_tab_align_get_type())
	GTypeTextTransform          = coreglib.Type(C.pango_text_transform_get_type())
	GTypeUnderline              = coreglib.Type(C.pango_underline_get_type())
	GTypeVariant                = coreglib.Type(C.pango_variant_get_type())
	GTypeWeight                 = coreglib.Type(C.pango_weight_get_type())
	GTypeWrapMode               = coreglib.Type(C.pango_wrap_mode_get_type())
	GTypeFontMask               = coreglib.Type(C.pango_font_mask_get_type())
	GTypeLayoutDeserializeFlags = coreglib.Type(C.pango_layout_deserialize_flags_get_type())
	GTypeLayoutSerializeFlags   = coreglib.Type(C.pango_layout_serialize_flags_get_type())
	GTypeShapeFlags             = coreglib.Type(C.pango_shape_flags_get_type())
	GTypeShowFlags              = coreglib.Type(C.pango_show_flags_get_type())
	GTypeContext                = coreglib.Type(C.pango_context_get_type())
	GTypeCoverage               = coreglib.Type(C.pango_coverage_get_type())
	GTypeFont                   = coreglib.Type(C.pango_font_get_type())
	GTypeFontFace               = coreglib.Type(C.pango_font_face_get_type())
	GTypeFontFamily             = coreglib.Type(C.pango_font_family_get_type())
	GTypeFontMap                = coreglib.Type(C.pango_font_map_get_type())
	GTypeFontset                = coreglib.Type(C.pango_fontset_get_type())
	GTypeFontsetSimple          = coreglib.Type(C.pango_fontset_simple_get_type())
	GTypeLayout                 = coreglib.Type(C.pango_layout_get_type())
	GTypeRenderer               = coreglib.Type(C.pango_renderer_get_type())
	GTypeAttrIterator           = coreglib.Type(C.pango_attr_iterator_get_type())
	GTypeAttrList               = coreglib.Type(C.pango_attr_list_get_type())
	GTypeAttribute              = coreglib.Type(C.pango_attribute_get_type())
	GTypeColor                  = coreglib.Type(C.pango_color_get_type())
	GTypeFontDescription        = coreglib.Type(C.pango_font_description_get_type())
	GTypeFontMetrics            = coreglib.Type(C.pango_font_metrics_get_type())
	GTypeGlyphItem              = coreglib.Type(C.pango_glyph_item_get_type())
	GTypeGlyphItemIter          = coreglib.Type(C.pango_glyph_item_iter_get_type())
	GTypeGlyphString            = coreglib.Type(C.pango_glyph_string_get_type())
	GTypeItem                   = coreglib.Type(C.pango_item_get_type())
	GTypeLanguage               = coreglib.Type(C.pango_language_get_type())
	GTypeLayoutIter             = coreglib.Type(C.pango_layout_iter_get_type())
	GTypeLayoutLine             = coreglib.Type(C.pango_layout_line_get_type())
	GTypeMatrix                 = coreglib.Type(C.pango_matrix_get_type())
	GTypeScriptIter             = coreglib.Type(C.pango_script_iter_get_type())
	GTypeTabArray               = coreglib.Type(C.pango_tab_array_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAlignment, F: marshalAlignment},
		coreglib.TypeMarshaler{T: GTypeAttrType, F: marshalAttrType},
		coreglib.TypeMarshaler{T: GTypeBaselineShift, F: marshalBaselineShift},
		coreglib.TypeMarshaler{T: GTypeBidiType, F: marshalBidiType},
		coreglib.TypeMarshaler{T: GTypeCoverageLevel, F: marshalCoverageLevel},
		coreglib.TypeMarshaler{T: GTypeDirection, F: marshalDirection},
		coreglib.TypeMarshaler{T: GTypeEllipsizeMode, F: marshalEllipsizeMode},
		coreglib.TypeMarshaler{T: GTypeFontScale, F: marshalFontScale},
		coreglib.TypeMarshaler{T: GTypeGravity, F: marshalGravity},
		coreglib.TypeMarshaler{T: GTypeGravityHint, F: marshalGravityHint},
		coreglib.TypeMarshaler{T: GTypeLayoutDeserializeError, F: marshalLayoutDeserializeError},
		coreglib.TypeMarshaler{T: GTypeOverline, F: marshalOverline},
		coreglib.TypeMarshaler{T: GTypeRenderPart, F: marshalRenderPart},
		coreglib.TypeMarshaler{T: GTypeScript, F: marshalScript},
		coreglib.TypeMarshaler{T: GTypeStretch, F: marshalStretch},
		coreglib.TypeMarshaler{T: GTypeStyle, F: marshalStyle},
		coreglib.TypeMarshaler{T: GTypeTabAlign, F: marshalTabAlign},
		coreglib.TypeMarshaler{T: GTypeTextTransform, F: marshalTextTransform},
		coreglib.TypeMarshaler{T: GTypeUnderline, F: marshalUnderline},
		coreglib.TypeMarshaler{T: GTypeVariant, F: marshalVariant},
		coreglib.TypeMarshaler{T: GTypeWeight, F: marshalWeight},
		coreglib.TypeMarshaler{T: GTypeWrapMode, F: marshalWrapMode},
		coreglib.TypeMarshaler{T: GTypeFontMask, F: marshalFontMask},
		coreglib.TypeMarshaler{T: GTypeLayoutDeserializeFlags, F: marshalLayoutDeserializeFlags},
		coreglib.TypeMarshaler{T: GTypeLayoutSerializeFlags, F: marshalLayoutSerializeFlags},
		coreglib.TypeMarshaler{T: GTypeShapeFlags, F: marshalShapeFlags},
		coreglib.TypeMarshaler{T: GTypeShowFlags, F: marshalShowFlags},
		coreglib.TypeMarshaler{T: GTypeContext, F: marshalContext},
		coreglib.TypeMarshaler{T: GTypeCoverage, F: marshalCoverage},
		coreglib.TypeMarshaler{T: GTypeFont, F: marshalFont},
		coreglib.TypeMarshaler{T: GTypeFontFace, F: marshalFontFace},
		coreglib.TypeMarshaler{T: GTypeFontFamily, F: marshalFontFamily},
		coreglib.TypeMarshaler{T: GTypeFontMap, F: marshalFontMap},
		coreglib.TypeMarshaler{T: GTypeFontset, F: marshalFontset},
		coreglib.TypeMarshaler{T: GTypeFontsetSimple, F: marshalFontsetSimple},
		coreglib.TypeMarshaler{T: GTypeLayout, F: marshalLayout},
		coreglib.TypeMarshaler{T: GTypeRenderer, F: marshalRenderer},
		coreglib.TypeMarshaler{T: GTypeAttrIterator, F: marshalAttrIterator},
		coreglib.TypeMarshaler{T: GTypeAttrList, F: marshalAttrList},
		coreglib.TypeMarshaler{T: GTypeAttribute, F: marshalAttribute},
		coreglib.TypeMarshaler{T: GTypeColor, F: marshalColor},
		coreglib.TypeMarshaler{T: GTypeFontDescription, F: marshalFontDescription},
		coreglib.TypeMarshaler{T: GTypeFontMetrics, F: marshalFontMetrics},
		coreglib.TypeMarshaler{T: GTypeGlyphItem, F: marshalGlyphItem},
		coreglib.TypeMarshaler{T: GTypeGlyphItemIter, F: marshalGlyphItemIter},
		coreglib.TypeMarshaler{T: GTypeGlyphString, F: marshalGlyphString},
		coreglib.TypeMarshaler{T: GTypeItem, F: marshalItem},
		coreglib.TypeMarshaler{T: GTypeLanguage, F: marshalLanguage},
		coreglib.TypeMarshaler{T: GTypeLayoutIter, F: marshalLayoutIter},
		coreglib.TypeMarshaler{T: GTypeLayoutLine, F: marshalLayoutLine},
		coreglib.TypeMarshaler{T: GTypeMatrix, F: marshalMatrix},
		coreglib.TypeMarshaler{T: GTypeScriptIter, F: marshalScriptIter},
		coreglib.TypeMarshaler{T: GTypeTabArray, F: marshalTabArray},
	})
}

// ANALYSIS_FLAG_CENTERED_BASELINE: whether the segment should be shifted to
// center around the baseline.
//
// This is mainly used in vertical writing directions.
const ANALYSIS_FLAG_CENTERED_BASELINE = 1

// ANALYSIS_FLAG_IS_ELLIPSIS: whether this run holds ellipsized text.
const ANALYSIS_FLAG_IS_ELLIPSIS = 2

// ANALYSIS_FLAG_NEED_HYPHEN: whether to add a hyphen at the end of the run
// during shaping.
const ANALYSIS_FLAG_NEED_HYPHEN = 4

// ATTR_INDEX_FROM_TEXT_BEGINNING: value for start_index in PangoAttribute that
// indicates the beginning of the text.
const ATTR_INDEX_FROM_TEXT_BEGINNING = 0

// ATTR_INDEX_TO_TEXT_END: value for end_index in PangoAttribute that indicates
// the end of the text.
const ATTR_INDEX_TO_TEXT_END = 4294967295

// SCALE: scale between dimensions used for Pango distances and device units.
//
// The definition of device units is dependent on the output device; it will
// typically be pixels for a screen, and points for a printer. PANGO_SCALE is
// currently 1024, but this may be changed in the future.
//
// When setting font sizes, device units are always considered to be points (as
// in "12 point font"), rather than pixels.
const SCALE = 1024

// VERSION_MAJOR: major component of the version of Pango available at
// compile-time.
const VERSION_MAJOR = 1

// VERSION_MICRO: micro component of the version of Pango available at
// compile-time.
const VERSION_MICRO = 2

// VERSION_MINOR: minor component of the version of Pango available at
// compile-time.
const VERSION_MINOR = 52

// VERSION_STRING: string literal containing the version of Pango available at
// compile-time.
const VERSION_STRING = "1.52.2"

// Glyph: PangoGlyph represents a single glyph in the output form of a string.
type Glyph = uint32

// GlyphUnit: PangoGlyphUnit type is used to store dimensions within Pango.
//
// Dimensions are stored in 1/PANGO_SCALE of a device unit. (A device unit
// might be a pixel for screen display, or a point on a printer.) PANGO_SCALE
// is currently 1024, and may change in the future (unlikely though), but you
// should not depend on its exact value.
//
// The PANGO_PIXELS() macro can be used to convert from glyph units into device
// units with correct rounding.
type GlyphUnit = int32

// LayoutRun: PangoLayoutRun represents a single run within a PangoLayoutLine.
//
// It is simply an alternate name for pango.GlyphItem. See the pango.GlyphItem
// docs for details on the fields.
type LayoutRun = GlyphItem

// Alignment: PangoAlignment describes how to align the lines of a PangoLayout
// within the available space.
//
// If the PangoLayout is set to justify using pango.Layout.SetJustify(),
// this only affects partial lines.
//
// See pango.Layout.SetAutoDir() for how text direction affects the
// interpretation of PangoAlignment values.
type Alignment C.gint

const (
	// AlignLeft: put all available space on the right.
	AlignLeft Alignment = iota
	// AlignCenter: center the line within the available space.
	AlignCenter
	// AlignRight: put all available space on the left.
	AlignRight
)

func marshalAlignment(p uintptr) (interface{}, error) {
	return Alignment(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Alignment.
func (a Alignment) String() string {
	switch a {
	case AlignLeft:
		return "Left"
	case AlignCenter:
		return "Center"
	case AlignRight:
		return "Right"
	default:
		return fmt.Sprintf("Alignment(%d)", a)
	}
}

// AttrType: PangoAttrType distinguishes between different types of attributes.
//
// Along with the predefined values, it is possible to allocate additional
// values for custom attributes using attrtype.Register(). The predefined values
// are given below. The type of structure used to store the attribute is listed
// in parentheses after the description.
type AttrType C.gint

const (
	// AttrTypeInvalid does not happen.
	AttrTypeInvalid AttrType = iota
	// AttrTypeLanguage: language (pango.AttrLanguage).
	AttrTypeLanguage
	// AttrTypeFamily: font family name list (pango.AttrString).
	AttrTypeFamily
	// AttrTypeStyle: font slant style (pango.AttrInt).
	AttrTypeStyle
	// AttrTypeWeight: font weight (pango.AttrInt).
	AttrTypeWeight
	// AttrTypeVariant: font variant (normal or small caps) (pango.AttrInt).
	AttrTypeVariant
	// AttrTypeStretch: font stretch (pango.AttrInt).
	AttrTypeStretch
	// AttrTypeSize: font size in points scaled by PANGO_SCALE (pango.AttrInt).
	AttrTypeSize
	// AttrTypeFontDesc: font description (pango.AttrFontDesc).
	AttrTypeFontDesc
	// AttrTypeForeground: foreground color (pango.AttrColor).
	AttrTypeForeground
	// AttrTypeBackground: background color (pango.AttrColor).
	AttrTypeBackground
	// AttrTypeUnderline: whether the text has an underline (pango.AttrInt).
	AttrTypeUnderline
	// AttrTypeStrikethrough: whether the text is struck-through
	// (pango.AttrInt).
	AttrTypeStrikethrough
	// AttrTypeRise: baseline displacement (pango.AttrInt).
	AttrTypeRise
	// AttrTypeShape: shape (pango.AttrShape).
	AttrTypeShape
	// AttrTypeScale: font size scale factor (pango.AttrFloat).
	AttrTypeScale
	// AttrTypeFallback: whether fallback is enabled (pango.AttrInt).
	AttrTypeFallback
	// AttrTypeLetterSpacing: letter spacing (pangoattrint).
	AttrTypeLetterSpacing
	// AttrTypeUnderlineColor: underline color (pango.AttrColor).
	AttrTypeUnderlineColor
	// AttrTypeStrikethroughColor: strikethrough color (pango.AttrColor).
	AttrTypeStrikethroughColor
	// AttrTypeAbsoluteSize: font size in pixels scaled by PANGO_SCALE
	// (pango.AttrInt).
	AttrTypeAbsoluteSize
	// AttrTypeGravity: base text gravity (pango.AttrInt).
	AttrTypeGravity
	// AttrTypeGravityHint: gravity hint (pango.AttrInt).
	AttrTypeGravityHint
	// AttrTypeFontFeatures: openType font features (pango.AttrFontFeatures).
	// Since 1.38.
	AttrTypeFontFeatures
	// AttrTypeForegroundAlpha: foreground alpha (pango.AttrInt). Since 1.38.
	AttrTypeForegroundAlpha
	// AttrTypeBackgroundAlpha: background alpha (pango.AttrInt). Since 1.38.
	AttrTypeBackgroundAlpha
	// AttrTypeAllowBreaks: whether breaks are allowed (pango.AttrInt). Since
	// 1.44.
	AttrTypeAllowBreaks
	// AttrTypeShow: how to render invisible characters (pango.AttrInt).
	// Since 1.44.
	AttrTypeShow
	// AttrTypeInsertHyphens: whether to insert hyphens at intra-word line
	// breaks (pango.AttrInt). Since 1.44.
	AttrTypeInsertHyphens
	// AttrTypeOverline: whether the text has an overline (pango.AttrInt).
	// Since 1.46.
	AttrTypeOverline
	// AttrTypeOverlineColor: overline color (pango.AttrColor). Since 1.46.
	AttrTypeOverlineColor
	// AttrTypeLineHeight: line height factor (pango.AttrFloat). Since: 1.50.
	AttrTypeLineHeight
	// AttrTypeAbsoluteLineHeight: line height (pango.AttrInt). Since: 1.50.
	AttrTypeAbsoluteLineHeight
	AttrTypeTextTransform
	// AttrTypeWord: override segmentation to classify the range of the
	// attribute as a single word (pango.AttrInt). Since 1.50.
	AttrTypeWord
	// AttrTypeSentence: override segmentation to classify the range of the
	// attribute as a single sentence (pango.AttrInt). Since 1.50.
	AttrTypeSentence
	// AttrTypeBaselineShift: baseline displacement (pango.AttrInt). Since 1.50.
	AttrTypeBaselineShift
	// AttrTypeFontScale: font-relative size change (pango.AttrInt). Since 1.50.
	AttrTypeFontScale
)

func marshalAttrType(p uintptr) (interface{}, error) {
	return AttrType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AttrType.
func (a AttrType) String() string {
	switch a {
	case AttrTypeInvalid:
		return "Invalid"
	case AttrTypeLanguage:
		return "Language"
	case AttrTypeFamily:
		return "Family"
	case AttrTypeStyle:
		return "Style"
	case AttrTypeWeight:
		return "Weight"
	case AttrTypeVariant:
		return "Variant"
	case AttrTypeStretch:
		return "Stretch"
	case AttrTypeSize:
		return "Size"
	case AttrTypeFontDesc:
		return "FontDesc"
	case AttrTypeForeground:
		return "Foreground"
	case AttrTypeBackground:
		return "Background"
	case AttrTypeUnderline:
		return "Underline"
	case AttrTypeStrikethrough:
		return "Strikethrough"
	case AttrTypeRise:
		return "Rise"
	case AttrTypeShape:
		return "Shape"
	case AttrTypeScale:
		return "Scale"
	case AttrTypeFallback:
		return "Fallback"
	case AttrTypeLetterSpacing:
		return "LetterSpacing"
	case AttrTypeUnderlineColor:
		return "UnderlineColor"
	case AttrTypeStrikethroughColor:
		return "StrikethroughColor"
	case AttrTypeAbsoluteSize:
		return "AbsoluteSize"
	case AttrTypeGravity:
		return "Gravity"
	case AttrTypeGravityHint:
		return "GravityHint"
	case AttrTypeFontFeatures:
		return "FontFeatures"
	case AttrTypeForegroundAlpha:
		return "ForegroundAlpha"
	case AttrTypeBackgroundAlpha:
		return "BackgroundAlpha"
	case AttrTypeAllowBreaks:
		return "AllowBreaks"
	case AttrTypeShow:
		return "Show"
	case AttrTypeInsertHyphens:
		return "InsertHyphens"
	case AttrTypeOverline:
		return "Overline"
	case AttrTypeOverlineColor:
		return "OverlineColor"
	case AttrTypeLineHeight:
		return "LineHeight"
	case AttrTypeAbsoluteLineHeight:
		return "AbsoluteLineHeight"
	case AttrTypeTextTransform:
		return "TextTransform"
	case AttrTypeWord:
		return "Word"
	case AttrTypeSentence:
		return "Sentence"
	case AttrTypeBaselineShift:
		return "BaselineShift"
	case AttrTypeFontScale:
		return "FontScale"
	default:
		return fmt.Sprintf("AttrType(%d)", a)
	}
}

// AttrTypeGetName fetches the attribute type name.
//
// The attribute type name is the string passed in when registering the type
// using pango.AttrType().Register.
//
// The returned value is an interned string (see g_intern_string() for what that
// means) that should not be modified or freed.
//
// The function takes the following parameters:
//
//   - typ: attribute type ID to fetch the name for.
//
// The function returns the following values:
//
//   - utf8 (optional): type ID name (which may be NULL), or NULL if type is a
//     built-in Pango attribute type or invalid.
func AttrTypeGetName(typ AttrType) string {
	var _arg1 C.PangoAttrType // out
	var _cret *C.char         // in

	_arg1 = C.PangoAttrType(typ)

	_cret = C.pango_attr_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// AttrTypeRegister: allocate a new attribute type ID.
//
// The attribute type name can be accessed later by using
// pango.AttrType().GetName.
//
// The function takes the following parameters:
//
//   - name: identifier for the type.
//
// The function returns the following values:
//
//   - attrType: new type ID.
func AttrTypeRegister(name string) AttrType {
	var _arg1 *C.char         // out
	var _cret C.PangoAttrType // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_attr_type_register(_arg1)
	runtime.KeepAlive(name)

	var _attrType AttrType // out

	_attrType = AttrType(_cret)

	return _attrType
}

// BaselineShift: enumeration that affects baseline shifts between runs.
type BaselineShift C.gint

const (
	// BaselineShiftNone: leave the baseline unchanged.
	BaselineShiftNone BaselineShift = iota
	// BaselineShiftSuperscript: shift the baseline to the superscript position,
	// relative to the previous run.
	BaselineShiftSuperscript
	// BaselineShiftSubscript: shift the baseline to the subscript position,
	// relative to the previous run.
	BaselineShiftSubscript
)

func marshalBaselineShift(p uintptr) (interface{}, error) {
	return BaselineShift(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BaselineShift.
func (b BaselineShift) String() string {
	switch b {
	case BaselineShiftNone:
		return "None"
	case BaselineShiftSuperscript:
		return "Superscript"
	case BaselineShiftSubscript:
		return "Subscript"
	default:
		return fmt.Sprintf("BaselineShift(%d)", b)
	}
}

// BidiType: PangoBidiType represents the bidirectional character type of a
// Unicode character.
//
// The values in this enumeration are specified by the Unicode bidirectional
// algorithm (http://www.unicode.org/reports/tr9/).
//
// Deprecated: Use fribidi for this information.
type BidiType C.gint

const (
	// BidiTypeL: left-to-Right.
	BidiTypeL BidiType = iota
	// BidiTypeLre: left-to-Right Embedding.
	BidiTypeLre
	// BidiTypeLro: left-to-Right Override.
	BidiTypeLro
	// BidiTypeR: right-to-Left.
	BidiTypeR
	// BidiTypeAl: right-to-Left Arabic.
	BidiTypeAl
	// BidiTypeRLE: right-to-Left Embedding.
	BidiTypeRLE
	// BidiTypeRlo: right-to-Left Override.
	BidiTypeRlo
	// BidiTypePDF: pop Directional Format.
	BidiTypePDF
	// BidiTypeEn: european Number.
	BidiTypeEn
	// BidiTypeES: european Number Separator.
	BidiTypeES
	// BidiTypeEt: european Number Terminator.
	BidiTypeEt
	// BidiTypeAn: arabic Number.
	BidiTypeAn
	// BidiTypeCs: common Number Separator.
	BidiTypeCs
	// BidiTypeNsm: nonspacing Mark.
	BidiTypeNsm
	// BidiTypeBn: boundary Neutral.
	BidiTypeBn
	// BidiTypeB: paragraph Separator.
	BidiTypeB
	// BidiTypeS: segment Separator.
	BidiTypeS
	// BidiTypeWs: whitespace.
	BidiTypeWs
	// BidiTypeOn: other Neutrals.
	BidiTypeOn
	// BidiTypeLri: left-to-Right isolate. Since 1.48.6.
	BidiTypeLri
	// BidiTypeRli: right-to-Left isolate. Since 1.48.6.
	BidiTypeRli
	// BidiTypeFsi: first strong isolate. Since 1.48.6.
	BidiTypeFsi
	// BidiTypePdi: pop directional isolate. Since 1.48.6.
	BidiTypePdi
)

func marshalBidiType(p uintptr) (interface{}, error) {
	return BidiType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BidiType.
func (b BidiType) String() string {
	switch b {
	case BidiTypeL:
		return "L"
	case BidiTypeLre:
		return "Lre"
	case BidiTypeLro:
		return "Lro"
	case BidiTypeR:
		return "R"
	case BidiTypeAl:
		return "Al"
	case BidiTypeRLE:
		return "RLE"
	case BidiTypeRlo:
		return "Rlo"
	case BidiTypePDF:
		return "PDF"
	case BidiTypeEn:
		return "En"
	case BidiTypeES:
		return "ES"
	case BidiTypeEt:
		return "Et"
	case BidiTypeAn:
		return "An"
	case BidiTypeCs:
		return "Cs"
	case BidiTypeNsm:
		return "Nsm"
	case BidiTypeBn:
		return "Bn"
	case BidiTypeB:
		return "B"
	case BidiTypeS:
		return "S"
	case BidiTypeWs:
		return "Ws"
	case BidiTypeOn:
		return "On"
	case BidiTypeLri:
		return "Lri"
	case BidiTypeRli:
		return "Rli"
	case BidiTypeFsi:
		return "Fsi"
	case BidiTypePdi:
		return "Pdi"
	default:
		return fmt.Sprintf("BidiType(%d)", b)
	}
}

// BidiTypeForUnichar determines the bidirectional type of a character.
//
// The bidirectional type is specified in the Unicode Character Database.
//
// A simplified version of this function is available as unichar_direction.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - bidiType: bidirectional character type, as used in the Unicode
//     bidirectional algorithm.
func BidiTypeForUnichar(ch uint32) BidiType {
	var _arg1 C.gunichar      // out
	var _cret C.PangoBidiType // in

	_arg1 = C.gunichar(ch)

	_cret = C.pango_bidi_type_for_unichar(_arg1)
	runtime.KeepAlive(ch)

	var _bidiType BidiType // out

	_bidiType = BidiType(_cret)

	return _bidiType
}

// CoverageLevel: PangoCoverageLevel is used to indicate how well a font can
// represent a particular Unicode character for a particular script.
//
// Since 1.44, only PANGO_COVERAGE_NONE and PANGO_COVERAGE_EXACT will be
// returned.
type CoverageLevel C.gint

const (
	// CoverageNone: character is not representable with the font.
	CoverageNone CoverageLevel = iota
	// CoverageFallback: character is represented in a way that may be
	// comprehensible but is not the correct graphical form. For instance,
	// a Hangul character represented as a a sequence of Jamos, or a Latin
	// transliteration of a Cyrillic word.
	CoverageFallback
	// CoverageApproximate: character is represented as basically the correct
	// graphical form, but with a stylistic variant inappropriate for the
	// current script.
	CoverageApproximate
	// CoverageExact: character is represented as the correct graphical form.
	CoverageExact
)

func marshalCoverageLevel(p uintptr) (interface{}, error) {
	return CoverageLevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CoverageLevel.
func (c CoverageLevel) String() string {
	switch c {
	case CoverageNone:
		return "None"
	case CoverageFallback:
		return "Fallback"
	case CoverageApproximate:
		return "Approximate"
	case CoverageExact:
		return "Exact"
	default:
		return fmt.Sprintf("CoverageLevel(%d)", c)
	}
}

// Direction: PangoDirection represents a direction in the Unicode bidirectional
// algorithm.
//
// Not every value in this enumeration makes sense for every usage of
// PangoDirection; for example, the return value of unichar_direction and
// find_base_dir cannot be PANGO_DIRECTION_WEAK_LTR or PANGO_DIRECTION_WEAK_RTL,
// since every character is either neutral or has a strong direction;
// on the other hand PANGO_DIRECTION_NEUTRAL doesn't make sense to pass to
// itemize_with_base_dir.
//
// The PANGO_DIRECTION_TTB_LTR, PANGO_DIRECTION_TTB_RTL values come from an
// earlier interpretation of this enumeration as the writing direction of a
// block of text and are no longer used. See PangoGravity for how vertical text
// is handled in Pango.
//
// If you are interested in text direction, you should really use fribidi
// directly. PangoDirection is only retained because it is used in some public
// apis.
type Direction C.gint

const (
	// DirectionLTR: strong left-to-right direction.
	DirectionLTR Direction = iota
	// DirectionRTL: strong right-to-left direction.
	DirectionRTL
	// DirectionTtbLTR: deprecated value; treated the same as
	// PANGO_DIRECTION_RTL.
	DirectionTtbLTR
	// DirectionTtbRTL: deprecated value; treated the same as
	// PANGO_DIRECTION_LTR.
	DirectionTtbRTL
	// DirectionWeakLTR: weak left-to-right direction.
	DirectionWeakLTR
	// DirectionWeakRTL: weak right-to-left direction.
	DirectionWeakRTL
	// DirectionNeutral: no direction specified.
	DirectionNeutral
)

func marshalDirection(p uintptr) (interface{}, error) {
	return Direction(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Direction.
func (d Direction) String() string {
	switch d {
	case DirectionLTR:
		return "LTR"
	case DirectionRTL:
		return "RTL"
	case DirectionTtbLTR:
		return "TtbLTR"
	case DirectionTtbRTL:
		return "TtbRTL"
	case DirectionWeakLTR:
		return "WeakLTR"
	case DirectionWeakRTL:
		return "WeakRTL"
	case DirectionNeutral:
		return "Neutral"
	default:
		return fmt.Sprintf("Direction(%d)", d)
	}
}

// EllipsizeMode: PangoEllipsizeMode describes what sort of ellipsization should
// be applied to text.
//
// In the ellipsization process characters are removed from the text in order to
// make it fit to a given width and replaced with an ellipsis.
type EllipsizeMode C.gint

const (
	// EllipsizeNone: no ellipsization.
	EllipsizeNone EllipsizeMode = iota
	// EllipsizeStart: omit characters at the start of the text.
	EllipsizeStart
	// EllipsizeMiddle: omit characters in the middle of the text.
	EllipsizeMiddle
	// EllipsizeEnd: omit characters at the end of the text.
	EllipsizeEnd
)

func marshalEllipsizeMode(p uintptr) (interface{}, error) {
	return EllipsizeMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EllipsizeMode.
func (e EllipsizeMode) String() string {
	switch e {
	case EllipsizeNone:
		return "None"
	case EllipsizeStart:
		return "Start"
	case EllipsizeMiddle:
		return "Middle"
	case EllipsizeEnd:
		return "End"
	default:
		return fmt.Sprintf("EllipsizeMode(%d)", e)
	}
}

// FontScale: enumeration that affects font sizes for superscript and subscript
// positioning and for (emulated) Small Caps.
type FontScale C.gint

const (
	// FontScaleNone: leave the font size unchanged.
	FontScaleNone FontScale = iota
	// FontScaleSuperscript: change the font to a size suitable for
	// superscripts.
	FontScaleSuperscript
	// FontScaleSubscript: change the font to a size suitable for subscripts.
	FontScaleSubscript
	// FontScaleSmallCaps: change the font to a size suitable for Small Caps.
	FontScaleSmallCaps
)

func marshalFontScale(p uintptr) (interface{}, error) {
	return FontScale(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FontScale.
func (f FontScale) String() string {
	switch f {
	case FontScaleNone:
		return "None"
	case FontScaleSuperscript:
		return "Superscript"
	case FontScaleSubscript:
		return "Subscript"
	case FontScaleSmallCaps:
		return "SmallCaps"
	default:
		return fmt.Sprintf("FontScale(%d)", f)
	}
}

// Gravity: PangoGravity represents the orientation of glyphs in a segment of
// text.
//
// This is useful when rendering vertical text layouts. In those situations,
// the layout is rotated using a non-identity pango.Matrix, and then glyph
// orientation is controlled using PangoGravity.
//
// Not every value in this enumeration makes sense for every usage of
// PangoGravity; for example, PANGO_GRAVITY_AUTO only can be passed
// to pango.Context.SetBaseGravity() and can only be returned by
// pango.Context.GetBaseGravity().
//
// See also: pango.GravityHint.
type Gravity C.gint

const (
	// GravitySouth glyphs stand upright (default) <img align="right"
	// valign="center" src="m-south.png">.
	GravitySouth Gravity = iota
	// GravityEast glyphs are rotated 90 degrees counter-clockwise. <img
	// align="right" valign="center" src="m-east.png">.
	GravityEast
	// GravityNorth glyphs are upside-down. <img align="right" valign="cener"
	// src="m-north.png">.
	GravityNorth
	// GravityWest glyphs are rotated 90 degrees clockwise. <img align="right"
	// valign="center" src="m-west.png">.
	GravityWest
	// GravityAuto: gravity is resolved from the context matrix.
	GravityAuto
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Gravity.
func (g Gravity) String() string {
	switch g {
	case GravitySouth:
		return "South"
	case GravityEast:
		return "East"
	case GravityNorth:
		return "North"
	case GravityWest:
		return "West"
	case GravityAuto:
		return "Auto"
	default:
		return fmt.Sprintf("Gravity(%d)", g)
	}
}

// GravityGetForMatrix finds the gravity that best matches the rotation
// component in a PangoMatrix.
//
// The function takes the following parameters:
//
//   - matrix (optional): PangoMatrix.
//
// The function returns the following values:
//
//   - gravity of matrix, which will never be PANGO_GRAVITY_AUTO, or
//     PANGO_GRAVITY_SOUTH if matrix is NULL.
func GravityGetForMatrix(matrix *Matrix) Gravity {
	var _arg1 *C.PangoMatrix // out
	var _cret C.PangoGravity // in

	if matrix != nil {
		_arg1 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	_cret = C.pango_gravity_get_for_matrix(_arg1)
	runtime.KeepAlive(matrix)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// GravityGetForScript returns the gravity to use in laying out a PangoItem.
//
// The gravity is determined based on the script, base gravity, and hint.
//
// If base_gravity is PANGO_GRAVITY_AUTO, it is first replaced with the
// preferred gravity of script. To get the preferred gravity of a script,
// pass PANGO_GRAVITY_AUTO and PANGO_GRAVITY_HINT_STRONG in.
//
// The function takes the following parameters:
//
//   - script: PangoScript to query.
//   - baseGravity: base gravity of the paragraph.
//   - hint: orientation hint.
//
// The function returns the following values:
//
//   - gravity: resolved gravity suitable to use for a run of text with script.
func GravityGetForScript(script Script, baseGravity Gravity, hint GravityHint) Gravity {
	var _arg1 C.PangoScript      // out
	var _arg2 C.PangoGravity     // out
	var _arg3 C.PangoGravityHint // out
	var _cret C.PangoGravity     // in

	_arg1 = C.PangoScript(script)
	_arg2 = C.PangoGravity(baseGravity)
	_arg3 = C.PangoGravityHint(hint)

	_cret = C.pango_gravity_get_for_script(_arg1, _arg2, _arg3)
	runtime.KeepAlive(script)
	runtime.KeepAlive(baseGravity)
	runtime.KeepAlive(hint)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// GravityGetForScriptAndWidth returns the gravity to use in laying out a single
// character or PangoItem.
//
// The gravity is determined based on the script, East Asian width, base
// gravity, and hint,
//
// This function is similar to pango.Gravity().GetForScript except that this
// function makes a distinction between narrow/half-width and wide/full-width
// characters also. Wide/full-width characters always stand *upright*, that is,
// they always take the base gravity, whereas narrow/full-width characters are
// always rotated in vertical context.
//
// If base_gravity is PANGO_GRAVITY_AUTO, it is first replaced with the
// preferred gravity of script.
//
// The function takes the following parameters:
//
//   - script: PangoScript to query.
//   - wide: TRUE for wide characters as returned by g_unichar_iswide().
//   - baseGravity: base gravity of the paragraph.
//   - hint: orientation hint.
//
// The function returns the following values:
//
//   - gravity: resolved gravity suitable to use for a run of text with script
//     and wide.
func GravityGetForScriptAndWidth(script Script, wide bool, baseGravity Gravity, hint GravityHint) Gravity {
	var _arg1 C.PangoScript      // out
	var _arg2 C.gboolean         // out
	var _arg3 C.PangoGravity     // out
	var _arg4 C.PangoGravityHint // out
	var _cret C.PangoGravity     // in

	_arg1 = C.PangoScript(script)
	if wide {
		_arg2 = C.TRUE
	}
	_arg3 = C.PangoGravity(baseGravity)
	_arg4 = C.PangoGravityHint(hint)

	_cret = C.pango_gravity_get_for_script_and_width(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(script)
	runtime.KeepAlive(wide)
	runtime.KeepAlive(baseGravity)
	runtime.KeepAlive(hint)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// GravityToRotation converts a PangoGravity value to its natural rotation in
// radians.
//
// Note that pango.Matrix.Rotate() takes angle in degrees, not radians. So,
// to call pango.Matrix,rotate with the output of this function you should
// multiply it by (180. / G_PI).
//
// The function takes the following parameters:
//
//   - gravity to query, should not be PANGO_GRAVITY_AUTO.
//
// The function returns the following values:
//
//   - gdouble: rotation value corresponding to gravity.
func GravityToRotation(gravity Gravity) float64 {
	var _arg1 C.PangoGravity // out
	var _cret C.double       // in

	_arg1 = C.PangoGravity(gravity)

	_cret = C.pango_gravity_to_rotation(_arg1)
	runtime.KeepAlive(gravity)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// GravityHint: PangoGravityHint defines how horizontal scripts should behave in
// a vertical context.
//
// That is, English excerpts in a vertical paragraph for example.
//
// See also pango.Gravity.
type GravityHint C.gint

const (
	// GravityHintNatural scripts will take their natural gravity based on the
	// base gravity and the script. This is the default.
	GravityHintNatural GravityHint = iota
	// GravityHintStrong always use the base gravity set, regardless of the
	// script.
	GravityHintStrong
	// GravityHintLine: for scripts not in their natural direction (eg. Latin in
	// East gravity), choose per-script gravity such that every script respects
	// the line progression. This means, Latin and Arabic will take opposite
	// gravities and both flow top-to-bottom for example.
	GravityHintLine
)

func marshalGravityHint(p uintptr) (interface{}, error) {
	return GravityHint(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GravityHint.
func (g GravityHint) String() string {
	switch g {
	case GravityHintNatural:
		return "Natural"
	case GravityHintStrong:
		return "Strong"
	case GravityHintLine:
		return "Line"
	default:
		return fmt.Sprintf("GravityHint(%d)", g)
	}
}

// LayoutDeserializeError errors that can be returned by
// pango.Layout().Deserialize.
type LayoutDeserializeError C.gint

const (
	// LayoutDeserializeInvalid: unspecified error.
	LayoutDeserializeInvalid LayoutDeserializeError = iota
	// LayoutDeserializeInvalidValue: JSon value could not be interpreted.
	LayoutDeserializeInvalidValue
	// LayoutDeserializeMissingValue: required JSon member was not found.
	LayoutDeserializeMissingValue
)

func marshalLayoutDeserializeError(p uintptr) (interface{}, error) {
	return LayoutDeserializeError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LayoutDeserializeError.
func (l LayoutDeserializeError) String() string {
	switch l {
	case LayoutDeserializeInvalid:
		return "Invalid"
	case LayoutDeserializeInvalidValue:
		return "InvalidValue"
	case LayoutDeserializeMissingValue:
		return "MissingValue"
	default:
		return fmt.Sprintf("LayoutDeserializeError(%d)", l)
	}
}

func LayoutDeserializeErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.pango_layout_deserialize_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// Overline: PangoOverline enumeration is used to specify whether text should be
// overlined, and if so, the type of line.
type Overline C.gint

const (
	// OverlineNone: no overline should be drawn.
	OverlineNone Overline = iota
	// OverlineSingle: draw a single line above the ink extents of the text
	// being underlined.
	OverlineSingle
)

func marshalOverline(p uintptr) (interface{}, error) {
	return Overline(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Overline.
func (o Overline) String() string {
	switch o {
	case OverlineNone:
		return "None"
	case OverlineSingle:
		return "Single"
	default:
		return fmt.Sprintf("Overline(%d)", o)
	}
}

// RenderPart: PangoRenderPart defines different items to render for such
// purposes as setting colors.
type RenderPart C.gint

const (
	// RenderPartForeground: text itself.
	RenderPartForeground RenderPart = iota
	// RenderPartBackground: area behind the text.
	RenderPartBackground
	// RenderPartUnderline: underlines.
	RenderPartUnderline
	// RenderPartStrikethrough: strikethrough lines.
	RenderPartStrikethrough
	// RenderPartOverline: overlines.
	RenderPartOverline
)

func marshalRenderPart(p uintptr) (interface{}, error) {
	return RenderPart(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RenderPart.
func (r RenderPart) String() string {
	switch r {
	case RenderPartForeground:
		return "Foreground"
	case RenderPartBackground:
		return "Background"
	case RenderPartUnderline:
		return "Underline"
	case RenderPartStrikethrough:
		return "Strikethrough"
	case RenderPartOverline:
		return "Overline"
	default:
		return fmt.Sprintf("RenderPart(%d)", r)
	}
}

// Script: PangoScript enumeration identifies different writing systems.
//
// The values correspond to the names as defined in the Unicode
// standard. See Unicode Standard Annex 24: Script names
// (http://www.unicode.org/reports/tr24/)
//
// Note that this enumeration is deprecated and will not be updated to include
// values in newer versions of the Unicode standard. Applications should use the
// glib.UnicodeScript enumeration instead, whose values are interchangeable with
// PangoScript.
type Script C.gint

const (
	// ScriptInvalidCode: value never returned from pango_script_for_unichar().
	ScriptInvalidCode Script = -1
	// ScriptCommon: character used by multiple different scripts.
	ScriptCommon Script = 0
	// ScriptInherited: mark glyph that takes its script from the base glyph to
	// which it is attached.
	ScriptInherited Script = 1
	// ScriptArabic: arabic.
	ScriptArabic Script = 2
	// ScriptArmenian: armenian.
	ScriptArmenian Script = 3
	// ScriptBengali: bengali.
	ScriptBengali Script = 4
	// ScriptBopomofo: bopomofo.
	ScriptBopomofo Script = 5
	// ScriptCherokee: cherokee.
	ScriptCherokee Script = 6
	// ScriptCoptic: coptic.
	ScriptCoptic Script = 7
	// ScriptCyrillic: cyrillic.
	ScriptCyrillic Script = 8
	// ScriptDeseret: deseret.
	ScriptDeseret Script = 9
	// ScriptDevanagari: devanagari.
	ScriptDevanagari Script = 10
	// ScriptEthiopic: ethiopic.
	ScriptEthiopic Script = 11
	// ScriptGeorgian: georgian.
	ScriptGeorgian Script = 12
	// ScriptGothic: gothic.
	ScriptGothic Script = 13
	// ScriptGreek: greek.
	ScriptGreek Script = 14
	// ScriptGujarati: gujarati.
	ScriptGujarati Script = 15
	// ScriptGurmukhi: gurmukhi.
	ScriptGurmukhi Script = 16
	// ScriptHan: han.
	ScriptHan Script = 17
	// ScriptHangul: hangul.
	ScriptHangul Script = 18
	// ScriptHebrew: hebrew.
	ScriptHebrew Script = 19
	// ScriptHiragana: hiragana.
	ScriptHiragana Script = 20
	// ScriptKannada: kannada.
	ScriptKannada Script = 21
	// ScriptKatakana: katakana.
	ScriptKatakana Script = 22
	// ScriptKhmer: khmer.
	ScriptKhmer Script = 23
	// ScriptLao: lao.
	ScriptLao Script = 24
	// ScriptLatin: latin.
	ScriptLatin Script = 25
	// ScriptMalayalam: malayalam.
	ScriptMalayalam Script = 26
	// ScriptMongolian: mongolian.
	ScriptMongolian Script = 27
	// ScriptMyanmar: myanmar.
	ScriptMyanmar Script = 28
	// ScriptOgham: ogham.
	ScriptOgham Script = 29
	// ScriptOldItalic: old Italic.
	ScriptOldItalic Script = 30
	// ScriptOriya: oriya.
	ScriptOriya Script = 31
	// ScriptRunic: runic.
	ScriptRunic Script = 32
	// ScriptSinhala: sinhala.
	ScriptSinhala Script = 33
	// ScriptSyriac: syriac.
	ScriptSyriac Script = 34
	// ScriptTamil: tamil.
	ScriptTamil Script = 35
	// ScriptTelugu: telugu.
	ScriptTelugu Script = 36
	// ScriptThaana: thaana.
	ScriptThaana Script = 37
	// ScriptThai: thai.
	ScriptThai Script = 38
	// ScriptTibetan: tibetan.
	ScriptTibetan Script = 39
	// ScriptCanadianAboriginal: canadian Aboriginal.
	ScriptCanadianAboriginal Script = 40
	// ScriptYi: yi.
	ScriptYi Script = 41
	// ScriptTagalog: tagalog.
	ScriptTagalog Script = 42
	// ScriptHanunoo: hanunoo.
	ScriptHanunoo Script = 43
	// ScriptBuhid: buhid.
	ScriptBuhid Script = 44
	// ScriptTagbanwa: tagbanwa.
	ScriptTagbanwa Script = 45
	// ScriptBraille: braille.
	ScriptBraille Script = 46
	// ScriptCypriot: cypriot.
	ScriptCypriot Script = 47
	// ScriptLimbu: limbu.
	ScriptLimbu Script = 48
	// ScriptOsmanya: osmanya.
	ScriptOsmanya Script = 49
	// ScriptShavian: shavian.
	ScriptShavian Script = 50
	// ScriptLinearB: linear B.
	ScriptLinearB Script = 51
	// ScriptTaiLe: tai Le.
	ScriptTaiLe Script = 52
	// ScriptUgaritic: ugaritic.
	ScriptUgaritic Script = 53
	// ScriptNewTaiLue: new Tai Lue. Since 1.10.
	ScriptNewTaiLue Script = 54
	// ScriptBuginese: buginese. Since 1.10.
	ScriptBuginese Script = 55
	// ScriptGlagolitic: glagolitic. Since 1.10.
	ScriptGlagolitic Script = 56
	// ScriptTifinagh: tifinagh. Since 1.10.
	ScriptTifinagh Script = 57
	// ScriptSylotiNagri: syloti Nagri. Since 1.10.
	ScriptSylotiNagri Script = 58
	// ScriptOldPersian: old Persian. Since 1.10.
	ScriptOldPersian Script = 59
	// ScriptKharoshthi: kharoshthi. Since 1.10.
	ScriptKharoshthi Script = 60
	// ScriptUnknown: unassigned code point. Since 1.14.
	ScriptUnknown Script = 61
	// ScriptBalinese: balinese. Since 1.14.
	ScriptBalinese Script = 62
	// ScriptCuneiform: cuneiform. Since 1.14.
	ScriptCuneiform Script = 63
	// ScriptPhoenician: phoenician. Since 1.14.
	ScriptPhoenician Script = 64
	// ScriptPhagsPa: phags-pa. Since 1.14.
	ScriptPhagsPa Script = 65
	// ScriptNko: n'Ko. Since 1.14.
	ScriptNko Script = 66
	// ScriptKayahLi: kayah Li. Since 1.20.1.
	ScriptKayahLi Script = 67
	// ScriptLepcha: lepcha. Since 1.20.1.
	ScriptLepcha Script = 68
	// ScriptRejang: rejang. Since 1.20.1.
	ScriptRejang Script = 69
	// ScriptSundanese: sundanese. Since 1.20.1.
	ScriptSundanese Script = 70
	// ScriptSaurashtra: saurashtra. Since 1.20.1.
	ScriptSaurashtra Script = 71
	// ScriptCham: cham. Since 1.20.1.
	ScriptCham Script = 72
	// ScriptOlChiki: ol Chiki. Since 1.20.1.
	ScriptOlChiki Script = 73
	// ScriptVai: vai. Since 1.20.1.
	ScriptVai Script = 74
	// ScriptCarian: carian. Since 1.20.1.
	ScriptCarian Script = 75
	// ScriptLycian: lycian. Since 1.20.1.
	ScriptLycian Script = 76
	// ScriptLydian: lydian. Since 1.20.1.
	ScriptLydian Script = 77
	// ScriptBatak: batak. Since 1.32.
	ScriptBatak Script = 78
	// ScriptBrahmi: brahmi. Since 1.32.
	ScriptBrahmi Script = 79
	// ScriptMandaic: mandaic. Since 1.32.
	ScriptMandaic Script = 80
	// ScriptChakma: chakma. Since: 1.32.
	ScriptChakma Script = 81
	// ScriptMeroiticCursive: meroitic Cursive. Since: 1.32.
	ScriptMeroiticCursive Script = 82
	// ScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 1.32.
	ScriptMeroiticHieroglyphs Script = 83
	// ScriptMiao: miao. Since: 1.32.
	ScriptMiao Script = 84
	// ScriptSharada: sharada. Since: 1.32.
	ScriptSharada Script = 85
	// ScriptSoraSompeng: sora Sompeng. Since: 1.32.
	ScriptSoraSompeng Script = 86
	// ScriptTakri: takri. Since: 1.32.
	ScriptTakri Script = 87
	// ScriptBassaVah: bassa. Since: 1.40.
	ScriptBassaVah Script = 88
	// ScriptCaucasianAlbanian: caucasian Albanian. Since: 1.40.
	ScriptCaucasianAlbanian Script = 89
	// ScriptDuployan: duployan. Since: 1.40.
	ScriptDuployan Script = 90
	// ScriptElbasan: elbasan. Since: 1.40.
	ScriptElbasan Script = 91
	// ScriptGrantha: grantha. Since: 1.40.
	ScriptGrantha Script = 92
	// ScriptKhojki: kjohki. Since: 1.40.
	ScriptKhojki Script = 93
	// ScriptKhudawadi: khudawadi, Sindhi. Since: 1.40.
	ScriptKhudawadi Script = 94
	// ScriptLinearA: linear A. Since: 1.40.
	ScriptLinearA Script = 95
	// ScriptMahajani: mahajani. Since: 1.40.
	ScriptMahajani Script = 96
	// ScriptManichaean: manichaean. Since: 1.40.
	ScriptManichaean Script = 97
	// ScriptMendeKikakui: mende Kikakui. Since: 1.40.
	ScriptMendeKikakui Script = 98
	// ScriptModi: modi. Since: 1.40.
	ScriptModi Script = 99
	// ScriptMro: mro. Since: 1.40.
	ScriptMro Script = 100
	// ScriptNabataean: nabataean. Since: 1.40.
	ScriptNabataean Script = 101
	// ScriptOldNorthArabian: old North Arabian. Since: 1.40.
	ScriptOldNorthArabian Script = 102
	// ScriptOldPermic: old Permic. Since: 1.40.
	ScriptOldPermic Script = 103
	// ScriptPahawhHmong: pahawh Hmong. Since: 1.40.
	ScriptPahawhHmong Script = 104
	// ScriptPalmyrene: palmyrene. Since: 1.40.
	ScriptPalmyrene Script = 105
	// ScriptPauCinHau: pau Cin Hau. Since: 1.40.
	ScriptPauCinHau Script = 106
	// ScriptPsalterPahlavi: psalter Pahlavi. Since: 1.40.
	ScriptPsalterPahlavi Script = 107
	// ScriptSiddham: siddham. Since: 1.40.
	ScriptSiddham Script = 108
	// ScriptTirhuta: tirhuta. Since: 1.40.
	ScriptTirhuta Script = 109
	// ScriptWarangCiti: warang Citi. Since: 1.40.
	ScriptWarangCiti Script = 110
	// ScriptAhom: ahom. Since: 1.40.
	ScriptAhom Script = 111
	// ScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 1.40.
	ScriptAnatolianHieroglyphs Script = 112
	// ScriptHatran: hatran. Since: 1.40.
	ScriptHatran Script = 113
	// ScriptMultani: multani. Since: 1.40.
	ScriptMultani Script = 114
	// ScriptOldHungarian: old Hungarian. Since: 1.40.
	ScriptOldHungarian Script = 115
	// ScriptSignwriting: signwriting. Since: 1.40.
	ScriptSignwriting Script = 116
)

func marshalScript(p uintptr) (interface{}, error) {
	return Script(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Script.
func (s Script) String() string {
	switch s {
	case ScriptInvalidCode:
		return "InvalidCode"
	case ScriptCommon:
		return "Common"
	case ScriptInherited:
		return "Inherited"
	case ScriptArabic:
		return "Arabic"
	case ScriptArmenian:
		return "Armenian"
	case ScriptBengali:
		return "Bengali"
	case ScriptBopomofo:
		return "Bopomofo"
	case ScriptCherokee:
		return "Cherokee"
	case ScriptCoptic:
		return "Coptic"
	case ScriptCyrillic:
		return "Cyrillic"
	case ScriptDeseret:
		return "Deseret"
	case ScriptDevanagari:
		return "Devanagari"
	case ScriptEthiopic:
		return "Ethiopic"
	case ScriptGeorgian:
		return "Georgian"
	case ScriptGothic:
		return "Gothic"
	case ScriptGreek:
		return "Greek"
	case ScriptGujarati:
		return "Gujarati"
	case ScriptGurmukhi:
		return "Gurmukhi"
	case ScriptHan:
		return "Han"
	case ScriptHangul:
		return "Hangul"
	case ScriptHebrew:
		return "Hebrew"
	case ScriptHiragana:
		return "Hiragana"
	case ScriptKannada:
		return "Kannada"
	case ScriptKatakana:
		return "Katakana"
	case ScriptKhmer:
		return "Khmer"
	case ScriptLao:
		return "Lao"
	case ScriptLatin:
		return "Latin"
	case ScriptMalayalam:
		return "Malayalam"
	case ScriptMongolian:
		return "Mongolian"
	case ScriptMyanmar:
		return "Myanmar"
	case ScriptOgham:
		return "Ogham"
	case ScriptOldItalic:
		return "OldItalic"
	case ScriptOriya:
		return "Oriya"
	case ScriptRunic:
		return "Runic"
	case ScriptSinhala:
		return "Sinhala"
	case ScriptSyriac:
		return "Syriac"
	case ScriptTamil:
		return "Tamil"
	case ScriptTelugu:
		return "Telugu"
	case ScriptThaana:
		return "Thaana"
	case ScriptThai:
		return "Thai"
	case ScriptTibetan:
		return "Tibetan"
	case ScriptCanadianAboriginal:
		return "CanadianAboriginal"
	case ScriptYi:
		return "Yi"
	case ScriptTagalog:
		return "Tagalog"
	case ScriptHanunoo:
		return "Hanunoo"
	case ScriptBuhid:
		return "Buhid"
	case ScriptTagbanwa:
		return "Tagbanwa"
	case ScriptBraille:
		return "Braille"
	case ScriptCypriot:
		return "Cypriot"
	case ScriptLimbu:
		return "Limbu"
	case ScriptOsmanya:
		return "Osmanya"
	case ScriptShavian:
		return "Shavian"
	case ScriptLinearB:
		return "LinearB"
	case ScriptTaiLe:
		return "TaiLe"
	case ScriptUgaritic:
		return "Ugaritic"
	case ScriptNewTaiLue:
		return "NewTaiLue"
	case ScriptBuginese:
		return "Buginese"
	case ScriptGlagolitic:
		return "Glagolitic"
	case ScriptTifinagh:
		return "Tifinagh"
	case ScriptSylotiNagri:
		return "SylotiNagri"
	case ScriptOldPersian:
		return "OldPersian"
	case ScriptKharoshthi:
		return "Kharoshthi"
	case ScriptUnknown:
		return "Unknown"
	case ScriptBalinese:
		return "Balinese"
	case ScriptCuneiform:
		return "Cuneiform"
	case ScriptPhoenician:
		return "Phoenician"
	case ScriptPhagsPa:
		return "PhagsPa"
	case ScriptNko:
		return "Nko"
	case ScriptKayahLi:
		return "KayahLi"
	case ScriptLepcha:
		return "Lepcha"
	case ScriptRejang:
		return "Rejang"
	case ScriptSundanese:
		return "Sundanese"
	case ScriptSaurashtra:
		return "Saurashtra"
	case ScriptCham:
		return "Cham"
	case ScriptOlChiki:
		return "OlChiki"
	case ScriptVai:
		return "Vai"
	case ScriptCarian:
		return "Carian"
	case ScriptLycian:
		return "Lycian"
	case ScriptLydian:
		return "Lydian"
	case ScriptBatak:
		return "Batak"
	case ScriptBrahmi:
		return "Brahmi"
	case ScriptMandaic:
		return "Mandaic"
	case ScriptChakma:
		return "Chakma"
	case ScriptMeroiticCursive:
		return "MeroiticCursive"
	case ScriptMeroiticHieroglyphs:
		return "MeroiticHieroglyphs"
	case ScriptMiao:
		return "Miao"
	case ScriptSharada:
		return "Sharada"
	case ScriptSoraSompeng:
		return "SoraSompeng"
	case ScriptTakri:
		return "Takri"
	case ScriptBassaVah:
		return "BassaVah"
	case ScriptCaucasianAlbanian:
		return "CaucasianAlbanian"
	case ScriptDuployan:
		return "Duployan"
	case ScriptElbasan:
		return "Elbasan"
	case ScriptGrantha:
		return "Grantha"
	case ScriptKhojki:
		return "Khojki"
	case ScriptKhudawadi:
		return "Khudawadi"
	case ScriptLinearA:
		return "LinearA"
	case ScriptMahajani:
		return "Mahajani"
	case ScriptManichaean:
		return "Manichaean"
	case ScriptMendeKikakui:
		return "MendeKikakui"
	case ScriptModi:
		return "Modi"
	case ScriptMro:
		return "Mro"
	case ScriptNabataean:
		return "Nabataean"
	case ScriptOldNorthArabian:
		return "OldNorthArabian"
	case ScriptOldPermic:
		return "OldPermic"
	case ScriptPahawhHmong:
		return "PahawhHmong"
	case ScriptPalmyrene:
		return "Palmyrene"
	case ScriptPauCinHau:
		return "PauCinHau"
	case ScriptPsalterPahlavi:
		return "PsalterPahlavi"
	case ScriptSiddham:
		return "Siddham"
	case ScriptTirhuta:
		return "Tirhuta"
	case ScriptWarangCiti:
		return "WarangCiti"
	case ScriptAhom:
		return "Ahom"
	case ScriptAnatolianHieroglyphs:
		return "AnatolianHieroglyphs"
	case ScriptHatran:
		return "Hatran"
	case ScriptMultani:
		return "Multani"
	case ScriptOldHungarian:
		return "OldHungarian"
	case ScriptSignwriting:
		return "Signwriting"
	default:
		return fmt.Sprintf("Script(%d)", s)
	}
}

// ScriptForUnichar looks up the script for a particular character.
//
// The script of a character is defined by Unicode Standard Annex 24: Script
// names (http://www.unicode.org/reports/tr24/).
//
// No check is made for ch being a valid Unicode character; if you pass in
// invalid character, the result is undefined.
//
// Note that while the return type of this function is declared as PangoScript,
// as of Pango 1.18, this function simply returns the return value of
// glib.UnicharGetScript(). Callers must be prepared to handle unknown values.
//
// Deprecated: Use g_unichar_get_script().
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - script: PangoScript for the character.
func ScriptForUnichar(ch uint32) Script {
	var _arg1 C.gunichar    // out
	var _cret C.PangoScript // in

	_arg1 = C.gunichar(ch)

	_cret = C.pango_script_for_unichar(_arg1)
	runtime.KeepAlive(ch)

	var _script Script // out

	_script = Script(_cret)

	return _script
}

// ScriptGetSampleLanguage finds a language tag that is reasonably
// representative of script.
//
// The language will usually be the most widely spoken or used language written
// in that script: for instance, the sample language for PANGO_SCRIPT_CYRILLIC
// is ru (Russian), the sample language for PANGO_SCRIPT_ARABIC is ar.
//
// For some scripts, no sample language will be returned because there is no
// language that is sufficiently representative. The best example of this is
// PANGO_SCRIPT_HAN, where various different variants of written Chinese,
// Japanese, and Korean all use significantly different sets of Han characters
// and forms of shared characters. No sample language can be provided for many
// historical scripts as well.
//
// As of 1.18, this function checks the environment variables PANGO_LANGUAGE
// and LANGUAGE (checked in that order) first. If one of them is set, it is
// parsed as a list of language tags separated by colons or other separators.
// This function will return the first language in the parsed list that Pango
// believes may use script for writing. This last predicate is tested using
// pango.Language.IncludesScript(). This can be used to control Pango's font
// selection for non-primary languages. For example, a PANGO_LANGUAGE enviroment
// variable set to "en:fa" makes Pango choose fonts suitable for Persian (fa)
// instead of Arabic (ar) when a segment of Arabic text is found in an otherwise
// non-Arabic text. The same trick can be used to choose a default language for
// PANGO_SCRIPT_HAN when setting context language is not feasible.
//
// The function takes the following parameters:
//
//   - script: PangoScript.
//
// The function returns the following values:
//
//   - language (optional): PangoLanguage that is representative of the script.
func ScriptGetSampleLanguage(script Script) *Language {
	var _arg1 C.PangoScript    // out
	var _cret *C.PangoLanguage // in

	_arg1 = C.PangoScript(script)

	_cret = C.pango_script_get_sample_language(_arg1)
	runtime.KeepAlive(script)

	var _language *Language // out

	if _cret != nil {
		_language = (*Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_language)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _language
}

// Stretch: enumeration specifying the width of the font relative to other
// designs within a family.
type Stretch C.gint

const (
	// StretchUltraCondensed: ultra condensed width.
	StretchUltraCondensed Stretch = iota
	// StretchExtraCondensed: extra condensed width.
	StretchExtraCondensed
	// StretchCondensed: condensed width.
	StretchCondensed
	// StretchSemiCondensed: semi condensed width.
	StretchSemiCondensed
	// StretchNormal: normal width.
	StretchNormal
	// StretchSemiExpanded: semi expanded width.
	StretchSemiExpanded
	// StretchExpanded: expanded width.
	StretchExpanded
	// StretchExtraExpanded: extra expanded width.
	StretchExtraExpanded
	// StretchUltraExpanded: ultra expanded width.
	StretchUltraExpanded
)

func marshalStretch(p uintptr) (interface{}, error) {
	return Stretch(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Stretch.
func (s Stretch) String() string {
	switch s {
	case StretchUltraCondensed:
		return "UltraCondensed"
	case StretchExtraCondensed:
		return "ExtraCondensed"
	case StretchCondensed:
		return "Condensed"
	case StretchSemiCondensed:
		return "SemiCondensed"
	case StretchNormal:
		return "Normal"
	case StretchSemiExpanded:
		return "SemiExpanded"
	case StretchExpanded:
		return "Expanded"
	case StretchExtraExpanded:
		return "ExtraExpanded"
	case StretchUltraExpanded:
		return "UltraExpanded"
	default:
		return fmt.Sprintf("Stretch(%d)", s)
	}
}

// Style: enumeration specifying the various slant styles possible for a font.
type Style C.gint

const (
	// StyleNormal: font is upright.
	StyleNormal Style = iota
	// StyleOblique: font is slanted, but in a roman style.
	StyleOblique
	// StyleItalic: font is slanted in an italic style.
	StyleItalic
)

func marshalStyle(p uintptr) (interface{}, error) {
	return Style(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Style.
func (s Style) String() string {
	switch s {
	case StyleNormal:
		return "Normal"
	case StyleOblique:
		return "Oblique"
	case StyleItalic:
		return "Italic"
	default:
		return fmt.Sprintf("Style(%d)", s)
	}
}

// TabAlign: PangoTabAlign specifies where the text appears relative to the tab
// stop position.
type TabAlign C.gint

const (
	// TabLeft: text appears to the right of the tab stop position.
	TabLeft TabAlign = iota
	// TabRight: text appears to the left of the tab stop position until the
	// available space is filled. Since: 1.50.
	TabRight
	// TabCenter: text is centered at the tab stop position until the available
	// space is filled. Since: 1.50.
	TabCenter
	// TabDecimal: text before the first occurrence of the decimal point
	// character appears to the left of the tab stop position (until the
	// available space is filled), the rest to the right. Since: 1.50.
	TabDecimal
)

func marshalTabAlign(p uintptr) (interface{}, error) {
	return TabAlign(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TabAlign.
func (t TabAlign) String() string {
	switch t {
	case TabLeft:
		return "Left"
	case TabRight:
		return "Right"
	case TabCenter:
		return "Center"
	case TabDecimal:
		return "Decimal"
	default:
		return fmt.Sprintf("TabAlign(%d)", t)
	}
}

// TextTransform: enumeration that affects how Pango treats characters during
// shaping.
type TextTransform C.gint

const (
	// TextTransformNone: leave text unchanged.
	TextTransformNone TextTransform = iota
	// TextTransformLowercase: display letters and numbers as lowercase.
	TextTransformLowercase
	// TextTransformUppercase: display letters and numbers as uppercase.
	TextTransformUppercase
	// TextTransformCapitalize: display the first character of a word in
	// titlecase.
	TextTransformCapitalize
)

func marshalTextTransform(p uintptr) (interface{}, error) {
	return TextTransform(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextTransform.
func (t TextTransform) String() string {
	switch t {
	case TextTransformNone:
		return "None"
	case TextTransformLowercase:
		return "Lowercase"
	case TextTransformUppercase:
		return "Uppercase"
	case TextTransformCapitalize:
		return "Capitalize"
	default:
		return fmt.Sprintf("TextTransform(%d)", t)
	}
}

// Underline: PangoUnderline enumeration is used to specify whether text should
// be underlined, and if so, the type of underlining.
type Underline C.gint

const (
	// UnderlineNone: no underline should be drawn.
	UnderlineNone Underline = iota
	// UnderlineSingle: single underline should be drawn.
	UnderlineSingle
	// UnderlineDouble: double underline should be drawn.
	UnderlineDouble
	// UnderlineLow: single underline should be drawn at a position beneath
	// the ink extents of the text being underlined. This should be used only
	// for underlining single characters, such as for keyboard accelerators.
	// PANGO_UNDERLINE_SINGLE should be used for extended portions of text.
	UnderlineLow
	// UnderlineError: underline indicating an error should be drawn below.
	// The exact style of rendering is up to the PangoRenderer in use, but
	// typical styles include wavy or dotted lines. This underline is typically
	// used to indicate an error such as a possible mispelling; in some cases a
	// contrasting color may automatically be used. This type of underlining is
	// available since Pango 1.4.
	UnderlineError
	// UnderlineSingleLine: like PANGO_UNDERLINE_SINGLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineSingleLine
	// UnderlineDoubleLine: like PANGO_UNDERLINE_DOUBLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineDoubleLine
	// UnderlineErrorLine: like PANGO_UNDERLINE_ERROR, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineErrorLine
)

func marshalUnderline(p uintptr) (interface{}, error) {
	return Underline(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Underline.
func (u Underline) String() string {
	switch u {
	case UnderlineNone:
		return "None"
	case UnderlineSingle:
		return "Single"
	case UnderlineDouble:
		return "Double"
	case UnderlineLow:
		return "Low"
	case UnderlineError:
		return "Error"
	case UnderlineSingleLine:
		return "SingleLine"
	case UnderlineDoubleLine:
		return "DoubleLine"
	case UnderlineErrorLine:
		return "ErrorLine"
	default:
		return fmt.Sprintf("Underline(%d)", u)
	}
}

// Variant: enumeration specifying capitalization variant of the font.
type Variant C.gint

const (
	// VariantNormal: normal font.
	VariantNormal Variant = iota
	// VariantSmallCaps: font with the lower case characters replaced by smaller
	// variants of the capital characters.
	VariantSmallCaps
	// VariantAllSmallCaps: font with all characters replaced by smaller
	// variants of the capital characters. Since: 1.50.
	VariantAllSmallCaps
	// VariantPetiteCaps: font with the lower case characters replaced by
	// smaller variants of the capital characters. Petite Caps can be even
	// smaller than Small Caps. Since: 1.50.
	VariantPetiteCaps
	// VariantAllPetiteCaps: font with all characters replaced by smaller
	// variants of the capital characters. Petite Caps can be even smaller than
	// Small Caps. Since: 1.50.
	VariantAllPetiteCaps
	// VariantUnicase: font with the upper case characters replaced by smaller
	// variants of the capital letters. Since: 1.50.
	VariantUnicase
	// VariantTitleCaps: font with capital letters that are more suitable for
	// all-uppercase titles. Since: 1.50.
	VariantTitleCaps
)

func marshalVariant(p uintptr) (interface{}, error) {
	return Variant(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Variant.
func (v Variant) String() string {
	switch v {
	case VariantNormal:
		return "Normal"
	case VariantSmallCaps:
		return "SmallCaps"
	case VariantAllSmallCaps:
		return "AllSmallCaps"
	case VariantPetiteCaps:
		return "PetiteCaps"
	case VariantAllPetiteCaps:
		return "AllPetiteCaps"
	case VariantUnicase:
		return "Unicase"
	case VariantTitleCaps:
		return "TitleCaps"
	default:
		return fmt.Sprintf("Variant(%d)", v)
	}
}

// Weight: enumeration specifying the weight (boldness) of a font.
//
// Weight is specified as a numeric value ranging from 100 to 1000. This
// enumeration simply provides some common, predefined values.
type Weight C.gint

const (
	// WeightThin: thin weight (= 100) Since: 1.24.
	WeightThin Weight = 100
	// WeightUltralight: ultralight weight (= 200).
	WeightUltralight Weight = 200
	// WeightLight: light weight (= 300).
	WeightLight Weight = 300
	// WeightSemilight: semilight weight (= 350) Since: 1.36.7.
	WeightSemilight Weight = 350
	// WeightBook: book weight (= 380) Since: 1.24).
	WeightBook Weight = 380
	// WeightNormal: default weight (= 400).
	WeightNormal Weight = 400
	// WeightMedium: medium weight (= 500) Since: 1.24.
	WeightMedium Weight = 500
	// WeightSemibold: semibold weight (= 600).
	WeightSemibold Weight = 600
	// WeightBold: bold weight (= 700).
	WeightBold Weight = 700
	// WeightUltrabold: ultrabold weight (= 800).
	WeightUltrabold Weight = 800
	// WeightHeavy: heavy weight (= 900).
	WeightHeavy Weight = 900
	// WeightUltraheavy: ultraheavy weight (= 1000) Since: 1.24.
	WeightUltraheavy Weight = 1000
)

func marshalWeight(p uintptr) (interface{}, error) {
	return Weight(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Weight.
func (w Weight) String() string {
	switch w {
	case WeightThin:
		return "Thin"
	case WeightUltralight:
		return "Ultralight"
	case WeightLight:
		return "Light"
	case WeightSemilight:
		return "Semilight"
	case WeightBook:
		return "Book"
	case WeightNormal:
		return "Normal"
	case WeightMedium:
		return "Medium"
	case WeightSemibold:
		return "Semibold"
	case WeightBold:
		return "Bold"
	case WeightUltrabold:
		return "Ultrabold"
	case WeightHeavy:
		return "Heavy"
	case WeightUltraheavy:
		return "Ultraheavy"
	default:
		return fmt.Sprintf("Weight(%d)", w)
	}
}

// WrapMode: PangoWrapMode describes how to wrap the lines of a PangoLayout to
// the desired width.
//
// For PANGO_WRAP_WORD, Pango uses break opportunities that are determined
// by the Unicode line breaking algorithm. For PANGO_WRAP_CHAR, Pango allows
// breaking at grapheme boundaries that are determined by the Unicode text
// segmentation algorithm.
type WrapMode C.gint

const (
	// WrapWord: wrap lines at word boundaries.
	WrapWord WrapMode = iota
	// WrapChar: wrap lines at character boundaries.
	WrapChar
	// WrapWordChar: wrap lines at word boundaries, but fall back to character
	// boundaries if there is not enough space for a full word.
	WrapWordChar
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WrapMode.
func (w WrapMode) String() string {
	switch w {
	case WrapWord:
		return "Word"
	case WrapChar:
		return "Char"
	case WrapWordChar:
		return "WordChar"
	default:
		return fmt.Sprintf("WrapMode(%d)", w)
	}
}

// FontMask bits in a PangoFontMask correspond to the set fields in a
// PangoFontDescription.
type FontMask C.guint

const (
	// FontMaskFamily: font family is specified.
	FontMaskFamily FontMask = 0b1
	// FontMaskStyle: font style is specified.
	FontMaskStyle FontMask = 0b10
	// FontMaskVariant: font variant is specified.
	FontMaskVariant FontMask = 0b100
	// FontMaskWeight: font weight is specified.
	FontMaskWeight FontMask = 0b1000
	// FontMaskStretch: font stretch is specified.
	FontMaskStretch FontMask = 0b10000
	// FontMaskSize: font size is specified.
	FontMaskSize FontMask = 0b100000
	// FontMaskGravity: font gravity is specified (Since: 1.16.).
	FontMaskGravity FontMask = 0b1000000
	// FontMaskVariations: openType font variations are specified (Since: 1.42).
	FontMaskVariations FontMask = 0b10000000
)

func marshalFontMask(p uintptr) (interface{}, error) {
	return FontMask(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FontMask.
func (f FontMask) String() string {
	if f == 0 {
		return "FontMask(0)"
	}

	var builder strings.Builder
	builder.Grow(123)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FontMaskFamily:
			builder.WriteString("Family|")
		case FontMaskStyle:
			builder.WriteString("Style|")
		case FontMaskVariant:
			builder.WriteString("Variant|")
		case FontMaskWeight:
			builder.WriteString("Weight|")
		case FontMaskStretch:
			builder.WriteString("Stretch|")
		case FontMaskSize:
			builder.WriteString("Size|")
		case FontMaskGravity:
			builder.WriteString("Gravity|")
		case FontMaskVariations:
			builder.WriteString("Variations|")
		default:
			builder.WriteString(fmt.Sprintf("FontMask(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FontMask) Has(other FontMask) bool {
	return (f & other) == other
}

// LayoutDeserializeFlags flags that influence the behavior of
// pango.Layout().Deserialize.
//
// New members may be added to this enumeration over time.
type LayoutDeserializeFlags C.guint

const (
	// LayoutDeserializeDefault: default behavior.
	LayoutDeserializeDefault LayoutDeserializeFlags = 0b0
	// LayoutDeserializeContext: apply context information from the
	// serialization to the PangoContext.
	LayoutDeserializeContext LayoutDeserializeFlags = 0b1
)

func marshalLayoutDeserializeFlags(p uintptr) (interface{}, error) {
	return LayoutDeserializeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for LayoutDeserializeFlags.
func (l LayoutDeserializeFlags) String() string {
	if l == 0 {
		return "LayoutDeserializeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(49)

	for l != 0 {
		next := l & (l - 1)
		bit := l - next

		switch bit {
		case LayoutDeserializeDefault:
			builder.WriteString("Default|")
		case LayoutDeserializeContext:
			builder.WriteString("Context|")
		default:
			builder.WriteString(fmt.Sprintf("LayoutDeserializeFlags(0b%b)|", bit))
		}

		l = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if l contains other.
func (l LayoutDeserializeFlags) Has(other LayoutDeserializeFlags) bool {
	return (l & other) == other
}

// LayoutSerializeFlags flags that influence the behavior of
// pango.Layout.Serialize().
//
// New members may be added to this enumeration over time.
type LayoutSerializeFlags C.guint

const (
	// LayoutSerializeDefault: default behavior.
	LayoutSerializeDefault LayoutSerializeFlags = 0b0
	// LayoutSerializeContext: include context information.
	LayoutSerializeContext LayoutSerializeFlags = 0b1
	// LayoutSerializeOutput: include information about the formatted output.
	LayoutSerializeOutput LayoutSerializeFlags = 0b10
)

func marshalLayoutSerializeFlags(p uintptr) (interface{}, error) {
	return LayoutSerializeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for LayoutSerializeFlags.
func (l LayoutSerializeFlags) String() string {
	if l == 0 {
		return "LayoutSerializeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(67)

	for l != 0 {
		next := l & (l - 1)
		bit := l - next

		switch bit {
		case LayoutSerializeDefault:
			builder.WriteString("Default|")
		case LayoutSerializeContext:
			builder.WriteString("Context|")
		case LayoutSerializeOutput:
			builder.WriteString("Output|")
		default:
			builder.WriteString(fmt.Sprintf("LayoutSerializeFlags(0b%b)|", bit))
		}

		l = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if l contains other.
func (l LayoutSerializeFlags) Has(other LayoutSerializeFlags) bool {
	return (l & other) == other
}

// ShapeFlags flags influencing the shaping process.
//
// PangoShapeFlags can be passed to pango.ShapeWithFlags().
type ShapeFlags C.guint

const (
	// ShapeNone: default value.
	ShapeNone ShapeFlags = 0b0
	// ShapeRoundPositions: round glyph positions and widths to whole device
	// units This option should be set if the target renderer can't do subpixel
	// positioning of glyphs.
	ShapeRoundPositions ShapeFlags = 0b1
)

func marshalShapeFlags(p uintptr) (interface{}, error) {
	return ShapeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ShapeFlags.
func (s ShapeFlags) String() string {
	if s == 0 {
		return "ShapeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(29)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ShapeNone:
			builder.WriteString("None|")
		case ShapeRoundPositions:
			builder.WriteString("RoundPositions|")
		default:
			builder.WriteString(fmt.Sprintf("ShapeFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ShapeFlags) Has(other ShapeFlags) bool {
	return (s & other) == other
}

// ShowFlags: these flags affect how Pango treats characters that are normally
// not visible in the output.
type ShowFlags C.guint

const (
	// ShowNone: no special treatment for invisible characters.
	ShowNone ShowFlags = 0b0
	// ShowSpaces: render spaces, tabs and newlines visibly.
	ShowSpaces ShowFlags = 0b1
	// ShowLineBreaks: render line breaks visibly.
	ShowLineBreaks ShowFlags = 0b10
	// ShowIgnorables: render default-ignorable Unicode characters visibly.
	ShowIgnorables ShowFlags = 0b100
)

func marshalShowFlags(p uintptr) (interface{}, error) {
	return ShowFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ShowFlags.
func (s ShowFlags) String() string {
	if s == 0 {
		return "ShowFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(49)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ShowNone:
			builder.WriteString("None|")
		case ShowSpaces:
			builder.WriteString("Spaces|")
		case ShowLineBreaks:
			builder.WriteString("LineBreaks|")
		case ShowIgnorables:
			builder.WriteString("Ignorables|")
		default:
			builder.WriteString(fmt.Sprintf("ShowFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ShowFlags) Has(other ShowFlags) bool {
	return (s & other) == other
}

// AttrDataCopyFunc: type of a function that can duplicate user data for an
// attribute.
type AttrDataCopyFunc func() (gpointer unsafe.Pointer)

// AttrFilterFunc: type of a function filtering a list of attributes.
type AttrFilterFunc func(attribute *Attribute) (ok bool)

// FontsetForEachFunc: callback used when enumerating fonts in a fontset.
//
// See pango.Fontset.ForEach().
type FontsetForEachFunc func(fontset Fontsetter, font Fonter) (ok bool)

// NewAttrAllowBreaks: create a new allow-breaks attribute.
//
// If breaks are disabled, the range will be kept in a single run, as far as
// possible.
//
// The function takes the following parameters:
//
//   - allowBreaks: TRUE if we line breaks are allowed.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrAllowBreaks(allowBreaks bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if allowBreaks {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_allow_breaks_new(_arg1)
	runtime.KeepAlive(allowBreaks)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrBackgroundAlpha: create a new background alpha attribute.
//
// The function takes the following parameters:
//
//   - alpha value, between 1 and 65536.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrBackgroundAlpha(alpha uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.guint16(alpha)

	_cret = C.pango_attr_background_alpha_new(_arg1)
	runtime.KeepAlive(alpha)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrBackground: create a new background color attribute.
//
// The function takes the following parameters:
//
//   - red value (ranging from 0 to 65535).
//   - green value.
//   - blue value.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrBackground(red, green, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.guint16(red)
	_arg2 = C.guint16(green)
	_arg3 = C.guint16(blue)

	_cret = C.pango_attr_background_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrBaselineShift: create a new baseline displacement attribute.
//
// The effect of this attribute is to shift the baseline of a run, relative to
// the run of preceding run.
//
// <picture> <source srcset="baseline-shift-dark.png"
// media="(prefers-color-scheme: dark)"> <img alt="Baseline Shift"
// src="baseline-shift-light.png"> </picture>.
//
// The function takes the following parameters:
//
//   - shift: either a PangoBaselineShift enumeration value or an absolute value
//     (> 1024) in Pango units, relative to the baseline of the previous run.
//     Positive values displace the text upwards.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrBaselineShift(shift int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.int(shift)

	_cret = C.pango_attr_baseline_shift_new(_arg1)
	runtime.KeepAlive(shift)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// AttrBreak: apply customization from attributes to the breaks in attrs.
//
// The line breaks are assumed to have been produced by pango.DefaultBreak() and
// pango.TailorBreak().
//
// The function takes the following parameters:
//
//   - text to break. Must be valid UTF-8.
//   - attrList: PangoAttrList to apply.
//   - offset: byte offset of text from the beginning of the paragraph.
//   - attrs: array with one PangoLogAttr per character in text, plus one extra,
//     to be filled in.
func AttrBreak(text string, attrList *AttrList, offset int, attrs []LogAttr) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 *C.PangoAttrList // out
	var _arg4 C.int            // out
	var _arg5 *C.PangoLogAttr  // out
	var _arg6 C.int

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrList)))
	_arg4 = C.int(offset)
	_arg6 = (C.int)(len(attrs))
	_arg5 = (*C.PangoLogAttr)(C.calloc(C.size_t(len(attrs)), C.size_t(C.sizeof_PangoLogAttr)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice((*C.PangoLogAttr)(_arg5), len(attrs))
		for i := range attrs {
			out[i] = *(*C.PangoLogAttr)(gextras.StructNative(unsafe.Pointer((&attrs[i]))))
		}
	}

	C.pango_attr_break(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(text)
	runtime.KeepAlive(attrList)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(attrs)
}

// NewAttrFallback: create a new font fallback attribute.
//
// If fallback is disabled, characters will only be used from the closest
// matching font on the system. No fallback will be done to other fonts on the
// system that might contain the characters in the text.
//
// The function takes the following parameters:
//
//   - enableFallback: TRUE if we should fall back on other fonts for characters
//     the active font is missing.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrFallback(enableFallback bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if enableFallback {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_fallback_new(_arg1)
	runtime.KeepAlive(enableFallback)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrFamily: create a new font family attribute.
//
// The function takes the following parameters:
//
//   - family or comma-separated list of families.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrFamily(family string) *Attribute {
	var _arg1 *C.char           // out
	var _cret *C.PangoAttribute // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(family)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_attr_family_new(_arg1)
	runtime.KeepAlive(family)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrFontScale: create a new font scale attribute.
//
// The effect of this attribute is to change the font size of a run, relative to
// the size of preceding run.
//
// The function takes the following parameters:
//
//   - scale: PangoFontScale value, which indicates font size change relative to
//     the size of the previous run.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrFontScale(scale FontScale) *Attribute {
	var _arg1 C.PangoFontScale  // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoFontScale(scale)

	_cret = C.pango_attr_font_scale_new(_arg1)
	runtime.KeepAlive(scale)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrForegroundAlpha: create a new foreground alpha attribute.
//
// The function takes the following parameters:
//
//   - alpha value, between 1 and 65536.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrForegroundAlpha(alpha uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.guint16(alpha)

	_cret = C.pango_attr_foreground_alpha_new(_arg1)
	runtime.KeepAlive(alpha)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrForeground: create a new foreground color attribute.
//
// The function takes the following parameters:
//
//   - red value (ranging from 0 to 65535).
//   - green value.
//   - blue value.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrForeground(red, green, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.guint16(red)
	_arg2 = C.guint16(green)
	_arg3 = C.guint16(blue)

	_cret = C.pango_attr_foreground_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrGravityHint: create a new gravity hint attribute.
//
// The function takes the following parameters:
//
//   - hint: gravity hint value.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrGravityHint(hint GravityHint) *Attribute {
	var _arg1 C.PangoGravityHint // out
	var _cret *C.PangoAttribute  // in

	_arg1 = C.PangoGravityHint(hint)

	_cret = C.pango_attr_gravity_hint_new(_arg1)
	runtime.KeepAlive(hint)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrGravity: create a new gravity attribute.
//
// The function takes the following parameters:
//
//   - gravity value; should not be PANGO_GRAVITY_AUTO.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrGravity(gravity Gravity) *Attribute {
	var _arg1 C.PangoGravity    // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoGravity(gravity)

	_cret = C.pango_attr_gravity_new(_arg1)
	runtime.KeepAlive(gravity)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrInsertHyphens: create a new insert-hyphens attribute.
//
// Pango will insert hyphens when breaking lines in the middle of a word.
// This attribute can be used to suppress the hyphen.
//
// The function takes the following parameters:
//
//   - insertHyphens: TRUE if hyphens should be inserted.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrInsertHyphens(insertHyphens bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if insertHyphens {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_insert_hyphens_new(_arg1)
	runtime.KeepAlive(insertHyphens)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrLetterSpacing: create a new letter-spacing attribute.
//
// The function takes the following parameters:
//
//   - letterSpacing: amount of extra space to add between graphemes of the
//     text, in Pango units.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrLetterSpacing(letterSpacing int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.int(letterSpacing)

	_cret = C.pango_attr_letter_spacing_new(_arg1)
	runtime.KeepAlive(letterSpacing)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrLineHeight: modify the height of logical line extents by a factor.
//
// This affects the values returned by pango.LayoutLine.GetExtents(),
// pango.LayoutLine.GetPixelExtents() and pango.LayoutIter.GetLineExtents().
//
// The function takes the following parameters:
//
//   - factor: scaling factor to apply to the logical height.
func NewAttrLineHeight(factor float64) *Attribute {
	var _arg1 C.double          // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.double(factor)

	_cret = C.pango_attr_line_height_new(_arg1)
	runtime.KeepAlive(factor)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// AttrLineHeightNewAbsolute: override the height of logical line extents to be
// height.
//
// This affects the values returned by pango.LayoutLine.GetExtents(),
// pango.LayoutLine.GetPixelExtents() and pango.LayoutIter.GetLineExtents().
//
// The function takes the following parameters:
//
//   - height: line height, in PANGO_SCALE-ths of a point.
func AttrLineHeightNewAbsolute(height int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.int(height)

	_cret = C.pango_attr_line_height_new_absolute(_arg1)
	runtime.KeepAlive(height)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrOverlineColor: create a new overline color attribute.
//
// This attribute modifies the color of overlines. If not set, overlines will
// use the foreground color.
//
// The function takes the following parameters:
//
//   - red value (ranging from 0 to 65535).
//   - green value.
//   - blue value.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrOverlineColor(red, green, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.guint16(red)
	_arg2 = C.guint16(green)
	_arg3 = C.guint16(blue)

	_cret = C.pango_attr_overline_color_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrOverline: create a new overline-style attribute.
//
// The function takes the following parameters:
//
//   - overline style.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrOverline(overline Overline) *Attribute {
	var _arg1 C.PangoOverline   // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoOverline(overline)

	_cret = C.pango_attr_overline_new(_arg1)
	runtime.KeepAlive(overline)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrRise: create a new baseline displacement attribute.
//
// The function takes the following parameters:
//
//   - rise: amount that the text should be displaced vertically, in Pango
//     units. Positive values displace the text upwards.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrRise(rise int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.int(rise)

	_cret = C.pango_attr_rise_new(_arg1)
	runtime.KeepAlive(rise)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrScale: create a new font size scale attribute.
//
// The base font for the affected text will have its size multiplied by
// scale_factor.
//
// The function takes the following parameters:
//
//   - scaleFactor: factor to scale the font.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrScale(scaleFactor float64) *Attribute {
	var _arg1 C.double          // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.double(scaleFactor)

	_cret = C.pango_attr_scale_new(_arg1)
	runtime.KeepAlive(scaleFactor)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrSentence marks the range of the attribute as a single sentence.
//
// Note that this may require adjustments to word and sentence classification
// around the range.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrSentence() *Attribute {
	var _cret *C.PangoAttribute // in

	_cret = C.pango_attr_sentence_new()

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrShow: create a new attribute that influences how invisible characters
// are rendered.
//
// The function takes the following parameters:
//
//   - flags: PangoShowFlags to apply.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrShow(flags ShowFlags) *Attribute {
	var _arg1 C.PangoShowFlags  // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoShowFlags(flags)

	_cret = C.pango_attr_show_new(_arg1)
	runtime.KeepAlive(flags)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrStretch: create a new font stretch attribute.
//
// The function takes the following parameters:
//
//   - stretch: stretch.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrStretch(stretch Stretch) *Attribute {
	var _arg1 C.PangoStretch    // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoStretch(stretch)

	_cret = C.pango_attr_stretch_new(_arg1)
	runtime.KeepAlive(stretch)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrStrikethroughColor: create a new strikethrough color attribute.
//
// This attribute modifies the color of strikethrough lines. If not set,
// strikethrough lines will use the foreground color.
//
// The function takes the following parameters:
//
//   - red value (ranging from 0 to 65535).
//   - green value.
//   - blue value.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrStrikethroughColor(red, green, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.guint16(red)
	_arg2 = C.guint16(green)
	_arg3 = C.guint16(blue)

	_cret = C.pango_attr_strikethrough_color_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrStrikethrough: create a new strike-through attribute.
//
// The function takes the following parameters:
//
//   - strikethrough: TRUE if the text should be struck-through.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrStrikethrough(strikethrough bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if strikethrough {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_strikethrough_new(_arg1)
	runtime.KeepAlive(strikethrough)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrStyle: create a new font slant style attribute.
//
// The function takes the following parameters:
//
//   - style: slant style.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrStyle(style Style) *Attribute {
	var _arg1 C.PangoStyle      // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoStyle(style)

	_cret = C.pango_attr_style_new(_arg1)
	runtime.KeepAlive(style)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrTextTransform: create a new attribute that influences how characters
// are transformed during shaping.
//
// The function takes the following parameters:
//
//   - transform: PangoTextTransform to apply.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrTextTransform(transform TextTransform) *Attribute {
	var _arg1 C.PangoTextTransform // out
	var _cret *C.PangoAttribute    // in

	_arg1 = C.PangoTextTransform(transform)

	_cret = C.pango_attr_text_transform_new(_arg1)
	runtime.KeepAlive(transform)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrUnderlineColor: create a new underline color attribute.
//
// This attribute modifies the color of underlines. If not set, underlines will
// use the foreground color.
//
// The function takes the following parameters:
//
//   - red value (ranging from 0 to 65535).
//   - green value.
//   - blue value.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrUnderlineColor(red, green, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.guint16(red)
	_arg2 = C.guint16(green)
	_arg3 = C.guint16(blue)

	_cret = C.pango_attr_underline_color_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrUnderline: create a new underline-style attribute.
//
// The function takes the following parameters:
//
//   - underline style.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrUnderline(underline Underline) *Attribute {
	var _arg1 C.PangoUnderline  // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoUnderline(underline)

	_cret = C.pango_attr_underline_new(_arg1)
	runtime.KeepAlive(underline)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrVariant: create a new font variant attribute (normal or small caps).
//
// The function takes the following parameters:
//
//   - variant: variant.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrVariant(variant Variant) *Attribute {
	var _arg1 C.PangoVariant    // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoVariant(variant)

	_cret = C.pango_attr_variant_new(_arg1)
	runtime.KeepAlive(variant)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrWeight: create a new font weight attribute.
//
// The function takes the following parameters:
//
//   - weight: weight.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrWeight(weight Weight) *Attribute {
	var _arg1 C.PangoWeight     // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.PangoWeight(weight)

	_cret = C.pango_attr_weight_new(_arg1)
	runtime.KeepAlive(weight)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrWord marks the range of the attribute as a single word.
//
// Note that this may require adjustments to word and sentence classification
// around the range.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrWord() *Attribute {
	var _cret *C.PangoAttribute // in

	_cret = C.pango_attr_word_new()

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// Break determines possible line, word, and character breaks for a string of
// Unicode text with a single analysis.
//
// For most purposes you may want to use pango.GetLogAttrs().
//
// Deprecated: Use pango.DefaultBreak(), pango.TailorBreak() and
// pango.AttrBreak().
//
// The function takes the following parameters:
//
//   - text to process. Must be valid UTF-8.
//   - analysis: PangoAnalysis structure for text.
//   - attrs: array to store character information in.
func Break(text string, analysis *Analysis, attrs []LogAttr) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 *C.PangoAnalysis // out
	var _arg4 *C.PangoLogAttr  // out
	var _arg5 C.int

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	_arg5 = (C.int)(len(attrs))
	_arg4 = (*C.PangoLogAttr)(C.calloc(C.size_t(len(attrs)), C.size_t(C.sizeof_PangoLogAttr)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.PangoLogAttr)(_arg4), len(attrs))
		for i := range attrs {
			out[i] = *(*C.PangoLogAttr)(gextras.StructNative(unsafe.Pointer((&attrs[i]))))
		}
	}

	C.pango_break(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(text)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(attrs)
}

// DefaultBreak: this is the default break algorithm.
//
// It applies rules from the Unicode Line Breaking Algorithm
// (http://www.unicode.org/unicode/reports/tr14/) without language-specific
// tailoring, therefore the analyis argument is unused and can be NULL.
//
// See pango.TailorBreak() for language-specific breaks.
//
// See pango.AttrBreak() for attribute-based customization.
//
// The function takes the following parameters:
//
//   - text to break. Must be valid UTF-8.
//   - analysis (optional): PangoAnalysis structure for the text.
//   - attrs: logical attributes to fill in.
//   - attrsLen: size of the array passed as attrs.
func DefaultBreak(text string, analysis *Analysis, attrs *LogAttr, attrsLen int) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 *C.PangoAnalysis // out
	var _arg4 *C.PangoLogAttr  // out
	var _arg5 C.int            // out

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	if analysis != nil {
		_arg3 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	}
	_arg4 = (*C.PangoLogAttr)(gextras.StructNative(unsafe.Pointer(attrs)))
	_arg5 = C.int(attrsLen)

	C.pango_default_break(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(text)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(attrs)
	runtime.KeepAlive(attrsLen)
}

// ExtentsToPixels converts extents from Pango units to device units.
//
// The conversion is done by dividing by the PANGO_SCALE factor and performing
// rounding.
//
// The inclusive rectangle is converted by flooring the x/y coordinates and
// extending width/height, such that the final rectangle completely includes the
// original rectangle.
//
// The nearest rectangle is converted by rounding the coordinates of the
// rectangle to the nearest device unit (pixel).
//
// The rule to which argument to use is: if you want the resulting device-space
// rectangle to completely contain the original rectangle, pass it in as
// inclusive. If you want two touching-but-not-overlapping rectangles stay
// touching-but-not-overlapping after rounding to device units, pass them in as
// nearest.
//
// The function takes the following parameters:
//
//   - inclusive (optional): rectangle to round to pixels inclusively.
//   - nearest (optional): rectangle to round to nearest pixels.
func ExtentsToPixels(inclusive, nearest *Rectangle) {
	var _arg1 *C.PangoRectangle // out
	var _arg2 *C.PangoRectangle // out

	if inclusive != nil {
		_arg1 = (*C.PangoRectangle)(gextras.StructNative(unsafe.Pointer(inclusive)))
	}
	if nearest != nil {
		_arg2 = (*C.PangoRectangle)(gextras.StructNative(unsafe.Pointer(nearest)))
	}

	C.pango_extents_to_pixels(_arg1, _arg2)
	runtime.KeepAlive(inclusive)
	runtime.KeepAlive(nearest)
}

// FindBaseDir searches a string the first character that has a strong
// direction, according to the Unicode bidirectional algorithm.
//
// The function takes the following parameters:
//
//   - text to process. Must be valid UTF-8.
//
// The function returns the following values:
//
//   - direction corresponding to the first strong character. If no such
//     character is found, then PANGO_DIRECTION_NEUTRAL is returned.
func FindBaseDir(text string) Direction {
	var _arg1 *C.gchar // out
	var _arg2 C.gint
	var _cret C.PangoDirection // in

	_arg2 = (C.gint)(len(text))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_find_base_dir(_arg1, _arg2)
	runtime.KeepAlive(text)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// FindParagraphBoundary locates a paragraph boundary in text.
//
// A boundary is caused by delimiter characters, such as a newline, carriage
// return, carriage return-newline pair, or Unicode paragraph separator
// character.
//
// The index of the run of delimiters is returned in paragraph_delimiter_index.
// The index of the start of the next paragraph (index after all delimiters) is
// stored n next_paragraph_start.
//
// If no delimiters are found, both paragraph_delimiter_index and
// next_paragraph_start are filled with the length of text (an index one off the
// end).
//
// The function takes the following parameters:
//
//   - text: UTF-8 text.
//
// The function returns the following values:
//
//   - paragraphDelimiterIndex: return location for index of delimiter.
//   - nextParagraphStart: return location for start of next paragraph.
func FindParagraphBoundary(text string) (paragraphDelimiterIndex, nextParagraphStart int) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 C.int // in
	var _arg4 C.int // in

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_find_paragraph_boundary(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(text)

	var _paragraphDelimiterIndex int // out
	var _nextParagraphStart int      // out

	_paragraphDelimiterIndex = int(_arg3)
	_nextParagraphStart = int(_arg4)

	return _paragraphDelimiterIndex, _nextParagraphStart
}

// GetLogAttrs computes a PangoLogAttr for each character in text.
//
// The attrs array must have one PangoLogAttr for each position in text; if text
// contains N characters, it has N+1 positions, including the last position at
// the end of the text. text should be an entire paragraph; logical attributes
// can't be computed without context (for example you need to see spaces on
// either side of a word to know the word is a word).
//
// The function takes the following parameters:
//
//   - text to process. Must be valid UTF-8.
//   - level: embedding level, or -1 if unknown.
//   - language tag.
//   - attrs: array with one PangoLogAttr per character in text, plus one extra,
//     to be filled in.
func GetLogAttrs(text string, level int, language *Language, attrs []LogAttr) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 C.int            // out
	var _arg4 *C.PangoLanguage // out
	var _arg5 *C.PangoLogAttr  // out
	var _arg6 C.int

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.int(level)
	_arg4 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	_arg6 = (C.int)(len(attrs))
	_arg5 = (*C.PangoLogAttr)(C.calloc(C.size_t(len(attrs)), C.size_t(C.sizeof_PangoLogAttr)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice((*C.PangoLogAttr)(_arg5), len(attrs))
		for i := range attrs {
			out[i] = *(*C.PangoLogAttr)(gextras.StructNative(unsafe.Pointer((&attrs[i]))))
		}
	}

	C.pango_get_log_attrs(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(text)
	runtime.KeepAlive(level)
	runtime.KeepAlive(language)
	runtime.KeepAlive(attrs)
}

// GetMirrorChar returns the mirrored character of a Unicode character.
//
// Mirror characters are determined by the Unicode mirrored property.
//
// Deprecated: Use glib.UnicharGetMirrorChar() instead; the docs for that
// function provide full details.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//   - mirroredCh: location to store the mirrored character.
//
// The function returns the following values:
//
//   - ok: TRUE if ch has a mirrored character and mirrored_ch is filled in,
//     FALSE otherwise.
func GetMirrorChar(ch uint32, mirroredCh *uint32) bool {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gunichar // out
	var _cret C.gboolean  // in

	_arg1 = C.gunichar(ch)
	_arg2 = (*C.gunichar)(unsafe.Pointer(mirroredCh))

	_cret = C.pango_get_mirror_char(_arg1, _arg2)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(mirroredCh)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsZeroWidth checks if a character that should not be normally rendered.
//
// This includes all Unicode characters with "ZERO WIDTH" in their name, as well
// as *bidi* formatting characters, and a few other ones.
//
// This is totally different from glib.UnicharIszerowidth() and is at best
// misnamed.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if ch is a zero-width character, FALSE otherwise.
func IsZeroWidth(ch uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.pango_is_zero_width(_arg1)
	runtime.KeepAlive(ch)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Itemize breaks a piece of text into segments with consistent directional
// level and font.
//
// Each byte of text will be contained in exactly one of the items in the
// returned list; the generated list of items will be in logical order (the
// start offsets of the items are ascending).
//
// cached_iter should be an iterator over attrs currently positioned at a range
// before or containing start_index; cached_iter will be advanced to the range
// covering the position just after start_index + length. (i.e. if itemizing in
// a loop, just keep passing in the same cached_iter).
//
// The function takes the following parameters:
//
//   - context: structure holding information that affects the itemization
//     process.
//   - text to itemize. Must be valid UTF-8.
//   - startIndex: first byte in text to process.
//   - length: number of bytes (not characters) to process after start_index.
//     This must be >= 0.
//   - attrs: set of attributes that apply to text.
//   - cachedIter (optional): cached attribute iterator.
//
// The function returns the following values:
//
//   - list: GList of pango.Item structures. The items should be freed using
//     pango.Item.Free() in combination with glib.List().FreeFull.
func Itemize(context *Context, text string, startIndex, length int, attrs *AttrList, cachedIter *AttrIterator) []*Item {
	var _arg1 *C.PangoContext      // out
	var _arg2 *C.char              // out
	var _arg3 C.int                // out
	var _arg4 C.int                // out
	var _arg5 *C.PangoAttrList     // out
	var _arg6 *C.PangoAttrIterator // out
	var _cret *C.GList             // in

	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(startIndex)
	_arg4 = C.int(length)
	_arg5 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	if cachedIter != nil {
		_arg6 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(cachedIter)))
	}

	_cret = C.pango_itemize(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(startIndex)
	runtime.KeepAlive(length)
	runtime.KeepAlive(attrs)
	runtime.KeepAlive(cachedIter)

	var _list []*Item // out

	_list = make([]*Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.PangoItem)(v)
		var dst *Item // out
		dst = (*Item)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_item_free((*C.PangoItem)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// ItemizeWithBaseDir: like pango_itemize(), but with an explicitly specified
// base direction.
//
// The base direction is used when computing bidirectional levels. itemize gets
// the base direction from the PangoContext (see pango.Context.SetBaseDir()).
//
// The function takes the following parameters:
//
//   - context: structure holding information that affects the itemization
//     process.
//   - baseDir: base direction to use for bidirectional processing.
//   - text to itemize.
//   - startIndex: first byte in text to process.
//   - length: number of bytes (not characters) to process after start_index.
//     This must be >= 0.
//   - attrs: set of attributes that apply to text.
//   - cachedIter (optional): cached attribute iterator.
//
// The function returns the following values:
//
//   - list: GList of pango.Item structures. The items should be freed using
//     pango.Item.Free() probably in combination with glib.List().FreeFull.
func ItemizeWithBaseDir(context *Context, baseDir Direction, text string, startIndex, length int, attrs *AttrList, cachedIter *AttrIterator) []*Item {
	var _arg1 *C.PangoContext      // out
	var _arg2 C.PangoDirection     // out
	var _arg3 *C.char              // out
	var _arg4 C.int                // out
	var _arg5 C.int                // out
	var _arg6 *C.PangoAttrList     // out
	var _arg7 *C.PangoAttrIterator // out
	var _cret *C.GList             // in

	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.PangoDirection(baseDir)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.int(startIndex)
	_arg5 = C.int(length)
	_arg6 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	if cachedIter != nil {
		_arg7 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(cachedIter)))
	}

	_cret = C.pango_itemize_with_base_dir(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(context)
	runtime.KeepAlive(baseDir)
	runtime.KeepAlive(text)
	runtime.KeepAlive(startIndex)
	runtime.KeepAlive(length)
	runtime.KeepAlive(attrs)
	runtime.KeepAlive(cachedIter)

	var _list []*Item // out

	_list = make([]*Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.PangoItem)(v)
		var dst *Item // out
		dst = (*Item)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_item_free((*C.PangoItem)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// Log2VisGetEmbeddingLevels: return the bidirectional embedding levels of the
// input paragraph.
//
// The bidirectional embedding levels are defined by the [Unicode Bidirectional
// Algorithm](http://www.unicode.org/reports/tr9/).
//
// If the input base direction is a weak direction, the direction of the
// characters in the text will determine the final resolved direction.
//
// The function takes the following parameters:
//
//   - text to itemize.
//   - pbaseDir: input base direction, and output resolved direction.
//
// The function returns the following values:
//
//   - guint8: newly allocated array of embedding levels, one item per character
//     (not byte), that should be freed using glib.Free().
func Log2VisGetEmbeddingLevels(text string, pbaseDir *Direction) *byte {
	var _arg1 *C.gchar // out
	var _arg2 C.int
	var _arg3 *C.PangoDirection // out
	var _cret *C.guint8         // in

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoDirection)(unsafe.Pointer(pbaseDir))

	_cret = C.pango_log2vis_get_embedding_levels(_arg1, _arg2, _arg3)
	runtime.KeepAlive(text)
	runtime.KeepAlive(pbaseDir)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// MarkupParserFinish finishes parsing markup.
//
// After feeding a Pango markup parser some data with
// glib.MarkupParseContext.Parse(), use this function to get the list of
// attributes and text out of the markup. This function will not free context,
// use glib.MarkupParseContext.Free() to do so.
//
// The function takes the following parameters:
//
//   - context: valid parse context that was returned from markup_parser_new.
//
// The function returns the following values:
//
//   - attrList (optional) address of return location for a PangoAttrList.
//   - text (optional) address of return location for text with tags stripped.
//   - accelChar (optional) address of return location for accelerator char.
func MarkupParserFinish(context *glib.MarkupParseContext) (*AttrList, string, uint32, error) {
	var _arg1 *C.GMarkupParseContext // out
	var _arg2 *C.PangoAttrList       // in
	var _arg3 *C.char                // in
	var _arg4 C.gunichar             // in
	var _cerr *C.GError              // in

	_arg1 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.pango_markup_parser_finish(_arg1, &_arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(context)

	var _attrList *AttrList // out
	var _text string        // out
	var _accelChar uint32   // out
	var _goerr error        // out

	if _arg2 != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}
	if _arg3 != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_accelChar = uint32(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _attrList, _text, _accelChar, _goerr
}

// NewMarkupParser: incrementally parses marked-up text to create a plain-text
// string and an attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in accel_char, when calling markup_parser_finish. Two accel_marker
// characters following each other produce a single literal accel_marker
// character.
//
// To feed markup to the parser, use glib.MarkupParseContext.Parse() on the
// returned glib.MarkupParseContext. When done with feeding markup to the
// parser, use markup_parser_finish to get the data out of it, and then use
// glib.MarkupParseContext.Free() to free it.
//
// This function is designed for applications that read Pango markup
// from streams. To simply parse a string containing Pango markup, the
// pango.ParseMarkup() API is recommended instead.
//
// The function takes the following parameters:
//
//   - accelMarker: character that precedes an accelerator, or 0 for none.
//
// The function returns the following values:
//
//   - markupParseContext: GMarkupParseContext that should be destroyed with
//     glib.MarkupParseContext.Free().
func NewMarkupParser(accelMarker uint32) *glib.MarkupParseContext {
	var _arg1 C.gunichar             // out
	var _cret *C.GMarkupParseContext // in

	_arg1 = C.gunichar(accelMarker)

	_cret = C.pango_markup_parser_new(_arg1)
	runtime.KeepAlive(accelMarker)

	var _markupParseContext *glib.MarkupParseContext // out

	_markupParseContext = (*glib.MarkupParseContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_markup_parse_context_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_markupParseContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_markup_parse_context_unref((*C.GMarkupParseContext)(intern.C))
		},
	)

	return _markupParseContext
}

// ParseEnum parses an enum type and stores the result in value.
//
// If str does not match the nick name of any of the possible values for the
// enum and is not an integer, FALSE is returned, a warning is issued if warn
// is TRUE, and a string representing the list of possible values is stored in
// possible_values. The list is slash-separated, eg. "none/start/middle/end".
//
// If failed and possible_values is not NULL, returned string should be freed
// using g_free().
//
// Deprecated: since version 1.38.
//
// The function takes the following parameters:
//
//   - typ: enum type to parse, eg. PANGO_TYPE_ELLIPSIZE_MODE.
//   - str (optional): string to parse.
//   - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//   - value (optional): integer to store the result in.
//   - possibleValues (optional): place to store list of possible values on
//     failure.
//   - ok: TRUE if str was successfully parsed.
func ParseEnum(typ coreglib.Type, str string, warn bool) (int, string, bool) {
	var _arg1 C.GType    // out
	var _arg2 *C.char    // out
	var _arg3 C.int      // in
	var _arg4 C.gboolean // out
	var _arg5 *C.char    // in
	var _cret C.gboolean // in

	_arg1 = C.GType(typ)
	if str != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if warn {
		_arg4 = C.TRUE
	}

	_cret = C.pango_parse_enum(_arg1, _arg2, &_arg3, _arg4, &_arg5)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _value int             // out
	var _possibleValues string // out
	var _ok bool               // out

	_value = int(_arg3)
	if _arg5 != nil {
		_possibleValues = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _cret != 0 {
		_ok = true
	}

	return _value, _possibleValues, _ok
}

// ParseMarkup parses marked-up text to create a plain-text string and an
// attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in accel_char. Two accel_marker characters following each other
// produce a single literal accel_marker character.
//
// To parse a stream of pango markup incrementally, use markup_parser_new.
//
// If any error happens, none of the output arguments are touched except for
// error.
//
// The function takes the following parameters:
//
//   - markupText: markup to parse (see the Pango Markup (pango_markup.html)
//     docs).
//   - accelMarker: character that precedes an accelerator, or 0 for none.
//
// The function returns the following values:
//
//   - attrList (optional) address of return location for a PangoAttrList.
//   - text (optional) address of return location for text with tags stripped.
//   - accelChar (optional) address of return location for accelerator char.
func ParseMarkup(markupText string, accelMarker uint32) (*AttrList, string, uint32, error) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 C.gunichar       // out
	var _arg4 *C.PangoAttrList // in
	var _arg5 *C.char          // in
	var _arg6 C.gunichar       // in
	var _cerr *C.GError        // in

	_arg2 = (C.int)(len(markupText))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(markupText) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(markupText)), markupText)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gunichar(accelMarker)

	C.pango_parse_markup(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_cerr)
	runtime.KeepAlive(markupText)
	runtime.KeepAlive(accelMarker)

	var _attrList *AttrList // out
	var _text string        // out
	var _accelChar uint32   // out
	var _goerr error        // out

	if _arg4 != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_arg4)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}
	if _arg5 != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	_accelChar = uint32(_arg6)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _attrList, _text, _accelChar, _goerr
}

// ParseStretch parses a font stretch.
//
// The allowed values are "ultra_condensed", "extra_condensed", "condensed",
// "semi_condensed", "normal", "semi_expanded", "expanded", "extra_expanded" and
// "ultra_expanded". Case variations are ignored and the '_' characters may be
// omitted.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//   - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//   - stretch: PangoStretch to store the result in.
//   - ok: TRUE if str was successfully parsed.
func ParseStretch(str string, warn bool) (Stretch, bool) {
	var _arg1 *C.char        // out
	var _arg2 C.PangoStretch // in
	var _arg3 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_stretch(_arg1, &_arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _stretch Stretch // out
	var _ok bool         // out

	_stretch = Stretch(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _stretch, _ok
}

// ParseStyle parses a font style.
//
// The allowed values are "normal", "italic" and "oblique", case variations
// being ignored.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//   - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//   - style: PangoStyle to store the result in.
//   - ok: TRUE if str was successfully parsed.
func ParseStyle(str string, warn bool) (Style, bool) {
	var _arg1 *C.char      // out
	var _arg2 C.PangoStyle // in
	var _arg3 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_style(_arg1, &_arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _style Style // out
	var _ok bool     // out

	_style = Style(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _style, _ok
}

// ParseVariant parses a font variant.
//
// The allowed values are "normal", "small-caps", "all-small-caps",
// "petite-caps", "all-petite-caps", "unicase" and "title-caps", case variations
// being ignored.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//   - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//   - variant: PangoVariant to store the result in.
//   - ok: TRUE if str was successfully parsed.
func ParseVariant(str string, warn bool) (Variant, bool) {
	var _arg1 *C.char        // out
	var _arg2 C.PangoVariant // in
	var _arg3 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_variant(_arg1, &_arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _variant Variant // out
	var _ok bool         // out

	_variant = Variant(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _variant, _ok
}

// ParseWeight parses a font weight.
//
// The allowed values are "heavy", "ultrabold", "bold", "normal", "light",
// "ultraleight" and integers. Case variations are ignored.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//   - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//   - weight: PangoWeight to store the result in.
//   - ok: TRUE if str was successfully parsed.
func ParseWeight(str string, warn bool) (Weight, bool) {
	var _arg1 *C.char       // out
	var _arg2 C.PangoWeight // in
	var _arg3 C.gboolean    // out
	var _cret C.gboolean    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_weight(_arg1, &_arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _weight Weight // out
	var _ok bool       // out

	_weight = Weight(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _weight, _ok
}

// ReorderItems: reorder items from logical order to visual order.
//
// The visual order is determined from the associated directional levels of the
// items. The original list is unmodified.
//
// (Please open a bug if you use this function. It is not a particularly
// convenient interface, and the code is duplicated elsewhere in Pango for that
// reason.).
//
// The function takes the following parameters:
//
//   - items: GList of PangoItem in logical order.
//
// The function returns the following values:
//
//   - list: GList of PangoItem structures in visual order.
func ReorderItems(items []*Item) []*Item {
	var _arg1 *C.GList // out
	var _cret *C.GList // in

	for i := len(items) - 1; i >= 0; i-- {
		src := items[i]
		var dst *C.PangoItem // out
		dst = (*C.PangoItem)(gextras.StructNative(unsafe.Pointer(src)))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	_cret = C.pango_reorder_items(_arg1)
	runtime.KeepAlive(items)

	var _list []*Item // out

	_list = make([]*Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.PangoItem)(v)
		var dst *Item // out
		dst = (*Item)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_item_free((*C.PangoItem)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// Shape: convert the characters in text into glyphs.
//
// Given a segment of text and the corresponding PangoAnalysis structure
// returned from pango.Itemize(), convert the characters into glyphs. You may
// also pass in only a substring of the item from pango.Itemize().
//
// It is recommended that you use pango.ShapeFull() instead, since that API
// allows for shaping interaction happening across text item boundaries.
//
// Some aspects of hyphen insertion and text transformation (in particular,
// capitalization) require log attrs, and thus can only be handled by
// pango.ShapeItem().
//
// Note that the extra attributes in the analyis that is returned from
// pango.Itemize() have indices that are relative to the entire paragraph,
// so you need to subtract the item offset from their indices before calling
// pango.Shape().
//
// The function takes the following parameters:
//
//   - text to process.
//   - analysis: PangoAnalysis structure from pango.Itemize().
//   - glyphs: glyph string in which to store results.
func Shape(text string, analysis *Analysis, glyphs *GlyphString) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 *C.PangoAnalysis    // out
	var _arg4 *C.PangoGlyphString // out

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	_arg4 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))

	C.pango_shape(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(text)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(glyphs)
}

// ShapeFull: convert the characters in text into glyphs.
//
// Given a segment of text and the corresponding PangoAnalysis structure
// returned from pango.Itemize(), convert the characters into glyphs. You may
// also pass in only a substring of the item from pango.Itemize().
//
// This is similar to pango.Shape(), except it also can optionally take the
// full paragraph text as input, which will then be used to perform certain
// cross-item shaping interactions. If you have access to the broader text of
// which item_text is part of, provide the broader text as paragraph_text.
// If paragraph_text is NULL, item text is used instead.
//
// Some aspects of hyphen insertion and text transformation (in particular,
// capitalization) require log attrs, and thus can only be handled by
// pango.ShapeItem().
//
// Note that the extra attributes in the analyis that is returned from
// pango.Itemize() have indices that are relative to the entire paragraph,
// so you do not pass the full paragraph text as paragraph_text, you need to
// subtract the item offset from their indices before calling pango.ShapeFull().
//
// The function takes the following parameters:
//
//   - itemText: valid UTF-8 text to shape.
//   - itemLength: length (in bytes) of item_text. -1 means nul-terminated text.
//   - paragraphText (optional): text of the paragraph (see details).
//   - paragraphLength: length (in bytes) of paragraph_text. -1 means
//     nul-terminated text.
//   - analysis: PangoAnalysis structure from pango.Itemize().
//   - glyphs: glyph string in which to store results.
func ShapeFull(itemText string, itemLength int, paragraphText string, paragraphLength int, analysis *Analysis, glyphs *GlyphString) {
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _arg3 *C.char             // out
	var _arg4 C.int               // out
	var _arg5 *C.PangoAnalysis    // out
	var _arg6 *C.PangoGlyphString // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(itemText)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(itemLength)
	if paragraphText != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(paragraphText)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.int(paragraphLength)
	_arg5 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	_arg6 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))

	C.pango_shape_full(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(itemText)
	runtime.KeepAlive(itemLength)
	runtime.KeepAlive(paragraphText)
	runtime.KeepAlive(paragraphLength)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(glyphs)
}

// ShapeItem: convert the characters in item into glyphs.
//
// This is similar to pango.ShapeWithFlags(), except it takes a PangoItem
// instead of separate item_text and analysis arguments.
//
// It also takes log_attrs, which are needed for implementing some aspects of
// hyphen insertion and text transforms (in particular, capitalization).
//
// Note that the extra attributes in the analyis that is returned from
// pango.Itemize() have indices that are relative to the entire paragraph,
// so you do not pass the full paragraph text as paragraph_text,
// you need to subtract the item offset from their indices before calling
// pango.ShapeWithFlags().
//
// The function takes the following parameters:
//
//   - item: PangoItem to shape.
//   - paragraphText (optional): text of the paragraph (see details).
//   - paragraphLength: length (in bytes) of paragraph_text. -1 means
//     nul-terminated text.
//   - logAttrs (optional): array of PangoLogAttr for item.
//   - glyphs: glyph string in which to store results.
//   - flags influencing the shaping process.
func ShapeItem(item *Item, paragraphText string, paragraphLength int, logAttrs *LogAttr, glyphs *GlyphString, flags ShapeFlags) {
	var _arg1 *C.PangoItem        // out
	var _arg2 *C.char             // out
	var _arg3 C.int               // out
	var _arg4 *C.PangoLogAttr     // out
	var _arg5 *C.PangoGlyphString // out
	var _arg6 C.PangoShapeFlags   // out

	_arg1 = (*C.PangoItem)(gextras.StructNative(unsafe.Pointer(item)))
	if paragraphText != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(paragraphText)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.int(paragraphLength)
	if logAttrs != nil {
		_arg4 = (*C.PangoLogAttr)(gextras.StructNative(unsafe.Pointer(logAttrs)))
	}
	_arg5 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg6 = C.PangoShapeFlags(flags)

	C.pango_shape_item(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(item)
	runtime.KeepAlive(paragraphText)
	runtime.KeepAlive(paragraphLength)
	runtime.KeepAlive(logAttrs)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(flags)
}

// ShapeWithFlags: convert the characters in text into glyphs.
//
// Given a segment of text and the corresponding PangoAnalysis structure
// returned from pango.Itemize(), convert the characters into glyphs. You may
// also pass in only a substring of the item from pango.Itemize().
//
// This is similar to pango.ShapeFull(), except it also takes flags that can
// influence the shaping process.
//
// Some aspects of hyphen insertion and text transformation (in particular,
// capitalization) require log attrs, and thus can only be handled by
// pango.ShapeItem().
//
// Note that the extra attributes in the analyis that is returned from
// pango.Itemize() have indices that are relative to the entire paragraph,
// so you do not pass the full paragraph text as paragraph_text,
// you need to subtract the item offset from their indices before calling
// pango.ShapeWithFlags().
//
// The function takes the following parameters:
//
//   - itemText: valid UTF-8 text to shape.
//   - itemLength: length (in bytes) of item_text. -1 means nul-terminated text.
//   - paragraphText (optional): text of the paragraph (see details).
//   - paragraphLength: length (in bytes) of paragraph_text. -1 means
//     nul-terminated text.
//   - analysis: PangoAnalysis structure from pango.Itemize().
//   - glyphs: glyph string in which to store results.
//   - flags influencing the shaping process.
func ShapeWithFlags(itemText string, itemLength int, paragraphText string, paragraphLength int, analysis *Analysis, glyphs *GlyphString, flags ShapeFlags) {
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _arg3 *C.char             // out
	var _arg4 C.int               // out
	var _arg5 *C.PangoAnalysis    // out
	var _arg6 *C.PangoGlyphString // out
	var _arg7 C.PangoShapeFlags   // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(itemText)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(itemLength)
	if paragraphText != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(paragraphText)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.int(paragraphLength)
	_arg5 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	_arg6 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg7 = C.PangoShapeFlags(flags)

	C.pango_shape_with_flags(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(itemText)
	runtime.KeepAlive(itemLength)
	runtime.KeepAlive(paragraphText)
	runtime.KeepAlive(paragraphLength)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(flags)
}

// SplitFileList splits a G_SEARCHPATH_SEPARATOR-separated list of files,
// stripping white space and substituting ~/ with $HOME/.
//
// Deprecated: since version 1.38.
//
// The function takes the following parameters:
//
//   - str: G_SEARCHPATH_SEPARATOR separated list of filenames.
//
// The function returns the following values:
//
//   - utf8s: list of strings to be freed with g_strfreev().
func SplitFileList(str string) []string {
	var _arg1 *C.char  // out
	var _cret **C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_split_file_list(_arg1)
	runtime.KeepAlive(str)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// TailorBreak: apply language-specific tailoring to the breaks in attrs.
//
// The line breaks are assumed to have been produced by pango.DefaultBreak().
//
// If offset is not -1, it is used to apply attributes from analysis that are
// relevant to line breaking.
//
// Note that it is better to pass -1 for offset and use pango.AttrBreak() to
// apply attributes to the whole paragraph.
//
// The function takes the following parameters:
//
//   - text to process. Must be valid UTF-8.
//   - analysis: PangoAnalysis for text.
//   - offset: byte offset of text from the beginning of the paragraph, or -1 to
//     ignore attributes from analysis.
//   - attrs: array with one PangoLogAttr per character in text, plus one extra,
//     to be filled in.
func TailorBreak(text string, analysis *Analysis, offset int, attrs []LogAttr) {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _arg3 *C.PangoAnalysis // out
	var _arg4 C.int            // out
	var _arg5 *C.PangoLogAttr  // out
	var _arg6 C.int

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	_arg4 = C.int(offset)
	_arg6 = (C.int)(len(attrs))
	_arg5 = (*C.PangoLogAttr)(C.calloc(C.size_t(len(attrs)), C.size_t(C.sizeof_PangoLogAttr)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice((*C.PangoLogAttr)(_arg5), len(attrs))
		for i := range attrs {
			out[i] = *(*C.PangoLogAttr)(gextras.StructNative(unsafe.Pointer((&attrs[i]))))
		}
	}

	C.pango_tailor_break(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(text)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(attrs)
}

// TrimString trims leading and trailing whitespace from a string.
//
// Deprecated: since version 1.38.
//
// The function takes the following parameters:
//
//   - str: string.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string that must be freed with g_free().
func TrimString(str string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_trim_string(_arg1)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UnicharDirection determines the inherent direction of a character.
//
// The inherent direction is either PANGO_DIRECTION_LTR, PANGO_DIRECTION_RTL,
// or PANGO_DIRECTION_NEUTRAL.
//
// This function is useful to categorize characters into left-to-right letters,
// right-to-left letters, and everything else. If full Unicode bidirectional
// type of a character is needed, pango.BidiType().ForUnichar can be used
// instead.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - direction of the character.
func UnicharDirection(ch uint32) Direction {
	var _arg1 C.gunichar       // out
	var _cret C.PangoDirection // in

	_arg1 = C.gunichar(ch)

	_cret = C.pango_unichar_direction(_arg1)
	runtime.KeepAlive(ch)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// UnitsFromDouble converts a floating-point number to Pango units.
//
// The conversion is done by multiplying d by PANGO_SCALE and rounding the
// result to nearest integer.
//
// The function takes the following parameters:
//
//   - d: double floating-point value.
//
// The function returns the following values:
//
//   - gint: value in Pango units.
func UnitsFromDouble(d float64) int {
	var _arg1 C.double // out
	var _cret C.int    // in

	_arg1 = C.double(d)

	_cret = C.pango_units_from_double(_arg1)
	runtime.KeepAlive(d)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnitsToDouble converts a number in Pango units to floating-point.
//
// The conversion is done by dividing i by PANGO_SCALE.
//
// The function takes the following parameters:
//
//   - i: value in Pango units.
//
// The function returns the following values:
//
//   - gdouble: double value.
func UnitsToDouble(i int) float64 {
	var _arg1 C.int    // out
	var _cret C.double // in

	_arg1 = C.int(i)

	_cret = C.pango_units_to_double(_arg1)
	runtime.KeepAlive(i)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Version returns the encoded version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION except that the macro returns the
// encoded version available at compile-time. A version number can be encoded
// into an integer using PANGO_VERSION_ENCODE().
//
// The function returns the following values:
//
//   - gint: encoded version of Pango library available at run time.
func Version() int {
	var _cret C.int // in

	_cret = C.pango_version()

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VersionCheck checks that the Pango library in use is compatible with the
// given version.
//
// Generally you would pass in the constants PANGO_VERSION_MAJOR,
// PANGO_VERSION_MINOR, PANGO_VERSION_MICRO as the three arguments to this
// function; that produces a check that the library in use at run-time is
// compatible with the version of Pango the application or module was compiled
// against.
//
// Compatibility is defined by two things: first the
// version of the running library is newer than the version
// required_major.required_minor.required_micro. Second the
// running library must be binary compatible with the version
// required_major.required_minor.required_micro (same major version.)
//
// For compile-time version checking use PANGO_VERSION_CHECK().
//
// The function takes the following parameters:
//
//   - requiredMajor: required major version.
//   - requiredMinor: required minor version.
//   - requiredMicro: required major version.
//
// The function returns the following values:
//
//   - utf8 (optional): NULL if the Pango library is compatible with the given
//     version, or a string describing the version mismatch. The returned string
//     is owned by Pango and should not be modified or freed.
func VersionCheck(requiredMajor, requiredMinor, requiredMicro int) string {
	var _arg1 C.int   // out
	var _arg2 C.int   // out
	var _arg3 C.int   // out
	var _cret *C.char // in

	_arg1 = C.int(requiredMajor)
	_arg2 = C.int(requiredMinor)
	_arg3 = C.int(requiredMicro)

	_cret = C.pango_version_check(_arg1, _arg2, _arg3)
	runtime.KeepAlive(requiredMajor)
	runtime.KeepAlive(requiredMinor)
	runtime.KeepAlive(requiredMicro)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// VersionString returns the version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION_STRING except that the macro
// returns the version available at compile-time.
//
// The function returns the following values:
//
//   - utf8: string containing the version of Pango library available at run
//     time. The returned string is owned by Pango and should not be modified or
//     freed.
func VersionString() string {
	var _cret *C.char // in

	_cret = C.pango_version_string()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Context: PangoContext stores global information used to control the
// itemization process.
//
// The information stored by PangoContext includes the fontmap used to look up
// fonts, and default values such as the default language, default gravity,
// or default font.
//
// To obtain a PangoContext, use pango.FontMap.CreateContext().
type Context struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Context)(nil)
)

func wrapContext(obj *coreglib.Object) *Context {
	return &Context{
		Object: obj,
	}
}

func marshalContext(p uintptr) (interface{}, error) {
	return wrapContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewContext creates a new PangoContext initialized to default values.
//
// This function is not particularly useful as it should always be
// followed by a pango.Context.SetFontMap() call, and the function
// pango.FontMap.CreateContext() does these two steps together and hence users
// are recommended to use that.
//
// If you are using Pango as part of a higher-level system, that system may have
// it's own way of create a PangoContext. For instance, the GTK toolkit has,
// among others, gtk_widget_get_pango_context(). Use those instead.
//
// The function returns the following values:
//
//   - context: newly allocated PangoContext, which should be freed with
//     g_object_unref().
func NewContext() *Context {
	var _cret *C.PangoContext // in

	_cret = C.pango_context_new()

	var _context *Context // out

	_context = wrapContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _context
}

// Changed forces a change in the context, which will cause any PangoLayout
// using this context to re-layout.
//
// This function is only useful when implementing a new backend for Pango,
// something applications won't do. Backends should call this function if they
// have attached extra data to the context and such data is changed.
func (context *Context) Changed() {
	var _arg0 *C.PangoContext // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.pango_context_changed(_arg0)
	runtime.KeepAlive(context)
}

// BaseDir retrieves the base direction for the context.
//
// See pango.Context.SetBaseDir().
//
// The function returns the following values:
//
//   - direction: base direction for the context.
func (context *Context) BaseDir() Direction {
	var _arg0 *C.PangoContext  // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_base_dir(_arg0)
	runtime.KeepAlive(context)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// BaseGravity retrieves the base gravity for the context.
//
// See pango.Context.SetBaseGravity().
//
// The function returns the following values:
//
//   - gravity: base gravity for the context.
func (context *Context) BaseGravity() Gravity {
	var _arg0 *C.PangoContext // out
	var _cret C.PangoGravity  // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_base_gravity(_arg0)
	runtime.KeepAlive(context)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// FontDescription: retrieve the default font description for the context.
//
// The function returns the following values:
//
//   - fontDescription (optional): pointer to the context's default font
//     description. This value must not be modified or freed.
func (context *Context) FontDescription() *FontDescription {
	var _arg0 *C.PangoContext         // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_font_description(_arg0)
	runtime.KeepAlive(context)

	var _fontDescription *FontDescription // out

	if _cret != nil {
		_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _fontDescription
}

// FontMap gets the PangoFontMap used to look up fonts for this context.
//
// The function returns the following values:
//
//   - fontMap (optional): font map for the. PangoContext This value is owned by
//     Pango and should not be unreferenced.
func (context *Context) FontMap() FontMapper {
	var _arg0 *C.PangoContext // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_font_map(_arg0)
	runtime.KeepAlive(context)

	var _fontMap FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontMapper)
				return ok
			})
			rv, ok := casted.(FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// Gravity retrieves the gravity for the context.
//
// This is similar to pango.Context.GetBaseGravity(), except for when the base
// gravity is PANGO_GRAVITY_AUTO for which pango.Gravity().GetForMatrix is used
// to return the gravity from the current context matrix.
//
// The function returns the following values:
//
//   - gravity: resolved gravity for the context.
func (context *Context) Gravity() Gravity {
	var _arg0 *C.PangoContext // out
	var _cret C.PangoGravity  // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_gravity(_arg0)
	runtime.KeepAlive(context)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// GravityHint retrieves the gravity hint for the context.
//
// See pango.Context.SetGravityHint() for details.
//
// The function returns the following values:
//
//   - gravityHint: gravity hint for the context.
func (context *Context) GravityHint() GravityHint {
	var _arg0 *C.PangoContext    // out
	var _cret C.PangoGravityHint // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_gravity_hint(_arg0)
	runtime.KeepAlive(context)

	var _gravityHint GravityHint // out

	_gravityHint = GravityHint(_cret)

	return _gravityHint
}

// Language retrieves the global language tag for the context.
//
// The function returns the following values:
//
//   - language: global language tag.
func (context *Context) Language() *Language {
	var _arg0 *C.PangoContext  // out
	var _cret *C.PangoLanguage // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_language(_arg0)
	runtime.KeepAlive(context)

	var _language *Language // out

	_language = (*Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _language
}

// Matrix gets the transformation matrix that will be applied when rendering
// with this context.
//
// See pango.Context.SetMatrix().
//
// The function returns the following values:
//
//   - matrix (optional): matrix, or NULL if no matrix has been set (which is
//     the same as the identity matrix). The returned matrix is owned by Pango
//     and must not be modified or freed.
func (context *Context) Matrix() *Matrix {
	var _arg0 *C.PangoContext // out
	var _cret *C.PangoMatrix  // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_matrix(_arg0)
	runtime.KeepAlive(context)

	var _matrix *Matrix // out

	if _cret != nil {
		_matrix = (*Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _matrix
}

// Metrics: get overall metric information for a particular font description.
//
// Since the metrics may be substantially different for different scripts, a
// language tag can be provided to indicate that the metrics should be retrieved
// that correspond to the script(s) used by that language.
//
// The PangoFontDescription is interpreted in the same way as by itemize,
// and the family name may be a comma separated list of names. If characters
// from multiple of these families would be used to render the string, then the
// returned fonts would be a composite of the metrics for the fonts loaded for
// the individual families.
//
// The function takes the following parameters:
//
//   - desc (optional): PangoFontDescription structure. NULL means that the font
//     description from the context will be used.
//   - language (optional) tag used to determine which script to get the metrics
//     for. NULL means that the language tag from the context will be used. If
//     no language tag is set on the context, metrics for the default language
//     (as determined by pango.Language().GetDefault will be returned.
//
// The function returns the following values:
//
//   - fontMetrics: PangoFontMetrics object. The caller must call
//     pango.FontMetrics.Unref() when finished using the object.
func (context *Context) Metrics(desc *FontDescription, language *Language) *FontMetrics {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 *C.PangoLanguage        // out
	var _cret *C.PangoFontMetrics     // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if desc != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	}
	if language != nil {
		_arg2 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}

	_cret = C.pango_context_get_metrics(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(language)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = (*FontMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontMetrics)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_metrics_unref((*C.PangoFontMetrics)(intern.C))
		},
	)

	return _fontMetrics
}

// RoundGlyphPositions returns whether font rendering with this context should
// round glyph positions and widths.
func (context *Context) RoundGlyphPositions() bool {
	var _arg0 *C.PangoContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_round_glyph_positions(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Serial returns the current serial number of context.
//
// The serial number is initialized to an small number larger than zero when a
// new context is created and is increased whenever the context is changed using
// any of the setter functions, or the PangoFontMap it uses to find fonts has
// changed. The serial may wrap, but will never have the value 0. Since it can
// wrap, never compare it with "less than", always use "not equals".
//
// This can be used to automatically detect changes to a PangoContext,
// and is only useful when implementing objects that need update when their
// PangoContext changes, like PangoLayout.
//
// The function returns the following values:
//
//   - guint: current serial number of context.
func (context *Context) Serial() uint {
	var _arg0 *C.PangoContext // out
	var _cret C.guint         // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_context_get_serial(_arg0)
	runtime.KeepAlive(context)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ListFamilies: list all families for a context.
//
// The function returns the following values:
//
//   - families: location to store a pointer to an array of PangoFontFamily.
//     This array should be freed with g_free().
func (context *Context) ListFamilies() []FontFamilier {
	var _arg0 *C.PangoContext     // out
	var _arg1 **C.PangoFontFamily // in
	var _arg2 C.int               // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.pango_context_list_families(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _families []FontFamilier // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice((**C.PangoFontFamily)(_arg1), _arg2)
		_families = make([]FontFamilier, _arg2)
		for i := 0; i < int(_arg2); i++ {
			{
				objptr := unsafe.Pointer(src[i])
				if objptr == nil {
					panic("object of type pango.FontFamilier is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(FontFamilier)
					return ok
				})
				rv, ok := casted.(FontFamilier)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
				}
				_families[i] = rv
			}
		}
	}

	return _families
}

// LoadFont loads the font in one of the fontmaps in the context that is the
// closest match for desc.
//
// The function takes the following parameters:
//
//   - desc: PangoFontDescription describing the font to load.
//
// The function returns the following values:
//
//   - font (optional): newly allocated PangoFont that was loaded, or NULL if no
//     font matched.
func (context *Context) LoadFont(desc *FontDescription) Fonter {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out
	var _cret *C.PangoFont            // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_context_load_font(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)

	var _font Fonter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Fonter)
				return ok
			})
			rv, ok := casted.(Fonter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
			}
			_font = rv
		}
	}

	return _font
}

// LoadFontset: load a set of fonts in the context that can be used to render a
// font matching desc.
//
// The function takes the following parameters:
//
//   - desc: PangoFontDescription describing the fonts to load.
//   - language: PangoLanguage the fonts will be used for.
//
// The function returns the following values:
//
//   - fontset (optional): newly allocated PangoFontset loaded, or NULL if no
//     font matched.
func (context *Context) LoadFontset(desc *FontDescription, language *Language) Fontsetter {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 *C.PangoLanguage        // out
	var _cret *C.PangoFontset         // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg2 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C.pango_context_load_fontset(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(language)

	var _fontset Fontsetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Fontsetter)
				return ok
			})
			rv, ok := casted.(Fontsetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fontsetter")
			}
			_fontset = rv
		}
	}

	return _fontset
}

// SetBaseDir sets the base direction for the context.
//
// The base direction is used in applying the Unicode bidirectional algorithm;
// if the direction is PANGO_DIRECTION_LTR or PANGO_DIRECTION_RTL, then the
// value will be used as the paragraph direction in the Unicode bidirectional
// algorithm. A value of PANGO_DIRECTION_WEAK_LTR or PANGO_DIRECTION_WEAK_RTL
// is used only for paragraphs that do not contain any strong characters
// themselves.
//
// The function takes the following parameters:
//
//   - direction: new base direction.
func (context *Context) SetBaseDir(direction Direction) {
	var _arg0 *C.PangoContext  // out
	var _arg1 C.PangoDirection // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.PangoDirection(direction)

	C.pango_context_set_base_dir(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(direction)
}

// SetBaseGravity sets the base gravity for the context.
//
// The base gravity is used in laying vertical text out.
//
// The function takes the following parameters:
//
//   - gravity: new base gravity.
func (context *Context) SetBaseGravity(gravity Gravity) {
	var _arg0 *C.PangoContext // out
	var _arg1 C.PangoGravity  // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.PangoGravity(gravity)

	C.pango_context_set_base_gravity(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(gravity)
}

// SetFontDescription: set the default font description for the context.
//
// The function takes the following parameters:
//
//   - desc (optional): new pango font description.
func (context *Context) SetFontDescription(desc *FontDescription) {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if desc != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	}

	C.pango_context_set_font_description(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)
}

// SetFontMap sets the font map to be searched when fonts are looked-up in this
// context.
//
// This is only for internal use by Pango backends, a PangoContext obtained via
// one of the recommended methods should already have a suitable font map.
//
// The function takes the following parameters:
//
//   - fontMap (optional): PangoFontMap to set.
func (context *Context) SetFontMap(fontMap FontMapper) {
	var _arg0 *C.PangoContext // out
	var _arg1 *C.PangoFontMap // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if fontMap != nil {
		_arg1 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontMap).Native()))
	}

	C.pango_context_set_font_map(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(fontMap)
}

// SetGravityHint sets the gravity hint for the context.
//
// The gravity hint is used in laying vertical text out, and is only relevant
// if gravity of the context as returned by pango.Context.GetGravity() is set to
// PANGO_GRAVITY_EAST or PANGO_GRAVITY_WEST.
//
// The function takes the following parameters:
//
//   - hint: new gravity hint.
func (context *Context) SetGravityHint(hint GravityHint) {
	var _arg0 *C.PangoContext    // out
	var _arg1 C.PangoGravityHint // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.PangoGravityHint(hint)

	C.pango_context_set_gravity_hint(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(hint)
}

// SetLanguage sets the global language tag for the context.
//
// The default language for the locale of the running process can be found using
// pango.Language().GetDefault.
//
// The function takes the following parameters:
//
//   - language (optional): new language tag.
func (context *Context) SetLanguage(language *Language) {
	var _arg0 *C.PangoContext  // out
	var _arg1 *C.PangoLanguage // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if language != nil {
		_arg1 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}

	C.pango_context_set_language(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(language)
}

// SetMatrix sets the transformation matrix that will be applied when rendering
// with this context.
//
// Note that reported metrics are in the user space coordinates before the
// application of the matrix, not device-space coordinates after the application
// of the matrix. So, they don't scale with the matrix, though they may change
// slightly for different matrices, depending on how the text is fit to the
// pixel grid.
//
// The function takes the following parameters:
//
//   - matrix (optional): PangoMatrix, or NULL to unset any existing matrix.
//     (No matrix set is the same as setting the identity matrix.).
func (context *Context) SetMatrix(matrix *Matrix) {
	var _arg0 *C.PangoContext // out
	var _arg1 *C.PangoMatrix  // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if matrix != nil {
		_arg1 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	C.pango_context_set_matrix(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(matrix)
}

// SetRoundGlyphPositions sets whether font rendering with this context should
// round glyph positions and widths to integral positions, in device units.
//
// This is useful when the renderer can't handle subpixel positioning of glyphs.
//
// The default value is to round glyph positions, to remain compatible with
// previous Pango behavior.
//
// The function takes the following parameters:
//
//   - roundPositions: whether to round glyph positions.
func (context *Context) SetRoundGlyphPositions(roundPositions bool) {
	var _arg0 *C.PangoContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if roundPositions {
		_arg1 = C.TRUE
	}

	C.pango_context_set_round_glyph_positions(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(roundPositions)
}

// Coverage: PangoCoverage structure is a map from Unicode characters to
// pango.CoverageLevel values.
//
// It is often necessary in Pango to determine if a particular font can
// represent a particular character, and also how well it can represent that
// character. The PangoCoverage is a data structure that is used to represent
// that information. It is an opaque structure with no public fields.
type Coverage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Coverage)(nil)
)

func wrapCoverage(obj *coreglib.Object) *Coverage {
	return &Coverage{
		Object: obj,
	}
}

func marshalCoverage(p uintptr) (interface{}, error) {
	return wrapCoverage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCoverage: create a new PangoCoverage.
//
// The function returns the following values:
//
//   - coverage: newly allocated PangoCoverage, initialized to
//     PANGO_COVERAGE_NONE with a reference count of one, which should be freed
//     with pango.Coverage.Unref().
func NewCoverage() *Coverage {
	var _cret *C.PangoCoverage // in

	_cret = C.pango_coverage_new()

	var _coverage *Coverage // out

	_coverage = wrapCoverage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _coverage
}

// Copy an existing PangoCoverage.
//
// The function returns the following values:
//
//   - ret: newly allocated PangoCoverage, with a reference count of one,
//     which should be freed with pango.Coverage.Unref().
func (coverage *Coverage) Copy() *Coverage {
	var _arg0 *C.PangoCoverage // out
	var _cret *C.PangoCoverage // in

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(coreglib.InternObject(coverage).Native()))

	_cret = C.pango_coverage_copy(_arg0)
	runtime.KeepAlive(coverage)

	var _ret *Coverage // out

	_ret = wrapCoverage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// Get: determine whether a particular index is covered by coverage.
//
// The function takes the following parameters:
//
//   - index_: index to check.
//
// The function returns the following values:
//
//   - coverageLevel: coverage level of coverage for character index_.
func (coverage *Coverage) Get(index_ int) CoverageLevel {
	var _arg0 *C.PangoCoverage     // out
	var _arg1 C.int                // out
	var _cret C.PangoCoverageLevel // in

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(coreglib.InternObject(coverage).Native()))
	_arg1 = C.int(index_)

	_cret = C.pango_coverage_get(_arg0, _arg1)
	runtime.KeepAlive(coverage)
	runtime.KeepAlive(index_)

	var _coverageLevel CoverageLevel // out

	_coverageLevel = CoverageLevel(_cret)

	return _coverageLevel
}

// Max: set the coverage for each index in coverage to be the max (better) value
// of the current coverage for the index and the coverage for the corresponding
// index in other.
//
// Deprecated: This function does nothing.
//
// The function takes the following parameters:
//
//   - other PangoCoverage.
func (coverage *Coverage) Max(other *Coverage) {
	var _arg0 *C.PangoCoverage // out
	var _arg1 *C.PangoCoverage // out

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(coreglib.InternObject(coverage).Native()))
	_arg1 = (*C.PangoCoverage)(unsafe.Pointer(coreglib.InternObject(other).Native()))

	C.pango_coverage_max(_arg0, _arg1)
	runtime.KeepAlive(coverage)
	runtime.KeepAlive(other)
}

// Set: modify a particular index within coverage.
//
// The function takes the following parameters:
//
//   - index_: index to modify.
//   - level: new level for index_.
func (coverage *Coverage) Set(index_ int, level CoverageLevel) {
	var _arg0 *C.PangoCoverage     // out
	var _arg1 C.int                // out
	var _arg2 C.PangoCoverageLevel // out

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(coreglib.InternObject(coverage).Native()))
	_arg1 = C.int(index_)
	_arg2 = C.PangoCoverageLevel(level)

	C.pango_coverage_set(_arg0, _arg1, _arg2)
	runtime.KeepAlive(coverage)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(level)
}

// ToBytes: convert a PangoCoverage structure into a flat binary format.
//
// Deprecated: This returns NULL.
//
// The function returns the following values:
//
//   - bytes: location to store result (must be freed with g_free()).
func (coverage *Coverage) ToBytes() []byte {
	var _arg0 *C.PangoCoverage // out
	var _arg1 *C.guchar        // in
	var _arg2 C.int            // in

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(coreglib.InternObject(coverage).Native()))

	C.pango_coverage_to_bytes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(coverage)

	var _bytes []byte // out

	defer C.free(unsafe.Pointer(_arg1))
	_bytes = make([]byte, _arg2)
	copy(_bytes, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))

	return _bytes
}

// CoverageFromBytes: convert data generated from pango.Coverage.ToBytes() back
// to a PangoCoverage.
//
// Deprecated: This returns NULL.
//
// The function takes the following parameters:
//
//   - bytes: binary data representing a PangoCoverage.
//
// The function returns the following values:
//
//   - coverage (optional): newly allocated PangoCoverage.
func CoverageFromBytes(bytes []byte) *Coverage {
	var _arg1 *C.guchar // out
	var _arg2 C.int
	var _cret *C.PangoCoverage // in

	_arg2 = (C.int)(len(bytes))
	if len(bytes) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&bytes[0]))
	}

	_cret = C.pango_coverage_from_bytes(_arg1, _arg2)
	runtime.KeepAlive(bytes)

	var _coverage *Coverage // out

	if _cret != nil {
		_coverage = wrapCoverage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _coverage
}

// FontOverrides contains methods that are overridable.
type FontOverrides struct {
	// Describe returns a description of the font, with font size set in points.
	//
	// Use pango.Font.DescribeWithAbsoluteSize() if you want the font size in
	// device units.
	//
	// The function returns the following values:
	//
	//   - fontDescription: newly-allocated PangoFontDescription object.
	Describe         func() *FontDescription
	DescribeAbsolute func() *FontDescription
	// Coverage computes the coverage map for a given font and language tag.
	//
	// The function takes the following parameters:
	//
	//   - language tag.
	//
	// The function returns the following values:
	//
	//   - coverage: newly-allocated PangoCoverage object.
	Coverage func(language *Language) *Coverage
	// FontMap gets the font map for which the font was created.
	//
	// Note that the font maintains a *weak* reference to the font map, so if
	// all references to font map are dropped, the font map will be finalized
	// even if there are fonts created with the font map that are still alive.
	// In that case this function will return NULL.
	//
	// It is the responsibility of the user to ensure that the font map is
	// kept alive. In most uses this is not an issue as a PangoContext holds a
	// reference to the font map.
	//
	// The function returns the following values:
	//
	//   - fontMap (optional): PangoFontMap for the font.
	FontMap func() FontMapper
	// GlyphExtents gets the logical and ink extents of a glyph within a font.
	//
	// The coordinate system for each rectangle has its origin at the
	// base line and horizontal origin of the character with increasing
	// coordinates extending to the right and down. The macros PANGO_ASCENT(),
	// PANGO_DESCENT(), PANGO_LBEARING(), and PANGO_RBEARING() can be used to
	// convert from the extents rectangle to more traditional font metrics.
	// The units of the rectangles are in 1/PANGO_SCALE of a device unit.
	//
	// If font is NULL, this function gracefully sets some sane values in the
	// output variables and returns.
	//
	// The function takes the following parameters:
	//
	//   - glyph index.
	//
	// The function returns the following values:
	//
	//   - inkRect (optional): rectangle used to store the extents of the glyph
	//     as drawn.
	//   - logicalRect (optional): rectangle used to store the logical extents
	//     of the glyph.
	GlyphExtents func(glyph Glyph) (inkRect, logicalRect *Rectangle)
	// Metrics gets overall metric information for a font.
	//
	// Since the metrics may be substantially different for different scripts,
	// a language tag can be provided to indicate that the metrics should be
	// retrieved that correspond to the script(s) used by that language.
	//
	// If font is NULL, this function gracefully sets some sane values in the
	// output variables and returns.
	//
	// The function takes the following parameters:
	//
	//   - language (optional) tag used to determine which script to get the
	//     metrics for, or NULL to indicate to get the metrics for the entire
	//     font.
	//
	// The function returns the following values:
	//
	//   - fontMetrics: PangoFontMetrics object. The caller must call
	//     pango.FontMetrics.Unref() when finished using the object.
	Metrics func(language *Language) *FontMetrics
}

func defaultFontOverrides(v *Font) FontOverrides {
	return FontOverrides{
		Describe:         v.describe,
		DescribeAbsolute: v.describeAbsolute,
		Coverage:         v.coverage,
		FontMap:          v.fontMap,
		GlyphExtents:     v.glyphExtents,
		Metrics:          v.metrics,
	}
}

// Font: PangoFont is used to represent a font in a rendering-system-independent
// manner.
type Font struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Font)(nil)
)

// Fonter describes types inherited from class Font.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Fonter interface {
	coreglib.Objector
	baseFont() *Font
}

var _ Fonter = (*Font)(nil)

func init() {
	coreglib.RegisterClassInfo[*Font, *FontClass, FontOverrides](
		GTypeFont,
		initFontClass,
		wrapFont,
		defaultFontOverrides,
	)
}

func initFontClass(gclass unsafe.Pointer, overrides FontOverrides, classInitFunc func(*FontClass)) {
	pclass := (*C.PangoFontClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFont))))

	if overrides.Describe != nil {
		pclass.describe = (*[0]byte)(C._gotk4_pango1_FontClass_describe)
	}

	if overrides.DescribeAbsolute != nil {
		pclass.describe_absolute = (*[0]byte)(C._gotk4_pango1_FontClass_describe_absolute)
	}

	if overrides.Coverage != nil {
		pclass.get_coverage = (*[0]byte)(C._gotk4_pango1_FontClass_get_coverage)
	}

	if overrides.FontMap != nil {
		pclass.get_font_map = (*[0]byte)(C._gotk4_pango1_FontClass_get_font_map)
	}

	if overrides.GlyphExtents != nil {
		pclass.get_glyph_extents = (*[0]byte)(C._gotk4_pango1_FontClass_get_glyph_extents)
	}

	if overrides.Metrics != nil {
		pclass.get_metrics = (*[0]byte)(C._gotk4_pango1_FontClass_get_metrics)
	}

	if classInitFunc != nil {
		class := (*FontClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFont(obj *coreglib.Object) *Font {
	return &Font{
		Object: obj,
	}
}

func marshalFont(p uintptr) (interface{}, error) {
	return wrapFont(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (font *Font) baseFont() *Font {
	return font
}

// BaseFont returns the underlying base object.
func BaseFont(obj Fonter) *Font {
	return obj.baseFont()
}

// Describe returns a description of the font, with font size set in points.
//
// Use pango.Font.DescribeWithAbsoluteSize() if you want the font size in device
// units.
//
// The function returns the following values:
//
//   - fontDescription: newly-allocated PangoFontDescription object.
func (font *Font) Describe() *FontDescription {
	var _arg0 *C.PangoFont            // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_cret = C.pango_font_describe(_arg0)
	runtime.KeepAlive(font)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

// DescribeWithAbsoluteSize returns a description of the font, with absolute
// font size set in device units.
//
// Use pango.Font.Describe() if you want the font size in points.
//
// The function returns the following values:
//
//   - fontDescription: newly-allocated PangoFontDescription object.
func (font *Font) DescribeWithAbsoluteSize() *FontDescription {
	var _arg0 *C.PangoFont            // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_cret = C.pango_font_describe_with_absolute_size(_arg0)
	runtime.KeepAlive(font)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

// Coverage computes the coverage map for a given font and language tag.
//
// The function takes the following parameters:
//
//   - language tag.
//
// The function returns the following values:
//
//   - coverage: newly-allocated PangoCoverage object.
func (font *Font) Coverage(language *Language) *Coverage {
	var _arg0 *C.PangoFont     // out
	var _arg1 *C.PangoLanguage // out
	var _cret *C.PangoCoverage // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg1 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C.pango_font_get_coverage(_arg0, _arg1)
	runtime.KeepAlive(font)
	runtime.KeepAlive(language)

	var _coverage *Coverage // out

	_coverage = wrapCoverage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _coverage
}

// Face gets the PangoFontFace to which font belongs.
//
// The function returns the following values:
//
//   - fontFace: PangoFontFace.
func (font *Font) Face() FontFacer {
	var _arg0 *C.PangoFont     // out
	var _cret *C.PangoFontFace // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_cret = C.pango_font_get_face(_arg0)
	runtime.KeepAlive(font)

	var _fontFace FontFacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontFacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FontFacer)
			return ok
		})
		rv, ok := casted.(FontFacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
		}
		_fontFace = rv
	}

	return _fontFace
}

// FontMap gets the font map for which the font was created.
//
// Note that the font maintains a *weak* reference to the font map, so if all
// references to font map are dropped, the font map will be finalized even if
// there are fonts created with the font map that are still alive. In that case
// this function will return NULL.
//
// It is the responsibility of the user to ensure that the font map is kept
// alive. In most uses this is not an issue as a PangoContext holds a reference
// to the font map.
//
// The function returns the following values:
//
//   - fontMap (optional): PangoFontMap for the font.
func (font *Font) FontMap() FontMapper {
	var _arg0 *C.PangoFont    // out
	var _cret *C.PangoFontMap // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}

	_cret = C.pango_font_get_font_map(_arg0)
	runtime.KeepAlive(font)

	var _fontMap FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontMapper)
				return ok
			})
			rv, ok := casted.(FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// GlyphExtents gets the logical and ink extents of a glyph within a font.
//
// The coordinate system for each rectangle has its origin at the base
// line and horizontal origin of the character with increasing coordinates
// extending to the right and down. The macros PANGO_ASCENT(), PANGO_DESCENT(),
// PANGO_LBEARING(), and PANGO_RBEARING() can be used to convert from the
// extents rectangle to more traditional font metrics. The units of the
// rectangles are in 1/PANGO_SCALE of a device unit.
//
// If font is NULL, this function gracefully sets some sane values in the output
// variables and returns.
//
// The function takes the following parameters:
//
//   - glyph index.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the glyph as
//     drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the glyph.
func (font *Font) GlyphExtents(glyph Glyph) (inkRect, logicalRect *Rectangle) {
	var _arg0 *C.PangoFont     // out
	var _arg1 C.PangoGlyph     // out
	var _arg2 C.PangoRectangle // in
	var _arg3 C.PangoRectangle // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}
	_arg1 = C.PangoGlyph(glyph)

	C.pango_font_get_glyph_extents(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyph)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _inkRect, _logicalRect
}

// Languages returns the languages that are supported by font.
//
// If the font backend does not provide this information, NULL is returned.
// For the fontconfig backend, this corresponds to the FC_LANG member of the
// FcPattern.
//
// The returned array is only valid as long as the font and its fontmap are
// valid.
//
// The function returns the following values:
//
//   - languages (optional): array of PangoLanguage.
func (font *Font) Languages() []*Language {
	var _arg0 *C.PangoFont      // out
	var _cret **C.PangoLanguage // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_cret = C.pango_font_get_languages(_arg0)
	runtime.KeepAlive(font)

	var _languages []*Language // out

	if _cret != nil {
		{
			var i int
			var z *C.PangoLanguage
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_languages = make([]*Language, i)
			for i := range src {
				_languages[i] = (*Language)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			}
		}
	}

	return _languages
}

// Metrics gets overall metric information for a font.
//
// Since the metrics may be substantially different for different scripts, a
// language tag can be provided to indicate that the metrics should be retrieved
// that correspond to the script(s) used by that language.
//
// If font is NULL, this function gracefully sets some sane values in the output
// variables and returns.
//
// The function takes the following parameters:
//
//   - language (optional) tag used to determine which script to get the metrics
//     for, or NULL to indicate to get the metrics for the entire font.
//
// The function returns the following values:
//
//   - fontMetrics: PangoFontMetrics object. The caller must call
//     pango.FontMetrics.Unref() when finished using the object.
func (font *Font) Metrics(language *Language) *FontMetrics {
	var _arg0 *C.PangoFont        // out
	var _arg1 *C.PangoLanguage    // out
	var _cret *C.PangoFontMetrics // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}
	if language != nil {
		_arg1 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}

	_cret = C.pango_font_get_metrics(_arg0, _arg1)
	runtime.KeepAlive(font)
	runtime.KeepAlive(language)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = (*FontMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontMetrics)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_metrics_unref((*C.PangoFontMetrics)(intern.C))
		},
	)

	return _fontMetrics
}

// HasChar returns whether the font provides a glyph for this character.
//
// The function takes the following parameters:
//
//   - wc: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if font can render wc.
func (font *Font) HasChar(wc uint32) bool {
	var _arg0 *C.PangoFont // out
	var _arg1 C.gunichar   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg1 = C.gunichar(wc)

	_cret = C.pango_font_has_char(_arg0, _arg1)
	runtime.KeepAlive(font)
	runtime.KeepAlive(wc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Serialize serializes the font in a way that can be uniquely identified.
//
// There are no guarantees about the format of the output across different
// versions of Pango.
//
// The intended use of this function is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
//
// To recreate a font from its serialized form, use pango.Font().Deserialize.
//
// The function returns the following values:
//
//   - bytes: GBytes containing the serialized form of font.
func (font *Font) Serialize() *glib.Bytes {
	var _arg0 *C.PangoFont // out
	var _cret *C.GBytes    // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_cret = C.pango_font_serialize(_arg0)
	runtime.KeepAlive(font)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Describe returns a description of the font, with font size set in points.
//
// Use pango.Font.DescribeWithAbsoluteSize() if you want the font size in device
// units.
//
// The function returns the following values:
//
//   - fontDescription: newly-allocated PangoFontDescription object.
func (font *Font) describe() *FontDescription {
	gclass := (*C.PangoFontClass)(coreglib.PeekParentClass(font))
	fnarg := gclass.describe

	var _arg0 *C.PangoFont            // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_cret = C._gotk4_pango1_Font_virtual_describe(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(font)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

func (font *Font) describeAbsolute() *FontDescription {
	gclass := (*C.PangoFontClass)(coreglib.PeekParentClass(font))
	fnarg := gclass.describe_absolute

	var _arg0 *C.PangoFont            // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_cret = C._gotk4_pango1_Font_virtual_describe_absolute(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(font)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

// Coverage computes the coverage map for a given font and language tag.
//
// The function takes the following parameters:
//
//   - language tag.
//
// The function returns the following values:
//
//   - coverage: newly-allocated PangoCoverage object.
func (font *Font) coverage(language *Language) *Coverage {
	gclass := (*C.PangoFontClass)(coreglib.PeekParentClass(font))
	fnarg := gclass.get_coverage

	var _arg0 *C.PangoFont     // out
	var _arg1 *C.PangoLanguage // out
	var _cret *C.PangoCoverage // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg1 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C._gotk4_pango1_Font_virtual_get_coverage(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(font)
	runtime.KeepAlive(language)

	var _coverage *Coverage // out

	_coverage = wrapCoverage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _coverage
}

// fontMap gets the font map for which the font was created.
//
// Note that the font maintains a *weak* reference to the font map, so if all
// references to font map are dropped, the font map will be finalized even if
// there are fonts created with the font map that are still alive. In that case
// this function will return NULL.
//
// It is the responsibility of the user to ensure that the font map is kept
// alive. In most uses this is not an issue as a PangoContext holds a reference
// to the font map.
//
// The function returns the following values:
//
//   - fontMap (optional): PangoFontMap for the font.
func (font *Font) fontMap() FontMapper {
	gclass := (*C.PangoFontClass)(coreglib.PeekParentClass(font))
	fnarg := gclass.get_font_map

	var _arg0 *C.PangoFont    // out
	var _cret *C.PangoFontMap // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}

	_cret = C._gotk4_pango1_Font_virtual_get_font_map(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(font)

	var _fontMap FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontMapper)
				return ok
			})
			rv, ok := casted.(FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// glyphExtents gets the logical and ink extents of a glyph within a font.
//
// The coordinate system for each rectangle has its origin at the base
// line and horizontal origin of the character with increasing coordinates
// extending to the right and down. The macros PANGO_ASCENT(), PANGO_DESCENT(),
// PANGO_LBEARING(), and PANGO_RBEARING() can be used to convert from the
// extents rectangle to more traditional font metrics. The units of the
// rectangles are in 1/PANGO_SCALE of a device unit.
//
// If font is NULL, this function gracefully sets some sane values in the output
// variables and returns.
//
// The function takes the following parameters:
//
//   - glyph index.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the glyph as
//     drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the glyph.
func (font *Font) glyphExtents(glyph Glyph) (inkRect, logicalRect *Rectangle) {
	gclass := (*C.PangoFontClass)(coreglib.PeekParentClass(font))
	fnarg := gclass.get_glyph_extents

	var _arg0 *C.PangoFont     // out
	var _arg1 C.PangoGlyph     // out
	var _arg2 C.PangoRectangle // in
	var _arg3 C.PangoRectangle // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}
	_arg1 = C.PangoGlyph(glyph)

	C._gotk4_pango1_Font_virtual_get_glyph_extents(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyph)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _inkRect, _logicalRect
}

// Metrics gets overall metric information for a font.
//
// Since the metrics may be substantially different for different scripts, a
// language tag can be provided to indicate that the metrics should be retrieved
// that correspond to the script(s) used by that language.
//
// If font is NULL, this function gracefully sets some sane values in the output
// variables and returns.
//
// The function takes the following parameters:
//
//   - language (optional) tag used to determine which script to get the metrics
//     for, or NULL to indicate to get the metrics for the entire font.
//
// The function returns the following values:
//
//   - fontMetrics: PangoFontMetrics object. The caller must call
//     pango.FontMetrics.Unref() when finished using the object.
func (font *Font) metrics(language *Language) *FontMetrics {
	gclass := (*C.PangoFontClass)(coreglib.PeekParentClass(font))
	fnarg := gclass.get_metrics

	var _arg0 *C.PangoFont        // out
	var _arg1 *C.PangoLanguage    // out
	var _cret *C.PangoFontMetrics // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}
	if language != nil {
		_arg1 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}

	_cret = C._gotk4_pango1_Font_virtual_get_metrics(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(font)
	runtime.KeepAlive(language)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = (*FontMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontMetrics)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_metrics_unref((*C.PangoFontMetrics)(intern.C))
		},
	)

	return _fontMetrics
}

// FontDeserialize loads data previously created via pango.Font.Serialize().
//
// For a discussion of the supported format, see that function.
//
// Note: to verify that the returned font is identical to the one that was
// serialized, you can compare bytes to the result of serializing the font
// again.
//
// The function takes the following parameters:
//
//   - context: PangoContext.
//   - bytes containing the data.
//
// The function returns the following values:
//
//   - font (optional): new PangoFont.
func FontDeserialize(context *Context, bytes *glib.Bytes) (Fonter, error) {
	var _arg1 *C.PangoContext // out
	var _arg2 *C.GBytes       // out
	var _cret *C.PangoFont    // in
	var _cerr *C.GError       // in

	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.pango_font_deserialize(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(bytes)

	var _font Fonter // out
	var _goerr error // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Fonter)
				return ok
			})
			rv, ok := casted.(Fonter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
			}
			_font = rv
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _font, _goerr
}

// FontFaceOverrides contains methods that are overridable.
type FontFaceOverrides struct {
	// Describe returns a font description that matches the face.
	//
	// The resulting font description will have the family, style, variant,
	// weight and stretch of the face, but its size field will be unset.
	//
	// The function returns the following values:
	//
	//   - fontDescription: newly-created PangoFontDescription structure holding
	//     the description of the face. Use pango.FontDescription.Free() to free
	//     the result.
	Describe func() *FontDescription
	// FaceName gets a name representing the style of this face.
	//
	// Note that a font family may contain multiple faces with the same name
	// (e.g. a variable and a non-variable face for the same style).
	//
	// The function returns the following values:
	//
	//   - utf8: face name for the face. This string is owned by the face object
	//     and must not be modified or freed.
	FaceName func() string
	// Family gets the PangoFontFamily that face belongs to.
	//
	// The function returns the following values:
	//
	//   - fontFamily: PangoFontFamily.
	Family func() FontFamilier
	// IsSynthesized returns whether a PangoFontFace is synthesized.
	//
	// This will be the case if the underlying font rendering engine creates
	// this face from another face, by shearing, emboldening, lightening or
	// modifying it in some other way.
	//
	// The function returns the following values:
	//
	//   - ok: whether face is synthesized.
	IsSynthesized func() bool
	// ListSizes: list the available sizes for a font.
	//
	// This is only applicable to bitmap fonts. For scalable fonts, stores
	// NULL at the location pointed to by sizes and 0 at the location pointed
	// to by n_sizes. The sizes returned are in Pango units and are sorted in
	// ascending order.
	//
	// The function returns the following values:
	//
	//   - sizes (optional): location to store a pointer to an array of int.
	//     This array should be freed with g_free().
	ListSizes func() []int
}

func defaultFontFaceOverrides(v *FontFace) FontFaceOverrides {
	return FontFaceOverrides{
		Describe:      v.describe,
		FaceName:      v.faceName,
		Family:        v.family,
		IsSynthesized: v.isSynthesized,
		ListSizes:     v.listSizes,
	}
}

// FontFace: PangoFontFace is used to represent a group of fonts with the same
// family, slant, weight, and width, but varying sizes.
type FontFace struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FontFace)(nil)
)

// FontFacer describes types inherited from class FontFace.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FontFacer interface {
	coreglib.Objector
	baseFontFace() *FontFace
}

var _ FontFacer = (*FontFace)(nil)

func init() {
	coreglib.RegisterClassInfo[*FontFace, *FontFaceClass, FontFaceOverrides](
		GTypeFontFace,
		initFontFaceClass,
		wrapFontFace,
		defaultFontFaceOverrides,
	)
}

func initFontFaceClass(gclass unsafe.Pointer, overrides FontFaceOverrides, classInitFunc func(*FontFaceClass)) {
	pclass := (*C.PangoFontFaceClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFontFace))))

	if overrides.Describe != nil {
		pclass.describe = (*[0]byte)(C._gotk4_pango1_FontFaceClass_describe)
	}

	if overrides.FaceName != nil {
		pclass.get_face_name = (*[0]byte)(C._gotk4_pango1_FontFaceClass_get_face_name)
	}

	if overrides.Family != nil {
		pclass.get_family = (*[0]byte)(C._gotk4_pango1_FontFaceClass_get_family)
	}

	if overrides.IsSynthesized != nil {
		pclass.is_synthesized = (*[0]byte)(C._gotk4_pango1_FontFaceClass_is_synthesized)
	}

	if overrides.ListSizes != nil {
		pclass.list_sizes = (*[0]byte)(C._gotk4_pango1_FontFaceClass_list_sizes)
	}

	if classInitFunc != nil {
		class := (*FontFaceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFontFace(obj *coreglib.Object) *FontFace {
	return &FontFace{
		Object: obj,
	}
}

func marshalFontFace(p uintptr) (interface{}, error) {
	return wrapFontFace(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (face *FontFace) baseFontFace() *FontFace {
	return face
}

// BaseFontFace returns the underlying base object.
func BaseFontFace(obj FontFacer) *FontFace {
	return obj.baseFontFace()
}

// Describe returns a font description that matches the face.
//
// The resulting font description will have the family, style, variant, weight
// and stretch of the face, but its size field will be unset.
//
// The function returns the following values:
//
//   - fontDescription: newly-created PangoFontDescription structure holding
//     the description of the face. Use pango.FontDescription.Free() to free the
//     result.
func (face *FontFace) Describe() *FontDescription {
	var _arg0 *C.PangoFontFace        // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C.pango_font_face_describe(_arg0)
	runtime.KeepAlive(face)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

// FaceName gets a name representing the style of this face.
//
// Note that a font family may contain multiple faces with the same name (e.g.
// a variable and a non-variable face for the same style).
//
// The function returns the following values:
//
//   - utf8: face name for the face. This string is owned by the face object and
//     must not be modified or freed.
func (face *FontFace) FaceName() string {
	var _arg0 *C.PangoFontFace // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C.pango_font_face_get_face_name(_arg0)
	runtime.KeepAlive(face)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Family gets the PangoFontFamily that face belongs to.
//
// The function returns the following values:
//
//   - fontFamily: PangoFontFamily.
func (face *FontFace) Family() FontFamilier {
	var _arg0 *C.PangoFontFace   // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C.pango_font_face_get_family(_arg0)
	runtime.KeepAlive(face)

	var _fontFamily FontFamilier // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontFamilier is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FontFamilier)
			return ok
		})
		rv, ok := casted.(FontFamilier)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
		}
		_fontFamily = rv
	}

	return _fontFamily
}

// IsSynthesized returns whether a PangoFontFace is synthesized.
//
// This will be the case if the underlying font rendering engine creates this
// face from another face, by shearing, emboldening, lightening or modifying it
// in some other way.
//
// The function returns the following values:
//
//   - ok: whether face is synthesized.
func (face *FontFace) IsSynthesized() bool {
	var _arg0 *C.PangoFontFace // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C.pango_font_face_is_synthesized(_arg0)
	runtime.KeepAlive(face)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListSizes: list the available sizes for a font.
//
// This is only applicable to bitmap fonts. For scalable fonts, stores NULL at
// the location pointed to by sizes and 0 at the location pointed to by n_sizes.
// The sizes returned are in Pango units and are sorted in ascending order.
//
// The function returns the following values:
//
//   - sizes (optional): location to store a pointer to an array of int.
//     This array should be freed with g_free().
func (face *FontFace) ListSizes() []int {
	var _arg0 *C.PangoFontFace // out
	var _arg1 *C.int           // in
	var _arg2 C.int            // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	C.pango_font_face_list_sizes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(face)

	var _sizes []int // out

	if _arg1 != nil {
		defer C.free(unsafe.Pointer(_arg1))
		{
			src := unsafe.Slice((*C.int)(_arg1), _arg2)
			_sizes = make([]int, _arg2)
			for i := 0; i < int(_arg2); i++ {
				_sizes[i] = int(src[i])
			}
		}
	}

	return _sizes
}

// Describe returns a font description that matches the face.
//
// The resulting font description will have the family, style, variant, weight
// and stretch of the face, but its size field will be unset.
//
// The function returns the following values:
//
//   - fontDescription: newly-created PangoFontDescription structure holding
//     the description of the face. Use pango.FontDescription.Free() to free the
//     result.
func (face *FontFace) describe() *FontDescription {
	gclass := (*C.PangoFontFaceClass)(coreglib.PeekParentClass(face))
	fnarg := gclass.describe

	var _arg0 *C.PangoFontFace        // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C._gotk4_pango1_FontFace_virtual_describe(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(face)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

// faceName gets a name representing the style of this face.
//
// Note that a font family may contain multiple faces with the same name (e.g.
// a variable and a non-variable face for the same style).
//
// The function returns the following values:
//
//   - utf8: face name for the face. This string is owned by the face object and
//     must not be modified or freed.
func (face *FontFace) faceName() string {
	gclass := (*C.PangoFontFaceClass)(coreglib.PeekParentClass(face))
	fnarg := gclass.get_face_name

	var _arg0 *C.PangoFontFace // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C._gotk4_pango1_FontFace_virtual_get_face_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(face)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Family gets the PangoFontFamily that face belongs to.
//
// The function returns the following values:
//
//   - fontFamily: PangoFontFamily.
func (face *FontFace) family() FontFamilier {
	gclass := (*C.PangoFontFaceClass)(coreglib.PeekParentClass(face))
	fnarg := gclass.get_family

	var _arg0 *C.PangoFontFace   // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C._gotk4_pango1_FontFace_virtual_get_family(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(face)

	var _fontFamily FontFamilier // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontFamilier is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FontFamilier)
			return ok
		})
		rv, ok := casted.(FontFamilier)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
		}
		_fontFamily = rv
	}

	return _fontFamily
}

// isSynthesized returns whether a PangoFontFace is synthesized.
//
// This will be the case if the underlying font rendering engine creates this
// face from another face, by shearing, emboldening, lightening or modifying it
// in some other way.
//
// The function returns the following values:
//
//   - ok: whether face is synthesized.
func (face *FontFace) isSynthesized() bool {
	gclass := (*C.PangoFontFaceClass)(coreglib.PeekParentClass(face))
	fnarg := gclass.is_synthesized

	var _arg0 *C.PangoFontFace // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_cret = C._gotk4_pango1_FontFace_virtual_is_synthesized(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(face)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// listSizes: list the available sizes for a font.
//
// This is only applicable to bitmap fonts. For scalable fonts, stores NULL at
// the location pointed to by sizes and 0 at the location pointed to by n_sizes.
// The sizes returned are in Pango units and are sorted in ascending order.
//
// The function returns the following values:
//
//   - sizes (optional): location to store a pointer to an array of int.
//     This array should be freed with g_free().
func (face *FontFace) listSizes() []int {
	gclass := (*C.PangoFontFaceClass)(coreglib.PeekParentClass(face))
	fnarg := gclass.list_sizes

	var _arg0 *C.PangoFontFace // out
	var _arg1 *C.int           // in
	var _arg2 C.int            // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	C._gotk4_pango1_FontFace_virtual_list_sizes(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(face)

	var _sizes []int // out

	if _arg1 != nil {
		defer C.free(unsafe.Pointer(_arg1))
		{
			src := unsafe.Slice((*C.int)(_arg1), _arg2)
			_sizes = make([]int, _arg2)
			for i := 0; i < int(_arg2); i++ {
				_sizes[i] = int(src[i])
			}
		}
	}

	return _sizes
}

// FontFamilyOverrides contains methods that are overridable.
type FontFamilyOverrides struct {
	// Face gets the PangoFontFace of family with the given name.
	//
	// The function takes the following parameters:
	//
	//   - name (optional) of a face. If the name is NULL, the family's default
	//     face (fontconfig calls it "Regular") will be returned.
	//
	// The function returns the following values:
	//
	//   - fontFace (optional): PangoFontFace, or NULL if no face with the given
	//     name exists.
	Face func(name string) FontFacer
	// Name gets the name of the family.
	//
	// The name is unique among all fonts for the font backend and can be used
	// in a PangoFontDescription to specify that a face from this family is
	// desired.
	//
	// The function returns the following values:
	//
	//   - utf8: name of the family. This string is owned by the family object
	//     and must not be modified or freed.
	Name func() string
	// IsMonospace: monospace font is a font designed for text display where the
	// the characters form a regular grid.
	//
	// For Western languages this would mean that the advance width of all
	// characters are the same, but this categorization also includes Asian
	// fonts which include double-width characters: characters that occupy two
	// grid cells. g_unichar_iswide() returns a result that indicates whether a
	// character is typically double-width in a monospace font.
	//
	// The best way to find out the grid-cell size is to call
	// pango.FontMetrics.GetApproximateDigitWidth(), since the results
	// of pango.FontMetrics.GetApproximateCharWidth() may be affected by
	// double-width characters.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the family is monospace.
	IsMonospace func() bool
	// IsVariable: variable font is a font which has axes that can be modified
	// to produce different faces.
	//
	// Such axes are also known as _variations_; see
	// pango.FontDescription.SetVariations() for more information.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the family is variable.
	IsVariable func() bool
	// ListFaces lists the different font faces that make up family.
	//
	// The faces in a family share a common design, but differ in slant, weight,
	// width and other aspects.
	//
	// Note that the returned faces are not in any particular order, and
	// multiple faces may have the same name or characteristics.
	//
	// PangoFontFamily also implemented the gio.ListModel interface for
	// enumerating faces.
	//
	// The function returns the following values:
	//
	//   - faces (optional): location to store an array of pointers to
	//     PangoFontFace objects, or NULL. This array should be freed with
	//     g_free() when it is no longer needed.
	ListFaces func() []FontFacer
}

func defaultFontFamilyOverrides(v *FontFamily) FontFamilyOverrides {
	return FontFamilyOverrides{
		Face:        v.face,
		Name:        v.name,
		IsMonospace: v.isMonospace,
		IsVariable:  v.isVariable,
		ListFaces:   v.listFaces,
	}
}

// FontFamily: PangoFontFamily is used to represent a family of related font
// faces.
//
// The font faces in a family share a common design, but differ in slant,
// weight, width or other aspects.
type FontFamily struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*FontFamily)(nil)
)

// FontFamilier describes types inherited from class FontFamily.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FontFamilier interface {
	coreglib.Objector
	baseFontFamily() *FontFamily
}

var _ FontFamilier = (*FontFamily)(nil)

func init() {
	coreglib.RegisterClassInfo[*FontFamily, *FontFamilyClass, FontFamilyOverrides](
		GTypeFontFamily,
		initFontFamilyClass,
		wrapFontFamily,
		defaultFontFamilyOverrides,
	)
}

func initFontFamilyClass(gclass unsafe.Pointer, overrides FontFamilyOverrides, classInitFunc func(*FontFamilyClass)) {
	pclass := (*C.PangoFontFamilyClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFontFamily))))

	if overrides.Face != nil {
		pclass.get_face = (*[0]byte)(C._gotk4_pango1_FontFamilyClass_get_face)
	}

	if overrides.Name != nil {
		pclass.get_name = (*[0]byte)(C._gotk4_pango1_FontFamilyClass_get_name)
	}

	if overrides.IsMonospace != nil {
		pclass.is_monospace = (*[0]byte)(C._gotk4_pango1_FontFamilyClass_is_monospace)
	}

	if overrides.IsVariable != nil {
		pclass.is_variable = (*[0]byte)(C._gotk4_pango1_FontFamilyClass_is_variable)
	}

	if overrides.ListFaces != nil {
		pclass.list_faces = (*[0]byte)(C._gotk4_pango1_FontFamilyClass_list_faces)
	}

	if classInitFunc != nil {
		class := (*FontFamilyClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFontFamily(obj *coreglib.Object) *FontFamily {
	return &FontFamily{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalFontFamily(p uintptr) (interface{}, error) {
	return wrapFontFamily(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (family *FontFamily) baseFontFamily() *FontFamily {
	return family
}

// BaseFontFamily returns the underlying base object.
func BaseFontFamily(obj FontFamilier) *FontFamily {
	return obj.baseFontFamily()
}

// Face gets the PangoFontFace of family with the given name.
//
// The function takes the following parameters:
//
//   - name (optional) of a face. If the name is NULL, the family's default face
//     (fontconfig calls it "Regular") will be returned.
//
// The function returns the following values:
//
//   - fontFace (optional): PangoFontFace, or NULL if no face with the given
//     name exists.
func (family *FontFamily) Face(name string) FontFacer {
	var _arg0 *C.PangoFontFamily // out
	var _arg1 *C.char            // out
	var _cret *C.PangoFontFace   // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.pango_font_family_get_face(_arg0, _arg1)
	runtime.KeepAlive(family)
	runtime.KeepAlive(name)

	var _fontFace FontFacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontFacer)
				return ok
			})
			rv, ok := casted.(FontFacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
			}
			_fontFace = rv
		}
	}

	return _fontFace
}

// Name gets the name of the family.
//
// The name is unique among all fonts for the font backend and can be used in a
// PangoFontDescription to specify that a face from this family is desired.
//
// The function returns the following values:
//
//   - utf8: name of the family. This string is owned by the family object and
//     must not be modified or freed.
func (family *FontFamily) Name() string {
	var _arg0 *C.PangoFontFamily // out
	var _cret *C.char            // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_cret = C.pango_font_family_get_name(_arg0)
	runtime.KeepAlive(family)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsMonospace: monospace font is a font designed for text display where the the
// characters form a regular grid.
//
// For Western languages this would mean that the advance width of all
// characters are the same, but this categorization also includes Asian fonts
// which include double-width characters: characters that occupy two grid cells.
// g_unichar_iswide() returns a result that indicates whether a character is
// typically double-width in a monospace font.
//
// The best way to find out the grid-cell size is to call
// pango.FontMetrics.GetApproximateDigitWidth(), since the results of
// pango.FontMetrics.GetApproximateCharWidth() may be affected by double-width
// characters.
//
// The function returns the following values:
//
//   - ok: TRUE if the family is monospace.
func (family *FontFamily) IsMonospace() bool {
	var _arg0 *C.PangoFontFamily // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_cret = C.pango_font_family_is_monospace(_arg0)
	runtime.KeepAlive(family)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVariable: variable font is a font which has axes that can be modified to
// produce different faces.
//
// Such axes are also known as _variations_; see
// pango.FontDescription.SetVariations() for more information.
//
// The function returns the following values:
//
//   - ok: TRUE if the family is variable.
func (family *FontFamily) IsVariable() bool {
	var _arg0 *C.PangoFontFamily // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_cret = C.pango_font_family_is_variable(_arg0)
	runtime.KeepAlive(family)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListFaces lists the different font faces that make up family.
//
// The faces in a family share a common design, but differ in slant, weight,
// width and other aspects.
//
// Note that the returned faces are not in any particular order, and multiple
// faces may have the same name or characteristics.
//
// PangoFontFamily also implemented the gio.ListModel interface for enumerating
// faces.
//
// The function returns the following values:
//
//   - faces (optional): location to store an array of pointers to PangoFontFace
//     objects, or NULL. This array should be freed with g_free() when it is no
//     longer needed.
func (family *FontFamily) ListFaces() []FontFacer {
	var _arg0 *C.PangoFontFamily // out
	var _arg1 **C.PangoFontFace  // in
	var _arg2 C.int              // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	C.pango_font_family_list_faces(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(family)

	var _faces []FontFacer // out

	if _arg1 != nil {
		defer C.free(unsafe.Pointer(_arg1))
		{
			src := unsafe.Slice((**C.PangoFontFace)(_arg1), _arg2)
			_faces = make([]FontFacer, _arg2)
			for i := 0; i < int(_arg2); i++ {
				{
					objptr := unsafe.Pointer(src[i])
					if objptr == nil {
						panic("object of type pango.FontFacer is nil")
					}

					object := coreglib.Take(objptr)
					casted := object.WalkCast(func(obj coreglib.Objector) bool {
						_, ok := obj.(FontFacer)
						return ok
					})
					rv, ok := casted.(FontFacer)
					if !ok {
						panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
					}
					_faces[i] = rv
				}
			}
		}
	}

	return _faces
}

// Face gets the PangoFontFace of family with the given name.
//
// The function takes the following parameters:
//
//   - name (optional) of a face. If the name is NULL, the family's default face
//     (fontconfig calls it "Regular") will be returned.
//
// The function returns the following values:
//
//   - fontFace (optional): PangoFontFace, or NULL if no face with the given
//     name exists.
func (family *FontFamily) face(name string) FontFacer {
	gclass := (*C.PangoFontFamilyClass)(coreglib.PeekParentClass(family))
	fnarg := gclass.get_face

	var _arg0 *C.PangoFontFamily // out
	var _arg1 *C.char            // out
	var _cret *C.PangoFontFace   // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C._gotk4_pango1_FontFamily_virtual_get_face(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(family)
	runtime.KeepAlive(name)

	var _fontFace FontFacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontFacer)
				return ok
			})
			rv, ok := casted.(FontFacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
			}
			_fontFace = rv
		}
	}

	return _fontFace
}

// Name gets the name of the family.
//
// The name is unique among all fonts for the font backend and can be used in a
// PangoFontDescription to specify that a face from this family is desired.
//
// The function returns the following values:
//
//   - utf8: name of the family. This string is owned by the family object and
//     must not be modified or freed.
func (family *FontFamily) name() string {
	gclass := (*C.PangoFontFamilyClass)(coreglib.PeekParentClass(family))
	fnarg := gclass.get_name

	var _arg0 *C.PangoFontFamily // out
	var _cret *C.char            // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_cret = C._gotk4_pango1_FontFamily_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(family)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// isMonospace: monospace font is a font designed for text display where the the
// characters form a regular grid.
//
// For Western languages this would mean that the advance width of all
// characters are the same, but this categorization also includes Asian fonts
// which include double-width characters: characters that occupy two grid cells.
// g_unichar_iswide() returns a result that indicates whether a character is
// typically double-width in a monospace font.
//
// The best way to find out the grid-cell size is to call
// pango.FontMetrics.GetApproximateDigitWidth(), since the results of
// pango.FontMetrics.GetApproximateCharWidth() may be affected by double-width
// characters.
//
// The function returns the following values:
//
//   - ok: TRUE if the family is monospace.
func (family *FontFamily) isMonospace() bool {
	gclass := (*C.PangoFontFamilyClass)(coreglib.PeekParentClass(family))
	fnarg := gclass.is_monospace

	var _arg0 *C.PangoFontFamily // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_cret = C._gotk4_pango1_FontFamily_virtual_is_monospace(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(family)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// isVariable: variable font is a font which has axes that can be modified to
// produce different faces.
//
// Such axes are also known as _variations_; see
// pango.FontDescription.SetVariations() for more information.
//
// The function returns the following values:
//
//   - ok: TRUE if the family is variable.
func (family *FontFamily) isVariable() bool {
	gclass := (*C.PangoFontFamilyClass)(coreglib.PeekParentClass(family))
	fnarg := gclass.is_variable

	var _arg0 *C.PangoFontFamily // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_cret = C._gotk4_pango1_FontFamily_virtual_is_variable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(family)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// listFaces lists the different font faces that make up family.
//
// The faces in a family share a common design, but differ in slant, weight,
// width and other aspects.
//
// Note that the returned faces are not in any particular order, and multiple
// faces may have the same name or characteristics.
//
// PangoFontFamily also implemented the gio.ListModel interface for enumerating
// faces.
//
// The function returns the following values:
//
//   - faces (optional): location to store an array of pointers to PangoFontFace
//     objects, or NULL. This array should be freed with g_free() when it is no
//     longer needed.
func (family *FontFamily) listFaces() []FontFacer {
	gclass := (*C.PangoFontFamilyClass)(coreglib.PeekParentClass(family))
	fnarg := gclass.list_faces

	var _arg0 *C.PangoFontFamily // out
	var _arg1 **C.PangoFontFace  // in
	var _arg2 C.int              // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	C._gotk4_pango1_FontFamily_virtual_list_faces(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(family)

	var _faces []FontFacer // out

	if _arg1 != nil {
		defer C.free(unsafe.Pointer(_arg1))
		{
			src := unsafe.Slice((**C.PangoFontFace)(_arg1), _arg2)
			_faces = make([]FontFacer, _arg2)
			for i := 0; i < int(_arg2); i++ {
				{
					objptr := unsafe.Pointer(src[i])
					if objptr == nil {
						panic("object of type pango.FontFacer is nil")
					}

					object := coreglib.Take(objptr)
					casted := object.WalkCast(func(obj coreglib.Objector) bool {
						_, ok := obj.(FontFacer)
						return ok
					})
					rv, ok := casted.(FontFacer)
					if !ok {
						panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
					}
					_faces[i] = rv
				}
			}
		}
	}

	return _faces
}

// FontMapOverrides contains methods that are overridable.
type FontMapOverrides struct {
	// Changed forces a change in the context, which will cause any PangoContext
	// using this fontmap to change.
	//
	// This function is only useful when implementing a new backend for Pango,
	// something applications won't do. Backends should call this function if
	// they have attached extra data to the context and such data is changed.
	Changed func()
	// Family gets a font family by name.
	//
	// The function takes the following parameters:
	//
	//   - name: family name.
	//
	// The function returns the following values:
	//
	//   - fontFamily: PangoFontFamily.
	Family func(name string) FontFamilier
	// Serial returns the current serial number of fontmap.
	//
	// The serial number is initialized to an small number larger than zero
	// when a new fontmap is created and is increased whenever the fontmap is
	// changed. It may wrap, but will never have the value 0. Since it can wrap,
	// never compare it with "less than", always use "not equals".
	//
	// The fontmap can only be changed using backend-specific API, like changing
	// fontmap resolution.
	//
	// This can be used to automatically detect changes to a PangoFontMap,
	// like in PangoContext.
	//
	// The function returns the following values:
	//
	//   - guint: current serial number of fontmap.
	Serial func() uint
	// ListFamilies: list all families for a fontmap.
	//
	// Note that the returned families are not in any particular order.
	//
	// PangoFontMap also implemented the gio.ListModel interface for enumerating
	// families.
	//
	// The function returns the following values:
	//
	//   - families: location to store a pointer to an array of PangoFontFamily
	//     *. This array should be freed with g_free().
	ListFamilies func() []FontFamilier
	// LoadFont: load the font in the fontmap that is the closest match for
	// desc.
	//
	// The function takes the following parameters:
	//
	//   - context: PangoContext the font will be used with.
	//   - desc: PangoFontDescription describing the font to load.
	//
	// The function returns the following values:
	//
	//   - font (optional): newly allocated PangoFont loaded, or NULL if no font
	//     matched.
	LoadFont func(context *Context, desc *FontDescription) Fonter
	// LoadFontset: load a set of fonts in the fontmap that can be used to
	// render a font matching desc.
	//
	// The function takes the following parameters:
	//
	//   - context: PangoContext the font will be used with.
	//   - desc: PangoFontDescription describing the font to load.
	//   - language: PangoLanguage the fonts will be used for.
	//
	// The function returns the following values:
	//
	//   - fontset (optional): newly allocated PangoFontset loaded, or NULL if
	//     no font matched.
	LoadFontset func(context *Context, desc *FontDescription, language *Language) Fontsetter
}

func defaultFontMapOverrides(v *FontMap) FontMapOverrides {
	return FontMapOverrides{
		Changed:      v.changed,
		Family:       v.family,
		Serial:       v.serial,
		ListFamilies: v.listFamilies,
		LoadFont:     v.loadFont,
		LoadFontset:  v.loadFontset,
	}
}

// FontMap: PangoFontMap represents the set of fonts available for a particular
// rendering system.
//
// This is a virtual object with implementations being specific to particular
// rendering systems.
type FontMap struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*FontMap)(nil)
)

// FontMapper describes types inherited from class FontMap.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FontMapper interface {
	coreglib.Objector
	baseFontMap() *FontMap
}

var _ FontMapper = (*FontMap)(nil)

func init() {
	coreglib.RegisterClassInfo[*FontMap, *FontMapClass, FontMapOverrides](
		GTypeFontMap,
		initFontMapClass,
		wrapFontMap,
		defaultFontMapOverrides,
	)
}

func initFontMapClass(gclass unsafe.Pointer, overrides FontMapOverrides, classInitFunc func(*FontMapClass)) {
	pclass := (*C.PangoFontMapClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFontMap))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_pango1_FontMapClass_changed)
	}

	if overrides.Family != nil {
		pclass.get_family = (*[0]byte)(C._gotk4_pango1_FontMapClass_get_family)
	}

	if overrides.Serial != nil {
		pclass.get_serial = (*[0]byte)(C._gotk4_pango1_FontMapClass_get_serial)
	}

	if overrides.ListFamilies != nil {
		pclass.list_families = (*[0]byte)(C._gotk4_pango1_FontMapClass_list_families)
	}

	if overrides.LoadFont != nil {
		pclass.load_font = (*[0]byte)(C._gotk4_pango1_FontMapClass_load_font)
	}

	if overrides.LoadFontset != nil {
		pclass.load_fontset = (*[0]byte)(C._gotk4_pango1_FontMapClass_load_fontset)
	}

	if classInitFunc != nil {
		class := (*FontMapClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFontMap(obj *coreglib.Object) *FontMap {
	return &FontMap{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalFontMap(p uintptr) (interface{}, error) {
	return wrapFontMap(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (fontmap *FontMap) baseFontMap() *FontMap {
	return fontmap
}

// BaseFontMap returns the underlying base object.
func BaseFontMap(obj FontMapper) *FontMap {
	return obj.baseFontMap()
}

// Changed forces a change in the context, which will cause any PangoContext
// using this fontmap to change.
//
// This function is only useful when implementing a new backend for Pango,
// something applications won't do. Backends should call this function if they
// have attached extra data to the context and such data is changed.
func (fontmap *FontMap) Changed() {
	var _arg0 *C.PangoFontMap // out

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))

	C.pango_font_map_changed(_arg0)
	runtime.KeepAlive(fontmap)
}

// CreateContext creates a PangoContext connected to fontmap.
//
// This is equivalent to pango.Context.New followed by
// pango.Context.SetFontMap().
//
// If you are using Pango as part of a higher-level system, that system may have
// it's own way of create a PangoContext. For instance, the GTK toolkit has,
// among others, gtk_widget_get_pango_context(). Use those instead.
//
// The function returns the following values:
//
//   - context: newly allocated PangoContext, which should be freed with
//     g_object_unref().
func (fontmap *FontMap) CreateContext() *Context {
	var _arg0 *C.PangoFontMap // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))

	_cret = C.pango_font_map_create_context(_arg0)
	runtime.KeepAlive(fontmap)

	var _context *Context // out

	_context = wrapContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _context
}

// Family gets a font family by name.
//
// The function takes the following parameters:
//
//   - name: family name.
//
// The function returns the following values:
//
//   - fontFamily: PangoFontFamily.
func (fontmap *FontMap) Family(name string) FontFamilier {
	var _arg0 *C.PangoFontMap    // out
	var _arg1 *C.char            // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_font_map_get_family(_arg0, _arg1)
	runtime.KeepAlive(fontmap)
	runtime.KeepAlive(name)

	var _fontFamily FontFamilier // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontFamilier is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FontFamilier)
			return ok
		})
		rv, ok := casted.(FontFamilier)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
		}
		_fontFamily = rv
	}

	return _fontFamily
}

// Serial returns the current serial number of fontmap.
//
// The serial number is initialized to an small number larger than zero when
// a new fontmap is created and is increased whenever the fontmap is changed.
// It may wrap, but will never have the value 0. Since it can wrap, never
// compare it with "less than", always use "not equals".
//
// The fontmap can only be changed using backend-specific API, like changing
// fontmap resolution.
//
// This can be used to automatically detect changes to a PangoFontMap, like in
// PangoContext.
//
// The function returns the following values:
//
//   - guint: current serial number of fontmap.
func (fontmap *FontMap) Serial() uint {
	var _arg0 *C.PangoFontMap // out
	var _cret C.guint         // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))

	_cret = C.pango_font_map_get_serial(_arg0)
	runtime.KeepAlive(fontmap)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ListFamilies: list all families for a fontmap.
//
// Note that the returned families are not in any particular order.
//
// PangoFontMap also implemented the gio.ListModel interface for enumerating
// families.
//
// The function returns the following values:
//
//   - families: location to store a pointer to an array of PangoFontFamily *.
//     This array should be freed with g_free().
func (fontmap *FontMap) ListFamilies() []FontFamilier {
	var _arg0 *C.PangoFontMap     // out
	var _arg1 **C.PangoFontFamily // in
	var _arg2 C.int               // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))

	C.pango_font_map_list_families(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(fontmap)

	var _families []FontFamilier // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice((**C.PangoFontFamily)(_arg1), _arg2)
		_families = make([]FontFamilier, _arg2)
		for i := 0; i < int(_arg2); i++ {
			{
				objptr := unsafe.Pointer(src[i])
				if objptr == nil {
					panic("object of type pango.FontFamilier is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(FontFamilier)
					return ok
				})
				rv, ok := casted.(FontFamilier)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
				}
				_families[i] = rv
			}
		}
	}

	return _families
}

// LoadFont: load the font in the fontmap that is the closest match for desc.
//
// The function takes the following parameters:
//
//   - context: PangoContext the font will be used with.
//   - desc: PangoFontDescription describing the font to load.
//
// The function returns the following values:
//
//   - font (optional): newly allocated PangoFont loaded, or NULL if no font
//     matched.
func (fontmap *FontMap) LoadFont(context *Context, desc *FontDescription) Fonter {
	var _arg0 *C.PangoFontMap         // out
	var _arg1 *C.PangoContext         // out
	var _arg2 *C.PangoFontDescription // out
	var _cret *C.PangoFont            // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_map_load_font(_arg0, _arg1, _arg2)
	runtime.KeepAlive(fontmap)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)

	var _font Fonter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Fonter)
				return ok
			})
			rv, ok := casted.(Fonter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
			}
			_font = rv
		}
	}

	return _font
}

// LoadFontset: load a set of fonts in the fontmap that can be used to render a
// font matching desc.
//
// The function takes the following parameters:
//
//   - context: PangoContext the font will be used with.
//   - desc: PangoFontDescription describing the font to load.
//   - language: PangoLanguage the fonts will be used for.
//
// The function returns the following values:
//
//   - fontset (optional): newly allocated PangoFontset loaded, or NULL if no
//     font matched.
func (fontmap *FontMap) LoadFontset(context *Context, desc *FontDescription, language *Language) Fontsetter {
	var _arg0 *C.PangoFontMap         // out
	var _arg1 *C.PangoContext         // out
	var _arg2 *C.PangoFontDescription // out
	var _arg3 *C.PangoLanguage        // out
	var _cret *C.PangoFontset         // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg3 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C.pango_font_map_load_fontset(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(fontmap)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(language)

	var _fontset Fontsetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Fontsetter)
				return ok
			})
			rv, ok := casted.(Fontsetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fontsetter")
			}
			_fontset = rv
		}
	}

	return _fontset
}

// ReloadFont returns a new font that is like font, except that its size is
// multiplied by scale, its backend-dependent configuration (e.g. cairo font
// options) is replaced by the one in context, and its variations are replaced
// by variations.
//
// The function takes the following parameters:
//
//   - font in fontmap.
//   - scale factor to apply.
//   - context (optional): PangoContext.
//   - variations (optional): font variations to use.
//
// The function returns the following values:
//
//   - ret: modified font.
func (fontmap *FontMap) ReloadFont(font Fonter, scale float64, context *Context, variations string) Fonter {
	var _arg0 *C.PangoFontMap // out
	var _arg1 *C.PangoFont    // out
	var _arg2 C.double        // out
	var _arg3 *C.PangoContext // out
	var _arg4 *C.char         // out
	var _cret *C.PangoFont    // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg2 = C.double(scale)
	if context != nil {
		_arg3 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}
	if variations != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(variations)))
		defer C.free(unsafe.Pointer(_arg4))
	}

	_cret = C.pango_font_map_reload_font(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(fontmap)
	runtime.KeepAlive(font)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(context)
	runtime.KeepAlive(variations)

	var _ret Fonter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Fonter)
			return ok
		})
		rv, ok := casted.(Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_ret = rv
	}

	return _ret
}

// Changed forces a change in the context, which will cause any PangoContext
// using this fontmap to change.
//
// This function is only useful when implementing a new backend for Pango,
// something applications won't do. Backends should call this function if they
// have attached extra data to the context and such data is changed.
func (fontmap *FontMap) changed() {
	gclass := (*C.PangoFontMapClass)(coreglib.PeekParentClass(fontmap))
	fnarg := gclass.changed

	var _arg0 *C.PangoFontMap // out

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))

	C._gotk4_pango1_FontMap_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontmap)
}

// Family gets a font family by name.
//
// The function takes the following parameters:
//
//   - name: family name.
//
// The function returns the following values:
//
//   - fontFamily: PangoFontFamily.
func (fontmap *FontMap) family(name string) FontFamilier {
	gclass := (*C.PangoFontMapClass)(coreglib.PeekParentClass(fontmap))
	fnarg := gclass.get_family

	var _arg0 *C.PangoFontMap    // out
	var _arg1 *C.char            // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_pango1_FontMap_virtual_get_family(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(fontmap)
	runtime.KeepAlive(name)

	var _fontFamily FontFamilier // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontFamilier is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FontFamilier)
			return ok
		})
		rv, ok := casted.(FontFamilier)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
		}
		_fontFamily = rv
	}

	return _fontFamily
}

// Serial returns the current serial number of fontmap.
//
// The serial number is initialized to an small number larger than zero when
// a new fontmap is created and is increased whenever the fontmap is changed.
// It may wrap, but will never have the value 0. Since it can wrap, never
// compare it with "less than", always use "not equals".
//
// The fontmap can only be changed using backend-specific API, like changing
// fontmap resolution.
//
// This can be used to automatically detect changes to a PangoFontMap, like in
// PangoContext.
//
// The function returns the following values:
//
//   - guint: current serial number of fontmap.
func (fontmap *FontMap) serial() uint {
	gclass := (*C.PangoFontMapClass)(coreglib.PeekParentClass(fontmap))
	fnarg := gclass.get_serial

	var _arg0 *C.PangoFontMap // out
	var _cret C.guint         // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))

	_cret = C._gotk4_pango1_FontMap_virtual_get_serial(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontmap)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// listFamilies: list all families for a fontmap.
//
// Note that the returned families are not in any particular order.
//
// PangoFontMap also implemented the gio.ListModel interface for enumerating
// families.
//
// The function returns the following values:
//
//   - families: location to store a pointer to an array of PangoFontFamily *.
//     This array should be freed with g_free().
func (fontmap *FontMap) listFamilies() []FontFamilier {
	gclass := (*C.PangoFontMapClass)(coreglib.PeekParentClass(fontmap))
	fnarg := gclass.list_families

	var _arg0 *C.PangoFontMap     // out
	var _arg1 **C.PangoFontFamily // in
	var _arg2 C.int               // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))

	C._gotk4_pango1_FontMap_virtual_list_families(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(fontmap)

	var _families []FontFamilier // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice((**C.PangoFontFamily)(_arg1), _arg2)
		_families = make([]FontFamilier, _arg2)
		for i := 0; i < int(_arg2); i++ {
			{
				objptr := unsafe.Pointer(src[i])
				if objptr == nil {
					panic("object of type pango.FontFamilier is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(FontFamilier)
					return ok
				})
				rv, ok := casted.(FontFamilier)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
				}
				_families[i] = rv
			}
		}
	}

	return _families
}

// loadFont: load the font in the fontmap that is the closest match for desc.
//
// The function takes the following parameters:
//
//   - context: PangoContext the font will be used with.
//   - desc: PangoFontDescription describing the font to load.
//
// The function returns the following values:
//
//   - font (optional): newly allocated PangoFont loaded, or NULL if no font
//     matched.
func (fontmap *FontMap) loadFont(context *Context, desc *FontDescription) Fonter {
	gclass := (*C.PangoFontMapClass)(coreglib.PeekParentClass(fontmap))
	fnarg := gclass.load_font

	var _arg0 *C.PangoFontMap         // out
	var _arg1 *C.PangoContext         // out
	var _arg2 *C.PangoFontDescription // out
	var _cret *C.PangoFont            // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C._gotk4_pango1_FontMap_virtual_load_font(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(fontmap)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)

	var _font Fonter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Fonter)
				return ok
			})
			rv, ok := casted.(Fonter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
			}
			_font = rv
		}
	}

	return _font
}

// loadFontset: load a set of fonts in the fontmap that can be used to render a
// font matching desc.
//
// The function takes the following parameters:
//
//   - context: PangoContext the font will be used with.
//   - desc: PangoFontDescription describing the font to load.
//   - language: PangoLanguage the fonts will be used for.
//
// The function returns the following values:
//
//   - fontset (optional): newly allocated PangoFontset loaded, or NULL if no
//     font matched.
func (fontmap *FontMap) loadFontset(context *Context, desc *FontDescription, language *Language) Fontsetter {
	gclass := (*C.PangoFontMapClass)(coreglib.PeekParentClass(fontmap))
	fnarg := gclass.load_fontset

	var _arg0 *C.PangoFontMap         // out
	var _arg1 *C.PangoContext         // out
	var _arg2 *C.PangoFontDescription // out
	var _arg3 *C.PangoLanguage        // out
	var _cret *C.PangoFontset         // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg3 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C._gotk4_pango1_FontMap_virtual_load_fontset(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(fontmap)
	runtime.KeepAlive(context)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(language)

	var _fontset Fontsetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Fontsetter)
				return ok
			})
			rv, ok := casted.(Fontsetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fontsetter")
			}
			_fontset = rv
		}
	}

	return _fontset
}

// FontsetOverrides contains methods that are overridable.
type FontsetOverrides struct {
	// Font returns the font in the fontset that contains the best glyph for a
	// Unicode character.
	//
	// The function takes the following parameters:
	//
	//   - wc: unicode character.
	//
	// The function returns the following values:
	//
	//   - font: PangoFont.
	Font func(wc uint) Fonter
	// Language: function to get the language of the fontset.
	Language func() *Language
	// Metrics: get overall metric information for the fonts in the fontset.
	//
	// The function returns the following values:
	//
	//   - fontMetrics: PangoFontMetrics object.
	Metrics func() *FontMetrics
}

func defaultFontsetOverrides(v *Fontset) FontsetOverrides {
	return FontsetOverrides{
		Font:     v.font,
		Language: v.language,
		Metrics:  v.metrics,
	}
}

// Fontset: PangoFontset represents a set of PangoFont to use when rendering
// text.
//
// A PangoFontset is the result of resolving a PangoFontDescription against a
// particular PangoContext. It has operations for finding the component font for
// a particular Unicode character, and for finding a composite set of metrics
// for the entire fontset.
type Fontset struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Fontset)(nil)
)

// Fontsetter describes types inherited from class Fontset.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Fontsetter interface {
	coreglib.Objector
	baseFontset() *Fontset
}

var _ Fontsetter = (*Fontset)(nil)

func init() {
	coreglib.RegisterClassInfo[*Fontset, *FontsetClass, FontsetOverrides](
		GTypeFontset,
		initFontsetClass,
		wrapFontset,
		defaultFontsetOverrides,
	)
}

func initFontsetClass(gclass unsafe.Pointer, overrides FontsetOverrides, classInitFunc func(*FontsetClass)) {
	pclass := (*C.PangoFontsetClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFontset))))

	if overrides.Font != nil {
		pclass.get_font = (*[0]byte)(C._gotk4_pango1_FontsetClass_get_font)
	}

	if overrides.Language != nil {
		pclass.get_language = (*[0]byte)(C._gotk4_pango1_FontsetClass_get_language)
	}

	if overrides.Metrics != nil {
		pclass.get_metrics = (*[0]byte)(C._gotk4_pango1_FontsetClass_get_metrics)
	}

	if classInitFunc != nil {
		class := (*FontsetClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFontset(obj *coreglib.Object) *Fontset {
	return &Fontset{
		Object: obj,
	}
}

func marshalFontset(p uintptr) (interface{}, error) {
	return wrapFontset(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (fontset *Fontset) baseFontset() *Fontset {
	return fontset
}

// BaseFontset returns the underlying base object.
func BaseFontset(obj Fontsetter) *Fontset {
	return obj.baseFontset()
}

// ForEach iterates through all the fonts in a fontset, calling func for each
// one.
//
// If func returns TRUE, that stops the iteration.
//
// The function takes the following parameters:
//
//   - fn: callback function.
func (fontset *Fontset) ForEach(fn FontsetForEachFunc) {
	var _arg0 *C.PangoFontset           // out
	var _arg1 C.PangoFontsetForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))
	_arg1 = (*[0]byte)(C._gotk4_pango1_FontsetForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.pango_fontset_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(fontset)
	runtime.KeepAlive(fn)
}

// Font returns the font in the fontset that contains the best glyph for a
// Unicode character.
//
// The function takes the following parameters:
//
//   - wc: unicode character.
//
// The function returns the following values:
//
//   - font: PangoFont.
func (fontset *Fontset) Font(wc uint) Fonter {
	var _arg0 *C.PangoFontset // out
	var _arg1 C.guint         // out
	var _cret *C.PangoFont    // in

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))
	_arg1 = C.guint(wc)

	_cret = C.pango_fontset_get_font(_arg0, _arg1)
	runtime.KeepAlive(fontset)
	runtime.KeepAlive(wc)

	var _font Fonter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Fonter)
			return ok
		})
		rv, ok := casted.(Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_font = rv
	}

	return _font
}

// Metrics: get overall metric information for the fonts in the fontset.
//
// The function returns the following values:
//
//   - fontMetrics: PangoFontMetrics object.
func (fontset *Fontset) Metrics() *FontMetrics {
	var _arg0 *C.PangoFontset     // out
	var _cret *C.PangoFontMetrics // in

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))

	_cret = C.pango_fontset_get_metrics(_arg0)
	runtime.KeepAlive(fontset)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = (*FontMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontMetrics)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_metrics_unref((*C.PangoFontMetrics)(intern.C))
		},
	)

	return _fontMetrics
}

// forEach iterates through all the fonts in a fontset, calling func for each
// one.
//
// If func returns TRUE, that stops the iteration.
//
// The function takes the following parameters:
//
//   - fn: callback function.
func (fontset *Fontset) forEach(fn FontsetForEachFunc) {
	gclass := (*C.PangoFontsetClass)(coreglib.PeekParentClass(fontset))
	fnarg := gclass.foreach

	var _arg0 *C.PangoFontset           // out
	var _arg1 C.PangoFontsetForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))
	_arg1 = (*[0]byte)(C._gotk4_pango1_FontsetForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C._gotk4_pango1_Fontset_virtual_foreach(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(fontset)
	runtime.KeepAlive(fn)
}

// Font returns the font in the fontset that contains the best glyph for a
// Unicode character.
//
// The function takes the following parameters:
//
//   - wc: unicode character.
//
// The function returns the following values:
//
//   - font: PangoFont.
func (fontset *Fontset) font(wc uint) Fonter {
	gclass := (*C.PangoFontsetClass)(coreglib.PeekParentClass(fontset))
	fnarg := gclass.get_font

	var _arg0 *C.PangoFontset // out
	var _arg1 C.guint         // out
	var _cret *C.PangoFont    // in

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))
	_arg1 = C.guint(wc)

	_cret = C._gotk4_pango1_Fontset_virtual_get_font(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(fontset)
	runtime.KeepAlive(wc)

	var _font Fonter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Fonter)
			return ok
		})
		rv, ok := casted.(Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_font = rv
	}

	return _font
}

// Language: function to get the language of the fontset.
func (fontset *Fontset) language() *Language {
	gclass := (*C.PangoFontsetClass)(coreglib.PeekParentClass(fontset))
	fnarg := gclass.get_language

	var _arg0 *C.PangoFontset  // out
	var _cret *C.PangoLanguage // in

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))

	_cret = C._gotk4_pango1_Fontset_virtual_get_language(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontset)

	var _language *Language // out

	_language = (*Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_language)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _language
}

// Metrics: get overall metric information for the fonts in the fontset.
//
// The function returns the following values:
//
//   - fontMetrics: PangoFontMetrics object.
func (fontset *Fontset) metrics() *FontMetrics {
	gclass := (*C.PangoFontsetClass)(coreglib.PeekParentClass(fontset))
	fnarg := gclass.get_metrics

	var _arg0 *C.PangoFontset     // out
	var _cret *C.PangoFontMetrics // in

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))

	_cret = C._gotk4_pango1_Fontset_virtual_get_metrics(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontset)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = (*FontMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontMetrics)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_metrics_unref((*C.PangoFontMetrics)(intern.C))
		},
	)

	return _fontMetrics
}

// FontsetSimple: PangoFontsetSimple is a implementation of the abstract
// PangoFontset base class as an array of fonts.
//
// When creating a PangoFontsetSimple, you have to provide the array of fonts
// that make up the fontset.
type FontsetSimple struct {
	_ [0]func() // equal guard
	Fontset
}

var (
	_ Fontsetter = (*FontsetSimple)(nil)
)

func wrapFontsetSimple(obj *coreglib.Object) *FontsetSimple {
	return &FontsetSimple{
		Fontset: Fontset{
			Object: obj,
		},
	}
}

func marshalFontsetSimple(p uintptr) (interface{}, error) {
	return wrapFontsetSimple(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFontsetSimple creates a new PangoFontsetSimple for the given language.
//
// The function takes the following parameters:
//
//   - language: PangoLanguage tag.
//
// The function returns the following values:
//
//   - fontsetSimple: newly allocated PangoFontsetSimple.
func NewFontsetSimple(language *Language) *FontsetSimple {
	var _arg1 *C.PangoLanguage      // out
	var _cret *C.PangoFontsetSimple // in

	_arg1 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C.pango_fontset_simple_new(_arg1)
	runtime.KeepAlive(language)

	var _fontsetSimple *FontsetSimple // out

	_fontsetSimple = wrapFontsetSimple(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fontsetSimple
}

// Append adds a font to the fontset.
//
// The fontset takes ownership of font.
//
// The function takes the following parameters:
//
//   - font: PangoFont.
func (fontset *FontsetSimple) Append(font Fonter) {
	var _arg0 *C.PangoFontsetSimple // out
	var _arg1 *C.PangoFont          // out

	_arg0 = (*C.PangoFontsetSimple)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(font).Native()))

	C.pango_fontset_simple_append(_arg0, _arg1)
	runtime.KeepAlive(fontset)
	runtime.KeepAlive(font)
}

// Size returns the number of fonts in the fontset.
//
// The function returns the following values:
//
//   - gint: size of fontset.
func (fontset *FontsetSimple) Size() int {
	var _arg0 *C.PangoFontsetSimple // out
	var _cret C.int                 // in

	_arg0 = (*C.PangoFontsetSimple)(unsafe.Pointer(coreglib.InternObject(fontset).Native()))

	_cret = C.pango_fontset_simple_size(_arg0)
	runtime.KeepAlive(fontset)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Layout: PangoLayout structure represents an entire paragraph of text.
//
// While complete access to the layout capabilities of Pango is provided using
// the detailed interfaces for itemization and shaping, using that functionality
// directly involves writing a fairly large amount of code. PangoLayout provides
// a high-level driver for formatting entire paragraphs of text at once. This
// includes paragraph-level functionality such as line breaking, justification,
// alignment and ellipsization.
//
// A PangoLayout is initialized with a PangoContext, UTF-8 string and set
// of attributes for that string. Once that is done, the set of formatted
// lines can be extracted from the object, the layout can be rendered,
// and conversion between logical character positions within the layout's text,
// and the physical position of the resulting glyphs can be made.
//
// There are a number of parameters to adjust the formatting of a PangoLayout.
// The following image shows adjustable parameters (on the left) and font
// metrics (on the right):
//
// <picture> <source srcset="layout-dark.png" media="(prefers-color-scheme:
// dark)"> <img alt="Pango Layout Parameters" src="layout-light.png"> </picture>
//
// The following images demonstrate the effect of alignment and justification on
// the layout of text:
//
// | | | | --- | --- | | !align=left (align-left.png) | !align=left,
// justify (align-left-justify.png) | | !align=center (align-center.png)
// | !align=center, justify (align-center-justify.png) | | !align=right
// (align-right.png) | !align=right, justify (align-right-justify.png) |
//
//	It is possible, as well, to ignore the 2-D setup, and simply treat the results of a PangoLayout as a list of lines.
type Layout struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Layout)(nil)
)

func wrapLayout(obj *coreglib.Object) *Layout {
	return &Layout{
		Object: obj,
	}
}

func marshalLayout(p uintptr) (interface{}, error) {
	return wrapLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewLayout: create a new PangoLayout object with attributes initialized to
// default values for a particular PangoContext.
//
// The function takes the following parameters:
//
//   - context: PangoContext.
//
// The function returns the following values:
//
//   - layout: newly allocated PangoLayout.
func NewLayout(context *Context) *Layout {
	var _arg1 *C.PangoContext // out
	var _cret *C.PangoLayout  // in

	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.pango_layout_new(_arg1)
	runtime.KeepAlive(context)

	var _layout *Layout // out

	_layout = wrapLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _layout
}

// ContextChanged forces recomputation of any state in the PangoLayout that
// might depend on the layout's context.
//
// This function should be called if you make changes to the context subsequent
// to creating the layout.
func (layout *Layout) ContextChanged() {
	var _arg0 *C.PangoLayout // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.pango_layout_context_changed(_arg0)
	runtime.KeepAlive(layout)
}

// Copy creates a deep copy-by-value of the layout.
//
// The attribute list, tab array, and text from the original layout are all
// copied by value.
//
// The function returns the following values:
//
//   - layout: newly allocated PangoLayout.
func (src *Layout) Copy() *Layout {
	var _arg0 *C.PangoLayout // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.pango_layout_copy(_arg0)
	runtime.KeepAlive(src)

	var _layout *Layout // out

	_layout = wrapLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _layout
}

// Alignment gets the alignment for the layout: how partial lines are positioned
// within the horizontal space available.
//
// The function returns the following values:
//
//   - alignment: alignment.
func (layout *Layout) Alignment() Alignment {
	var _arg0 *C.PangoLayout   // out
	var _cret C.PangoAlignment // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_alignment(_arg0)
	runtime.KeepAlive(layout)

	var _alignment Alignment // out

	_alignment = Alignment(_cret)

	return _alignment
}

// Attributes gets the attribute list for the layout, if any.
//
// The function returns the following values:
//
//   - attrList (optional): PangoAttrList.
func (layout *Layout) Attributes() *AttrList {
	var _arg0 *C.PangoLayout   // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_attributes(_arg0)
	runtime.KeepAlive(layout)

	var _attrList *AttrList // out

	if _cret != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// AutoDir gets whether to calculate the base direction for the layout according
// to its contents.
//
// See pango.Layout.SetAutoDir().
//
// The function returns the following values:
//
//   - ok: TRUE if the bidirectional base direction is computed from the
//     layout's contents, FALSE otherwise.
func (layout *Layout) AutoDir() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_auto_dir(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Baseline gets the Y position of baseline of the first line in layout.
//
// The function returns the following values:
//
//   - gint: baseline of first line, from top of layout.
func (layout *Layout) Baseline() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_baseline(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CaretPos: given an index within a layout, determines the positions that of
// the strong and weak cursors if the insertion point is at that index.
//
// This is a variant of pango.Layout.GetCursorPos() that applies font metric
// information about caret slope and offset to the positions it returns.
//
// <picture> <source srcset="caret-metrics-dark.png"
// media="(prefers-color-scheme: dark)"> <img alt="Caret metrics"
// src="caret-metrics-light.png"> </picture>.
//
// The function takes the following parameters:
//
//   - index_: byte index of the cursor.
//
// The function returns the following values:
//
//   - strongPos (optional): location to store the strong cursor position.
//   - weakPos (optional): location to store the weak cursor position.
func (layout *Layout) CaretPos(index_ int) (strongPos, weakPos *Rectangle) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _arg2 C.PangoRectangle // in
	var _arg3 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(index_)

	C.pango_layout_get_caret_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index_)

	var _strongPos *Rectangle // out
	var _weakPos *Rectangle   // out

	_strongPos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_weakPos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _strongPos, _weakPos
}

// CharacterCount returns the number of Unicode characters in the the text of
// layout.
//
// The function returns the following values:
//
//   - gint: number of Unicode characters in the text of layout.
func (layout *Layout) CharacterCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.gint         // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_character_count(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Context retrieves the PangoContext used for this layout.
//
// The function returns the following values:
//
//   - context: PangoContext for the layout.
func (layout *Layout) Context() *Context {
	var _arg0 *C.PangoLayout  // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_context(_arg0)
	runtime.KeepAlive(layout)

	var _context *Context // out

	_context = wrapContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _context
}

// CursorPos: given an index within a layout, determines the positions that of
// the strong and weak cursors if the insertion point is at that index.
//
// The position of each cursor is stored as a zero-width rectangle with the
// height of the run extents.
//
// <picture> <source srcset="cursor-positions-dark.png"
// media="(prefers-color-scheme: dark)"> <img alt="Cursor positions"
// src="cursor-positions-light.png"> </picture>
//
// The strong cursor location is the location where characters of the
// directionality equal to the base direction of the layout are inserted. The
// weak cursor location is the location where characters of the directionality
// opposite to the base direction of the layout are inserted.
//
// The following example shows text with both a strong and a weak cursor.
//
// <picture> <source srcset="split-cursor-dark.png"
// media="(prefers-color-scheme: dark)"> <img alt="Strong and weak cursors"
// src="split-cursor-light.png"> </picture>
//
// The strong cursor has a little arrow pointing to the right, the weak cursor
// to the left. Typing a 'c' in this situation will insert the character after
// the 'b', and typing another Hebrew character, like '', will insert it at the
// end.
//
// The function takes the following parameters:
//
//   - index_: byte index of the cursor.
//
// The function returns the following values:
//
//   - strongPos (optional): location to store the strong cursor position.
//   - weakPos (optional): location to store the weak cursor position.
func (layout *Layout) CursorPos(index_ int) (strongPos, weakPos *Rectangle) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _arg2 C.PangoRectangle // in
	var _arg3 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(index_)

	C.pango_layout_get_cursor_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index_)

	var _strongPos *Rectangle // out
	var _weakPos *Rectangle   // out

	_strongPos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_weakPos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _strongPos, _weakPos
}

// Direction gets the text direction at the given character position in layout.
//
// The function takes the following parameters:
//
//   - index: byte index of the char.
//
// The function returns the following values:
//
//   - direction: text direction at index.
func (layout *Layout) Direction(index int) Direction {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(index)

	_cret = C.pango_layout_get_direction(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// Ellipsize gets the type of ellipsization being performed for layout.
//
// See pango.Layout.SetEllipsize().
//
// Use pango.Layout.IsEllipsized() to query whether any paragraphs were actually
// ellipsized.
//
// The function returns the following values:
//
//   - ellipsizeMode: current ellipsization mode for layout.
func (layout *Layout) Ellipsize() EllipsizeMode {
	var _arg0 *C.PangoLayout       // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_ellipsize(_arg0)
	runtime.KeepAlive(layout)

	var _ellipsizeMode EllipsizeMode // out

	_ellipsizeMode = EllipsizeMode(_cret)

	return _ellipsizeMode
}

// Extents computes the logical and ink extents of layout.
//
// Logical extents are usually what you want for positioning things. Note that
// both extents may have non-zero x and y. You may want to use those to offset
// where you render the layout. Not doing that is a very typical bug that shows
// up as right-to-left layouts not being correctly positioned in a layout with a
// set width.
//
// The extents are given in layout coordinates and in Pango units; layout
// coordinates begin at the top left corner of the layout.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the layout as
//     drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the layout.
func (layout *Layout) Extents() (inkRect, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.PangoRectangle // in
	var _arg2 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.pango_layout_get_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// FontDescription gets the font description for the layout, if any.
//
// The function returns the following values:
//
//   - fontDescription (optional): pointer to the layout's font description,
//     or NULL if the font description from the layout's context is inherited.
func (layout *Layout) FontDescription() *FontDescription {
	var _arg0 *C.PangoLayout          // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_font_description(_arg0)
	runtime.KeepAlive(layout)

	var _fontDescription *FontDescription // out

	if _cret != nil {
		_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _fontDescription
}

// Height gets the height of layout used for ellipsization.
//
// See pango.Layout.SetHeight() for details.
//
// The function returns the following values:
//
//   - gint: height, in Pango units if positive, or number of lines if negative.
func (layout *Layout) Height() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_height(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Indent gets the paragraph indent width in Pango units.
//
// A negative value indicates a hanging indentation.
//
// The function returns the following values:
//
//   - gint: indent in Pango units.
func (layout *Layout) Indent() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_indent(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Iter returns an iterator to iterate over the visual extents of the layout.
//
// The function returns the following values:
//
//   - layoutIter: new PangoLayoutIter.
func (layout *Layout) Iter() *LayoutIter {
	var _arg0 *C.PangoLayout     // out
	var _cret *C.PangoLayoutIter // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_iter(_arg0)
	runtime.KeepAlive(layout)

	var _layoutIter *LayoutIter // out

	_layoutIter = (*LayoutIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_layoutIter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_layout_iter_free((*C.PangoLayoutIter)(intern.C))
		},
	)

	return _layoutIter
}

// Justify gets whether each complete line should be stretched to fill the
// entire width of the layout.
//
// The function returns the following values:
//
//   - ok: justify value.
func (layout *Layout) Justify() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_justify(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// JustifyLastLine gets whether the last line should be stretched to fill the
// entire width of the layout.
//
// The function returns the following values:
//
//   - ok: justify value.
func (layout *Layout) JustifyLastLine() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_justify_last_line(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Line retrieves a particular line from a PangoLayout.
//
// Use the faster pango.Layout.GetLineReadonly() if you do not plan to modify
// the contents of the line (glyphs, glyph widths, etc.).
//
// The function takes the following parameters:
//
//   - line: index of a line, which must be between 0 and
//     pango_layout_get_line_count(layout) - 1, inclusive.
//
// The function returns the following values:
//
//   - layoutLine (optional): requested PangoLayoutLine, or NULL if the index
//     is out of range. This layout line can be ref'ed and retained, but will
//     become invalid if changes are made to the PangoLayout.
func (layout *Layout) Line(line int) *LayoutLine {
	var _arg0 *C.PangoLayout     // out
	var _arg1 C.int              // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(line)

	_cret = C.pango_layout_get_line(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(line)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// LineCount retrieves the count of lines for the layout.
//
// The function returns the following values:
//
//   - gint: line count.
func (layout *Layout) LineCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_line_count(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineReadonly retrieves a particular line from a PangoLayout.
//
// This is a faster alternative to pango.Layout.GetLine(), but the user is not
// expected to modify the contents of the line (glyphs, glyph widths, etc.).
//
// The function takes the following parameters:
//
//   - line: index of a line, which must be between 0 and
//     pango_layout_get_line_count(layout) - 1, inclusive.
//
// The function returns the following values:
//
//   - layoutLine (optional): requested PangoLayoutLine, or NULL if the index
//     is out of range. This layout line can be ref'ed and retained, but will
//     become invalid if changes are made to the PangoLayout. No changes should
//     be made to the line.
func (layout *Layout) LineReadonly(line int) *LayoutLine {
	var _arg0 *C.PangoLayout     // out
	var _arg1 C.int              // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(line)

	_cret = C.pango_layout_get_line_readonly(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(line)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// LineSpacing gets the line spacing factor of layout.
//
// See pango.Layout.SetLineSpacing().
func (layout *Layout) LineSpacing() float32 {
	var _arg0 *C.PangoLayout // out
	var _cret C.float        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_line_spacing(_arg0)
	runtime.KeepAlive(layout)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Lines returns the lines of the layout as a list.
//
// Use the faster pango.Layout.GetLinesReadonly() if you do not plan to modify
// the contents of the lines (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//   - sList: GSList containing the lines in the layout. This points to internal
//     data of the PangoLayout and must be used with care. It will become
//     invalid on any change to the layout's text or properties.
func (layout *Layout) Lines() []*LayoutLine {
	var _arg0 *C.PangoLayout // out
	var _cret *C.GSList      // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_lines(_arg0)
	runtime.KeepAlive(layout)

	var _sList []*LayoutLine // out

	_sList = make([]*LayoutLine, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.PangoLayoutLine)(v)
		var dst *LayoutLine // out
		dst = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(src)))
		C.pango_layout_line_ref(src)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// LinesReadonly returns the lines of the layout as a list.
//
// This is a faster alternative to pango.Layout.GetLines(), but the user is not
// expected to modify the contents of the lines (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//   - sList: GSList containing the lines in the layout. This points to internal
//     data of the PangoLayout and must be used with care. It will become
//     invalid on any change to the layout's text or properties. No changes
//     should be made to the lines.
func (layout *Layout) LinesReadonly() []*LayoutLine {
	var _arg0 *C.PangoLayout // out
	var _cret *C.GSList      // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_lines_readonly(_arg0)
	runtime.KeepAlive(layout)

	var _sList []*LayoutLine // out

	_sList = make([]*LayoutLine, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.PangoLayoutLine)(v)
		var dst *LayoutLine // out
		dst = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(src)))
		C.pango_layout_line_ref(src)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// LogAttrs retrieves an array of logical attributes for each character in the
// layout.
//
// The function returns the following values:
//
//   - attrs: location to store a pointer to an array of logical attributes.
//     This value must be freed with g_free().
func (layout *Layout) LogAttrs() []LogAttr {
	var _arg0 *C.PangoLayout  // out
	var _arg1 *C.PangoLogAttr // in
	var _arg2 C.gint          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.pango_layout_get_log_attrs(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _attrs []LogAttr // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice((*C.PangoLogAttr)(_arg1), _arg2)
		_attrs = make([]LogAttr, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_attrs[i] = *(*LogAttr)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _attrs
}

// LogAttrsReadonly retrieves an array of logical attributes for each character
// in the layout.
//
// This is a faster alternative to pango.Layout.GetLogAttrs(). The returned
// array is part of layout and must not be modified. Modifying the layout will
// invalidate the returned array.
//
// The number of attributes returned in n_attrs will be one more than the
// total number of characters in the layout, since there need to be attributes
// corresponding to both the position before the first character and the
// position after the last character.
//
// The function returns the following values:
//
//   - logAttrs: array of logical attributes.
func (layout *Layout) LogAttrsReadonly() []LogAttr {
	var _arg0 *C.PangoLayout  // out
	var _cret *C.PangoLogAttr // in
	var _arg1 C.gint          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_log_attrs_readonly(_arg0, &_arg1)
	runtime.KeepAlive(layout)

	var _logAttrs []LogAttr // out

	{
		src := unsafe.Slice((*C.PangoLogAttr)(_cret), _arg1)
		_logAttrs = make([]LogAttr, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_logAttrs[i] = *(*LogAttr)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _logAttrs
}

// PixelExtents computes the logical and ink extents of layout in device units.
//
// This function just calls pango.Layout.GetExtents() followed by two
// extents_to_pixels calls, rounding ink_rect and logical_rect such that the
// rounded rectangles fully contain the unrounded one (that is, passes them as
// first argument to pango.ExtentsToPixels()).
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the layout as
//     drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the layout.
func (layout *Layout) PixelExtents() (inkRect, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.PangoRectangle // in
	var _arg2 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.pango_layout_get_pixel_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// PixelSize determines the logical width and height of a PangoLayout in device
// units.
//
// pango.Layout.GetSize() returns the width and height scaled by PANGO_SCALE.
// This is simply a convenience function around pango.Layout.GetPixelExtents().
//
// The function returns the following values:
//
//   - width (optional): location to store the logical width.
//   - height (optional): location to store the logical height.
func (layout *Layout) PixelSize() (width, height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.pango_layout_get_pixel_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// Serial returns the current serial number of layout.
//
// The serial number is initialized to an small number larger than zero when
// a new layout is created and is increased whenever the layout is changed
// using any of the setter functions, or the PangoContext it uses has changed.
// The serial may wrap, but will never have the value 0. Since it can wrap,
// never compare it with "less than", always use "not equals".
//
// This can be used to automatically detect changes to a PangoLayout, and is
// useful for example to decide whether a layout needs redrawing. To force the
// serial to be increased, use pango.Layout.ContextChanged().
//
// The function returns the following values:
//
//   - guint: current serial number of layout.
func (layout *Layout) Serial() uint {
	var _arg0 *C.PangoLayout // out
	var _cret C.guint        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_serial(_arg0)
	runtime.KeepAlive(layout)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SingleParagraphMode obtains whether layout is in single paragraph mode.
//
// See pango.Layout.SetSingleParagraphMode().
//
// The function returns the following values:
//
//   - ok: TRUE if the layout does not break paragraphs at paragraph separator
//     characters, FALSE otherwise.
func (layout *Layout) SingleParagraphMode() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_single_paragraph_mode(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size determines the logical width and height of a PangoLayout in Pango units.
//
// This is simply a convenience function around pango.Layout.GetExtents().
//
// The function returns the following values:
//
//   - width (optional): location to store the logical width.
//   - height (optional): location to store the logical height.
func (layout *Layout) Size() (width, height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.pango_layout_get_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// Spacing gets the amount of spacing between the lines of the layout.
//
// The function returns the following values:
//
//   - gint: spacing in Pango units.
func (layout *Layout) Spacing() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_spacing(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tabs gets the current PangoTabArray used by this layout.
//
// If no PangoTabArray has been set, then the default tabs are in use and NULL
// is returned. Default tabs are every 8 spaces.
//
// The return value should be freed with pango.TabArray.Free().
//
// The function returns the following values:
//
//   - tabArray (optional): copy of the tabs for this layout.
func (layout *Layout) Tabs() *TabArray {
	var _arg0 *C.PangoLayout   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_tabs(_arg0)
	runtime.KeepAlive(layout)

	var _tabArray *TabArray // out

	if _cret != nil {
		_tabArray = (*TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tabArray)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
			},
		)
	}

	return _tabArray
}

// Text gets the text in the layout.
//
// The returned text should not be freed or modified.
//
// The function returns the following values:
//
//   - utf8: text in the layout.
func (layout *Layout) Text() string {
	var _arg0 *C.PangoLayout // out
	var _cret *C.char        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_text(_arg0)
	runtime.KeepAlive(layout)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UnknownGlyphsCount counts the number of unknown glyphs in layout.
//
// This function can be used to determine if there are any fonts available to
// render all characters in a certain string, or when used in combination with
// PANGO_ATTR_FALLBACK, to check if a certain font supports all the characters
// in the string.
//
// The function returns the following values:
//
//   - gint: number of unknown glyphs in layout.
func (layout *Layout) UnknownGlyphsCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_unknown_glyphs_count(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Width gets the width to which the lines of the PangoLayout should wrap.
//
// The function returns the following values:
//
//   - gint: width in Pango units, or -1 if no width set.
func (layout *Layout) Width() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_width(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Wrap gets the wrap mode for the layout.
//
// Use pango.Layout.IsWrapped() to query whether any paragraphs were actually
// wrapped.
//
// The function returns the following values:
//
//   - wrapMode: active wrap mode.
func (layout *Layout) Wrap() WrapMode {
	var _arg0 *C.PangoLayout  // out
	var _cret C.PangoWrapMode // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_wrap(_arg0)
	runtime.KeepAlive(layout)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

// IndexToLineX converts from byte index_ within the layout to line and X
// position.
//
// The X position is measured from the left edge of the line.
//
// The function takes the following parameters:
//
//   - index_: byte index of a grapheme within the layout.
//   - trailing: integer indicating the edge of the grapheme to retrieve the
//     position of. If > 0, the trailing edge of the grapheme, if 0, the leading
//     of the grapheme.
//
// The function returns the following values:
//
//   - line (optional): location to store resulting line index. (which will
//     between 0 and pango_layout_get_line_count(layout) - 1).
//   - xPos (optional): location to store resulting position within line
//     (PANGO_SCALE units per device unit).
func (layout *Layout) IndexToLineX(index_ int, trailing bool) (line, xPos int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _arg2 C.gboolean     // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(index_)
	if trailing {
		_arg2 = C.TRUE
	}

	C.pango_layout_index_to_line_x(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(trailing)

	var _line int // out
	var _xPos int // out

	_line = int(_arg3)
	_xPos = int(_arg4)

	return _line, _xPos
}

// IndexToPos converts from an index within a PangoLayout to the onscreen
// position corresponding to the grapheme at that index.
//
// The returns is represented as rectangle. Note that pos->x is always the
// leading edge of the grapheme and pos->x + pos->width the trailing edge
// of the grapheme. If the directionality of the grapheme is right-to-left,
// then pos->width will be negative.
//
// The function takes the following parameters:
//
//   - index_: byte index within layout.
//
// The function returns the following values:
//
//   - pos: rectangle in which to store the position of the grapheme.
func (layout *Layout) IndexToPos(index_ int) *Rectangle {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _arg2 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(index_)

	C.pango_layout_index_to_pos(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index_)

	var _pos *Rectangle // out

	_pos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _pos
}

// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
//
// This returns TRUE if the ellipsization mode for layout is not
// PANGO_ELLIPSIZE_NONE, a positive width is set on layout, and there are
// paragraphs exceeding that width that have to be ellipsized.
//
// The function returns the following values:
//
//   - ok: TRUE if any paragraphs had to be ellipsized, FALSE otherwise.
func (layout *Layout) IsEllipsized() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_is_ellipsized(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsWrapped queries whether the layout had to wrap any paragraphs.
//
// This returns TRUE if a positive width is set on layout, ellipsization mode of
// layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs exceeding the
// layout width that have to be wrapped.
//
// The function returns the following values:
//
//   - ok: TRUE if any paragraphs had to be wrapped, FALSE otherwise.
func (layout *Layout) IsWrapped() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_is_wrapped(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveCursorVisually computes a new cursor position from an old position and a
// direction.
//
// If direction is positive, then the new position will cause the strong or weak
// cursor to be displayed one position to right of where it was with the old
// cursor position. If direction is negative, it will be moved to the left.
//
// In the presence of bidirectional text, the correspondence between logical and
// visual order will depend on the direction of the current run, and there may
// be jumps when the cursor is moved off of the end of a run.
//
// Motion here is in cursor positions, not in characters, so a single call to
// this function may move the cursor over multiple characters when multiple
// characters combine to form a single grapheme.
//
// The function takes the following parameters:
//
//   - strong: whether the moving cursor is the strong cursor or the weak
//     cursor. The strong cursor is the cursor corresponding to text insertion
//     in the base direction for the layout.
//   - oldIndex: byte index of the current cursor position.
//   - oldTrailing: if 0, the cursor was at the leading edge of the grapheme
//     indicated by old_index, if > 0, the cursor was at the trailing edge.
//   - direction to move cursor. A negative value indicates motion to the left.
//
// The function returns the following values:
//
//   - newIndex: location to store the new cursor byte index. A value of -1
//     indicates that the cursor has been moved off the beginning of the layout.
//     A value of G_MAXINT indicates that the cursor has been moved off the end
//     of the layout.
//   - newTrailing: number of characters to move forward from the location
//     returned for new_index to get the position where the cursor should be
//     displayed. This allows distinguishing the position at the beginning of
//     one line from the position at the end of the preceding line. new_index is
//     always on the line where the cursor should be displayed.
func (layout *Layout) MoveCursorVisually(strong bool, oldIndex, oldTrailing, direction int) (newIndex, newTrailing int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out
	var _arg4 C.int          // out
	var _arg5 C.int          // in
	var _arg6 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if strong {
		_arg1 = C.TRUE
	}
	_arg2 = C.int(oldIndex)
	_arg3 = C.int(oldTrailing)
	_arg4 = C.int(direction)

	C.pango_layout_move_cursor_visually(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(strong)
	runtime.KeepAlive(oldIndex)
	runtime.KeepAlive(oldTrailing)
	runtime.KeepAlive(direction)

	var _newIndex int    // out
	var _newTrailing int // out

	_newIndex = int(_arg5)
	_newTrailing = int(_arg6)

	return _newIndex, _newTrailing
}

// Serialize serializes the layout for later deserialization via
// pango.Layout().Deserialize.
//
// There are no guarantees about the format of the output across different
// versions of Pango and pango.Layout().Deserialize will reject data that it
// cannot parse.
//
// The intended use of this function is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
//
// The function takes the following parameters:
//
//   - flags: PangoLayoutSerializeFlags.
//
// The function returns the following values:
//
//   - bytes: GBytes containing the serialized form of layout.
func (layout *Layout) Serialize(flags LayoutSerializeFlags) *glib.Bytes {
	var _arg0 *C.PangoLayout              // out
	var _arg1 C.PangoLayoutSerializeFlags // out
	var _cret *C.GBytes                   // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.PangoLayoutSerializeFlags(flags)

	_cret = C.pango_layout_serialize(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(flags)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// SetAlignment sets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
//
// The default alignment is PANGO_ALIGN_LEFT.
//
// The function takes the following parameters:
//
//   - alignment: alignment.
func (layout *Layout) SetAlignment(alignment Alignment) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.PangoAlignment // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.PangoAlignment(alignment)

	C.pango_layout_set_alignment(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(alignment)
}

// SetAttributes sets the text attributes for a layout object.
//
// References attrs, so the caller can unref its reference.
//
// The function takes the following parameters:
//
//   - attrs (optional): PangoAttrList.
func (layout *Layout) SetAttributes(attrs *AttrList) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if attrs != nil {
		_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	}

	C.pango_layout_set_attributes(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(attrs)
}

// SetAutoDir sets whether to calculate the base direction for the layout
// according to its contents.
//
// When this flag is on (the default), then paragraphs in layout that begin
// with strong right-to-left characters (Arabic and Hebrew principally),
// will have right-to-left layout, paragraphs with letters from other scripts
// will have left-to-right layout. Paragraphs with only neutral characters get
// their direction from the surrounding paragraphs.
//
// When FALSE, the choice between left-to-right and right-to-left layout is
// done according to the base direction of the layout's PangoContext. (See
// pango.Context.SetBaseDir()).
//
// When the auto-computed direction of a paragraph differs from the base
// direction of the context, the interpretation of PANGO_ALIGN_LEFT and
// PANGO_ALIGN_RIGHT are swapped.
//
// The function takes the following parameters:
//
//   - autoDir: if TRUE, compute the bidirectional base direction from the
//     layout's contents.
func (layout *Layout) SetAutoDir(autoDir bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if autoDir {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_auto_dir(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(autoDir)
}

// SetEllipsize sets the type of ellipsization being performed for layout.
//
// Depending on the ellipsization mode ellipsize text is removed from the start,
// middle, or end of text so they fit within the width and height of layout set
// with pango.Layout.SetWidth() and pango.Layout.SetHeight().
//
// If the layout contains characters such as newlines that force it to be
// layed out in multiple paragraphs, then whether each paragraph is ellipsized
// separately or the entire layout is ellipsized as a whole depends on the set
// height of the layout.
//
// The default value is PANGO_ELLIPSIZE_NONE.
//
// See pango.Layout.SetHeight() for details.
//
// The function takes the following parameters:
//
//   - ellipsize: new ellipsization mode for layout.
func (layout *Layout) SetEllipsize(ellipsize EllipsizeMode) {
	var _arg0 *C.PangoLayout       // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.PangoEllipsizeMode(ellipsize)

	C.pango_layout_set_ellipsize(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(ellipsize)
}

// SetFontDescription sets the default font description for the layout.
//
// If no font description is set on the layout, the font description from the
// layout's context is used.
//
// The function takes the following parameters:
//
//   - desc (optional): new PangoFontDescription to unset the current font
//     description.
func (layout *Layout) SetFontDescription(desc *FontDescription) {
	var _arg0 *C.PangoLayout          // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if desc != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	}

	C.pango_layout_set_font_description(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(desc)
}

// SetHeight sets the height to which the PangoLayout should be ellipsized at.
//
// There are two different behaviors, based on whether height is positive or
// negative.
//
// If height is positive, it will be the maximum height of the layout.
// Only lines would be shown that would fit, and if there is any text omitted,
// an ellipsis added. At least one line is included in each paragraph regardless
// of how small the height value is. A value of zero will render exactly one
// line for the entire layout.
//
// If height is negative, it will be the (negative of) maximum number of lines
// per paragraph. That is, the total number of lines shown may well be more than
// this value if the layout contains multiple paragraphs of text. The default
// value of -1 means that the first line of each paragraph is ellipsized.
// This behavior may be changed in the future to act per layout instead of per
// paragraph. File a bug against pango at https://gitlab.gnome.org/gnome/pango
// (https://gitlab.gnome.org/gnome/pango) if your code relies on this behavior.
//
// Height setting only has effect if a positive width is set on layout and
// ellipsization mode of layout is not PANGO_ELLIPSIZE_NONE. The behavior is
// undefined if a height other than -1 is set and ellipsization mode is set to
// PANGO_ELLIPSIZE_NONE, and may change in the future.
//
// The function takes the following parameters:
//
//   - height: desired height of the layout in Pango units if positive,
//     or desired number of lines if negative.
func (layout *Layout) SetHeight(height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(height)

	C.pango_layout_set_height(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(height)
}

// SetIndent sets the width in Pango units to indent each paragraph.
//
// A negative value of indent will produce a hanging indentation. That is, the
// first line will have the full width, and subsequent lines will be indented by
// the absolute value of indent.
//
// The indent setting is ignored if layout alignment is set to
// PANGO_ALIGN_CENTER.
//
// The default value is 0.
//
// The function takes the following parameters:
//
//   - indent: amount by which to indent.
func (layout *Layout) SetIndent(indent int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(indent)

	C.pango_layout_set_indent(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(indent)
}

// SetJustify sets whether each complete line should be stretched to fill the
// entire width of the layout.
//
// Stretching is typically done by adding whitespace, but for some scripts
// (such as Arabic), the justification may be done in more complex ways,
// like extending the characters.
//
// Note that this setting is not implemented and so is ignored in Pango older
// than 1.18.
//
// Note that tabs and justification conflict with each other: Justification will
// move content away from its tab-aligned positions.
//
// The default value is FALSE.
//
// Also see pango.Layout.SetJustifyLastLine().
//
// The function takes the following parameters:
//
//   - justify: whether the lines in the layout should be justified.
func (layout *Layout) SetJustify(justify bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if justify {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_justify(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(justify)
}

// SetJustifyLastLine sets whether the last line should be stretched to fill the
// entire width of the layout.
//
// This only has an effect if pango.Layout.SetJustify() has been called as well.
//
// The default value is FALSE.
//
// The function takes the following parameters:
//
//   - justify: whether the last line in the layout should be justified.
func (layout *Layout) SetJustifyLastLine(justify bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if justify {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_justify_last_line(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(justify)
}

// SetLineSpacing sets a factor for line spacing.
//
// Typical values are: 0, 1, 1.5, 2. The default values is 0.
//
// If factor is non-zero, lines are placed so that
//
//	baseline2 = baseline1 + factor * height2
//
// where height2 is the line height of the second line (as determined by the
// font(s)). In this case, the spacing set with pango.Layout.SetSpacing() is
// ignored.
//
// If factor is zero (the default), spacing is applied as before.
//
// Note: for semantics that are closer to the CSS line-height property,
// see pango.NewAttrLineHeight().
//
// The function takes the following parameters:
//
//   - factor: new line spacing factor.
func (layout *Layout) SetLineSpacing(factor float32) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.float        // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.float(factor)

	C.pango_layout_set_line_spacing(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(factor)
}

// SetMarkup sets the layout text and attribute list from marked-up text.
//
// See Pango Markup (pango_markup.html)).
//
// Replaces the current text and attribute list.
//
// This is the same as pango.Layout.SetMarkupWithAccel(), but the markup text
// isn't scanned for accelerators.
//
// The function takes the following parameters:
//
//   - markup: marked-up text.
func (layout *Layout) SetMarkup(markup string) {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg2 = (C.int)(len(markup))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(markup) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(markup)), markup)
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_layout_set_markup(_arg0, _arg1, _arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(markup)
}

// SetMarkupWithAccel sets the layout text and attribute list from marked-up
// text.
//
// See Pango Markup (pango_markup.html)).
//
// Replaces the current text and attribute list.
//
// If accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in accel_char. Two accel_marker characters following each other
// produce a single literal accel_marker character.
//
// The function takes the following parameters:
//
//   - markup: marked-up text (see Pango Markup (pango_markup.html)).
//   - accelMarker: marker for accelerators in the text.
//
// The function returns the following values:
//
//   - accelChar (optional): return location for first located accelerator.
func (layout *Layout) SetMarkupWithAccel(markup string, accelMarker uint32) uint32 {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int
	var _arg3 C.gunichar // out
	var _arg4 C.gunichar // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg2 = (C.int)(len(markup))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(markup) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(markup)), markup)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gunichar(accelMarker)

	C.pango_layout_set_markup_with_accel(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(markup)
	runtime.KeepAlive(accelMarker)

	var _accelChar uint32 // out

	_accelChar = uint32(_arg4)

	return _accelChar
}

// SetSingleParagraphMode sets the single paragraph mode of layout.
//
// If setting is TRUE, do not treat newlines and similar characters as paragraph
// separators; instead, keep all text in a single paragraph, and display a glyph
// for paragraph separator characters. Used when you want to allow editing of
// newlines on a single text line.
//
// The default value is FALSE.
//
// The function takes the following parameters:
//
//   - setting: new setting.
func (layout *Layout) SetSingleParagraphMode(setting bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_single_paragraph_mode(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(setting)
}

// SetSpacing sets the amount of spacing in Pango units between the lines of the
// layout.
//
// When placing lines with spacing, Pango arranges things so that
//
//	line2.top = line1.bottom + spacing
//
// The default value is 0.
//
// Note: Since 1.44, Pango is using the line height (as determined by the font)
// for placing lines when the line spacing factor is set to a non-zero value
// with pango.Layout.SetLineSpacing(). In that case, the spacing set with this
// function is ignored.
//
// Note: for semantics that are closer to the CSS line-height property,
// see pango.NewAttrLineHeight().
//
// The function takes the following parameters:
//
//   - spacing: amount of spacing.
func (layout *Layout) SetSpacing(spacing int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(spacing)

	C.pango_layout_set_spacing(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(spacing)
}

// SetTabs sets the tabs to use for layout, overriding the default tabs.
//
// PangoLayout will place content at the next tab position whenever it meets a
// Tab character (U+0009).
//
// By default, tabs are every 8 spaces. If tabs is NULL, the default tabs are
// reinstated. tabs is copied into the layout; you must free your copy of tabs
// yourself.
//
// Note that tabs and justification conflict with each other: Justification
// will move content away from its tab-aligned positions. The same is true for
// alignments other than PANGO_ALIGN_LEFT.
//
// The function takes the following parameters:
//
//   - tabs (optional): PangoTabArray.
func (layout *Layout) SetTabs(tabs *TabArray) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	if tabs != nil {
		_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))
	}

	C.pango_layout_set_tabs(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(tabs)
}

// SetText sets the text of the layout.
//
// This function validates text and renders invalid UTF-8 with a placeholder
// glyph.
//
// Note that if you have used pango.Layout.SetMarkup() or
// pango.Layout.SetMarkupWithAccel() on layout before, you may want to call
// pango.Layout.SetAttributes() to clear the attributes set on the layout from
// the markup as this function does not clear attributes.
//
// The function takes the following parameters:
//
//   - text: text.
func (layout *Layout) SetText(text string) {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_layout_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(text)
}

// SetWidth sets the width to which the lines of the PangoLayout should wrap or
// ellipsized.
//
// The default value is -1: no width set.
//
// The function takes the following parameters:
//
//   - width: desired width in Pango units, or -1 to indicate that no wrapping
//     or ellipsization should be performed.
func (layout *Layout) SetWidth(width int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(width)

	C.pango_layout_set_width(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(width)
}

// SetWrap sets the wrap mode.
//
// The wrap mode only has effect if a width is set on the layout with
// pango.Layout.SetWidth(). To turn off wrapping, set the width to -1.
//
// The default value is PANGO_WRAP_WORD.
//
// The function takes the following parameters:
//
//   - wrap mode.
func (layout *Layout) SetWrap(wrap WrapMode) {
	var _arg0 *C.PangoLayout  // out
	var _arg1 C.PangoWrapMode // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.PangoWrapMode(wrap)

	C.pango_layout_set_wrap(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(wrap)
}

// WriteToFile: convenience method to serialize a layout to a file.
//
// It is equivalent to calling pango.Layout.Serialize() followed by
// glib.FileSetContents().
//
// See those two functions for details on the arguments.
//
// It is mostly intended for use inside a debugger to quickly dump a layout to a
// file for later inspection.
//
// The function takes the following parameters:
//
//   - flags: PangoLayoutSerializeFlags.
//   - filename: file to save it to.
func (layout *Layout) WriteToFile(flags LayoutSerializeFlags, filename string) error {
	var _arg0 *C.PangoLayout              // out
	var _arg1 C.PangoLayoutSerializeFlags // out
	var _arg2 *C.char                     // out
	var _cerr *C.GError                   // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.PangoLayoutSerializeFlags(flags)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg2))

	C.pango_layout_write_to_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// XYToIndex converts from X and Y position within a layout to the byte index to
// the character at that logical position.
//
// If the Y position is not inside the layout, the closest position is chosen
// (the position will be clamped inside the layout). If the X position is
// not within the layout, then the start or the end of the line is chosen as
// described for pango.LayoutLine.XToIndex(). If either the X or Y positions
// were not inside the layout, then the function returns FALSE; on an exact hit,
// it returns TRUE.
//
// The function takes the following parameters:
//
//   - x: x offset (in Pango units) from the left edge of the layout.
//   - y: y offset (in Pango units) from the top edge of the layout.
//
// The function returns the following values:
//
//   - index_: location to store calculated byte index.
//   - trailing: location to store a integer indicating where in the grapheme
//     the user clicked. It will either be zero, or the number of characters in
//     the grapheme. 0 represents the leading edge of the grapheme.
//   - ok: TRUE if the coordinates were inside text, FALSE otherwise.
func (layout *Layout) XYToIndex(x, y int) (index_, trailing int, ok bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.pango_layout_xy_to_index(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _index_ int   // out
	var _trailing int // out
	var _ok bool      // out

	_index_ = int(_arg3)
	_trailing = int(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _index_, _trailing, _ok
}

// LayoutDeserialize loads data previously created via pango.Layout.Serialize().
//
// For a discussion of the supported format, see that function.
//
// Note: to verify that the returned layout is identical to the one that was
// serialized, you can compare bytes to the result of serializing the layout
// again.
//
// The function takes the following parameters:
//
//   - context: PangoContext.
//   - bytes containing the data.
//   - flags: PangoLayoutDeserializeFlags.
//
// The function returns the following values:
//
//   - layout (optional): new PangoLayout.
func LayoutDeserialize(context *Context, bytes *glib.Bytes, flags LayoutDeserializeFlags) (*Layout, error) {
	var _arg1 *C.PangoContext               // out
	var _arg2 *C.GBytes                     // out
	var _arg3 C.PangoLayoutDeserializeFlags // out
	var _cret *C.PangoLayout                // in
	var _cerr *C.GError                     // in

	_arg1 = (*C.PangoContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	_arg3 = C.PangoLayoutDeserializeFlags(flags)

	_cret = C.pango_layout_deserialize(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(flags)

	var _layout *Layout // out
	var _goerr error    // out

	if _cret != nil {
		_layout = wrapLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _layout, _goerr
}

// RendererOverrides contains methods that are overridable.
type RendererOverrides struct {
	// Begin: do renderer-specific initialization before drawing.
	Begin func()
	// DrawErrorUnderline: draw a squiggly line that approximately covers the
	// given rectangle in the style of an underline used to indicate a spelling
	// error.
	//
	// The width of the underline is rounded to an integer number of up/down
	// segments and the resulting rectangle is centered in the original
	// rectangle.
	//
	// This should be called while renderer is already active. Use
	// pango.Renderer.Activate() to activate a renderer.
	//
	// The function takes the following parameters:
	//
	//   - x: x coordinate of underline, in Pango units in user coordinate
	//     system.
	//   - y: y coordinate of underline, in Pango units in user coordinate
	//     system.
	//   - width of underline, in Pango units in user coordinate system.
	//   - height of underline, in Pango units in user coordinate system.
	DrawErrorUnderline func(x, y, width, height int)
	// DrawGlyph draws a single glyph with coordinates in device space.
	//
	// The function takes the following parameters:
	//
	//   - font: PangoFont.
	//   - glyph index of a single glyph.
	//   - x: x coordinate of left edge of baseline of glyph.
	//   - y: y coordinate of left edge of baseline of glyph.
	DrawGlyph func(font Fonter, glyph Glyph, x, y float64)
	// DrawGlyphItem draws the glyphs in glyph_item with the specified
	// PangoRenderer, embedding the text associated with the glyphs in the
	// output if the output format supports it.
	//
	// This is useful for rendering text in PDF.
	//
	// Note that this method does not handle attributes in glyph_item.
	// If you want colors, shapes and lines handled automatically according to
	// those attributes, you need to use pango_renderer_draw_layout_line() or
	// pango_renderer_draw_layout().
	//
	// Note that text is the start of the text for layout, which is then indexed
	// by glyph_item->item->offset.
	//
	// If text is NULL, this simply calls pango.Renderer.DrawGlyphs().
	//
	// The default implementation of this method simply falls back to
	// pango.Renderer.DrawGlyphs().
	//
	// The function takes the following parameters:
	//
	//   - text (optional): UTF-8 text that glyph_item refers to.
	//   - glyphItem: PangoGlyphItem.
	//   - x: x position of left edge of baseline, in user space coordinates in
	//     Pango units.
	//   - y: y position of left edge of baseline, in user space coordinates in
	//     Pango units.
	DrawGlyphItem func(text string, glyphItem *GlyphItem, x, y int)
	// DrawGlyphs draws the glyphs in glyphs with the specified PangoRenderer.
	//
	// The function takes the following parameters:
	//
	//   - font: PangoFont.
	//   - glyphs: PangoGlyphString.
	//   - x: x position of left edge of baseline, in user space coordinates in
	//     Pango units.
	//   - y: y position of left edge of baseline, in user space coordinates in
	//     Pango units.
	DrawGlyphs func(font Fonter, glyphs *GlyphString, x, y int)
	// DrawRectangle draws an axis-aligned rectangle in user space coordinates
	// with the specified PangoRenderer.
	//
	// This should be called while renderer is already active. Use
	// pango.Renderer.Activate() to activate a renderer.
	//
	// The function takes the following parameters:
	//
	//   - part: type of object this rectangle is part of.
	//   - x: x position at which to draw rectangle, in user space coordinates
	//     in Pango units.
	//   - y: y position at which to draw rectangle, in user space coordinates
	//     in Pango units.
	//   - width of rectangle in Pango units.
	//   - height of rectangle in Pango units.
	DrawRectangle func(part RenderPart, x, y, width, height int)
	// DrawShape: draw content for a glyph shaped with PangoAttrShape x, y are
	// the coordinates of the left edge of the baseline, in user coordinates.
	//
	// The function takes the following parameters:
	//
	//   - attr
	//   - x
	//   - y
	DrawShape func(attr *AttrShape, x, y int)
	// DrawTrapezoid draws a trapezoid with the parallel sides aligned with the
	// X axis using the given PangoRenderer; coordinates are in device space.
	//
	// The function takes the following parameters:
	//
	//   - part: type of object this trapezoid is part of.
	//   - y1: y coordinate of top of trapezoid.
	//   - x11: x coordinate of left end of top of trapezoid.
	//   - x21: x coordinate of right end of top of trapezoid.
	//   - y2: y coordinate of bottom of trapezoid.
	//   - x12: x coordinate of left end of bottom of trapezoid.
	//   - x22: x coordinate of right end of bottom of trapezoid.
	DrawTrapezoid func(part RenderPart, y1, x11, x21, y2, x12, x22 float64)
	// End: do renderer-specific cleanup after drawing.
	End func()
	// PartChanged informs Pango that the way that the rendering is done for
	// part has changed.
	//
	// This should be called if the rendering changes in a way that would
	// prevent multiple pieces being joined together into one drawing call.
	// For instance, if a subclass of PangoRenderer was to add a stipple option
	// for drawing underlines, it needs to call
	//
	//	pango_renderer_part_changed (render, PANGO_RENDER_PART_UNDERLINE);
	//
	// When the stipple changes or underlines with different stipples might be
	// joined together. Pango automatically calls this for changes to colors.
	// (See pango.Renderer.SetColor()).
	//
	// The function takes the following parameters:
	//
	//   - part for which rendering has changed.
	PartChanged func(part RenderPart)
	// PrepareRun updates the renderer for a new run.
	PrepareRun func(run *LayoutRun)
}

func defaultRendererOverrides(v *Renderer) RendererOverrides {
	return RendererOverrides{
		Begin:              v.begin,
		DrawErrorUnderline: v.drawErrorUnderline,
		DrawGlyph:          v.drawGlyph,
		DrawGlyphItem:      v.drawGlyphItem,
		DrawGlyphs:         v.drawGlyphs,
		DrawRectangle:      v.drawRectangle,
		DrawShape:          v.drawShape,
		DrawTrapezoid:      v.drawTrapezoid,
		End:                v.end,
		PartChanged:        v.partChanged,
		PrepareRun:         v.prepareRun,
	}
}

// Renderer: PangoRenderer is a base class for objects that can render text
// provided as PangoGlyphString or PangoLayout.
//
// By subclassing PangoRenderer and overriding operations such as draw_glyphs
// and draw_rectangle, renderers for particular font backends and destinations
// can be created.
type Renderer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Renderer)(nil)
)

// Rendererer describes types inherited from class Renderer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Rendererer interface {
	coreglib.Objector
	baseRenderer() *Renderer
}

var _ Rendererer = (*Renderer)(nil)

func init() {
	coreglib.RegisterClassInfo[*Renderer, *RendererClass, RendererOverrides](
		GTypeRenderer,
		initRendererClass,
		wrapRenderer,
		defaultRendererOverrides,
	)
}

func initRendererClass(gclass unsafe.Pointer, overrides RendererOverrides, classInitFunc func(*RendererClass)) {
	pclass := (*C.PangoRendererClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRenderer))))

	if overrides.Begin != nil {
		pclass.begin = (*[0]byte)(C._gotk4_pango1_RendererClass_begin)
	}

	if overrides.DrawErrorUnderline != nil {
		pclass.draw_error_underline = (*[0]byte)(C._gotk4_pango1_RendererClass_draw_error_underline)
	}

	if overrides.DrawGlyph != nil {
		pclass.draw_glyph = (*[0]byte)(C._gotk4_pango1_RendererClass_draw_glyph)
	}

	if overrides.DrawGlyphItem != nil {
		pclass.draw_glyph_item = (*[0]byte)(C._gotk4_pango1_RendererClass_draw_glyph_item)
	}

	if overrides.DrawGlyphs != nil {
		pclass.draw_glyphs = (*[0]byte)(C._gotk4_pango1_RendererClass_draw_glyphs)
	}

	if overrides.DrawRectangle != nil {
		pclass.draw_rectangle = (*[0]byte)(C._gotk4_pango1_RendererClass_draw_rectangle)
	}

	if overrides.DrawShape != nil {
		pclass.draw_shape = (*[0]byte)(C._gotk4_pango1_RendererClass_draw_shape)
	}

	if overrides.DrawTrapezoid != nil {
		pclass.draw_trapezoid = (*[0]byte)(C._gotk4_pango1_RendererClass_draw_trapezoid)
	}

	if overrides.End != nil {
		pclass.end = (*[0]byte)(C._gotk4_pango1_RendererClass_end)
	}

	if overrides.PartChanged != nil {
		pclass.part_changed = (*[0]byte)(C._gotk4_pango1_RendererClass_part_changed)
	}

	if overrides.PrepareRun != nil {
		pclass.prepare_run = (*[0]byte)(C._gotk4_pango1_RendererClass_prepare_run)
	}

	if classInitFunc != nil {
		class := (*RendererClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRenderer(obj *coreglib.Object) *Renderer {
	return &Renderer{
		Object: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	return wrapRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (renderer *Renderer) baseRenderer() *Renderer {
	return renderer
}

// BaseRenderer returns the underlying base object.
func BaseRenderer(obj Rendererer) *Renderer {
	return obj.baseRenderer()
}

// Activate does initial setup before rendering operations on renderer.
//
// pango.Renderer.Deactivate() should be called when done drawing. Calls such as
// pango.Renderer.DrawLayout() automatically activate the layout before drawing
// on it.
//
// Calls to pango.Renderer.Activate() and pango.Renderer.Deactivate() can be
// nested and the renderer will only be initialized and deinitialized once.
func (renderer *Renderer) Activate() {
	var _arg0 *C.PangoRenderer // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.pango_renderer_activate(_arg0)
	runtime.KeepAlive(renderer)
}

// Deactivate cleans up after rendering operations on renderer.
//
// See docs for pango.Renderer.Activate().
func (renderer *Renderer) Deactivate() {
	var _arg0 *C.PangoRenderer // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.pango_renderer_deactivate(_arg0)
	runtime.KeepAlive(renderer)
}

// DrawErrorUnderline: draw a squiggly line that approximately covers the given
// rectangle in the style of an underline used to indicate a spelling error.
//
// The width of the underline is rounded to an integer number of up/down
// segments and the resulting rectangle is centered in the original rectangle.
//
// This should be called while renderer is already active. Use
// pango.Renderer.Activate() to activate a renderer.
//
// The function takes the following parameters:
//
//   - x: x coordinate of underline, in Pango units in user coordinate system.
//   - y: y coordinate of underline, in Pango units in user coordinate system.
//   - width of underline, in Pango units in user coordinate system.
//   - height of underline, in Pango units in user coordinate system.
func (renderer *Renderer) DrawErrorUnderline(x, y, width, height int) {
	var _arg0 *C.PangoRenderer // out
	var _arg1 C.int            // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	_arg3 = C.int(width)
	_arg4 = C.int(height)

	C.pango_renderer_draw_error_underline(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// DrawGlyph draws a single glyph with coordinates in device space.
//
// The function takes the following parameters:
//
//   - font: PangoFont.
//   - glyph index of a single glyph.
//   - x: x coordinate of left edge of baseline of glyph.
//   - y: y coordinate of left edge of baseline of glyph.
func (renderer *Renderer) DrawGlyph(font Fonter, glyph Glyph, x, y float64) {
	var _arg0 *C.PangoRenderer // out
	var _arg1 *C.PangoFont     // out
	var _arg2 C.PangoGlyph     // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg2 = C.PangoGlyph(glyph)
	_arg3 = C.double(x)
	_arg4 = C.double(y)

	C.pango_renderer_draw_glyph(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyph)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawGlyphItem draws the glyphs in glyph_item with the specified
// PangoRenderer, embedding the text associated with the glyphs in the output if
// the output format supports it.
//
// This is useful for rendering text in PDF.
//
// Note that this method does not handle attributes in glyph_item.
// If you want colors, shapes and lines handled automatically according to
// those attributes, you need to use pango_renderer_draw_layout_line() or
// pango_renderer_draw_layout().
//
// Note that text is the start of the text for layout, which is then indexed by
// glyph_item->item->offset.
//
// If text is NULL, this simply calls pango.Renderer.DrawGlyphs().
//
// The default implementation of this method simply falls back to
// pango.Renderer.DrawGlyphs().
//
// The function takes the following parameters:
//
//   - text (optional): UTF-8 text that glyph_item refers to.
//   - glyphItem: PangoGlyphItem.
//   - x: x position of left edge of baseline, in user space coordinates in
//     Pango units.
//   - y: y position of left edge of baseline, in user space coordinates in
//     Pango units.
func (renderer *Renderer) DrawGlyphItem(text string, glyphItem *GlyphItem, x, y int) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 *C.char           // out
	var _arg2 *C.PangoGlyphItem // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	C.pango_renderer_draw_glyph_item(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawGlyphs draws the glyphs in glyphs with the specified PangoRenderer.
//
// The function takes the following parameters:
//
//   - font: PangoFont.
//   - glyphs: PangoGlyphString.
//   - x: x position of left edge of baseline, in user space coordinates in
//     Pango units.
//   - y: y position of left edge of baseline, in user space coordinates in
//     Pango units.
func (renderer *Renderer) DrawGlyphs(font Fonter, glyphs *GlyphString, x, y int) {
	var _arg0 *C.PangoRenderer    // out
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 C.int               // out
	var _arg4 C.int               // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg2 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	C.pango_renderer_draw_glyphs(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawLayout draws layout with the specified PangoRenderer.
//
// This is equivalent to drawing the lines of the layout, at their respective
// positions relative to x, y.
//
// The function takes the following parameters:
//
//   - layout: PangoLayout.
//   - x: x position of left edge of baseline, in user space coordinates in
//     Pango units.
//   - y: y position of left edge of baseline, in user space coordinates in
//     Pango units.
func (renderer *Renderer) DrawLayout(layout *Layout, x, y int) {
	var _arg0 *C.PangoRenderer // out
	var _arg1 *C.PangoLayout   // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg2 = C.int(x)
	_arg3 = C.int(y)

	C.pango_renderer_draw_layout(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawLayoutLine draws line with the specified PangoRenderer.
//
// This draws the glyph items that make up the line, as well as shapes,
// backgrounds and lines that are specified by the attributes of those items.
//
// The function takes the following parameters:
//
//   - line: PangoLayoutLine.
//   - x: x position of left edge of baseline, in user space coordinates in
//     Pango units.
//   - y: y position of left edge of baseline, in user space coordinates in
//     Pango units.
func (renderer *Renderer) DrawLayoutLine(line *LayoutLine, x, y int) {
	var _arg0 *C.PangoRenderer   // out
	var _arg1 *C.PangoLayoutLine // out
	var _arg2 C.int              // out
	var _arg3 C.int              // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))
	_arg2 = C.int(x)
	_arg3 = C.int(y)

	C.pango_renderer_draw_layout_line(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(line)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawRectangle draws an axis-aligned rectangle in user space coordinates with
// the specified PangoRenderer.
//
// This should be called while renderer is already active. Use
// pango.Renderer.Activate() to activate a renderer.
//
// The function takes the following parameters:
//
//   - part: type of object this rectangle is part of.
//   - x: x position at which to draw rectangle, in user space coordinates in
//     Pango units.
//   - y: y position at which to draw rectangle, in user space coordinates in
//     Pango units.
//   - width of rectangle in Pango units.
//   - height of rectangle in Pango units.
func (renderer *Renderer) DrawRectangle(part RenderPart, x, y, width, height int) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.int             // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out
	var _arg5 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)
	_arg2 = C.int(x)
	_arg3 = C.int(y)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	C.pango_renderer_draw_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// DrawTrapezoid draws a trapezoid with the parallel sides aligned with the X
// axis using the given PangoRenderer; coordinates are in device space.
//
// The function takes the following parameters:
//
//   - part: type of object this trapezoid is part of.
//   - y1: y coordinate of top of trapezoid.
//   - x11: x coordinate of left end of top of trapezoid.
//   - x21: x coordinate of right end of top of trapezoid.
//   - y2: y coordinate of bottom of trapezoid.
//   - x12: x coordinate of left end of bottom of trapezoid.
//   - x22: x coordinate of right end of bottom of trapezoid.
func (renderer *Renderer) DrawTrapezoid(part RenderPart, y1, x11, x21, y2, x12, x22 float64) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.double          // out
	var _arg3 C.double          // out
	var _arg4 C.double          // out
	var _arg5 C.double          // out
	var _arg6 C.double          // out
	var _arg7 C.double          // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)
	_arg2 = C.double(y1)
	_arg3 = C.double(x11)
	_arg4 = C.double(x21)
	_arg5 = C.double(y2)
	_arg6 = C.double(x12)
	_arg7 = C.double(x22)

	C.pango_renderer_draw_trapezoid(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
	runtime.KeepAlive(y1)
	runtime.KeepAlive(x11)
	runtime.KeepAlive(x21)
	runtime.KeepAlive(y2)
	runtime.KeepAlive(x12)
	runtime.KeepAlive(x22)
}

// Alpha gets the current alpha for the specified part.
//
// The function takes the following parameters:
//
//   - part to get the alpha for.
//
// The function returns the following values:
//
//   - guint16: alpha for the specified part, or 0 if it hasn't been set and
//     should be inherited from the environment.
func (renderer *Renderer) Alpha(part RenderPart) uint16 {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _cret C.guint16         // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)

	_cret = C.pango_renderer_get_alpha(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Color gets the current rendering color for the specified part.
//
// The function takes the following parameters:
//
//   - part to get the color for.
//
// The function returns the following values:
//
//   - color (optional) for the specified part, or NULL if it hasn't been set
//     and should be inherited from the environment.
func (renderer *Renderer) Color(part RenderPart) *Color {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _cret *C.PangoColor     // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)

	_cret = C.pango_renderer_get_color(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)

	var _color *Color // out

	if _cret != nil {
		_color = (*Color)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _color
}

// Layout gets the layout currently being rendered using renderer.
//
// Calling this function only makes sense from inside a subclass's methods,
// like in its draw_shape vfunc, for example.
//
// The returned layout should not be modified while still being rendered.
//
// The function returns the following values:
//
//   - layout (optional): layout, or NULL if no layout is being rendered using
//     renderer at this time.
func (renderer *Renderer) Layout() *Layout {
	var _arg0 *C.PangoRenderer // out
	var _cret *C.PangoLayout   // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.pango_renderer_get_layout(_arg0)
	runtime.KeepAlive(renderer)

	var _layout *Layout // out

	if _cret != nil {
		_layout = wrapLayout(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _layout
}

// LayoutLine gets the layout line currently being rendered using renderer.
//
// Calling this function only makes sense from inside a subclass's methods,
// like in its draw_shape vfunc, for example.
//
// The returned layout line should not be modified while still being rendered.
//
// The function returns the following values:
//
//   - layoutLine (optional): layout line, or NULL if no layout line is being
//     rendered using renderer at this time.
func (renderer *Renderer) LayoutLine() *LayoutLine {
	var _arg0 *C.PangoRenderer   // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.pango_renderer_get_layout_line(_arg0)
	runtime.KeepAlive(renderer)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// Matrix gets the transformation matrix that will be applied when rendering.
//
// See pango.Renderer.SetMatrix().
//
// The function returns the following values:
//
//   - matrix (optional): matrix, or NULL if no matrix has been set (which is
//     the same as the identity matrix). The returned matrix is owned by Pango
//     and must not be modified or freed.
func (renderer *Renderer) Matrix() *Matrix {
	var _arg0 *C.PangoRenderer // out
	var _cret *C.PangoMatrix   // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.pango_renderer_get_matrix(_arg0)
	runtime.KeepAlive(renderer)

	var _matrix *Matrix // out

	if _cret != nil {
		_matrix = (*Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _matrix
}

// PartChanged informs Pango that the way that the rendering is done for part
// has changed.
//
// This should be called if the rendering changes in a way that would prevent
// multiple pieces being joined together into one drawing call. For instance,
// if a subclass of PangoRenderer was to add a stipple option for drawing
// underlines, it needs to call
//
//	pango_renderer_part_changed (render, PANGO_RENDER_PART_UNDERLINE);
//
// When the stipple changes or underlines with different stipples might be
// joined together. Pango automatically calls this for changes to colors.
// (See pango.Renderer.SetColor()).
//
// The function takes the following parameters:
//
//   - part for which rendering has changed.
func (renderer *Renderer) PartChanged(part RenderPart) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)

	C.pango_renderer_part_changed(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
}

// SetAlpha sets the alpha for part of the rendering.
//
// Note that the alpha may only be used if a color is specified for part as
// well.
//
// The function takes the following parameters:
//
//   - part to set the alpha for.
//   - alpha value between 1 and 65536, or 0 to unset the alpha.
func (renderer *Renderer) SetAlpha(part RenderPart, alpha uint16) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.guint16         // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)
	_arg2 = C.guint16(alpha)

	C.pango_renderer_set_alpha(_arg0, _arg1, _arg2)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
	runtime.KeepAlive(alpha)
}

// SetColor sets the color for part of the rendering.
//
// Also see pango.Renderer.SetAlpha().
//
// The function takes the following parameters:
//
//   - part to change the color of.
//   - color (optional): new color or NULL to unset the current color.
func (renderer *Renderer) SetColor(part RenderPart, color *Color) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 *C.PangoColor     // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)
	if color != nil {
		_arg2 = (*C.PangoColor)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.pango_renderer_set_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
	runtime.KeepAlive(color)
}

// SetMatrix sets the transformation matrix that will be applied when rendering.
//
// The function takes the following parameters:
//
//   - matrix (optional): PangoMatrix, or NULL to unset any existing matrix (No
//     matrix set is the same as setting the identity matrix.).
func (renderer *Renderer) SetMatrix(matrix *Matrix) {
	var _arg0 *C.PangoRenderer // out
	var _arg1 *C.PangoMatrix   // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if matrix != nil {
		_arg1 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	C.pango_renderer_set_matrix(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(matrix)
}

// Begin: do renderer-specific initialization before drawing.
func (renderer *Renderer) begin() {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.begin

	var _arg0 *C.PangoRenderer // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C._gotk4_pango1_Renderer_virtual_begin(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(renderer)
}

// drawErrorUnderline: draw a squiggly line that approximately covers the given
// rectangle in the style of an underline used to indicate a spelling error.
//
// The width of the underline is rounded to an integer number of up/down
// segments and the resulting rectangle is centered in the original rectangle.
//
// This should be called while renderer is already active. Use
// pango.Renderer.Activate() to activate a renderer.
//
// The function takes the following parameters:
//
//   - x: x coordinate of underline, in Pango units in user coordinate system.
//   - y: y coordinate of underline, in Pango units in user coordinate system.
//   - width of underline, in Pango units in user coordinate system.
//   - height of underline, in Pango units in user coordinate system.
func (renderer *Renderer) drawErrorUnderline(x, y, width, height int) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_error_underline

	var _arg0 *C.PangoRenderer // out
	var _arg1 C.int            // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	_arg3 = C.int(width)
	_arg4 = C.int(height)

	C._gotk4_pango1_Renderer_virtual_draw_error_underline(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// drawGlyph draws a single glyph with coordinates in device space.
//
// The function takes the following parameters:
//
//   - font: PangoFont.
//   - glyph index of a single glyph.
//   - x: x coordinate of left edge of baseline of glyph.
//   - y: y coordinate of left edge of baseline of glyph.
func (renderer *Renderer) drawGlyph(font Fonter, glyph Glyph, x, y float64) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_glyph

	var _arg0 *C.PangoRenderer // out
	var _arg1 *C.PangoFont     // out
	var _arg2 C.PangoGlyph     // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg2 = C.PangoGlyph(glyph)
	_arg3 = C.double(x)
	_arg4 = C.double(y)

	C._gotk4_pango1_Renderer_virtual_draw_glyph(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyph)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// drawGlyphItem draws the glyphs in glyph_item with the specified
// PangoRenderer, embedding the text associated with the glyphs in the output if
// the output format supports it.
//
// This is useful for rendering text in PDF.
//
// Note that this method does not handle attributes in glyph_item.
// If you want colors, shapes and lines handled automatically according to
// those attributes, you need to use pango_renderer_draw_layout_line() or
// pango_renderer_draw_layout().
//
// Note that text is the start of the text for layout, which is then indexed by
// glyph_item->item->offset.
//
// If text is NULL, this simply calls pango.Renderer.DrawGlyphs().
//
// The default implementation of this method simply falls back to
// pango.Renderer.DrawGlyphs().
//
// The function takes the following parameters:
//
//   - text (optional): UTF-8 text that glyph_item refers to.
//   - glyphItem: PangoGlyphItem.
//   - x: x position of left edge of baseline, in user space coordinates in
//     Pango units.
//   - y: y position of left edge of baseline, in user space coordinates in
//     Pango units.
func (renderer *Renderer) drawGlyphItem(text string, glyphItem *GlyphItem, x, y int) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_glyph_item

	var _arg0 *C.PangoRenderer  // out
	var _arg1 *C.char           // out
	var _arg2 *C.PangoGlyphItem // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	C._gotk4_pango1_Renderer_virtual_draw_glyph_item(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// drawGlyphs draws the glyphs in glyphs with the specified PangoRenderer.
//
// The function takes the following parameters:
//
//   - font: PangoFont.
//   - glyphs: PangoGlyphString.
//   - x: x position of left edge of baseline, in user space coordinates in
//     Pango units.
//   - y: y position of left edge of baseline, in user space coordinates in
//     Pango units.
func (renderer *Renderer) drawGlyphs(font Fonter, glyphs *GlyphString, x, y int) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_glyphs

	var _arg0 *C.PangoRenderer    // out
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 C.int               // out
	var _arg4 C.int               // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg2 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	C._gotk4_pango1_Renderer_virtual_draw_glyphs(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// drawRectangle draws an axis-aligned rectangle in user space coordinates with
// the specified PangoRenderer.
//
// This should be called while renderer is already active. Use
// pango.Renderer.Activate() to activate a renderer.
//
// The function takes the following parameters:
//
//   - part: type of object this rectangle is part of.
//   - x: x position at which to draw rectangle, in user space coordinates in
//     Pango units.
//   - y: y position at which to draw rectangle, in user space coordinates in
//     Pango units.
//   - width of rectangle in Pango units.
//   - height of rectangle in Pango units.
func (renderer *Renderer) drawRectangle(part RenderPart, x, y, width, height int) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_rectangle

	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.int             // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out
	var _arg5 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)
	_arg2 = C.int(x)
	_arg3 = C.int(y)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	C._gotk4_pango1_Renderer_virtual_draw_rectangle(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// drawShape: draw content for a glyph shaped with PangoAttrShape x, y are the
// coordinates of the left edge of the baseline, in user coordinates.
//
// The function takes the following parameters:
//
//   - attr
//   - x
//   - y
func (renderer *Renderer) drawShape(attr *AttrShape, x, y int) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_shape

	var _arg0 *C.PangoRenderer  // out
	var _arg1 *C.PangoAttrShape // out
	var _arg2 C.int             // out
	var _arg3 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoAttrShape)(gextras.StructNative(unsafe.Pointer(attr)))
	_arg2 = C.int(x)
	_arg3 = C.int(y)

	C._gotk4_pango1_Renderer_virtual_draw_shape(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(attr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// drawTrapezoid draws a trapezoid with the parallel sides aligned with the X
// axis using the given PangoRenderer; coordinates are in device space.
//
// The function takes the following parameters:
//
//   - part: type of object this trapezoid is part of.
//   - y1: y coordinate of top of trapezoid.
//   - x11: x coordinate of left end of top of trapezoid.
//   - x21: x coordinate of right end of top of trapezoid.
//   - y2: y coordinate of bottom of trapezoid.
//   - x12: x coordinate of left end of bottom of trapezoid.
//   - x22: x coordinate of right end of bottom of trapezoid.
func (renderer *Renderer) drawTrapezoid(part RenderPart, y1, x11, x21, y2, x12, x22 float64) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_trapezoid

	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.double          // out
	var _arg3 C.double          // out
	var _arg4 C.double          // out
	var _arg5 C.double          // out
	var _arg6 C.double          // out
	var _arg7 C.double          // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)
	_arg2 = C.double(y1)
	_arg3 = C.double(x11)
	_arg4 = C.double(x21)
	_arg5 = C.double(y2)
	_arg6 = C.double(x12)
	_arg7 = C.double(x22)

	C._gotk4_pango1_Renderer_virtual_draw_trapezoid(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
	runtime.KeepAlive(y1)
	runtime.KeepAlive(x11)
	runtime.KeepAlive(x21)
	runtime.KeepAlive(y2)
	runtime.KeepAlive(x12)
	runtime.KeepAlive(x22)
}

// End: do renderer-specific cleanup after drawing.
func (renderer *Renderer) end() {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.end

	var _arg0 *C.PangoRenderer // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C._gotk4_pango1_Renderer_virtual_end(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(renderer)
}

// partChanged informs Pango that the way that the rendering is done for part
// has changed.
//
// This should be called if the rendering changes in a way that would prevent
// multiple pieces being joined together into one drawing call. For instance,
// if a subclass of PangoRenderer was to add a stipple option for drawing
// underlines, it needs to call
//
//	pango_renderer_part_changed (render, PANGO_RENDER_PART_UNDERLINE);
//
// When the stipple changes or underlines with different stipples might be
// joined together. Pango automatically calls this for changes to colors.
// (See pango.Renderer.SetColor()).
//
// The function takes the following parameters:
//
//   - part for which rendering has changed.
func (renderer *Renderer) partChanged(part RenderPart) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.part_changed

	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.PangoRenderPart(part)

	C._gotk4_pango1_Renderer_virtual_part_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(part)
}

// prepareRun updates the renderer for a new run.
func (renderer *Renderer) prepareRun(run *LayoutRun) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.prepare_run

	var _arg0 *C.PangoRenderer  // out
	var _arg1 *C.PangoLayoutRun // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(run)))
	type _ = *LayoutRun
	type _ = *GlyphItem

	C._gotk4_pango1_Renderer_virtual_prepare_run(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(run)
}

// Analysis: PangoAnalysis structure stores information about the properties of
// a segment of text.
//
// An instance of this type is always passed by reference.
type Analysis struct {
	*analysis
}

// analysis is the struct that's finalized.
type analysis struct {
	native *C.PangoAnalysis
}

// ShapeEngine: unused, reserved.
func (a *Analysis) ShapeEngine() unsafe.Pointer {
	valptr := &a.native.shape_engine
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// LangEngine: unused, reserved.
func (a *Analysis) LangEngine() unsafe.Pointer {
	valptr := &a.native.lang_engine
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Font: font for this segment.
func (a *Analysis) Font() Fonter {
	valptr := &a.native.font
	var _v Fonter // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Fonter)
			return ok
		})
		rv, ok := casted.(Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_v = rv
	}
	return _v
}

// Level: bidirectional level for this segment.
func (a *Analysis) Level() byte {
	valptr := &a.native.level
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// Gravity: glyph orientation for this segment (A PangoGravity).
func (a *Analysis) Gravity() byte {
	valptr := &a.native.gravity
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// Flags: boolean flags for this segment (Since: 1.16).
func (a *Analysis) Flags() byte {
	valptr := &a.native.flags
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// Script: detected script for this segment (A PangoScript) (Since: 1.18).
func (a *Analysis) Script() byte {
	valptr := &a.native.script
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// Language: detected language for this segment.
func (a *Analysis) Language() *Language {
	valptr := &a.native.language
	var _v *Language // out
	_v = (*Language)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Level: bidirectional level for this segment.
func (a *Analysis) SetLevel(level byte) {
	valptr := &a.native.level
	*valptr = C.guint8(level)
}

// Gravity: glyph orientation for this segment (A PangoGravity).
func (a *Analysis) SetGravity(gravity byte) {
	valptr := &a.native.gravity
	*valptr = C.guint8(gravity)
}

// Flags: boolean flags for this segment (Since: 1.16).
func (a *Analysis) SetFlags(flags byte) {
	valptr := &a.native.flags
	*valptr = C.guint8(flags)
}

// Script: detected script for this segment (A PangoScript) (Since: 1.18).
func (a *Analysis) SetScript(script byte) {
	valptr := &a.native.script
	*valptr = C.guint8(script)
}

// AttrClass: PangoAttrClass structure stores the type and operations for a
// particular type of attribute.
//
// The functions in this structure should not be called directly. Instead,
// one should use the wrapper functions provided for PangoAttribute.
//
// An instance of this type is always passed by reference.
type AttrClass struct {
	*attrClass
}

// attrClass is the struct that's finalized.
type attrClass struct {
	native *C.PangoAttrClass
}

// Type: type ID for this attribute.
func (a *AttrClass) Type() AttrType {
	valptr := &a.native._type
	var _v AttrType // out
	_v = AttrType(*valptr)
	return _v
}

// AttrColor: PangoAttrColor structure is used to represent attributes that are
// colors.
//
// An instance of this type is always passed by reference.
type AttrColor struct {
	*attrColor
}

// attrColor is the struct that's finalized.
type attrColor struct {
	native *C.PangoAttrColor
}

// Attr: common portion of the attribute.
func (a *AttrColor) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Color: PangoColor which is the value of the attribute.
func (a *AttrColor) Color() *Color {
	valptr := &a.native.color
	var _v *Color // out
	_v = (*Color)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AttrFloat: PangoAttrFloat structure is used to represent attributes with a
// float or double value.
//
// An instance of this type is always passed by reference.
type AttrFloat struct {
	*attrFloat
}

// attrFloat is the struct that's finalized.
type attrFloat struct {
	native *C.PangoAttrFloat
}

// Attr: common portion of the attribute.
func (a *AttrFloat) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Value: value of the attribute.
func (a *AttrFloat) Value() float64 {
	valptr := &a.native.value
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// Value: value of the attribute.
func (a *AttrFloat) SetValue(value float64) {
	valptr := &a.native.value
	*valptr = C.double(value)
}

// AttrFontDesc: PangoAttrFontDesc structure is used to store an attribute that
// sets all aspects of the font description at once.
//
// An instance of this type is always passed by reference.
type AttrFontDesc struct {
	*attrFontDesc
}

// attrFontDesc is the struct that's finalized.
type attrFontDesc struct {
	native *C.PangoAttrFontDesc
}

// Attr: common portion of the attribute.
func (a *AttrFontDesc) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Desc: font description which is the value of this attribute.
func (a *AttrFontDesc) Desc() *FontDescription {
	valptr := &a.native.desc
	var _v *FontDescription // out
	_v = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// NewAttrFontDesc: create a new font description attribute.
//
// This attribute allows setting family, style, weight, variant, stretch,
// and size simultaneously.
//
// The function takes the following parameters:
//
//   - desc: font description.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrFontDesc(desc *FontDescription) *Attribute {
	var _arg1 *C.PangoFontDescription // out
	var _cret *C.PangoAttribute       // in

	_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_attr_font_desc_new(_arg1)
	runtime.KeepAlive(desc)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// AttrFontFeatures: PangoAttrFontFeatures structure is used to represent
// OpenType font features as an attribute.
//
// An instance of this type is always passed by reference.
type AttrFontFeatures struct {
	*attrFontFeatures
}

// attrFontFeatures is the struct that's finalized.
type attrFontFeatures struct {
	native *C.PangoAttrFontFeatures
}

// Attr: common portion of the attribute.
func (a *AttrFontFeatures) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Features: features, as a string in CSS syntax.
func (a *AttrFontFeatures) Features() string {
	valptr := &a.native.features
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// NewAttrFontFeatures: create a new font features tag attribute.
//
// You can use this attribute to select OpenType font features like small-caps,
// alternative glyphs, ligatures, etc. for fonts that support them.
//
// The function takes the following parameters:
//
//   - features: string with OpenType font features,
//     with the syntax of the [CSS font-feature-settings
//     property](https://www.w3.org/TR/css-fonts-4/#font-rend-desc).
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrFontFeatures(features string) *Attribute {
	var _arg1 *C.char           // out
	var _cret *C.PangoAttribute // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(features)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_attr_font_features_new(_arg1)
	runtime.KeepAlive(features)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// AttrInt: PangoAttrInt structure is used to represent attributes with an
// integer or enumeration value.
//
// An instance of this type is always passed by reference.
type AttrInt struct {
	*attrInt
}

// attrInt is the struct that's finalized.
type attrInt struct {
	native *C.PangoAttrInt
}

// Attr: common portion of the attribute.
func (a *AttrInt) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Value: value of the attribute.
func (a *AttrInt) Value() int {
	valptr := &a.native.value
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Value: value of the attribute.
func (a *AttrInt) SetValue(value int) {
	valptr := &a.native.value
	*valptr = C.int(value)
}

// AttrIterator: PangoAttrIterator is used to iterate through a PangoAttrList.
//
// A new iterator is created with pango.AttrList.GetIterator(). Once the
// iterator is created, it can be advanced through the style changes in the
// text using pango.AttrIterator.Next(). At each style change, the range of the
// current style segment and the attributes currently in effect can be queried.
//
// An instance of this type is always passed by reference.
type AttrIterator struct {
	*attrIterator
}

// attrIterator is the struct that's finalized.
type attrIterator struct {
	native *C.PangoAttrIterator
}

func marshalAttrIterator(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AttrIterator{&attrIterator{(*C.PangoAttrIterator)(b)}}, nil
}

// Copy a PangoAttrIterator.
//
// The function returns the following values:
//
//   - attrIterator: newly allocated PangoAttrIterator, which should be freed
//     with pango.AttrIterator.Destroy().
func (iterator *AttrIterator) Copy() *AttrIterator {
	var _arg0 *C.PangoAttrIterator // out
	var _cret *C.PangoAttrIterator // in

	_arg0 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iterator)))

	_cret = C.pango_attr_iterator_copy(_arg0)
	runtime.KeepAlive(iterator)

	var _attrIterator *AttrIterator // out

	_attrIterator = (*AttrIterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrIterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attr_iterator_destroy((*C.PangoAttrIterator)(intern.C))
		},
	)

	return _attrIterator
}

// Destroy a PangoAttrIterator and free all associated memory.
func (iterator *AttrIterator) Destroy() {
	var _arg0 *C.PangoAttrIterator // out

	_arg0 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iterator)))

	C.pango_attr_iterator_destroy(_arg0)
	runtime.KeepAlive(iterator)
}

// Get: find the current attribute of a particular type at the iterator
// location.
//
// When multiple attributes of the same type overlap, the attribute whose range
// starts closest to the current location is used.
//
// The function takes the following parameters:
//
//   - typ: type of attribute to find.
//
// The function returns the following values:
//
//   - attribute (optional): current attribute of the given type, or NULL if no
//     attribute of that type applies to the current location.
func (iterator *AttrIterator) Get(typ AttrType) *Attribute {
	var _arg0 *C.PangoAttrIterator // out
	var _arg1 C.PangoAttrType      // out
	var _cret *C.PangoAttribute    // in

	_arg0 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iterator)))
	_arg1 = C.PangoAttrType(typ)

	_cret = C.pango_attr_iterator_get(_arg0, _arg1)
	runtime.KeepAlive(iterator)
	runtime.KeepAlive(typ)

	var _attribute *Attribute // out

	if _cret != nil {
		_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attribute
}

// Attrs gets a list of all attributes at the current position of the iterator.
//
// The function returns the following values:
//
//   - sList: a list of all attributes for the current range. To free this
//     value, call pango.Attribute.Destroy() on each value and g_slist_free() on
//     the list.
func (iterator *AttrIterator) Attrs() []*Attribute {
	var _arg0 *C.PangoAttrIterator // out
	var _cret *C.GSList            // in

	_arg0 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iterator)))

	_cret = C.pango_attr_iterator_get_attrs(_arg0)
	runtime.KeepAlive(iterator)

	var _sList []*Attribute // out

	_sList = make([]*Attribute, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.PangoAttribute)(v)
		var dst *Attribute // out
		dst = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// Font: get the font and other attributes at the current iterator position.
//
// The function takes the following parameters:
//
//   - desc: PangoFontDescription to fill in with the current values.
//     The family name in this structure will be set using
//     pango.FontDescription.SetFamilyStatic() using values from an attribute
//     in the PangoAttrList associated with the iterator, so if you plan to
//     keep it around, you must call: pango_font_description_set_family (desc,
//     pango_font_description_get_family (desc)).
//
// The function returns the following values:
//
//   - language (optional): location to store language tag for item, or NULL if
//     none is found.
//   - extraAttrs (optional): location in which to store a list of non-font
//     attributes at the the current position; only the highest priority value
//     of each attribute will be added to this list. In order to free this
//     value, you must call pango.Attribute.Destroy() on each member.
func (iterator *AttrIterator) Font(desc *FontDescription) (*Language, []*Attribute) {
	var _arg0 *C.PangoAttrIterator    // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 *C.PangoLanguage        // in
	var _arg3 *C.GSList               // in

	_arg0 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iterator)))
	_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	C.pango_attr_iterator_get_font(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(iterator)
	runtime.KeepAlive(desc)

	var _language *Language      // out
	var _extraAttrs []*Attribute // out

	if _arg2 != nil {
		_language = (*Language)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_language)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	if _arg3 != nil {
		_extraAttrs = make([]*Attribute, 0, gextras.SListSize(unsafe.Pointer(_arg3)))
		gextras.MoveSList(unsafe.Pointer(_arg3), true, func(v unsafe.Pointer) {
			src := (*C.PangoAttribute)(v)
			var dst *Attribute // out
			dst = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(src)))
			_extraAttrs = append(_extraAttrs, dst)
		})
	}

	return _language, _extraAttrs
}

// Next: advance the iterator until the next change of style.
//
// The function returns the following values:
//
//   - ok: FALSE if the iterator is at the end of the list, otherwise TRUE.
func (iterator *AttrIterator) Next() bool {
	var _arg0 *C.PangoAttrIterator // out
	var _cret C.gboolean           // in

	_arg0 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iterator)))

	_cret = C.pango_attr_iterator_next(_arg0)
	runtime.KeepAlive(iterator)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Range: get the range of the current segment.
//
// Note that the stored return values are signed, not unsigned like the values
// in PangoAttribute. To deal with this API oversight, stored return values that
// wouldn't fit into a signed integer are clamped to G_MAXINT.
//
// The function returns the following values:
//
//   - start: location to store the start of the range.
//   - end: location to store the end of the range.
func (iterator *AttrIterator) Range() (start int, end int) {
	var _arg0 *C.PangoAttrIterator // out
	var _arg1 C.int                // in
	var _arg2 C.int                // in

	_arg0 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iterator)))

	C.pango_attr_iterator_range(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iterator)

	var _start int // out
	var _end int   // out

	_start = int(_arg1)
	_end = int(_arg2)

	return _start, _end
}

// AttrLanguage: PangoAttrLanguage structure is used to represent attributes
// that are languages.
//
// An instance of this type is always passed by reference.
type AttrLanguage struct {
	*attrLanguage
}

// attrLanguage is the struct that's finalized.
type attrLanguage struct {
	native *C.PangoAttrLanguage
}

// Attr: common portion of the attribute.
func (a *AttrLanguage) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Value: PangoLanguage which is the value of the attribute.
func (a *AttrLanguage) Value() *Language {
	valptr := &a.native.value
	var _v *Language // out
	_v = (*Language)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// NewAttrLanguage: create a new language tag attribute.
//
// The function takes the following parameters:
//
//   - language tag.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrLanguage(language *Language) *Attribute {
	var _arg1 *C.PangoLanguage  // out
	var _cret *C.PangoAttribute // in

	_arg1 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C.pango_attr_language_new(_arg1)
	runtime.KeepAlive(language)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// AttrList: PangoAttrList represents a list of attributes that apply to a
// section of text.
//
// The attributes in a PangoAttrList are, in general, allowed to overlap in an
// arbitrary fashion. However, if the attributes are manipulated only through
// pango.AttrList.Change(), the overlap between properties will meet stricter
// criteria.
//
// Since the PangoAttrList structure is stored as a linear list, it is not
// suitable for storing attributes for large amounts of text. In general, you
// should not use a single PangoAttrList for more than one paragraph of text.
//
// An instance of this type is always passed by reference.
type AttrList struct {
	*attrList
}

// attrList is the struct that's finalized.
type attrList struct {
	native *C.PangoAttrList
}

func marshalAttrList(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AttrList{&attrList{(*C.PangoAttrList)(b)}}, nil
}

// NewAttrList constructs a struct AttrList.
func NewAttrList() *AttrList {
	var _cret *C.PangoAttrList // in

	_cret = C.pango_attr_list_new()

	var _attrList *AttrList // out

	_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
		},
	)

	return _attrList
}

// Change: insert the given attribute into the PangoAttrList.
//
// It will replace any attributes of the same type on that segment and be merged
// with any adjoining attributes that are identical.
//
// This function is slower than pango.AttrList.Insert() for creating an
// attribute list in order (potentially much slower for large lists). However,
// pango.AttrList.Insert() is not suitable for continually changing a set of
// attributes since it never removes or combines existing attributes.
//
// The function takes the following parameters:
//
//   - attr: attribute to insert.
func (list *AttrList) Change(attr *Attribute) {
	var _arg0 *C.PangoAttrList  // out
	var _arg1 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(attr)), nil)

	C.pango_attr_list_change(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(attr)
}

// Copy list and return an identical new list.
//
// The function returns the following values:
//
//   - attrList (optional): newly allocated PangoAttrList, with a reference
//     count of one, which should be freed with pango.AttrList.Unref(). Returns
//     NULL if list was NULL.
func (list *AttrList) Copy() *AttrList {
	var _arg0 *C.PangoAttrList // out
	var _cret *C.PangoAttrList // in

	if list != nil {
		_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	}

	_cret = C.pango_attr_list_copy(_arg0)
	runtime.KeepAlive(list)

	var _attrList *AttrList // out

	if _cret != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// Equal checks whether list and other_list contain the same attributes and
// whether those attributes apply to the same ranges.
//
// Beware that this will return wrong values if any list contains duplicates.
//
// The function takes the following parameters:
//
//   - otherList: other PangoAttrList.
//
// The function returns the following values:
//
//   - ok: TRUE if the lists are equal, FALSE if they aren't.
func (list *AttrList) Equal(otherList *AttrList) bool {
	var _arg0 *C.PangoAttrList // out
	var _arg1 *C.PangoAttrList // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(otherList)))

	_cret = C.pango_attr_list_equal(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(otherList)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Filter: given a PangoAttrList and callback function, removes any elements of
// list for which func returns TRUE and inserts them into a new list.
//
// The function takes the following parameters:
//
//   - fn: callback function; returns TRUE if an attribute should be filtered
//     out.
//
// The function returns the following values:
//
//   - attrList (optional): new PangoAttrList or NULL if no attributes of the
//     given types were found.
func (list *AttrList) Filter(fn AttrFilterFunc) *AttrList {
	var _arg0 *C.PangoAttrList      // out
	var _arg1 C.PangoAttrFilterFunc // out
	var _arg2 C.gpointer
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*[0]byte)(C._gotk4_pango1_AttrFilterFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.pango_attr_list_filter(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(fn)

	var _attrList *AttrList // out

	if _cret != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// Attributes gets a list of all attributes in list.
//
// The function returns the following values:
//
//   - sList: a list of all attributes in list. To free this value, call
//     pango.Attribute.Destroy() on each value and g_slist_free() on the list.
func (list *AttrList) Attributes() []*Attribute {
	var _arg0 *C.PangoAttrList // out
	var _cret *C.GSList        // in

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.pango_attr_list_get_attributes(_arg0)
	runtime.KeepAlive(list)

	var _sList []*Attribute // out

	_sList = make([]*Attribute, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.PangoAttribute)(v)
		var dst *Attribute // out
		dst = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// Iterator: create a iterator initialized to the beginning of the list.
//
// list must not be modified until this iterator is freed.
//
// The function returns the following values:
//
//   - attrIterator: newly allocated PangoAttrIterator, which should be freed
//     with pango.AttrIterator.Destroy().
func (list *AttrList) Iterator() *AttrIterator {
	var _arg0 *C.PangoAttrList     // out
	var _cret *C.PangoAttrIterator // in

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.pango_attr_list_get_iterator(_arg0)
	runtime.KeepAlive(list)

	var _attrIterator *AttrIterator // out

	_attrIterator = (*AttrIterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrIterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attr_iterator_destroy((*C.PangoAttrIterator)(intern.C))
		},
	)

	return _attrIterator
}

// Insert the given attribute into the PangoAttrList.
//
// It will be inserted after all other attributes with a matching start_index.
//
// The function takes the following parameters:
//
//   - attr: attribute to insert.
func (list *AttrList) Insert(attr *Attribute) {
	var _arg0 *C.PangoAttrList  // out
	var _arg1 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(attr)), nil)

	C.pango_attr_list_insert(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(attr)
}

// InsertBefore: insert the given attribute into the PangoAttrList.
//
// It will be inserted before all other attributes with a matching start_index.
//
// The function takes the following parameters:
//
//   - attr: attribute to insert.
func (list *AttrList) InsertBefore(attr *Attribute) {
	var _arg0 *C.PangoAttrList  // out
	var _arg1 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(attr)), nil)

	C.pango_attr_list_insert_before(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(attr)
}

// Splice: this function opens up a hole in list, fills it in with attributes
// from the left, and then merges other on top of the hole.
//
// This operation is equivalent to stretching every attribute that
// applies at position pos in list by an amount len, and then calling
// pango.AttrList.Change() with a copy of each attribute in other in sequence
// (offset in position by pos, and limited in length to len).
//
// This operation proves useful for, for instance, inserting a pre-edit string
// in the middle of an edit buffer.
//
// For backwards compatibility, the function behaves differently when len is 0.
// In this case, the attributes from other are not imited to len, and are just
// overlayed on top of list.
//
// This mode is useful for merging two lists of attributes together.
//
// The function takes the following parameters:
//
//   - other PangoAttrList.
//   - pos: position in list at which to insert other.
//   - len: length of the spliced segment. (Note that this must be specified
//     since the attributes in other may only be present at some subsection of
//     this range).
func (list *AttrList) Splice(other *AttrList, pos int, len int) {
	var _arg0 *C.PangoAttrList // out
	var _arg1 *C.PangoAttrList // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(other)))
	_arg2 = C.int(pos)
	_arg3 = C.int(len)

	C.pango_attr_list_splice(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(other)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(len)
}

// String serializes a PangoAttrList to a string.
//
// In the resulting string, serialized attributes are separated by newlines or
// commas. Individual attributes are serialized to a string of the form
//
//	START END TYPE VALUE
//
// Where START and END are the indices (with -1 being accepted in place of
// MAXUINT), TYPE is the nickname of the attribute value type, e.g. _weight_ or
// _stretch_, and the value is serialized according to its type:
//
// - enum values as nick or numeric value
//
// - boolean values as _true_ or _false_
//
// - integers and floats as numbers
//
// - strings as string, optionally quoted
//
// - font features as quoted string
//
// - PangoLanguage as string
//
// - PangoFontDescription as serialized by pango.FontDescription.ToString(),
// quoted
//
// - PangoColor as serialized by pango.Color.ToString()
//
// Examples:
//
//	0 10 foreground red, 5 15 weight bold, 0 200 font-desc "Sans 10"
//
//
//
//
//	0 -1 weight 700
//	0 100 family Times
//
// To parse the returned value, use pango.AttrList().FromString.
//
// Note that shape attributes can not be serialized.
//
// The function returns the following values:
//
//   - utf8: newly allocated string.
func (list *AttrList) String() string {
	var _arg0 *C.PangoAttrList // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.pango_attr_list_to_string(_arg0)
	runtime.KeepAlive(list)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Update indices of attributes in list for a change in the text they refer to.
//
// The change that this function applies is removing remove bytes at position
// pos and inserting add bytes instead.
//
// Attributes that fall entirely in the (pos, pos + remove) range are removed.
//
// Attributes that start or end inside the (pos, pos + remove) range are
// shortened to reflect the removal.
//
// Attributes start and end positions are updated if they are behind pos +
// remove.
//
// The function takes the following parameters:
//
//   - pos: position of the change.
//   - remove: number of removed bytes.
//   - add: number of added bytes.
func (list *AttrList) Update(pos int, remove int, add int) {
	var _arg0 *C.PangoAttrList // out
	var _arg1 C.int            // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.int(pos)
	_arg2 = C.int(remove)
	_arg3 = C.int(add)

	C.pango_attr_list_update(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(remove)
	runtime.KeepAlive(add)
}

// AttrListFromString deserializes a PangoAttrList from a string.
//
// This is the counterpart to pango.AttrList.ToString(). See that functions for
// details about the format.
//
// The function takes the following parameters:
//
//   - text: string.
//
// The function returns the following values:
//
//   - attrList (optional): new PangoAttrList.
func AttrListFromString(text string) *AttrList {
	var _arg1 *C.char          // out
	var _cret *C.PangoAttrList // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_attr_list_from_string(_arg1)
	runtime.KeepAlive(text)

	var _attrList *AttrList // out

	if _cret != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// AttrShape: PangoAttrShape structure is used to represent attributes which
// impose shape restrictions.
//
// An instance of this type is always passed by reference.
type AttrShape struct {
	*attrShape
}

// attrShape is the struct that's finalized.
type attrShape struct {
	native *C.PangoAttrShape
}

// NewAttrShape: create a new shape attribute.
//
// A shape is used to impose a particular ink and logical rectangle on the
// result of shaping a particular glyph. This might be used, for instance,
// for embedding a picture or a widget inside a PangoLayout.
//
// The function takes the following parameters:
//
//   - inkRect: ink rectangle to assign to each character.
//   - logicalRect: logical rectangle to assign to each character.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrShape(inkRect, logicalRect *Rectangle) *Attribute {
	var _arg1 *C.PangoRectangle // out
	var _arg2 *C.PangoRectangle // out
	var _cret *C.PangoAttribute // in

	_arg1 = (*C.PangoRectangle)(gextras.StructNative(unsafe.Pointer(inkRect)))
	_arg2 = (*C.PangoRectangle)(gextras.StructNative(unsafe.Pointer(logicalRect)))

	_cret = C.pango_attr_shape_new(_arg1, _arg2)
	runtime.KeepAlive(inkRect)
	runtime.KeepAlive(logicalRect)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// AttrSize: PangoAttrSize structure is used to represent attributes which set
// font size.
//
// An instance of this type is always passed by reference.
type AttrSize struct {
	*attrSize
}

// attrSize is the struct that's finalized.
type attrSize struct {
	native *C.PangoAttrSize
}

// Attr: common portion of the attribute.
func (a *AttrSize) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Size: size of font, in units of 1/PANGO_SCALE of a point (for
// PANGO_ATTR_SIZE) or of a device unit (for PANGO_ATTR_ABSOLUTE_SIZE).
func (a *AttrSize) Size() int {
	valptr := &a.native.size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Size: size of font, in units of 1/PANGO_SCALE of a point (for
// PANGO_ATTR_SIZE) or of a device unit (for PANGO_ATTR_ABSOLUTE_SIZE).
func (a *AttrSize) SetSize(size int) {
	valptr := &a.native.size
	*valptr = C.int(size)
}

// NewAttrSize: create a new font-size attribute in fractional points.
//
// The function takes the following parameters:
//
//   - size: font size, in PANGO_SCALE-ths of a point.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrSize(size int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.int(size)

	_cret = C.pango_attr_size_new(_arg1)
	runtime.KeepAlive(size)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// NewAttrSizeAbsolute: create a new font-size attribute in device units.
//
// The function takes the following parameters:
//
//   - size: font size, in PANGO_SCALE-ths of a device unit.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func NewAttrSizeAbsolute(size int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = C.int(size)

	_cret = C.pango_attr_size_new_absolute(_arg1)
	runtime.KeepAlive(size)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// AttrString: PangoAttrString structure is used to represent attributes with a
// string value.
//
// An instance of this type is always passed by reference.
type AttrString struct {
	*attrString
}

// attrString is the struct that's finalized.
type attrString struct {
	native *C.PangoAttrString
}

// Attr: common portion of the attribute.
func (a *AttrString) Attr() *Attribute {
	valptr := &a.native.attr
	var _v *Attribute // out
	_v = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Value: string which is the value of the attribute.
func (a *AttrString) Value() string {
	valptr := &a.native.value
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Attribute: PangoAttribute structure represents the common portions of all
// attributes.
//
// Particular types of attributes include this structure as their initial
// portion. The common portion of the attribute holds the range to which the
// value in the type-specific part of the attribute applies and should be
// initialized using pango.Attribute.Init(). By default, an attribute will have
// an all-inclusive range of [0,G_MAXUINT].
//
// An instance of this type is always passed by reference.
type Attribute struct {
	*attribute
}

// attribute is the struct that's finalized.
type attribute struct {
	native *C.PangoAttribute
}

func marshalAttribute(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Attribute{&attribute{(*C.PangoAttribute)(b)}}, nil
}

// Klass class structure holding information about the type of the attribute.
func (a *Attribute) Klass() *AttrClass {
	valptr := &a.native.klass
	var _v *AttrClass // out
	_v = (*AttrClass)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// StartIndex: start index of the range (in bytes).
func (a *Attribute) StartIndex() uint {
	valptr := &a.native.start_index
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// EndIndex: end index of the range (in bytes). The character at this index is
// not included in the range.
func (a *Attribute) EndIndex() uint {
	valptr := &a.native.end_index
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// StartIndex: start index of the range (in bytes).
func (a *Attribute) SetStartIndex(startIndex uint) {
	valptr := &a.native.start_index
	*valptr = C.guint(startIndex)
}

// EndIndex: end index of the range (in bytes). The character at this index is
// not included in the range.
func (a *Attribute) SetEndIndex(endIndex uint) {
	valptr := &a.native.end_index
	*valptr = C.guint(endIndex)
}

// AsColor returns the attribute cast to PangoAttrColor.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrColor (optional): attribute as PangoAttrColor, or NULL if it's not a
//     color attribute.
func (attr *Attribute) AsColor() *AttrColor {
	var _arg0 *C.PangoAttribute // out
	var _cret *C.PangoAttrColor // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_color(_arg0)
	runtime.KeepAlive(attr)

	var _attrColor *AttrColor // out

	if _cret != nil {
		_attrColor = (*AttrColor)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrColor
}

// AsFloat returns the attribute cast to PangoAttrFloat.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrFloat (optional): attribute as PangoAttrFloat, or NULL if it's not a
//     floating point attribute.
func (attr *Attribute) AsFloat() *AttrFloat {
	var _arg0 *C.PangoAttribute // out
	var _cret *C.PangoAttrFloat // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_float(_arg0)
	runtime.KeepAlive(attr)

	var _attrFloat *AttrFloat // out

	if _cret != nil {
		_attrFloat = (*AttrFloat)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrFloat
}

// AsFontDesc returns the attribute cast to PangoAttrFontDesc.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrFontDesc (optional): attribute as PangoAttrFontDesc, or NULL if it's
//     not a font description attribute.
func (attr *Attribute) AsFontDesc() *AttrFontDesc {
	var _arg0 *C.PangoAttribute    // out
	var _cret *C.PangoAttrFontDesc // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_font_desc(_arg0)
	runtime.KeepAlive(attr)

	var _attrFontDesc *AttrFontDesc // out

	if _cret != nil {
		_attrFontDesc = (*AttrFontDesc)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrFontDesc
}

// AsFontFeatures returns the attribute cast to PangoAttrFontFeatures.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrFontFeatures (optional): attribute as PangoAttrFontFeatures, or NULL
//     if it's not a font features attribute.
func (attr *Attribute) AsFontFeatures() *AttrFontFeatures {
	var _arg0 *C.PangoAttribute        // out
	var _cret *C.PangoAttrFontFeatures // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_font_features(_arg0)
	runtime.KeepAlive(attr)

	var _attrFontFeatures *AttrFontFeatures // out

	if _cret != nil {
		_attrFontFeatures = (*AttrFontFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrFontFeatures
}

// AsInt returns the attribute cast to PangoAttrInt.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrInt (optional): attribute as PangoAttrInt, or NULL if it's not an
//     integer attribute.
func (attr *Attribute) AsInt() *AttrInt {
	var _arg0 *C.PangoAttribute // out
	var _cret *C.PangoAttrInt   // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_int(_arg0)
	runtime.KeepAlive(attr)

	var _attrInt *AttrInt // out

	if _cret != nil {
		_attrInt = (*AttrInt)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrInt
}

// AsLanguage returns the attribute cast to PangoAttrLanguage.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrLanguage (optional): attribute as PangoAttrLanguage, or NULL if it's
//     not a language attribute.
func (attr *Attribute) AsLanguage() *AttrLanguage {
	var _arg0 *C.PangoAttribute    // out
	var _cret *C.PangoAttrLanguage // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_language(_arg0)
	runtime.KeepAlive(attr)

	var _attrLanguage *AttrLanguage // out

	if _cret != nil {
		_attrLanguage = (*AttrLanguage)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrLanguage
}

// AsShape returns the attribute cast to PangoAttrShape.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrShape (optional): attribute as PangoAttrShape, or NULL if it's not a
//     shape attribute.
func (attr *Attribute) AsShape() *AttrShape {
	var _arg0 *C.PangoAttribute // out
	var _cret *C.PangoAttrShape // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_shape(_arg0)
	runtime.KeepAlive(attr)

	var _attrShape *AttrShape // out

	if _cret != nil {
		_attrShape = (*AttrShape)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrShape
}

// AsSize returns the attribute cast to PangoAttrSize.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrSize (optional): attribute as PangoAttrSize, or NULL if it's not a
//     size attribute.
func (attr *Attribute) AsSize() *AttrSize {
	var _arg0 *C.PangoAttribute // out
	var _cret *C.PangoAttrSize  // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_size(_arg0)
	runtime.KeepAlive(attr)

	var _attrSize *AttrSize // out

	if _cret != nil {
		_attrSize = (*AttrSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrSize
}

// AsString returns the attribute cast to PangoAttrString.
//
// This is mainly useful for language bindings.
//
// The function returns the following values:
//
//   - attrString (optional): attribute as PangoAttrString, or NULL if it's not
//     a string attribute.
func (attr *Attribute) AsString() *AttrString {
	var _arg0 *C.PangoAttribute  // out
	var _cret *C.PangoAttrString // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_as_string(_arg0)
	runtime.KeepAlive(attr)

	var _attrString *AttrString // out

	if _cret != nil {
		_attrString = (*AttrString)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _attrString
}

// Copy: make a copy of an attribute.
//
// The function returns the following values:
//
//   - attribute: newly allocated PangoAttribute, which should be freed with
//     pango.Attribute.Destroy().
func (attr *Attribute) Copy() *Attribute {
	var _arg0 *C.PangoAttribute // out
	var _cret *C.PangoAttribute // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = C.pango_attribute_copy(_arg0)
	runtime.KeepAlive(attr)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attribute_destroy((*C.PangoAttribute)(intern.C))
		},
	)

	return _attribute
}

// Destroy a PangoAttribute and free all associated memory.
func (attr *Attribute) Destroy() {
	var _arg0 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))

	C.pango_attribute_destroy(_arg0)
	runtime.KeepAlive(attr)
}

// Equal: compare two attributes for equality.
//
// This compares only the actual value of the two attributes and not the ranges
// that the attributes apply to.
//
// The function takes the following parameters:
//
//   - attr2: another PangoAttribute.
//
// The function returns the following values:
//
//   - ok: TRUE if the two attributes have the same value.
func (attr1 *Attribute) Equal(attr2 *Attribute) bool {
	var _arg0 *C.PangoAttribute // out
	var _arg1 *C.PangoAttribute // out
	var _cret C.gboolean        // in

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr1)))
	_arg1 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr2)))

	_cret = C.pango_attribute_equal(_arg0, _arg1)
	runtime.KeepAlive(attr1)
	runtime.KeepAlive(attr2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Init initializes attr's klass to klass, it's start_index
// to PANGO_ATTR_INDEX_FROM_TEXT_BEGINNING and end_index to
// PANGO_ATTR_INDEX_TO_TEXT_END such that the attribute applies to the entire
// text by default.
//
// The function takes the following parameters:
//
//   - klass: PangoAttrClass.
func (attr *Attribute) Init(klass *AttrClass) {
	var _arg0 *C.PangoAttribute // out
	var _arg1 *C.PangoAttrClass // out

	_arg0 = (*C.PangoAttribute)(gextras.StructNative(unsafe.Pointer(attr)))
	_arg1 = (*C.PangoAttrClass)(gextras.StructNative(unsafe.Pointer(klass)))

	C.pango_attribute_init(_arg0, _arg1)
	runtime.KeepAlive(attr)
	runtime.KeepAlive(klass)
}

// Color: PangoColor structure is used to represent a color in an uncalibrated
// RGB color-space.
//
// An instance of this type is always passed by reference.
type Color struct {
	*color
}

// color is the struct that's finalized.
type color struct {
	native *C.PangoColor
}

func marshalColor(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Color{&color{(*C.PangoColor)(b)}}, nil
}

// NewColor creates a new Color instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewColor(red, green, blue uint16) Color {
	var f0 C.guint16 // out
	f0 = C.guint16(red)
	var f1 C.guint16 // out
	f1 = C.guint16(green)
	var f2 C.guint16 // out
	f2 = C.guint16(blue)

	v := C.PangoColor{
		red:   f0,
		green: f1,
		blue:  f2,
	}

	return *(*Color)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Red: value of red component.
func (c *Color) Red() uint16 {
	valptr := &c.native.red
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

// Green: value of green component.
func (c *Color) Green() uint16 {
	valptr := &c.native.green
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

// Blue: value of blue component.
func (c *Color) Blue() uint16 {
	valptr := &c.native.blue
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

// Red: value of red component.
func (c *Color) SetRed(red uint16) {
	valptr := &c.native.red
	*valptr = C.guint16(red)
}

// Green: value of green component.
func (c *Color) SetGreen(green uint16) {
	valptr := &c.native.green
	*valptr = C.guint16(green)
}

// Blue: value of blue component.
func (c *Color) SetBlue(blue uint16) {
	valptr := &c.native.blue
	*valptr = C.guint16(blue)
}

// Copy creates a copy of src.
//
// The copy should be freed with pango.Color.Free(). Primarily used by language
// bindings, not that useful otherwise (since colors can just be copied by
// assignment in C).
//
// The function returns the following values:
//
//   - color (optional): newly allocated PangoColor, which should be freed with
//     pango.Color.Free().
func (src *Color) Copy() *Color {
	var _arg0 *C.PangoColor // out
	var _cret *C.PangoColor // in

	if src != nil {
		_arg0 = (*C.PangoColor)(gextras.StructNative(unsafe.Pointer(src)))
	}

	_cret = C.pango_color_copy(_arg0)
	runtime.KeepAlive(src)

	var _color *Color // out

	if _cret != nil {
		_color = (*Color)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_color)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_color_free((*C.PangoColor)(intern.C))
			},
		)
	}

	return _color
}

// Parse: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors),
// or it can be a value in the form #rgb, #rrggbb, #rrrgggbbb or #rrrrggggbbbb,
// where r, g and b are hex digits of the red, green, and blue components of the
// color, respectively. (White in the four forms is #fff, #ffffff, #fffffffff
// and #ffffffffffff.).
//
// The function takes the following parameters:
//
//   - spec: string specifying the new color.
//
// The function returns the following values:
//
//   - ok: TRUE if parsing of the specifier succeeded, otherwise FALSE.
func (color *Color) Parse(spec string) bool {
	var _arg0 *C.PangoColor // out
	var _arg1 *C.char       // out
	var _cret C.gboolean    // in

	if color != nil {
		_arg0 = (*C.PangoColor)(gextras.StructNative(unsafe.Pointer(color)))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(spec)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_color_parse(_arg0, _arg1)
	runtime.KeepAlive(color)
	runtime.KeepAlive(spec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseWithAlpha: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors),
// or it can be a hexadecimal value in the form #rgb, #rrggbb, #rrrgggbbb or
// #rrrrggggbbbb where r, g and b are hex digits of the red, green, and blue
// components of the color, respectively. (White in the four forms is #fff,
// #ffffff, #fffffffff and #ffffffffffff.)
//
// Additionally, parse strings of the form #rgba, #rrggbbaa, #rrrrggggbbbbaaaa,
// if alpha is not NULL, and set alpha to the value specified by the hex digits
// for a. If no alpha component is found in spec, alpha is set to 0xffff (for a
// solid color).
//
// The function takes the following parameters:
//
//   - spec: string specifying the new color.
//
// The function returns the following values:
//
//   - alpha (optional): return location for alpha.
//   - ok: TRUE if parsing of the specifier succeeded, otherwise FALSE.
func (color *Color) ParseWithAlpha(spec string) (uint16, bool) {
	var _arg0 *C.PangoColor // out
	var _arg1 C.guint16     // in
	var _arg2 *C.char       // out
	var _cret C.gboolean    // in

	if color != nil {
		_arg0 = (*C.PangoColor)(gextras.StructNative(unsafe.Pointer(color)))
	}
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(spec)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.pango_color_parse_with_alpha(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(color)
	runtime.KeepAlive(spec)

	var _alpha uint16 // out
	var _ok bool      // out

	_alpha = uint16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _alpha, _ok
}

// String returns a textual specification of color.
//
// The string is in the hexadecimal form #rrrrggggbbbb, where r, g and b are hex
// digits representing the red, green, and blue components respectively.
//
// The function returns the following values:
//
//   - utf8: newly-allocated text string that must be freed with g_free().
func (color *Color) String() string {
	var _arg0 *C.PangoColor // out
	var _cret *C.char       // in

	_arg0 = (*C.PangoColor)(gextras.StructNative(unsafe.Pointer(color)))

	_cret = C.pango_color_to_string(_arg0)
	runtime.KeepAlive(color)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FontClass: instance of this type is always passed by reference.
type FontClass struct {
	*fontClass
}

// fontClass is the struct that's finalized.
type fontClass struct {
	native *C.PangoFontClass
}

// FontDescription: PangoFontDescription describes a font in an
// implementation-independent manner.
//
// PangoFontDescription structures are used both to list what fonts are
// available on the system and also for specifying the characteristics of a font
// to load.
//
// An instance of this type is always passed by reference.
type FontDescription struct {
	*fontDescription
}

// fontDescription is the struct that's finalized.
type fontDescription struct {
	native *C.PangoFontDescription
}

func marshalFontDescription(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FontDescription{&fontDescription{(*C.PangoFontDescription)(b)}}, nil
}

// NewFontDescription constructs a struct FontDescription.
func NewFontDescription() *FontDescription {
	var _cret *C.PangoFontDescription // in

	_cret = C.pango_font_description_new()

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

// BetterMatch determines if the style attributes of new_match are a closer
// match for desc than those of old_match are, or if old_match is NULL,
// determines if new_match is a match at all.
//
// Approximate matching is done for weight and style; other style attributes
// must match exactly. Style attributes are all attributes other than family
// and size-related attributes. Approximate matching for style considers
// PANGO_STYLE_OBLIQUE and PANGO_STYLE_ITALIC as matches, but not as good a
// match as when the styles are equal.
//
// Note that old_match must match desc.
//
// The function takes the following parameters:
//
//   - oldMatch (optional): PangoFontDescription, or NULL.
//   - newMatch: PangoFontDescription.
//
// The function returns the following values:
//
//   - ok: TRUE if new_match is a better match.
func (desc *FontDescription) BetterMatch(oldMatch *FontDescription, newMatch *FontDescription) bool {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 *C.PangoFontDescription // out
	var _cret C.gboolean              // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	if oldMatch != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(oldMatch)))
	}
	_arg2 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(newMatch)))

	_cret = C.pango_font_description_better_match(_arg0, _arg1, _arg2)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(oldMatch)
	runtime.KeepAlive(newMatch)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy: make a copy of a PangoFontDescription.
//
// The function returns the following values:
//
//   - fontDescription (optional): newly allocated PangoFontDescription,
//     which should be freed with pango.FontDescription.Free(), or NULL if desc
//     was NULL.
func (desc *FontDescription) Copy() *FontDescription {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.PangoFontDescription // in

	if desc != nil {
		_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	}

	_cret = C.pango_font_description_copy(_arg0)
	runtime.KeepAlive(desc)

	var _fontDescription *FontDescription // out

	if _cret != nil {
		_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fontDescription)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
			},
		)
	}

	return _fontDescription
}

// CopyStatic: make a copy of a PangoFontDescription, but don't duplicate
// allocated fields.
//
// This is like pango.FontDescription.Copy(), but only a shallow copy is made of
// the family name and other allocated fields. The result can only be used until
// desc is modified or freed. This is meant to be used when the copy is only
// needed temporarily.
//
// The function returns the following values:
//
//   - fontDescription (optional): newly allocated PangoFontDescription,
//     which should be freed with pango.FontDescription.Free(), or NULL if desc
//     was NULL.
func (desc *FontDescription) CopyStatic() *FontDescription {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.PangoFontDescription // in

	if desc != nil {
		_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	}

	_cret = C.pango_font_description_copy_static(_arg0)
	runtime.KeepAlive(desc)

	var _fontDescription *FontDescription // out

	if _cret != nil {
		_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fontDescription)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
			},
		)
	}

	return _fontDescription
}

// Equal compares two font descriptions for equality.
//
// Two font descriptions are considered equal if the fonts they describe are
// provably identical. This means that their masks do not have to match,
// as long as other fields are all the same. (Two font descriptions may result
// in identical fonts being loaded, but still compare FALSE.).
//
// The function takes the following parameters:
//
//   - desc2: another PangoFontDescription.
//
// The function returns the following values:
//
//   - ok: TRUE if the two font descriptions are identical, FALSE otherwise.
func (desc1 *FontDescription) Equal(desc2 *FontDescription) bool {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _cret C.gboolean              // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc1)))
	_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc2)))

	_cret = C.pango_font_description_equal(_arg0, _arg1)
	runtime.KeepAlive(desc1)
	runtime.KeepAlive(desc2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Family gets the family name field of a font description.
//
// See pango.FontDescription.SetFamily().
//
// The function returns the following values:
//
//   - utf8 (optional): family name field for the font description, or NULL if
//     not previously set. This has the same life-time as the font description
//     itself and should not be freed.
func (desc *FontDescription) Family() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_family(_arg0)
	runtime.KeepAlive(desc)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Gravity gets the gravity field of a font description.
//
// See pango.FontDescription.SetGravity().
//
// The function returns the following values:
//
//   - gravity field for the font description. Use
//     pango.FontDescription.GetSetFields() to find out if the field was
//     explicitly set or not.
func (desc *FontDescription) Gravity() Gravity {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoGravity          // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_gravity(_arg0)
	runtime.KeepAlive(desc)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// SetFields determines which fields in a font description have been set.
//
// The function returns the following values:
//
//   - fontMask: bitmask with bits set corresponding to the fields in desc that
//     have been set.
func (desc *FontDescription) SetFields() FontMask {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoFontMask         // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_set_fields(_arg0)
	runtime.KeepAlive(desc)

	var _fontMask FontMask // out

	_fontMask = FontMask(_cret)

	return _fontMask
}

// Size gets the size field of a font description.
//
// See pango.FontDescription.SetSize().
//
// The function returns the following values:
//
//   - gint: size field for the font description in points or device units.
//     You must call pango.FontDescription.GetSizeIsAbsolute() to find out which
//     is the case. Returns 0 if the size field has not previously been set or
//     it has been set to 0 explicitly. Use pango.FontDescription.GetSetFields()
//     to find out if the field was explicitly set or not.
func (desc *FontDescription) Size() int {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.gint                  // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_size(_arg0)
	runtime.KeepAlive(desc)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SizeIsAbsolute determines whether the size of the font is in points (not
// absolute) or device units (absolute).
//
// See pango.FontDescription.SetSize() and
// pango.FontDescription.SetAbsoluteSize().
//
// The function returns the following values:
//
//   - ok: whether the size for the font description is in points or device
//     units. Use pango.FontDescription.GetSetFields() to find out if the size
//     field of the font description was explicitly set or not.
func (desc *FontDescription) SizeIsAbsolute() bool {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.gboolean              // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_size_is_absolute(_arg0)
	runtime.KeepAlive(desc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stretch gets the stretch field of a font description.
//
// See pango.FontDescription.SetStretch().
//
// The function returns the following values:
//
//   - stretch field for the font description. Use
//     pango.FontDescription.GetSetFields() to find out if the field was
//     explicitly set or not.
func (desc *FontDescription) Stretch() Stretch {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoStretch          // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_stretch(_arg0)
	runtime.KeepAlive(desc)

	var _stretch Stretch // out

	_stretch = Stretch(_cret)

	return _stretch
}

// Style gets the style field of a PangoFontDescription.
//
// See pango.FontDescription.SetStyle().
//
// The function returns the following values:
//
//   - style field for the font description. Use
//     pango.FontDescription.GetSetFields() to find out if the field was
//     explicitly set or not.
func (desc *FontDescription) Style() Style {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoStyle            // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_style(_arg0)
	runtime.KeepAlive(desc)

	var _style Style // out

	_style = Style(_cret)

	return _style
}

// Variant gets the variant field of a PangoFontDescription.
//
// See pango.FontDescription.SetVariant().
//
// The function returns the following values:
//
//   - variant field for the font description. Use
//     pango.FontDescription.GetSetFields() to find out if the field was
//     explicitly set or not.
func (desc *FontDescription) Variant() Variant {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoVariant          // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_variant(_arg0)
	runtime.KeepAlive(desc)

	var _variant Variant // out

	_variant = Variant(_cret)

	return _variant
}

// Variations gets the variations field of a font description.
//
// See pango.FontDescription.SetVariations().
//
// The function returns the following values:
//
//   - utf8 (optional) variations field for the font description, or NULL if
//     not previously set. This has the same life-time as the font description
//     itself and should not be freed.
func (desc *FontDescription) Variations() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_variations(_arg0)
	runtime.KeepAlive(desc)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Weight gets the weight field of a font description.
//
// See pango.FontDescription.SetWeight().
//
// The function returns the following values:
//
//   - weight field for the font description. Use
//     pango.FontDescription.GetSetFields() to find out if the field was
//     explicitly set or not.
func (desc *FontDescription) Weight() Weight {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoWeight           // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_get_weight(_arg0)
	runtime.KeepAlive(desc)

	var _weight Weight // out

	_weight = Weight(_cret)

	return _weight
}

// Hash computes a hash of a PangoFontDescription structure.
//
// This is suitable to be used, for example, as an argument to
// g_hash_table_new(). The hash value is independent of desc->mask.
//
// The function returns the following values:
//
//   - guint: hash value.
func (desc *FontDescription) Hash() uint {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.guint                 // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_hash(_arg0)
	runtime.KeepAlive(desc)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Merge merges the fields that are set in desc_to_merge into the fields in
// desc.
//
// If replace_existing is FALSE, only fields in desc that are not already set
// are affected. If TRUE, then fields that are already set will be replaced as
// well.
//
// If desc_to_merge is NULL, this function performs nothing.
//
// The function takes the following parameters:
//
//   - descToMerge (optional): PangoFontDescription to merge from, or NULL.
//   - replaceExisting: if TRUE, replace fields in desc with the corresponding
//     values from desc_to_merge, even if they are already exist.
func (desc *FontDescription) Merge(descToMerge *FontDescription, replaceExisting bool) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 C.gboolean              // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	if descToMerge != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(descToMerge)))
	}
	if replaceExisting {
		_arg2 = C.TRUE
	}

	C.pango_font_description_merge(_arg0, _arg1, _arg2)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(descToMerge)
	runtime.KeepAlive(replaceExisting)
}

// MergeStatic merges the fields that are set in desc_to_merge into the fields
// in desc, without copying allocated fields.
//
// This is like pango.FontDescription.Merge(), but only a shallow copy is made
// of the family name and other allocated fields. desc can only be used until
// desc_to_merge is modified or freed. This is meant to be used when the merged
// font description is only needed temporarily.
//
// The function takes the following parameters:
//
//   - descToMerge: PangoFontDescription to merge from.
//   - replaceExisting: if TRUE, replace fields in desc with the corresponding
//     values from desc_to_merge, even if they are already exist.
func (desc *FontDescription) MergeStatic(descToMerge *FontDescription, replaceExisting bool) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 C.gboolean              // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(descToMerge)))
	if replaceExisting {
		_arg2 = C.TRUE
	}

	C.pango_font_description_merge_static(_arg0, _arg1, _arg2)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(descToMerge)
	runtime.KeepAlive(replaceExisting)
}

// SetAbsoluteSize sets the size field of a font description, in device units.
//
// This is mutually exclusive with pango.FontDescription.SetSize() which sets
// the font size in points.
//
// The function takes the following parameters:
//
//   - size: new size, in Pango units. There are PANGO_SCALE Pango units in
//     one device unit. For an output backend where a device unit is a pixel,
//     a size value of 10 * PANGO_SCALE gives a 10 pixel font.
func (desc *FontDescription) SetAbsoluteSize(size float64) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.double                // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.double(size)

	C.pango_font_description_set_absolute_size(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(size)
}

// SetFamily sets the family name field of a font description.
//
// The family name represents a family of related font styles, and will resolve
// to a particular PangoFontFamily. In some uses of PangoFontDescription, it is
// also possible to use a comma separated list of family names for this field.
//
// The function takes the following parameters:
//
//   - family: string representing the family name.
func (desc *FontDescription) SetFamily(family string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(family)))
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_font_description_set_family(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(family)
}

// SetFamilyStatic sets the family name field of a font description, without
// copying the string.
//
// This is like pango.FontDescription.SetFamily(), except that no copy of family
// is made. The caller must make sure that the string passed in stays around
// until desc has been freed or the name is set again. This function can be used
// if family is a static string such as a C string literal, or if desc is only
// needed temporarily.
//
// The function takes the following parameters:
//
//   - family: string representing the family name.
func (desc *FontDescription) SetFamilyStatic(family string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(family)))
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_font_description_set_family_static(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(family)
}

// SetGravity sets the gravity field of a font description.
//
// The gravity field specifies how the glyphs should be rotated. If gravity
// is PANGO_GRAVITY_AUTO, this actually unsets the gravity mask on the font
// description.
//
// This function is seldom useful to the user. Gravity should normally be set on
// a PangoContext.
//
// The function takes the following parameters:
//
//   - gravity for the font description.
func (desc *FontDescription) SetGravity(gravity Gravity) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoGravity          // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.PangoGravity(gravity)

	C.pango_font_description_set_gravity(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(gravity)
}

// SetSize sets the size field of a font description in fractional points.
//
// This is mutually exclusive with pango.FontDescription.SetAbsoluteSize().
//
// The function takes the following parameters:
//
//   - size of the font in points, scaled by PANGO_SCALE. (That is, a size value
//     of 10 * PANGO_SCALE is a 10 point font. The conversion factor between
//     points and device units depends on system configuration and the output
//     device. For screen display, a logical DPI of 96 is common, in which
//     case a 10 point font corresponds to a 10 * (96 / 72) = 13.3 pixel font.
//     Use pango.FontDescription.SetAbsoluteSize() if you need a particular size
//     in device units.
func (desc *FontDescription) SetSize(size int) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.gint                  // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.gint(size)

	C.pango_font_description_set_size(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(size)
}

// SetStretch sets the stretch field of a font description.
//
// The pango.Stretch field specifies how narrow or wide the font should be.
//
// The function takes the following parameters:
//
//   - stretch for the font description.
func (desc *FontDescription) SetStretch(stretch Stretch) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoStretch          // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.PangoStretch(stretch)

	C.pango_font_description_set_stretch(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(stretch)
}

// SetStyle sets the style field of a PangoFontDescription.
//
// The pango.Style enumeration describes whether the font is slanted and
// the manner in which it is slanted; it can be either PANGO_STYLE_NORMAL,
// PANGO_STYLE_ITALIC, or PANGO_STYLE_OBLIQUE.
//
// Most fonts will either have a italic style or an oblique style, but not both,
// and font matching in Pango will match italic specifications with oblique
// fonts and vice-versa if an exact match is not found.
//
// The function takes the following parameters:
//
//   - style for the font description.
func (desc *FontDescription) SetStyle(style Style) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoStyle            // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.PangoStyle(style)

	C.pango_font_description_set_style(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(style)
}

// SetVariant sets the variant field of a font description.
//
// The pango.Variant can either be PANGO_VARIANT_NORMAL or
// PANGO_VARIANT_SMALL_CAPS.
//
// The function takes the following parameters:
//
//   - variant type for the font description.
func (desc *FontDescription) SetVariant(variant Variant) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoVariant          // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.PangoVariant(variant)

	C.pango_font_description_set_variant(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(variant)
}

// SetVariations sets the variations field of a font description.
//
// OpenType font variations allow to select a font instance by specifying values
// for a number of axes, such as width or weight.
//
// The format of the variations string is
//
//	AXIS1=VALUE,AXIS2=VALUE...
//
// with each AXIS a 4 character tag that identifies a font axis, and each VALUE
// a floating point number. Unknown axes are ignored, and values are clamped to
// their allowed range.
//
// Pango does not currently have a way to find supported
// axes of a font. Both harfbuzz and freetype have API
// for this. See for example hb_ot_var_get_axis_infos
// (https://harfbuzz.github.io/harfbuzz-hb-ot-var.html#hb-ot-var-get-axis-infos).
//
// The function takes the following parameters:
//
//   - variations (optional): string representing the variations.
func (desc *FontDescription) SetVariations(variations string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	if variations != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(variations)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.pango_font_description_set_variations(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(variations)
}

// SetVariationsStatic sets the variations field of a font description.
//
// This is like pango.FontDescription.SetVariations(), except that no copy of
// variations is made. The caller must make sure that the string passed in stays
// around until desc has been freed or the name is set again. This function
// can be used if variations is a static string such as a C string literal,
// or if desc is only needed temporarily.
//
// The function takes the following parameters:
//
//   - variations: string representing the variations.
func (desc *FontDescription) SetVariationsStatic(variations string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(variations)))
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_font_description_set_variations_static(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(variations)
}

// SetWeight sets the weight field of a font description.
//
// The weight field specifies how bold or light the font should be. In addition
// to the values of the pango.Weight enumeration, other intermediate numeric
// values are possible.
//
// The function takes the following parameters:
//
//   - weight for the font description.
func (desc *FontDescription) SetWeight(weight Weight) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoWeight           // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.PangoWeight(weight)

	C.pango_font_description_set_weight(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(weight)
}

// ToFilename creates a filename representation of a font description.
//
// The filename is identical to the result from calling
// pango.FontDescription.ToString(), but with underscores instead of characters
// that are untypical in filenames, and in lower case only.
//
// The function returns the following values:
//
//   - utf8 (optional): new string that must be freed with g_free().
func (desc *FontDescription) ToFilename() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_to_filename(_arg0)
	runtime.KeepAlive(desc)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// String creates a string representation of a font description.
//
// See pango.FontDescription().FromString for a description of the format of
// the string representation. The family list in the string description will
// only have a terminating comma if the last word of the list is a valid style
// option.
//
// The function returns the following values:
//
//   - utf8: new string that must be freed with g_free().
func (desc *FontDescription) String() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = C.pango_font_description_to_string(_arg0)
	runtime.KeepAlive(desc)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UnsetFields unsets some of the fields in a PangoFontDescription.
//
// The unset fields will get back to their default values.
//
// The function takes the following parameters:
//
//   - toUnset: bitmask of fields in the desc to unset.
func (desc *FontDescription) UnsetFields(toUnset FontMask) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoFontMask         // out

	_arg0 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	_arg1 = C.PangoFontMask(toUnset)

	C.pango_font_description_unset_fields(_arg0, _arg1)
	runtime.KeepAlive(desc)
	runtime.KeepAlive(toUnset)
}

// FontDescriptionFromString creates a new font description from a string
// representation.
//
// The string must have the form
//
//	"\[FAMILY-LIST] \[STYLE-OPTIONS] \[SIZE] \[VARIATIONS]",
//
// where FAMILY-LIST is a comma-separated list of families optionally terminated
// by a comma, STYLE_OPTIONS is a whitespace-separated list of words where each
// word describes one of style, variant, weight, stretch, or gravity, and SIZE
// is a decimal number (size in points) or optionally followed by the unit
// modifier "px" for absolute size. VARIATIONS is a comma-separated list of font
// variation specifications of the form "\axis=value" (the = sign is optional).
//
// The following words are understood as styles: "Normal", "Roman", "Oblique",
// "Italic".
//
// The following words are understood as variants: "Small-Caps",
// "All-Small-Caps", "Petite-Caps", "All-Petite-Caps", "Unicase", "Title-Caps".
//
// The following words are understood as weights: "Thin", "Ultra-Light",
// "Extra-Light", "Light", "Semi-Light", "Demi-Light", "Book", "Regular",
// "Medium", "Semi-Bold", "Demi-Bold", "Bold", "Ultra-Bold", "Extra-Bold",
// "Heavy", "Black", "Ultra-Black", "Extra-Black".
//
// The following words are understood as stretch values: "Ultra-Condensed",
// "Extra-Condensed", "Condensed", "Semi-Condensed", "Semi-Expanded",
// "Expanded", "Extra-Expanded", "Ultra-Expanded".
//
// The following words are understood as gravity values: "Not-Rotated", "South",
// "Upside-Down", "North", "Rotated-Left", "East", "Rotated-Right", "West".
//
// Any one of the options may be absent. If FAMILY-LIST is absent, then the
// family_name field of the resulting font description will be initialized
// to NULL. If STYLE-OPTIONS is missing, then all style options will be set
// to the default values. If SIZE is missing, the size in the resulting font
// description will be set to 0.
//
// A typical example:
//
//	"Cantarell Italic Light 15 \wght=200".
//
// The function takes the following parameters:
//
//   - str: string representation of a font description.
//
// The function returns the following values:
//
//   - fontDescription: new PangoFontDescription.
func FontDescriptionFromString(str string) *FontDescription {
	var _arg1 *C.char                 // out
	var _cret *C.PangoFontDescription // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_font_description_from_string(_arg1)
	runtime.KeepAlive(str)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
		},
	)

	return _fontDescription
}

// FontFaceClass: instance of this type is always passed by reference.
type FontFaceClass struct {
	*fontFaceClass
}

// fontFaceClass is the struct that's finalized.
type fontFaceClass struct {
	native *C.PangoFontFaceClass
}

// FontFamilyClass: instance of this type is always passed by reference.
type FontFamilyClass struct {
	*fontFamilyClass
}

// fontFamilyClass is the struct that's finalized.
type fontFamilyClass struct {
	native *C.PangoFontFamilyClass
}

// FontMapClass: PangoFontMapClass structure holds the virtual functions for a
// particular PangoFontMap implementation.
//
// An instance of this type is always passed by reference.
type FontMapClass struct {
	*fontMapClass
}

// fontMapClass is the struct that's finalized.
type fontMapClass struct {
	native *C.PangoFontMapClass
}

// ShapeEngineType: type of rendering-system-dependent engines that can handle
// fonts of this fonts loaded with this fontmap.
func (f *FontMapClass) ShapeEngineType() string {
	valptr := &f.native.shape_engine_type
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// FontMetrics: PangoFontMetrics structure holds the overall metric information
// for a font.
//
// The information in a PangoFontMetrics structure may be restricted to a
// script. The fields of this structure are private to implementations of a font
// backend. See the documentation of the corresponding getters for documentation
// of their meaning.
//
// For an overview of the most important metrics, see:
//
// <picture> <source srcset="fontmetrics-dark.png" media="(prefers-color-scheme:
// dark)"> <img alt="Font metrics" src="fontmetrics-light.png"> </picture>
//
// An instance of this type is always passed by reference.
type FontMetrics struct {
	*fontMetrics
}

// fontMetrics is the struct that's finalized.
type fontMetrics struct {
	native *C.PangoFontMetrics
}

func marshalFontMetrics(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FontMetrics{&fontMetrics{(*C.PangoFontMetrics)(b)}}, nil
}

// ApproximateCharWidth gets the approximate character width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual characters in text will be wider and
// narrower than this.
//
// The function returns the following values:
//
//   - gint: character width, in Pango units.
func (metrics *FontMetrics) ApproximateCharWidth() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_approximate_char_width(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ApproximateDigitWidth gets the approximate digit width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual digits in text can be wider or narrower
// than this, though this value is generally somewhat more accurate than the
// result of pango_font_metrics_get_approximate_char_width() for digits.
//
// The function returns the following values:
//
//   - gint: digit width, in Pango units.
func (metrics *FontMetrics) ApproximateDigitWidth() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_approximate_digit_width(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Ascent gets the ascent from a font metrics structure.
//
// The ascent is the distance from the baseline to the logical top of a line of
// text. (The logical top may be above or below the top of the actual drawn ink.
// It is necessary to lay out the text to figure where the ink will be.).
//
// The function returns the following values:
//
//   - gint: ascent, in Pango units.
func (metrics *FontMetrics) Ascent() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_ascent(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Descent gets the descent from a font metrics structure.
//
// The descent is the distance from the baseline to the logical bottom of a line
// of text. (The logical bottom may be above or below the bottom of the actual
// drawn ink. It is necessary to lay out the text to figure where the ink will
// be.).
//
// The function returns the following values:
//
//   - gint: descent, in Pango units.
func (metrics *FontMetrics) Descent() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_descent(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Height gets the line height from a font metrics structure.
//
// The line height is the recommended distance between successive baselines in
// wrapped text using this font.
//
// If the line height is not available, 0 is returned.
//
// The function returns the following values:
//
//   - gint: height, in Pango units.
func (metrics *FontMetrics) Height() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_height(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StrikethroughPosition gets the suggested position to draw the strikethrough.
//
// The value returned is the distance *above* the baseline of the top of the
// strikethrough.
//
// The function returns the following values:
//
//   - gint: suggested strikethrough position, in Pango units.
func (metrics *FontMetrics) StrikethroughPosition() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_strikethrough_position(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StrikethroughThickness gets the suggested thickness to draw for the
// strikethrough.
//
// The function returns the following values:
//
//   - gint: suggested strikethrough thickness, in Pango units.
func (metrics *FontMetrics) StrikethroughThickness() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_strikethrough_thickness(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnderlinePosition gets the suggested position to draw the underline.
//
// The value returned is the distance *above* the baseline of the top of the
// underline. Since most fonts have underline positions beneath the baseline,
// this value is typically negative.
//
// The function returns the following values:
//
//   - gint: suggested underline position, in Pango units.
func (metrics *FontMetrics) UnderlinePosition() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_underline_position(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnderlineThickness gets the suggested thickness to draw for the underline.
//
// The function returns the following values:
//
//   - gint: suggested underline thickness, in Pango units.
func (metrics *FontMetrics) UnderlineThickness() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = C.pango_font_metrics_get_underline_thickness(_arg0)
	runtime.KeepAlive(metrics)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// FontsetClass: PangoFontsetClass structure holds the virtual functions for a
// particular PangoFontset implementation.
//
// An instance of this type is always passed by reference.
type FontsetClass struct {
	*fontsetClass
}

// fontsetClass is the struct that's finalized.
type fontsetClass struct {
	native *C.PangoFontsetClass
}

// GlyphGeometry: PangoGlyphGeometry structure contains width and positioning
// information for a single glyph.
//
// Note that width is not guaranteed to be the same as the glyph extents.
// Kerning and other positioning applied during shaping will affect both the
// width and the x_offset for the glyphs in the glyph string that results from
// shaping.
//
// The information in this struct is intended for rendering the glyphs,
// as follows:
//
// 1. Assume the current point is (x, y) 2. Render the current glyph at (x +
// x_offset, y + y_offset), 3. Advance the current point to (x + width, y) 4.
// Render the next glyph
//
// An instance of this type is always passed by reference.
type GlyphGeometry struct {
	*glyphGeometry
}

// glyphGeometry is the struct that's finalized.
type glyphGeometry struct {
	native *C.PangoGlyphGeometry
}

// Width: logical width to use for the the character.
func (g *GlyphGeometry) Width() GlyphUnit {
	valptr := &g.native.width
	var _v GlyphUnit // out
	_v = GlyphUnit(*valptr)
	return _v
}

// XOffset: horizontal offset from nominal character position.
func (g *GlyphGeometry) XOffset() GlyphUnit {
	valptr := &g.native.x_offset
	var _v GlyphUnit // out
	_v = GlyphUnit(*valptr)
	return _v
}

// YOffset: vertical offset from nominal character position.
func (g *GlyphGeometry) YOffset() GlyphUnit {
	valptr := &g.native.y_offset
	var _v GlyphUnit // out
	_v = GlyphUnit(*valptr)
	return _v
}

// GlyphInfo: PangoGlyphInfo structure represents a single glyph with
// positioning information and visual attributes.
//
// An instance of this type is always passed by reference.
type GlyphInfo struct {
	*glyphInfo
}

// glyphInfo is the struct that's finalized.
type glyphInfo struct {
	native *C.PangoGlyphInfo
}

// Glyph: glyph itself.
func (g *GlyphInfo) Glyph() Glyph {
	valptr := &g.native.glyph
	var _v Glyph // out
	_v = Glyph(*valptr)
	return _v
}

// Geometry: positional information about the glyph.
func (g *GlyphInfo) Geometry() *GlyphGeometry {
	valptr := &g.native.geometry
	var _v *GlyphGeometry // out
	_v = (*GlyphGeometry)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Attr: visual attributes of the glyph.
func (g *GlyphInfo) Attr() *GlyphVisAttr {
	valptr := &g.native.attr
	var _v *GlyphVisAttr // out
	_v = (*GlyphVisAttr)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GlyphItem: PangoGlyphItem is a pair of a PangoItem and the glyphs resulting
// from shaping the items text.
//
// As an example of the usage of PangoGlyphItem, the results of shaping text
// with PangoLayout is a list of PangoLayoutLine, each of which contains a list
// of PangoGlyphItem.
//
// An instance of this type is always passed by reference.
type GlyphItem struct {
	*glyphItem
}

// glyphItem is the struct that's finalized.
type glyphItem struct {
	native *C.PangoGlyphItem
}

func marshalGlyphItem(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GlyphItem{&glyphItem{(*C.PangoGlyphItem)(b)}}, nil
}

// Item: corresponding PangoItem.
func (g *GlyphItem) Item() *Item {
	valptr := &g.native.item
	var _v *Item // out
	_v = (*Item)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Glyphs: corresponding PangoGlyphString.
func (g *GlyphItem) Glyphs() *GlyphString {
	valptr := &g.native.glyphs
	var _v *GlyphString // out
	_v = (*GlyphString)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// YOffset: shift of the baseline, relative to the baseline of the containing
// line. Positive values shift upwards.
func (g *GlyphItem) YOffset() int {
	valptr := &g.native.y_offset
	var _v int // out
	_v = int(*valptr)
	return _v
}

// StartXOffset: horizontal displacement to apply before the glyph item.
// Positive values shift right.
func (g *GlyphItem) StartXOffset() int {
	valptr := &g.native.start_x_offset
	var _v int // out
	_v = int(*valptr)
	return _v
}

// EndXOffset: horizontal displacement to apply after th glyph item. Positive
// values shift right.
func (g *GlyphItem) EndXOffset() int {
	valptr := &g.native.end_x_offset
	var _v int // out
	_v = int(*valptr)
	return _v
}

// YOffset: shift of the baseline, relative to the baseline of the containing
// line. Positive values shift upwards.
func (g *GlyphItem) SetYOffset(yOffset int) {
	valptr := &g.native.y_offset
	*valptr = C.int(yOffset)
}

// StartXOffset: horizontal displacement to apply before the glyph item.
// Positive values shift right.
func (g *GlyphItem) SetStartXOffset(startXOffset int) {
	valptr := &g.native.start_x_offset
	*valptr = C.int(startXOffset)
}

// EndXOffset: horizontal displacement to apply after th glyph item. Positive
// values shift right.
func (g *GlyphItem) SetEndXOffset(endXOffset int) {
	valptr := &g.native.end_x_offset
	*valptr = C.int(endXOffset)
}

// ApplyAttrs splits a shaped item (PangoGlyphItem) into multiple items based on
// an attribute list.
//
// The idea is that if you have attributes that don't affect shaping,
// such as color or underline, to avoid affecting shaping, you filter them out
// (pango.AttrList.Filter()), apply the shaping process and then reapply them to
// the result using this function.
//
// All attributes that start or end inside a cluster are applied to
// that cluster; for instance, if half of a cluster is underlined and
// the other-half strikethrough, then the cluster will end up with both
// underline and strikethrough attributes. In these cases, it may happen that
// item->extra_attrs for some of the result items can have multiple attributes
// of the same type.
//
// This function takes ownership of glyph_item; it will be reused as one of the
// elements in the list.
//
// The function takes the following parameters:
//
//   - text that list applies to.
//   - list: PangoAttrList.
//
// The function returns the following values:
//
//   - sList: a list of glyph items resulting from splitting glyph_item. Free
//     the elements using pango.GlyphItem.Free(), the list using g_slist_free().
func (glyphItem *GlyphItem) ApplyAttrs(text string, list *AttrList) []*GlyphItem {
	var _arg0 *C.PangoGlyphItem // out
	var _arg1 *C.char           // out
	var _arg2 *C.PangoAttrList  // out
	var _cret *C.GSList         // in

	_arg0 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.pango_glyph_item_apply_attrs(_arg0, _arg1, _arg2)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(text)
	runtime.KeepAlive(list)

	var _sList []*GlyphItem // out

	_sList = make([]*GlyphItem, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.PangoGlyphItem)(v)
		var dst *GlyphItem // out
		dst = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_glyph_item_free((*C.PangoGlyphItem)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// Copy: make a deep copy of an existing PangoGlyphItem structure.
//
// The function returns the following values:
//
//   - glyphItem (optional): newly allocated PangoGlyphItem.
func (orig *GlyphItem) Copy() *GlyphItem {
	var _arg0 *C.PangoGlyphItem // out
	var _cret *C.PangoGlyphItem // in

	if orig != nil {
		_arg0 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(orig)))
	}

	_cret = C.pango_glyph_item_copy(_arg0)
	runtime.KeepAlive(orig)

	var _glyphItem *GlyphItem // out

	if _cret != nil {
		_glyphItem = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glyphItem)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_glyph_item_free((*C.PangoGlyphItem)(intern.C))
			},
		)
	}

	return _glyphItem
}

// Split modifies orig to cover only the text after split_index, and returns a
// new item that covers the text before split_index that used to be in orig.
//
// You can think of split_index as the length of the returned item. split_index
// may not be 0, and it may not be greater than or equal to the length of orig
// (that is, there must be at least one byte assigned to each item, you can't
// create a zero-length item).
//
// This function is similar in function to pango_item_split() (and uses it
// internally.).
//
// The function takes the following parameters:
//
//   - text to which positions in orig apply.
//   - splitIndex: byte index of position to split item, relative to the start
//     of the item.
//
// The function returns the following values:
//
//   - glyphItem (optional): newly allocated item representing text before
//     split_index, which should be freed with pango_glyph_item_free().
func (orig *GlyphItem) Split(text string, splitIndex int) *GlyphItem {
	var _arg0 *C.PangoGlyphItem // out
	var _arg1 *C.char           // out
	var _arg2 C.int             // out
	var _cret *C.PangoGlyphItem // in

	_arg0 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(orig)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(splitIndex)

	_cret = C.pango_glyph_item_split(_arg0, _arg1, _arg2)
	runtime.KeepAlive(orig)
	runtime.KeepAlive(text)
	runtime.KeepAlive(splitIndex)

	var _glyphItem *GlyphItem // out

	if _cret != nil {
		_glyphItem = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glyphItem)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_glyph_item_free((*C.PangoGlyphItem)(intern.C))
			},
		)
	}

	return _glyphItem
}

// GlyphItemIter: PangoGlyphItemIter is an iterator over the clusters in a
// PangoGlyphItem.
//
// The *forward direction* of the iterator is the logical direction of text.
// That is, with increasing start_index and start_char values. If glyph_item
// is right-to-left (that is, if glyph_item->item->analysis.level is odd),
// then start_glyph decreases as the iterator moves forward. Moreover,
// in right-to-left cases, start_glyph is greater than end_glyph.
//
// An iterator should be initialized using either
// pango_glyph_item_iter_init_start() or pango_glyph_item_iter_init_end(),
// for forward and backward iteration respectively, and walked over
// using any desired mixture of pango_glyph_item_iter_next_cluster() and
// pango_glyph_item_iter_prev_cluster().
//
// A common idiom for doing a forward iteration over the clusters is:
//
//	PangoGlyphItemIter cluster_iter;
//	gboolean have_cluster;
//
//	for (have_cluster = pango_glyph_item_iter_init_start (&cluster_iter,
//	                                                      glyph_item, text);
//	     have_cluster;
//	     have_cluster = pango_glyph_item_iter_next_cluster (&cluster_iter))
//	{
//	  ...
//	}
//
// Note that text is the start of the text for layout, which is then indexed by
// glyph_item->item->offset to get to the text of glyph_item. The start_index
// and end_index values can directly index into text. The start_glyph,
// end_glyph, start_char, and end_char values however are zero-based for the
// glyph_item. For each cluster, the item pointed at by the start variables is
// included in the cluster while the one pointed at by end variables is not.
//
// None of the members of a PangoGlyphItemIter should be modified manually.
//
// An instance of this type is always passed by reference.
type GlyphItemIter struct {
	*glyphItemIter
}

// glyphItemIter is the struct that's finalized.
type glyphItemIter struct {
	native *C.PangoGlyphItemIter
}

func marshalGlyphItemIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GlyphItemIter{&glyphItemIter{(*C.PangoGlyphItemIter)(b)}}, nil
}

func (g *GlyphItemIter) GlyphItem() *GlyphItem {
	valptr := &g.native.glyph_item
	var _v *GlyphItem // out
	_v = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

func (g *GlyphItemIter) Text() string {
	valptr := &g.native.text
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

func (g *GlyphItemIter) StartGlyph() int {
	valptr := &g.native.start_glyph
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) StartIndex() int {
	valptr := &g.native.start_index
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) StartChar() int {
	valptr := &g.native.start_char
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) EndGlyph() int {
	valptr := &g.native.end_glyph
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) EndIndex() int {
	valptr := &g.native.end_index
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) EndChar() int {
	valptr := &g.native.end_char
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) SetStartGlyph(startGlyph int) {
	valptr := &g.native.start_glyph
	*valptr = C.int(startGlyph)
}

func (g *GlyphItemIter) SetStartIndex(startIndex int) {
	valptr := &g.native.start_index
	*valptr = C.int(startIndex)
}

func (g *GlyphItemIter) SetStartChar(startChar int) {
	valptr := &g.native.start_char
	*valptr = C.int(startChar)
}

func (g *GlyphItemIter) SetEndGlyph(endGlyph int) {
	valptr := &g.native.end_glyph
	*valptr = C.int(endGlyph)
}

func (g *GlyphItemIter) SetEndIndex(endIndex int) {
	valptr := &g.native.end_index
	*valptr = C.int(endIndex)
}

func (g *GlyphItemIter) SetEndChar(endChar int) {
	valptr := &g.native.end_char
	*valptr = C.int(endChar)
}

// Copy: make a shallow copy of an existing PangoGlyphItemIter structure.
//
// The function returns the following values:
//
//   - glyphItemIter (optional): newly allocated PangoGlyphItemIter.
func (orig *GlyphItemIter) Copy() *GlyphItemIter {
	var _arg0 *C.PangoGlyphItemIter // out
	var _cret *C.PangoGlyphItemIter // in

	if orig != nil {
		_arg0 = (*C.PangoGlyphItemIter)(gextras.StructNative(unsafe.Pointer(orig)))
	}

	_cret = C.pango_glyph_item_iter_copy(_arg0)
	runtime.KeepAlive(orig)

	var _glyphItemIter *GlyphItemIter // out

	if _cret != nil {
		_glyphItemIter = (*GlyphItemIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glyphItemIter)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_glyph_item_iter_free((*C.PangoGlyphItemIter)(intern.C))
			},
		)
	}

	return _glyphItemIter
}

// InitEnd initializes a PangoGlyphItemIter structure to point to the last
// cluster in a glyph item.
//
// See PangoGlyphItemIter for details of cluster orders.
//
// The function takes the following parameters:
//
//   - glyphItem: glyph item to iterate over.
//   - text corresponding to the glyph item.
//
// The function returns the following values:
//
//   - ok: FALSE if there are no clusters in the glyph item.
func (iter *GlyphItemIter) InitEnd(glyphItem *GlyphItem, text string) bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _arg1 *C.PangoGlyphItem     // out
	var _arg2 *C.char               // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.pango_glyph_item_iter_init_end(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(text)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InitStart initializes a PangoGlyphItemIter structure to point to the first
// cluster in a glyph item.
//
// See PangoGlyphItemIter for details of cluster orders.
//
// The function takes the following parameters:
//
//   - glyphItem: glyph item to iterate over.
//   - text corresponding to the glyph item.
//
// The function returns the following values:
//
//   - ok: FALSE if there are no clusters in the glyph item.
func (iter *GlyphItemIter) InitStart(glyphItem *GlyphItem, text string) bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _arg1 *C.PangoGlyphItem     // out
	var _arg2 *C.char               // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.pango_glyph_item_iter_init_start(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(text)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextCluster advances the iterator to the next cluster in the glyph item.
//
// See PangoGlyphItemIter for details of cluster orders.
//
// The function returns the following values:
//
//   - ok: TRUE if the iterator was advanced, FALSE if we were already on the
//     last cluster.
func (iter *GlyphItemIter) NextCluster() bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_glyph_item_iter_next_cluster(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrevCluster moves the iterator to the preceding cluster in the glyph item.
// See PangoGlyphItemIter for details of cluster orders.
//
// The function returns the following values:
//
//   - ok: TRUE if the iterator was moved, FALSE if we were already on the first
//     cluster.
func (iter *GlyphItemIter) PrevCluster() bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_glyph_item_iter_prev_cluster(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GlyphString: PangoGlyphString is used to store strings of glyphs with
// geometry and visual attribute information.
//
// The storage for the glyph information is owned by the structure which
// simplifies memory management.
//
// An instance of this type is always passed by reference.
type GlyphString struct {
	*glyphString
}

// glyphString is the struct that's finalized.
type glyphString struct {
	native *C.PangoGlyphString
}

func marshalGlyphString(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GlyphString{&glyphString{(*C.PangoGlyphString)(b)}}, nil
}

// NewGlyphString constructs a struct GlyphString.
func NewGlyphString() *GlyphString {
	var _cret *C.PangoGlyphString // in

	_cret = C.pango_glyph_string_new()

	var _glyphString *GlyphString // out

	_glyphString = (*GlyphString)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glyphString)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_glyph_string_free((*C.PangoGlyphString)(intern.C))
		},
	)

	return _glyphString
}

// Copy a glyph string and associated storage.
//
// The function returns the following values:
//
//   - glyphString (optional): newly allocated PangoGlyphString.
func (str *GlyphString) Copy() *GlyphString {
	var _arg0 *C.PangoGlyphString // out
	var _cret *C.PangoGlyphString // in

	if str != nil {
		_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(str)))
	}

	_cret = C.pango_glyph_string_copy(_arg0)
	runtime.KeepAlive(str)

	var _glyphString *GlyphString // out

	if _cret != nil {
		_glyphString = (*GlyphString)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glyphString)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_glyph_string_free((*C.PangoGlyphString)(intern.C))
			},
		)
	}

	return _glyphString
}

// Extents: compute the logical and ink extents of a glyph string.
//
// See the documentation for pango.Font.GetGlyphExtents() for details about the
// interpretation of the rectangles.
//
// Examples of logical (red) and ink (green) rects:
//
// ! (rects1.png) ! (rects2.png).
//
// The function takes the following parameters:
//
//   - font: PangoFont.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the glyph
//     string as drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the glyph string.
func (glyphs *GlyphString) Extents(font Fonter) (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.PangoFont        // out
	var _arg2 C.PangoRectangle    // in
	var _arg3 C.PangoRectangle    // in

	_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	C.pango_glyph_string_extents(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(font)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _inkRect, _logicalRect
}

// ExtentsRange computes the extents of a sub-portion of a glyph string.
//
// The extents are relative to the start of the glyph string range (the origin
// of their coordinate system is at the start of the range, not at the start of
// the entire glyph string).
//
// The function takes the following parameters:
//
//   - start index.
//   - end index (the range is the set of bytes with indices such that start <=
//     index < end).
//   - font: PangoFont.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the glyph
//     string range as drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the glyph string range.
func (glyphs *GlyphString) ExtentsRange(start int, end int, font Fonter) (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.int               // out
	var _arg2 C.int               // out
	var _arg3 *C.PangoFont        // out
	var _arg4 C.PangoRectangle    // in
	var _arg5 C.PangoRectangle    // in

	_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg1 = C.int(start)
	_arg2 = C.int(end)
	_arg3 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	C.pango_glyph_string_extents_range(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(font)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg5))))

	return _inkRect, _logicalRect
}

// Width computes the logical width of the glyph string.
//
// This can also be computed using pango.GlyphString.Extents(). However,
// since this only computes the width, it's much faster. This is in fact only a
// convenience function that computes the sum of geometry.width for each glyph
// in the glyphs.
//
// The function returns the following values:
//
//   - gint: logical width of the glyph string.
func (glyphs *GlyphString) Width() int {
	var _arg0 *C.PangoGlyphString // out
	var _cret C.int               // in

	_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))

	_cret = C.pango_glyph_string_get_width(_arg0)
	runtime.KeepAlive(glyphs)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IndexToX converts from character position to x position.
//
// The X position is measured from the left edge of the run. Character positions
// are obtained using font metrics for ligatures where available, and computed
// by dividing up each cluster into equal portions, otherwise.
//
// <picture> <source srcset="glyphstring-positions-dark.png"
// media="(prefers-color-scheme: dark)"> <img alt="Glyph positions"
// src="glyphstring-positions-light.png"> </picture>.
//
// The function takes the following parameters:
//
//   - text for the run.
//   - analysis information return from itemize.
//   - index_: byte index within text.
//   - trailing: whether we should compute the result for the beginning (FALSE)
//     or end (TRUE) of the character.
//
// The function returns the following values:
//
//   - xPos: location to store result.
func (glyphs *GlyphString) IndexToX(text string, analysis *Analysis, index_ int, trailing bool) int {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.char             // out
	var _arg2 C.int
	var _arg3 *C.PangoAnalysis // out
	var _arg4 C.int            // out
	var _arg5 C.gboolean       // out
	var _arg6 C.int            // in

	_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	_arg4 = C.int(index_)
	if trailing {
		_arg5 = C.TRUE
	}

	C.pango_glyph_string_index_to_x(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(text)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(trailing)

	var _xPos int // out

	_xPos = int(_arg6)

	return _xPos
}

// IndexToXFull converts from character position to x position.
//
// This variant of pango.GlyphString.IndexToX() additionally accepts a
// PangoLogAttr array. The grapheme boundary information in it can be used to
// disambiguate positioning inside some complex clusters.
//
// The function takes the following parameters:
//
//   - text for the run.
//   - analysis information return from itemize.
//   - attrs (optional): PangoLogAttr array for text.
//   - index_: byte index within text.
//   - trailing: whether we should compute the result for the beginning (FALSE)
//     or end (TRUE) of the character.
//
// The function returns the following values:
//
//   - xPos: location to store result.
func (glyphs *GlyphString) IndexToXFull(text string, analysis *Analysis, attrs *LogAttr, index_ int, trailing bool) int {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.char             // out
	var _arg2 C.int
	var _arg3 *C.PangoAnalysis // out
	var _arg4 *C.PangoLogAttr  // out
	var _arg5 C.int            // out
	var _arg6 C.gboolean       // out
	var _arg7 C.int            // in

	_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	if attrs != nil {
		_arg4 = (*C.PangoLogAttr)(gextras.StructNative(unsafe.Pointer(attrs)))
	}
	_arg5 = C.int(index_)
	if trailing {
		_arg6 = C.TRUE
	}

	C.pango_glyph_string_index_to_x_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_arg7)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(text)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(attrs)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(trailing)

	var _xPos int // out

	_xPos = int(_arg7)

	return _xPos
}

// SetSize: resize a glyph string to the given length.
//
// The function takes the following parameters:
//
//   - newLen: new length of the string.
func (str *GlyphString) SetSize(newLen int) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.int               // out

	_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(str)))
	_arg1 = C.int(newLen)

	C.pango_glyph_string_set_size(_arg0, _arg1)
	runtime.KeepAlive(str)
	runtime.KeepAlive(newLen)
}

// XToIndex: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
//
// The function takes the following parameters:
//
//   - text for the run.
//   - analysis information return from itemize.
//   - xPos: x offset (in Pango units).
//
// The function returns the following values:
//
//   - index_: location to store calculated byte index within text.
//   - trailing: location to store a boolean indicating whether the user clicked
//     on the leading or trailing edge of the character.
func (glyphs *GlyphString) XToIndex(text string, analysis *Analysis, xPos int) (index_ int, trailing int) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.char             // out
	var _arg2 C.int
	var _arg3 *C.PangoAnalysis // out
	var _arg4 C.int            // out
	var _arg5 C.int            // in
	var _arg6 C.int            // in

	_arg0 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.PangoAnalysis)(gextras.StructNative(unsafe.Pointer(analysis)))
	_arg4 = C.int(xPos)

	C.pango_glyph_string_x_to_index(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(text)
	runtime.KeepAlive(analysis)
	runtime.KeepAlive(xPos)

	var _index_ int   // out
	var _trailing int // out

	_index_ = int(_arg5)
	_trailing = int(_arg6)

	return _index_, _trailing
}

// GlyphVisAttr: PangoGlyphVisAttr structure communicates information between
// the shaping and rendering phases.
//
// Currently, it contains cluster start and color information. More attributes
// may be added in the future.
//
// Clusters are stored in visual order, within the cluster, glyphs are always
// ordered in logical order, since visual order is meaningless; that is,
// in Arabic text, accent glyphs follow the glyphs for the base character.
//
// An instance of this type is always passed by reference.
type GlyphVisAttr struct {
	*glyphVisAttr
}

// glyphVisAttr is the struct that's finalized.
type glyphVisAttr struct {
	native *C.PangoGlyphVisAttr
}

// Item: PangoItem structure stores information about a segment of text.
//
// You typically obtain PangoItems by itemizing a piece of text with itemize.
//
// An instance of this type is always passed by reference.
type Item struct {
	*item
}

// item is the struct that's finalized.
type item struct {
	native *C.PangoItem
}

func marshalItem(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Item{&item{(*C.PangoItem)(b)}}, nil
}

// NewItem constructs a struct Item.
func NewItem() *Item {
	var _cret *C.PangoItem // in

	_cret = C.pango_item_new()

	var _item *Item // out

	_item = (*Item)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_item)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_item_free((*C.PangoItem)(intern.C))
		},
	)

	return _item
}

// Offset: byte offset of the start of this item in text.
func (i *Item) Offset() int {
	valptr := &i.native.offset
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Length: length of this item in bytes.
func (i *Item) Length() int {
	valptr := &i.native.length
	var _v int // out
	_v = int(*valptr)
	return _v
}

// NumChars: number of Unicode characters in the item.
func (i *Item) NumChars() int {
	valptr := &i.native.num_chars
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Analysis analysis results for the item.
func (i *Item) Analysis() *Analysis {
	valptr := &i.native.analysis
	var _v *Analysis // out
	_v = (*Analysis)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Offset: byte offset of the start of this item in text.
func (i *Item) SetOffset(offset int) {
	valptr := &i.native.offset
	*valptr = C.int(offset)
}

// Length: length of this item in bytes.
func (i *Item) SetLength(length int) {
	valptr := &i.native.length
	*valptr = C.int(length)
}

// NumChars: number of Unicode characters in the item.
func (i *Item) SetNumChars(numChars int) {
	valptr := &i.native.num_chars
	*valptr = C.int(numChars)
}

// ApplyAttrs: add attributes to a PangoItem.
//
// The idea is that you have attributes that don't affect itemization,
// such as font features, so you filter them out using pango.AttrList.Filter(),
// itemize your text, then reapply the attributes to the resulting items using
// this function.
//
// The iter should be positioned before the range of the item, and will be
// advanced past it. This function is meant to be called in a loop over the
// items resulting from itemization, while passing the iter to each call.
//
// The function takes the following parameters:
//
//   - iter: PangoAttrIterator.
func (item *Item) ApplyAttrs(iter *AttrIterator) {
	var _arg0 *C.PangoItem         // out
	var _arg1 *C.PangoAttrIterator // out

	_arg0 = (*C.PangoItem)(gextras.StructNative(unsafe.Pointer(item)))
	_arg1 = (*C.PangoAttrIterator)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_item_apply_attrs(_arg0, _arg1)
	runtime.KeepAlive(item)
	runtime.KeepAlive(iter)
}

// Copy an existing PangoItem structure.
//
// The function returns the following values:
//
//   - ret (optional): newly allocated PangoItem.
func (item *Item) Copy() *Item {
	var _arg0 *C.PangoItem // out
	var _cret *C.PangoItem // in

	if item != nil {
		_arg0 = (*C.PangoItem)(gextras.StructNative(unsafe.Pointer(item)))
	}

	_cret = C.pango_item_copy(_arg0)
	runtime.KeepAlive(item)

	var _ret *Item // out

	if _cret != nil {
		_ret = (*Item)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_item_free((*C.PangoItem)(intern.C))
			},
		)
	}

	return _ret
}

// Split modifies orig to cover only the text after split_index, and returns a
// new item that covers the text before split_index that used to be in orig.
//
// You can think of split_index as the length of the returned item. split_index
// may not be 0, and it may not be greater than or equal to the length of orig
// (that is, there must be at least one byte assigned to each item, you can't
// create a zero-length item). split_offset is the length of the first item in
// chars, and must be provided because the text used to generate the item isn't
// available, so pango_item_split() can't count the char length of the split
// items itself.
//
// The function takes the following parameters:
//
//   - splitIndex: byte index of position to split item, relative to the start
//     of the item.
//   - splitOffset: number of chars between start of orig and split_index.
//
// The function returns the following values:
//
//   - item: new item representing text before split_index, which should be
//     freed with pango.Item.Free().
func (orig *Item) Split(splitIndex int, splitOffset int) *Item {
	var _arg0 *C.PangoItem // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _cret *C.PangoItem // in

	_arg0 = (*C.PangoItem)(gextras.StructNative(unsafe.Pointer(orig)))
	_arg1 = C.int(splitIndex)
	_arg2 = C.int(splitOffset)

	_cret = C.pango_item_split(_arg0, _arg1, _arg2)
	runtime.KeepAlive(orig)
	runtime.KeepAlive(splitIndex)
	runtime.KeepAlive(splitOffset)

	var _item *Item // out

	_item = (*Item)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_item)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_item_free((*C.PangoItem)(intern.C))
		},
	)

	return _item
}

// Language: PangoLanguage structure is used to represent a language.
//
// PangoLanguage pointers can be efficiently copied and compared with each
// other.
//
// An instance of this type is always passed by reference.
type Language struct {
	*language
}

// language is the struct that's finalized.
type language struct {
	native *C.PangoLanguage
}

func marshalLanguage(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Language{&language{(*C.PangoLanguage)(b)}}, nil
}

// SampleString: get a string that is representative of the characters needed to
// render a particular language.
//
// The sample text may be a pangram, but is not necessarily. It is chosen to
// be demonstrative of normal text in the language, as well as exposing font
// feature requirements unique to the language. It is suitable for use as sample
// text in a font selection dialog.
//
// If language is NULL, the default language as found by
// pango.Language().GetDefault is used.
//
// If Pango does not have a sample string for language, the classic "The quick
// brown fox..." is returned. This can be detected by comparing the returned
// pointer value to that returned for (non-existent) language code "xx".
// That is, compare to:
//
//	pango_language_get_sample_string (pango_language_from_string ("xx")).
//
// The function returns the following values:
//
//   - utf8: sample string.
func (language *Language) SampleString() string {
	var _arg0 *C.PangoLanguage // out
	var _cret *C.char          // in

	if language != nil {
		_arg0 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}

	_cret = C.pango_language_get_sample_string(_arg0)
	runtime.KeepAlive(language)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Scripts determines the scripts used to to write language.
//
// If nothing is known about the language tag language, or if language is NULL,
// then NULL is returned. The list of scripts returned starts with the script
// that the language uses most and continues to the one it uses least.
//
// The value num_script points at will be set to the number of scripts in the
// returned array (or zero if NULL is returned).
//
// Most languages use only one script for writing, but there are some that
// use two (Latin and Cyrillic for example), and a few use three (Japanese for
// example). Applications should not make any assumptions on the maximum number
// of scripts returned though, except that it is positive if the return value is
// not NULL, and it is a small number.
//
// The pango.Language.IncludesScript() function uses this function internally.
//
// Note: while the return value is declared as PangoScript, the returned values
// are from the GUnicodeScript enumeration, which may have more values. Callers
// need to handle unknown values.
//
// The function returns the following values:
//
//   - scripts (optional): An array of PangoScript values, with the number of
//     entries in the array stored in num_scripts, or NULL if Pango does not
//     have any information about this particular language tag (also the case if
//     language is NULL).
func (language *Language) Scripts() []Script {
	var _arg0 *C.PangoLanguage // out
	var _cret *C.PangoScript   // in
	var _arg1 C.int            // in

	if language != nil {
		_arg0 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}

	_cret = C.pango_language_get_scripts(_arg0, &_arg1)
	runtime.KeepAlive(language)

	var _scripts []Script // out

	if _cret != nil {
		_scripts = make([]Script, _arg1)
		copy(_scripts, unsafe.Slice((*Script)(unsafe.Pointer(_cret)), _arg1))
	}

	return _scripts
}

// IncludesScript determines if script is one of the scripts used to write
// language.
//
// The returned value is conservative; if nothing is known about the language
// tag language, TRUE will be returned, since, as far as Pango knows, script
// might be used to write language.
//
// This routine is used in Pango's itemization process when determining if
// a supplied language tag is relevant to a particular section of text.
// It probably is not useful for applications in most circumstances.
//
// This function uses pango.Language.GetScripts() internally.
//
// The function takes the following parameters:
//
//   - script: PangoScript.
//
// The function returns the following values:
//
//   - ok: TRUE if script is one of the scripts used to write language or if
//     nothing is known about language (including the case that language is
//     NULL), FALSE otherwise.
func (language *Language) IncludesScript(script Script) bool {
	var _arg0 *C.PangoLanguage // out
	var _arg1 C.PangoScript    // out
	var _cret C.gboolean       // in

	if language != nil {
		_arg0 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}
	_arg1 = C.PangoScript(script)

	_cret = C.pango_language_includes_script(_arg0, _arg1)
	runtime.KeepAlive(language)
	runtime.KeepAlive(script)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches checks if a language tag matches one of the elements in a list of
// language ranges.
//
// A language tag is considered to match a range in the list if the range is
// '*', the range is exactly the tag, or the range is a prefix of the tag,
// and the character after it in the tag is '-'.
//
// The function takes the following parameters:
//
//   - rangeList: list of language ranges, separated by ';', ':', ',', or space
//     characters. Each element must either be '*', or a RFC 3066 language range
//     canonicalized as by pango.Language().FromString.
//
// The function returns the following values:
//
//   - ok: TRUE if a match was found.
func (language *Language) Matches(rangeList string) bool {
	var _arg0 *C.PangoLanguage // out
	var _arg1 *C.char          // out
	var _cret C.gboolean       // in

	if language != nil {
		_arg0 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(rangeList)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_language_matches(_arg0, _arg1)
	runtime.KeepAlive(language)
	runtime.KeepAlive(rangeList)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String gets the RFC-3066 format string representing the given language tag.
//
// Returns (transfer none): a string representing the language tag.
func (language *Language) String() string {
	var _arg0 *C.PangoLanguage // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoLanguage)(gextras.StructNative(unsafe.Pointer(language)))

	_cret = C.pango_language_to_string(_arg0)
	runtime.KeepAlive(language)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// LanguageFromString: convert a language tag to a PangoLanguage.
//
// The language tag must be in a RFC-3066 format. PangoLanguage pointers can be
// efficiently copied (copy the pointer) and compared with other language tags
// (compare the pointer.)
//
// This function first canonicalizes the string by converting it to lowercase,
// mapping '_' to '-', and stripping all characters other than letters and '-'.
//
// Use pango.Language().GetDefault if you want to get the PangoLanguage for the
// current locale of the process.
//
// The function takes the following parameters:
//
//   - language (optional): string representing a language tag.
//
// The function returns the following values:
//
//   - ret (optional): PangoLanguage.
func LanguageFromString(language string) *Language {
	var _arg1 *C.char          // out
	var _cret *C.PangoLanguage // in

	if language != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(language)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.pango_language_from_string(_arg1)
	runtime.KeepAlive(language)

	var _ret *Language // out

	if _cret != nil {
		_ret = (*Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _ret
}

// LanguageGetDefault returns the PangoLanguage for the current locale of the
// process.
//
// On Unix systems, this is the return value is derived from setlocale
// (LC_CTYPE, NULL), and the user can affect this through the environment
// variables LC_ALL, LC_CTYPE or LANG (checked in that order). The locale string
// typically is in the form lang_COUNTRY, where lang is an ISO-639 language
// code, and COUNTRY is an ISO-3166 country code. For instance, sv_FI for
// Swedish as written in Finland or pt_BR for Portuguese as written in Brazil.
//
// On Windows, the C library does not use any such environment variables,
// and setting them won't affect the behavior of functions like ctime().
// The user sets the locale through the Regional Options in the Control Panel.
// The C library (in the setlocale() function) does not use country and language
// codes, but country and language names spelled out in English. However,
// this function does check the above environment variables, and does return a
// Unix-style locale string based on either said environment variables or the
// thread's current locale.
//
// Your application should call setlocale(LC_ALL, "") for the user settings to
// take effect. GTK does this in its initialization functions automatically (by
// calling gtk_set_locale()). See the setlocale() manpage for more details.
//
// Note that the default language can change over the life of an application.
//
// Also note that this function will not do the right thing if you use
// per-thread locales with uselocale(). In that case, you should just call
// pango_language_from_string() yourself.
//
// The function returns the following values:
//
//   - language: default language as a PangoLanguage.
func LanguageGetDefault() *Language {
	var _cret *C.PangoLanguage // in

	_cret = C.pango_language_get_default()

	var _language *Language // out

	_language = (*Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _language
}

// LanguageGetPreferred returns the list of languages that the user prefers.
//
// The list is specified by the PANGO_LANGUAGE or LANGUAGE environment
// variables, in order of preference. Note that this list does not necessarily
// include the language returned by pango.Language().GetDefault.
//
// When choosing language-specific resources, such as the sample text returned
// by pango.Language.GetSampleString(), you should first try the default
// language, followed by the languages returned by this function.
//
// The function returns the following values:
//
//   - languages (optional): NULL-terminated array of PangoLanguage*.
func LanguageGetPreferred() []*Language {
	var _cret **C.PangoLanguage // in

	_cret = C.pango_language_get_preferred()

	var _languages []*Language // out

	if _cret != nil {
		{
			var i int
			var z *C.PangoLanguage
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_languages = make([]*Language, i)
			for i := range src {
				_languages[i] = (*Language)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			}
		}
	}

	return _languages
}

// LayoutIter: PangoLayoutIter can be used to iterate over the visual extents of
// a PangoLayout.
//
// To obtain a PangoLayoutIter, use pango.Layout.GetIter().
//
// The PangoLayoutIter structure is opaque, and has no user-visible fields.
//
// An instance of this type is always passed by reference.
type LayoutIter struct {
	*layoutIter
}

// layoutIter is the struct that's finalized.
type layoutIter struct {
	native *C.PangoLayoutIter
}

func marshalLayoutIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &LayoutIter{&layoutIter{(*C.PangoLayoutIter)(b)}}, nil
}

// AtLastLine determines whether iter is on the last line of the layout.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is on the last line.
func (iter *LayoutIter) AtLastLine() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_at_last_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy copies a PangoLayoutIter.
//
// The function returns the following values:
//
//   - layoutIter (optional): newly allocated PangoLayoutIter.
func (iter *LayoutIter) Copy() *LayoutIter {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutIter // in

	if iter != nil {
		_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	_cret = C.pango_layout_iter_copy(_arg0)
	runtime.KeepAlive(iter)

	var _layoutIter *LayoutIter // out

	if _cret != nil {
		_layoutIter = (*LayoutIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutIter)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_iter_free((*C.PangoLayoutIter)(intern.C))
			},
		)
	}

	return _layoutIter
}

// Baseline gets the Y position of the current line's baseline, in layout
// coordinates.
//
// Layout coordinates have the origin at the top left of the entire layout.
//
// The function returns the following values:
//
//   - gint: baseline of current line.
func (iter *LayoutIter) Baseline() int {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_baseline(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CharExtents gets the extents of the current character, in layout coordinates.
//
// Layout coordinates have the origin at the top left of the entire layout.
//
// Only logical extents can sensibly be obtained for characters; ink extents
// make sense only down to the level of clusters.
//
// The function returns the following values:
//
//   - logicalRect: rectangle to fill with logical extents.
func (iter *LayoutIter) CharExtents() *Rectangle {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_char_extents(_arg0, &_arg1)
	runtime.KeepAlive(iter)

	var _logicalRect *Rectangle // out

	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _logicalRect
}

// ClusterExtents gets the extents of the current cluster, in layout
// coordinates.
//
// Layout coordinates have the origin at the top left of the entire layout.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle to fill with ink extents.
//   - logicalRect (optional): rectangle to fill with logical extents.
func (iter *LayoutIter) ClusterExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_cluster_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// Index gets the current byte index.
//
// Note that iterating forward by char moves in visual order, not logical
// order, so indexes may not be sequential. Also, the index may be equal
// to the length of the text in the layout, if on the NULL run (see
// pango.LayoutIter.GetRun()).
//
// The function returns the following values:
//
//   - gint: current byte index.
func (iter *LayoutIter) Index() int {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_index(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Layout gets the layout associated with a PangoLayoutIter.
//
// The function returns the following values:
//
//   - layout (optional) associated with iter.
func (iter *LayoutIter) Layout() *Layout {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayout     // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_layout(_arg0)
	runtime.KeepAlive(iter)

	var _layout *Layout // out

	if _cret != nil {
		_layout = wrapLayout(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _layout
}

// LayoutExtents obtains the extents of the PangoLayout being iterated over.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle to fill with ink extents.
//   - logicalRect (optional): rectangle to fill with logical extents.
func (iter *LayoutIter) LayoutExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_layout_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// Line gets the current line.
//
// Use the faster pango.LayoutIter.GetLineReadonly() if you do not plan to
// modify the contents of the line (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//   - layoutLine (optional): current line.
func (iter *LayoutIter) Line() *LayoutLine {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_line(_arg0)
	runtime.KeepAlive(iter)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// LineExtents obtains the extents of the current line.
//
// Extents are in layout coordinates (origin is the top-left corner of the
// entire PangoLayout). Thus the extents returned by this function will be
// the same width/height but not at the same x/y as the extents returned from
// pango.LayoutLine.GetExtents().
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle to fill with ink extents.
//   - logicalRect (optional): rectangle to fill with logical extents.
func (iter *LayoutIter) LineExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_line_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// LineReadonly gets the current line for read-only access.
//
// This is a faster alternative to pango.LayoutIter.GetLine(), but the user is
// not expected to modify the contents of the line (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//   - layoutLine (optional): current line, that should not be modified.
func (iter *LayoutIter) LineReadonly() *LayoutLine {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_line_readonly(_arg0)
	runtime.KeepAlive(iter)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// LineYrange divides the vertical space in the PangoLayout being iterated
// over between the lines in the layout, and returns the space belonging to the
// current line.
//
// A line's range includes the line's logical extents. plus half of the spacing
// above and below the line, if pango.Layout.SetSpacing() has been called to set
// layout spacing. The Y positions are in layout coordinates (origin at top left
// of the entire layout).
//
// Note: Since 1.44, Pango uses line heights for placing lines, and there may be
// gaps between the ranges returned by this function.
//
// The function returns the following values:
//
//   - y0 (optional): start of line.
//   - y1 (optional): end of line.
func (iter *LayoutIter) LineYrange() (y0 int, y1 int) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_line_yrange(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _y0 int // out
	var _y1 int // out

	_y0 = int(_arg1)
	_y1 = int(_arg2)

	return _y0, _y1
}

// Run gets the current run.
//
// When iterating by run, at the end of each line, there's a position with a
// NULL run, so this function can return NULL. The NULL run at the end of each
// line ensures that all lines have at least one run, even lines consisting of
// only a newline.
//
// Use the faster pango.LayoutIter.GetRunReadonly() if you do not plan to modify
// the contents of the run (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//   - layoutRun (optional): current run.
func (iter *LayoutIter) Run() *LayoutRun {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutRun  // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_run(_arg0)
	runtime.KeepAlive(iter)

	var _layoutRun *LayoutRun // out

	if _cret != nil {
		_layoutRun = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		type _ = *LayoutRun
		type _ = *GlyphItem
	}

	return _layoutRun
}

// RunBaseline gets the Y position of the current run's baseline, in layout
// coordinates.
//
// Layout coordinates have the origin at the top left of the entire layout.
//
// The run baseline can be different from the line baseline, for example due to
// superscript or subscript positioning.
func (iter *LayoutIter) RunBaseline() int {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_run_baseline(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RunExtents gets the extents of the current run in layout coordinates.
//
// Layout coordinates have the origin at the top left of the entire layout.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle to fill with ink extents.
//   - logicalRect (optional): rectangle to fill with logical extents.
func (iter *LayoutIter) RunExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_run_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// RunReadonly gets the current run for read-only access.
//
// When iterating by run, at the end of each line, there's a position with a
// NULL run, so this function can return NULL. The NULL run at the end of each
// line ensures that all lines have at least one run, even lines consisting of
// only a newline.
//
// This is a faster alternative to pango.LayoutIter.GetRun(), but the user is
// not expected to modify the contents of the run (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//   - layoutRun (optional): current run, that should not be modified.
func (iter *LayoutIter) RunReadonly() *LayoutRun {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutRun  // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_run_readonly(_arg0)
	runtime.KeepAlive(iter)

	var _layoutRun *LayoutRun // out

	if _cret != nil {
		_layoutRun = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		type _ = *LayoutRun
		type _ = *GlyphItem
	}

	return _layoutRun
}

// NextChar moves iter forward to the next character in visual order.
//
// If iter was already at the end of the layout, returns FALSE.
//
// The function returns the following values:
//
//   - ok: whether motion was possible.
func (iter *LayoutIter) NextChar() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_char(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextCluster moves iter forward to the next cluster in visual order.
//
// If iter was already at the end of the layout, returns FALSE.
//
// The function returns the following values:
//
//   - ok: whether motion was possible.
func (iter *LayoutIter) NextCluster() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_cluster(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextLine moves iter forward to the start of the next line.
//
// If iter is already on the last line, returns FALSE.
//
// The function returns the following values:
//
//   - ok: whether motion was possible.
func (iter *LayoutIter) NextLine() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextRun moves iter forward to the next run in visual order.
//
// If iter was already at the end of the layout, returns FALSE.
//
// The function returns the following values:
//
//   - ok: whether motion was possible.
func (iter *LayoutIter) NextRun() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_run(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LayoutLine: PangoLayoutLine represents one of the lines resulting from laying
// out a paragraph via PangoLayout.
//
// PangoLayoutLine structures are obtained by calling pango.Layout.GetLine()
// and are only valid until the text, attributes, or settings of the parent
// PangoLayout are modified.
//
// An instance of this type is always passed by reference.
type LayoutLine struct {
	*layoutLine
}

// layoutLine is the struct that's finalized.
type layoutLine struct {
	native *C.PangoLayoutLine
}

func marshalLayoutLine(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &LayoutLine{&layoutLine{(*C.PangoLayoutLine)(b)}}, nil
}

// Layout: layout this line belongs to, might be NULL.
func (l *LayoutLine) Layout() *Layout {
	valptr := &l.native.layout
	var _v *Layout // out
	_v = wrapLayout(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// Extents computes the logical and ink extents of a layout line.
//
// See pango.Font.GetGlyphExtents() for details about the interpretation of the
// rectangles.
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the glyph
//     string as drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the glyph string.
func (line *LayoutLine) Extents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	C.pango_layout_line_get_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(line)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// Height computes the height of the line, as the maximum of the heights of
// fonts used in this line.
//
// Note that the actual baseline-to-baseline distance between lines of text
// is influenced by other factors, such as pango.Layout.SetSpacing() and
// pango.Layout.SetLineSpacing().
//
// The function returns the following values:
//
//   - height (optional): return location for the line height.
func (line *LayoutLine) Height() int {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	C.pango_layout_line_get_height(_arg0, &_arg1)
	runtime.KeepAlive(line)

	var _height int // out

	_height = int(_arg1)

	return _height
}

// Length returns the length of the line, in bytes.
//
// The function returns the following values:
//
//   - gint: length of the line.
func (line *LayoutLine) Length() int {
	var _arg0 *C.PangoLayoutLine // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	_cret = C.pango_layout_line_get_length(_arg0)
	runtime.KeepAlive(line)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelExtents computes the logical and ink extents of layout_line in device
// units.
//
// This function just calls pango.LayoutLine.GetExtents() followed by two
// extents_to_pixels calls, rounding ink_rect and logical_rect such that the
// rounded rectangles fully contain the unrounded one (that is, passes them as
// first argument to extents_to_pixels).
//
// The function returns the following values:
//
//   - inkRect (optional): rectangle used to store the extents of the glyph
//     string as drawn.
//   - logicalRect (optional): rectangle used to store the logical extents of
//     the glyph string.
func (layoutLine *LayoutLine) PixelExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(layoutLine)))

	C.pango_layout_line_get_pixel_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layoutLine)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// ResolvedDirection returns the resolved direction of the line.
//
// The function returns the following values:
//
//   - direction: resolved direction of the line.
func (line *LayoutLine) ResolvedDirection() Direction {
	var _arg0 *C.PangoLayoutLine // out
	var _cret C.PangoDirection   // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	_cret = C.pango_layout_line_get_resolved_direction(_arg0)
	runtime.KeepAlive(line)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// StartIndex returns the start index of the line, as byte index into the text
// of the layout.
//
// The function returns the following values:
//
//   - gint: start index of the line.
func (line *LayoutLine) StartIndex() int {
	var _arg0 *C.PangoLayoutLine // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	_cret = C.pango_layout_line_get_start_index(_arg0)
	runtime.KeepAlive(line)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// XRanges gets a list of visual ranges corresponding to a given logical range.
//
// This list is not necessarily minimal - there may be consecutive ranges which
// are adjacent. The ranges will be sorted from left to right. The ranges are
// with respect to the left edge of the entire layout, not with respect to the
// line.
//
// The function takes the following parameters:
//
//   - startIndex: start byte index of the logical range. If this value is less
//     than the start index for the line, then the first range will extend all
//     the way to the leading edge of the layout. Otherwise, it will start at
//     the leading edge of the first character.
//   - endIndex: ending byte index of the logical range. If this value is
//     greater than the end index for the line, then the last range will extend
//     all the way to the trailing edge of the layout. Otherwise, it will end at
//     the trailing edge of the last character.
//
// The function returns the following values:
//
//   - ranges: location to store a pointer to an array of ranges. The array will
//     be of length 2*n_ranges, with each range starting at (*ranges)[2*n] and
//     of width (*ranges)[2*n + 1] - (*ranges)[2*n]. This array must be freed
//     with g_free(). The coordinates are relative to the layout and are in
//     Pango units.
func (line *LayoutLine) XRanges(startIndex int, endIndex int) []int {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out
	var _arg3 *C.int             // in
	var _arg4 C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))
	_arg1 = C.int(startIndex)
	_arg2 = C.int(endIndex)

	C.pango_layout_line_get_x_ranges(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(line)
	runtime.KeepAlive(startIndex)
	runtime.KeepAlive(endIndex)

	var _ranges []int // out

	defer C.free(unsafe.Pointer(_arg3))
	{
		src := unsafe.Slice((*C.int)(_arg3), _arg4)
		_ranges = make([]int, _arg4)
		for i := 0; i < int(_arg4); i++ {
			_ranges[i] = int(src[i])
		}
	}

	return _ranges
}

// IndexToX converts an index within a line to a X position.
//
// The function takes the following parameters:
//
//   - index_: byte offset of a grapheme within the layout.
//   - trailing: integer indicating the edge of the grapheme to retrieve the
//     position of. If > 0, the trailing edge of the grapheme, if 0, the leading
//     of the grapheme.
//
// The function returns the following values:
//
//   - xPos: location to store the x_offset (in Pango units).
func (line *LayoutLine) IndexToX(index_ int, trailing bool) int {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // out
	var _arg2 C.gboolean         // out
	var _arg3 C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))
	_arg1 = C.int(index_)
	if trailing {
		_arg2 = C.TRUE
	}

	C.pango_layout_line_index_to_x(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(line)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(trailing)

	var _xPos int // out

	_xPos = int(_arg3)

	return _xPos
}

// IsParagraphStart returns whether this is the first line of the paragraph.
//
// The function returns the following values:
//
//   - ok: TRUE if this is the first line.
func (line *LayoutLine) IsParagraphStart() bool {
	var _arg0 *C.PangoLayoutLine // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	_cret = C.pango_layout_line_is_paragraph_start(_arg0)
	runtime.KeepAlive(line)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XToIndex converts from x offset to the byte index of the corresponding
// character within the text of the layout.
//
// If x_pos is outside the line, index_ and trailing will point to the very
// first or very last position in the line. This determination is based on the
// resolved direction of the paragraph; for example, if the resolved direction
// is right-to-left, then an X position to the right of the line (after it)
// results in 0 being stored in index_ and trailing. An X position to the left
// of the line results in index_ pointing to the (logical) last grapheme in the
// line and trailing being set to the number of characters in that grapheme.
// The reverse is true for a left-to-right line.
//
// The function takes the following parameters:
//
//   - xPos: x offset (in Pango units) from the left edge of the line.
//
// The function returns the following values:
//
//   - index_: location to store calculated byte index for the grapheme in which
//     the user clicked.
//   - trailing: location to store an integer indicating where in the grapheme
//     the user clicked. It will either be zero, or the number of characters in
//     the grapheme. 0 represents the leading edge of the grapheme.
//   - ok: FALSE if x_pos was outside the line, TRUE if inside.
func (line *LayoutLine) XToIndex(xPos int) (index_ int, trailing int, ok bool) {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))
	_arg1 = C.int(xPos)

	_cret = C.pango_layout_line_x_to_index(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(line)
	runtime.KeepAlive(xPos)

	var _index_ int   // out
	var _trailing int // out
	var _ok bool      // out

	_index_ = int(_arg2)
	_trailing = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _index_, _trailing, _ok
}

// LogAttr: PangoLogAttr structure stores information about the attributes of a
// single character.
//
// An instance of this type is always passed by reference.
type LogAttr struct {
	*logAttr
}

// logAttr is the struct that's finalized.
type logAttr struct {
	native *C.PangoLogAttr
}

// Matrix: PangoMatrix specifies a transformation between user-space and device
// coordinates.
//
// The transformation is given by
//
//	x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;
//	y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0;
//
// An instance of this type is always passed by reference.
type Matrix struct {
	*matrix
}

// matrix is the struct that's finalized.
type matrix struct {
	native *C.PangoMatrix
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Matrix{&matrix{(*C.PangoMatrix)(b)}}, nil
}

// NewMatrix creates a new Matrix instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewMatrix(xx, xy, yx, yy, x0, y0 float64) Matrix {
	var f0 C.double // out
	f0 = C.double(xx)
	var f1 C.double // out
	f1 = C.double(xy)
	var f2 C.double // out
	f2 = C.double(yx)
	var f3 C.double // out
	f3 = C.double(yy)
	var f4 C.double // out
	f4 = C.double(x0)
	var f5 C.double // out
	f5 = C.double(y0)

	v := C.PangoMatrix{
		xx: f0,
		xy: f1,
		yx: f2,
		yy: f3,
		x0: f4,
		y0: f5,
	}

	return *(*Matrix)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) XX() float64 {
	valptr := &m.native.xx
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) XY() float64 {
	valptr := &m.native.xy
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) YX() float64 {
	valptr := &m.native.yx
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) YY() float64 {
	valptr := &m.native.yy
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// X0: x translation.
func (m *Matrix) X0() float64 {
	valptr := &m.native.x0
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// Y0: y translation.
func (m *Matrix) Y0() float64 {
	valptr := &m.native.y0
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) SetXX(xx float64) {
	valptr := &m.native.xx
	*valptr = C.double(xx)
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) SetXY(xy float64) {
	valptr := &m.native.xy
	*valptr = C.double(xy)
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) SetYX(yx float64) {
	valptr := &m.native.yx
	*valptr = C.double(yx)
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) SetYY(yy float64) {
	valptr := &m.native.yy
	*valptr = C.double(yy)
}

// X0: x translation.
func (m *Matrix) SetX0(x0 float64) {
	valptr := &m.native.x0
	*valptr = C.double(x0)
}

// Y0: y translation.
func (m *Matrix) SetY0(y0 float64) {
	valptr := &m.native.y0
	*valptr = C.double(y0)
}

// Concat changes the transformation represented by matrix to be the
// transformation given by first applying transformation given by new_matrix
// then applying the original transformation.
//
// The function takes the following parameters:
//
//   - newMatrix: PangoMatrix.
func (matrix *Matrix) Concat(newMatrix *Matrix) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 *C.PangoMatrix // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(newMatrix)))

	C.pango_matrix_concat(_arg0, _arg1)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(newMatrix)
}

// Copy copies a PangoMatrix.
//
// The function returns the following values:
//
//   - ret (optional): newly allocated PangoMatrix.
func (matrix *Matrix) Copy() *Matrix {
	var _arg0 *C.PangoMatrix // out
	var _cret *C.PangoMatrix // in

	if matrix != nil {
		_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	_cret = C.pango_matrix_copy(_arg0)
	runtime.KeepAlive(matrix)

	var _ret *Matrix // out

	if _cret != nil {
		_ret = (*Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_matrix_free((*C.PangoMatrix)(intern.C))
			},
		)
	}

	return _ret
}

// FontScaleFactor returns the scale factor of a matrix on the height of the
// font.
//
// That is, the scale factor in the direction perpendicular to the vector that
// the X coordinate is mapped to. If the scale in the X coordinate is needed as
// well, use pango.Matrix.GetFontScaleFactors().
//
// The function returns the following values:
//
//   - gdouble: scale factor of matrix on the height of the font, or 1.0 if
//     matrix is NULL.
func (matrix *Matrix) FontScaleFactor() float64 {
	var _arg0 *C.PangoMatrix // out
	var _cret C.double       // in

	if matrix != nil {
		_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	_cret = C.pango_matrix_get_font_scale_factor(_arg0)
	runtime.KeepAlive(matrix)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// FontScaleFactors calculates the scale factor of a matrix on the width and
// height of the font.
//
// That is, xscale is the scale factor in the direction of the X coordinate,
// and yscale is the scale factor in the direction perpendicular to the vector
// that the X coordinate is mapped to.
//
// Note that output numbers will always be non-negative.
//
// The function returns the following values:
//
//   - xscale (optional): output scale factor in the x direction.
//   - yscale (optional): output scale factor perpendicular to the x direction.
func (matrix *Matrix) FontScaleFactors() (xscale float64, yscale float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // in
	var _arg2 C.double       // in

	if matrix != nil {
		_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	C.pango_matrix_get_font_scale_factors(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(matrix)

	var _xscale float64 // out
	var _yscale float64 // out

	_xscale = float64(_arg1)
	_yscale = float64(_arg2)

	return _xscale, _yscale
}

// SlantRatio gets the slant ratio of a matrix.
//
// For a simple shear matrix in the form:
//
//	1 
//	0 1
//
// this is simply .
//
// The function returns the following values:
//
//   - gdouble: slant ratio of matrix.
func (matrix *Matrix) SlantRatio() float64 {
	var _arg0 *C.PangoMatrix // out
	var _cret C.double       // in

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))

	_cret = C.pango_matrix_get_slant_ratio(_arg0)
	runtime.KeepAlive(matrix)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Rotate changes the transformation represented by matrix to be the
// transformation given by first rotating by degrees degrees counter-clockwise
// then applying the original transformation.
//
// The function takes the following parameters:
//
//   - degrees to rotate counter-clockwise.
func (matrix *Matrix) Rotate(degrees float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = C.double(degrees)

	C.pango_matrix_rotate(_arg0, _arg1)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(degrees)
}

// Scale changes the transformation represented by matrix to be the
// transformation given by first scaling by sx in the X direction and sy in the
// Y direction then applying the original transformation.
//
// The function takes the following parameters:
//
//   - scaleX: amount to scale by in X direction.
//   - scaleY: amount to scale by in Y direction.
func (matrix *Matrix) Scale(scaleX float64, scaleY float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = C.double(scaleX)
	_arg2 = C.double(scaleY)

	C.pango_matrix_scale(_arg0, _arg1, _arg2)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
}

// Translate changes the transformation represented by matrix to be the
// transformation given by first translating by (tx, ty) then applying the
// original transformation.
//
// The function takes the following parameters:
//
//   - tx: amount to translate in the X direction.
//   - ty: amount to translate in the Y direction.
func (matrix *Matrix) Translate(tx float64, ty float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = C.double(tx)
	_arg2 = C.double(ty)

	C.pango_matrix_translate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(tx)
	runtime.KeepAlive(ty)
}

// Rectangle: PangoRectangle structure represents a rectangle.
//
// PangoRectangle is frequently used to represent the logical or ink
// extents of a single glyph or section of text. (See, for instance,
// pango.Font.GetGlyphExtents().)
//
// An instance of this type is always passed by reference.
type Rectangle struct {
	*rectangle
}

// rectangle is the struct that's finalized.
type rectangle struct {
	native *C.PangoRectangle
}

// NewRectangle creates a new Rectangle instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewRectangle(x, y, width, height int) Rectangle {
	var f0 C.int // out
	f0 = C.int(x)
	var f1 C.int // out
	f1 = C.int(y)
	var f2 C.int // out
	f2 = C.int(width)
	var f3 C.int // out
	f3 = C.int(height)

	v := C.PangoRectangle{
		x:      f0,
		y:      f1,
		width:  f2,
		height: f3,
	}

	return *(*Rectangle)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// X coordinate of the left side of the rectangle.
func (r *Rectangle) X() int {
	valptr := &r.native.x
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Y coordinate of the the top side of the rectangle.
func (r *Rectangle) Y() int {
	valptr := &r.native.y
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width: width of the rectangle.
func (r *Rectangle) Width() int {
	valptr := &r.native.width
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height: height of the rectangle.
func (r *Rectangle) Height() int {
	valptr := &r.native.height
	var _v int // out
	_v = int(*valptr)
	return _v
}

// X coordinate of the left side of the rectangle.
func (r *Rectangle) SetX(x int) {
	valptr := &r.native.x
	*valptr = C.int(x)
}

// Y coordinate of the the top side of the rectangle.
func (r *Rectangle) SetY(y int) {
	valptr := &r.native.y
	*valptr = C.int(y)
}

// Width: width of the rectangle.
func (r *Rectangle) SetWidth(width int) {
	valptr := &r.native.width
	*valptr = C.int(width)
}

// Height: height of the rectangle.
func (r *Rectangle) SetHeight(height int) {
	valptr := &r.native.height
	*valptr = C.int(height)
}

// RendererClass class structure for PangoRenderer.
//
// The following vfuncs take user space coordinates in Pango units and have
// default implementations:
//
// - draw_glyphs
//
// - draw_rectangle
//
// - draw_error_underline
//
// - draw_shape
//
// - draw_glyph_item
//
// The default draw_shape implementation draws nothing.
//
// The following vfuncs take device space coordinates as doubles and must be
// implemented:
//
// - draw_trapezoid
//
// - draw_glyph
//
// An instance of this type is always passed by reference.
type RendererClass struct {
	*rendererClass
}

// rendererClass is the struct that's finalized.
type rendererClass struct {
	native *C.PangoRendererClass
}

// ScriptIter: PangoScriptIter is used to iterate through a string and identify
// ranges in different scripts.
//
// An instance of this type is always passed by reference.
type ScriptIter struct {
	*scriptIter
}

// scriptIter is the struct that's finalized.
type scriptIter struct {
	native *C.PangoScriptIter
}

func marshalScriptIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ScriptIter{&scriptIter{(*C.PangoScriptIter)(b)}}, nil
}

// NewScriptIter constructs a struct ScriptIter.
func NewScriptIter(text string) *ScriptIter {
	var _arg1 *C.char // out
	var _arg2 C.int
	var _cret *C.PangoScriptIter // in

	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_script_iter_new(_arg1, _arg2)
	runtime.KeepAlive(text)

	var _scriptIter *ScriptIter // out

	_scriptIter = (*ScriptIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_scriptIter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_script_iter_free((*C.PangoScriptIter)(intern.C))
		},
	)

	return _scriptIter
}

// Range gets information about the range to which iter currently points.
//
// The range is the set of locations p where *start <= p < *end. (That is,
// it doesn't include the character stored at *end)
//
// Note that while the type of the script argument is declared as PangoScript,
// as of Pango 1.18, this function simply returns GUnicodeScript values. Callers
// must be prepared to handle unknown values.
//
// The function returns the following values:
//
//   - start (optional): location to store start position of the range.
//   - end (optional): location to store end position of the range.
//   - script (optional): location to store script for range.
func (iter *ScriptIter) Range() (start string, end string, script Script) {
	var _arg0 *C.PangoScriptIter // out
	var _arg1 *C.char            // in
	var _arg2 *C.char            // in
	var _arg3 C.PangoScript      // in

	_arg0 = (*C.PangoScriptIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_script_iter_get_range(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(iter)

	var _start string  // out
	var _end string    // out
	var _script Script // out

	if _arg1 != nil {
		_start = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_end = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_script = Script(_arg3)

	return _start, _end, _script
}

// Next advances a PangoScriptIter to the next range.
//
// If iter is already at the end, it is left unchanged and FALSE is returned.
//
// The function returns the following values:
//
//   - ok: TRUE if iter was successfully advanced.
func (iter *ScriptIter) Next() bool {
	var _arg0 *C.PangoScriptIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoScriptIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_script_iter_next(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabArray: PangoTabArray contains an array of tab stops.
//
// PangoTabArray can be used to set tab stops in a PangoLayout. Each tab stop
// has an alignment, a position, and optionally a character to use as decimal
// point.
//
// An instance of this type is always passed by reference.
type TabArray struct {
	*tabArray
}

// tabArray is the struct that's finalized.
type tabArray struct {
	native *C.PangoTabArray
}

func marshalTabArray(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TabArray{&tabArray{(*C.PangoTabArray)(b)}}, nil
}

// NewTabArray constructs a struct TabArray.
func NewTabArray(initialSize int, positionsInPixels bool) *TabArray {
	var _arg1 C.gint           // out
	var _arg2 C.gboolean       // out
	var _cret *C.PangoTabArray // in

	_arg1 = C.gint(initialSize)
	if positionsInPixels {
		_arg2 = C.TRUE
	}

	_cret = C.pango_tab_array_new(_arg1, _arg2)
	runtime.KeepAlive(initialSize)
	runtime.KeepAlive(positionsInPixels)

	var _tabArray *TabArray // out

	_tabArray = (*TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tabArray)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
		},
	)

	return _tabArray
}

// Copy copies a PangoTabArray.
//
// The function returns the following values:
//
//   - tabArray: newly allocated PangoTabArray, which should be freed with
//     pango.TabArray.Free().
func (src *TabArray) Copy() *TabArray {
	var _arg0 *C.PangoTabArray // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(src)))

	_cret = C.pango_tab_array_copy(_arg0)
	runtime.KeepAlive(src)

	var _tabArray *TabArray // out

	_tabArray = (*TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tabArray)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
		},
	)

	return _tabArray
}

// DecimalPoint gets the Unicode character to use as decimal point.
//
// This is only relevant for tabs with PANGO_TAB_DECIMAL alignment, which align
// content at the first occurrence of the decimal point character.
//
// The default value of 0 means that Pango will use the decimal point according
// to the current locale.
//
// The function takes the following parameters:
//
//   - tabIndex: index of a tab stop.
func (tabArray *TabArray) DecimalPoint(tabIndex int) uint32 {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.int            // out
	var _cret C.gunichar       // in

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))
	_arg1 = C.int(tabIndex)

	_cret = C.pango_tab_array_get_decimal_point(_arg0, _arg1)
	runtime.KeepAlive(tabArray)
	runtime.KeepAlive(tabIndex)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// PositionsInPixels returns TRUE if the tab positions are in pixels, FALSE if
// they are in Pango units.
//
// The function returns the following values:
//
//   - ok: whether positions are in pixels.
func (tabArray *TabArray) PositionsInPixels() bool {
	var _arg0 *C.PangoTabArray // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))

	_cret = C.pango_tab_array_get_positions_in_pixels(_arg0)
	runtime.KeepAlive(tabArray)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size gets the number of tab stops in tab_array.
//
// The function returns the following values:
//
//   - gint: number of tab stops in the array.
func (tabArray *TabArray) Size() int {
	var _arg0 *C.PangoTabArray // out
	var _cret C.gint           // in

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))

	_cret = C.pango_tab_array_get_size(_arg0)
	runtime.KeepAlive(tabArray)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tab gets the alignment and position of a tab stop.
//
// The function takes the following parameters:
//
//   - tabIndex: tab stop index.
//
// The function returns the following values:
//
//   - alignment (optional): location to store alignment.
//   - location (optional) to store tab position.
func (tabArray *TabArray) Tab(tabIndex int) (TabAlign, int) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.gint           // out
	var _arg2 C.PangoTabAlign  // in
	var _arg3 C.gint           // in

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))
	_arg1 = C.gint(tabIndex)

	C.pango_tab_array_get_tab(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(tabArray)
	runtime.KeepAlive(tabIndex)

	var _alignment TabAlign // out
	var _location int       // out

	_alignment = TabAlign(_arg2)
	_location = int(_arg3)

	return _alignment, _location
}

// Resize resizes a tab array.
//
// You must subsequently initialize any tabs that were added as a result of
// growing the array.
//
// The function takes the following parameters:
//
//   - newSize: new size of the array.
func (tabArray *TabArray) Resize(newSize int) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.gint           // out

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))
	_arg1 = C.gint(newSize)

	C.pango_tab_array_resize(_arg0, _arg1)
	runtime.KeepAlive(tabArray)
	runtime.KeepAlive(newSize)
}

// SetDecimalPoint sets the Unicode character to use as decimal point.
//
// This is only relevant for tabs with PANGO_TAB_DECIMAL alignment, which align
// content at the first occurrence of the decimal point character.
//
// By default, Pango uses the decimal point according to the current locale.
//
// The function takes the following parameters:
//
//   - tabIndex: index of a tab stop.
//   - decimalPoint: decimal point to use.
func (tabArray *TabArray) SetDecimalPoint(tabIndex int, decimalPoint uint32) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.int            // out
	var _arg2 C.gunichar       // out

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))
	_arg1 = C.int(tabIndex)
	_arg2 = C.gunichar(decimalPoint)

	C.pango_tab_array_set_decimal_point(_arg0, _arg1, _arg2)
	runtime.KeepAlive(tabArray)
	runtime.KeepAlive(tabIndex)
	runtime.KeepAlive(decimalPoint)
}

// SetPositionsInPixels sets whether positions in this array are specified in
// pixels.
//
// The function takes the following parameters:
//
//   - positionsInPixels: whether positions are in pixels.
func (tabArray *TabArray) SetPositionsInPixels(positionsInPixels bool) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))
	if positionsInPixels {
		_arg1 = C.TRUE
	}

	C.pango_tab_array_set_positions_in_pixels(_arg0, _arg1)
	runtime.KeepAlive(tabArray)
	runtime.KeepAlive(positionsInPixels)
}

// SetTab sets the alignment and location of a tab stop.
//
// The function takes the following parameters:
//
//   - tabIndex: index of a tab stop.
//   - alignment: tab alignment.
//   - location: tab location in Pango units.
func (tabArray *TabArray) SetTab(tabIndex int, alignment TabAlign, location int) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.gint           // out
	var _arg2 C.PangoTabAlign  // out
	var _arg3 C.gint           // out

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))
	_arg1 = C.gint(tabIndex)
	_arg2 = C.PangoTabAlign(alignment)
	_arg3 = C.gint(location)

	C.pango_tab_array_set_tab(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(tabArray)
	runtime.KeepAlive(tabIndex)
	runtime.KeepAlive(alignment)
	runtime.KeepAlive(location)
}

// Sort: utility function to ensure that the tab stops are in increasing order.
func (tabArray *TabArray) Sort() {
	var _arg0 *C.PangoTabArray // out

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))

	C.pango_tab_array_sort(_arg0)
	runtime.KeepAlive(tabArray)
}

// String serializes a PangoTabArray to a string.
//
// No guarantees are made about the format of the string, it may change between
// Pango versions.
//
// The intended use of this function is testing and debugging. The format is not
// meant as a permanent storage format.
//
// The function returns the following values:
//
//   - utf8: newly allocated string.
func (tabArray *TabArray) String() string {
	var _arg0 *C.PangoTabArray // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabArray)))

	_cret = C.pango_tab_array_to_string(_arg0)
	runtime.KeepAlive(tabArray)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TabArrayFromString deserializes a PangoTabArray from a string.
//
// This is the counterpart to pango.TabArray.ToString(). See that functions for
// details about the format.
//
// The function takes the following parameters:
//
//   - text: string.
//
// The function returns the following values:
//
//   - tabArray (optional): new PangoTabArray.
func TabArrayFromString(text string) *TabArray {
	var _arg1 *C.char          // out
	var _cret *C.PangoTabArray // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_tab_array_from_string(_arg1)
	runtime.KeepAlive(text)

	var _tabArray *TabArray // out

	if _cret != nil {
		_tabArray = (*TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tabArray)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
			},
		)
	}

	return _tabArray
}
