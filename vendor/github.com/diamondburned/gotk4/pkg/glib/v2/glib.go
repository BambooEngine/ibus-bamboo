// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"reflect"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"time"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <glib.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_glib2_LogFunc(gchar*, GLogLevelFlags, gchar*, gpointer);
// extern void _gotk4_glib2_HFunc(gpointer, gpointer, gpointer);
// extern void _gotk4_glib2_Func(gpointer, gpointer);
// extern gint _gotk4_glib2_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gboolean _gotk4_glib2_SourceFunc(gpointer);
// extern gboolean _gotk4_glib2_HRFunc(gpointer, gpointer, gpointer);
// extern GLogWriterOutput _gotk4_glib2_LogWriterFunc(GLogLevelFlags, GLogField*, gsize, gpointer);
import "C"

// GType values.
var (
	GTypeNormalizeMode      = coreglib.Type(C.g_normalize_mode_get_type())
	GTypeUnicodeBreakType   = coreglib.Type(C.g_unicode_break_type_get_type())
	GTypeUnicodeScript      = coreglib.Type(C.g_unicode_script_get_type())
	GTypeUnicodeType        = coreglib.Type(C.g_unicode_type_get_type())
	GTypeIOCondition        = coreglib.Type(C.g_io_condition_get_type())
	GTypeBookmarkFile       = coreglib.Type(C.g_bookmark_file_get_type())
	GTypeChecksum           = coreglib.Type(C.g_checksum_get_type())
	GTypeDateTime           = coreglib.Type(C.g_date_time_get_type())
	GTypeDir                = coreglib.Type(C.g_dir_get_type())
	GTypeHashTable          = coreglib.Type(C.g_hash_table_get_type())
	GTypeHMAC               = coreglib.Type(C.g_hmac_get_type())
	GTypeIOChannel          = coreglib.Type(C.g_io_channel_get_type())
	GTypeKeyFile            = coreglib.Type(C.g_key_file_get_type())
	GTypeMainContext        = coreglib.Type(C.g_main_context_get_type())
	GTypeMainLoop           = coreglib.Type(C.g_main_loop_get_type())
	GTypeMappedFile         = coreglib.Type(C.g_mapped_file_get_type())
	GTypeMarkupParseContext = coreglib.Type(C.g_markup_parse_context_get_type())
	GTypeMatchInfo          = coreglib.Type(C.g_match_info_get_type())
	GTypeOptionGroup        = coreglib.Type(C.g_option_group_get_type())
	GTypePatternSpec        = coreglib.Type(C.g_pattern_spec_get_type())
	GTypeRand               = coreglib.Type(C.g_rand_get_type())
	GTypeRegex              = coreglib.Type(C.g_regex_get_type())
	GTypeSource             = coreglib.Type(C.g_source_get_type())
	GTypeTimeZone           = coreglib.Type(C.g_time_zone_get_type())
	GTypeTree               = coreglib.Type(C.g_tree_get_type())
	GTypeURI                = coreglib.Type(C.g_uri_get_type())
	GTypeVariantBuilder     = coreglib.Type(C.g_variant_builder_get_type())
	GTypeVariantDict        = coreglib.Type(C.g_variant_dict_get_type())
	GTypeVariantType        = coreglib.Type(C.g_variant_type_get_gtype())
	GTypeVariant            = coreglib.Type(coreglib.TypeVariant)
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNormalizeMode, F: marshalNormalizeMode},
		coreglib.TypeMarshaler{T: GTypeUnicodeBreakType, F: marshalUnicodeBreakType},
		coreglib.TypeMarshaler{T: GTypeUnicodeScript, F: marshalUnicodeScript},
		coreglib.TypeMarshaler{T: GTypeUnicodeType, F: marshalUnicodeType},
		coreglib.TypeMarshaler{T: GTypeIOCondition, F: marshalIOCondition},
		coreglib.TypeMarshaler{T: GTypeBookmarkFile, F: marshalBookmarkFile},
		coreglib.TypeMarshaler{T: GTypeChecksum, F: marshalChecksum},
		coreglib.TypeMarshaler{T: GTypeDateTime, F: marshalDateTime},
		coreglib.TypeMarshaler{T: GTypeDir, F: marshalDir},
		coreglib.TypeMarshaler{T: GTypeHashTable, F: marshalHashTable},
		coreglib.TypeMarshaler{T: GTypeHMAC, F: marshalHMAC},
		coreglib.TypeMarshaler{T: GTypeIOChannel, F: marshalIOChannel},
		coreglib.TypeMarshaler{T: GTypeKeyFile, F: marshalKeyFile},
		coreglib.TypeMarshaler{T: GTypeMainContext, F: marshalMainContext},
		coreglib.TypeMarshaler{T: GTypeMainLoop, F: marshalMainLoop},
		coreglib.TypeMarshaler{T: GTypeMappedFile, F: marshalMappedFile},
		coreglib.TypeMarshaler{T: GTypeMarkupParseContext, F: marshalMarkupParseContext},
		coreglib.TypeMarshaler{T: GTypeMatchInfo, F: marshalMatchInfo},
		coreglib.TypeMarshaler{T: GTypeOptionGroup, F: marshalOptionGroup},
		coreglib.TypeMarshaler{T: GTypePatternSpec, F: marshalPatternSpec},
		coreglib.TypeMarshaler{T: GTypeRand, F: marshalRand},
		coreglib.TypeMarshaler{T: GTypeRegex, F: marshalRegex},
		coreglib.TypeMarshaler{T: GTypeSource, F: marshalSource},
		coreglib.TypeMarshaler{T: GTypeTimeZone, F: marshalTimeZone},
		coreglib.TypeMarshaler{T: GTypeTree, F: marshalTree},
		coreglib.TypeMarshaler{T: GTypeURI, F: marshalURI},
		coreglib.TypeMarshaler{T: GTypeVariantBuilder, F: marshalVariantBuilder},
		coreglib.TypeMarshaler{T: GTypeVariantDict, F: marshalVariantDict},
		coreglib.TypeMarshaler{T: GTypeVariantType, F: marshalVariantType},
		coreglib.TypeMarshaler{T: GTypeVariant, F: marshalVariant},
	})
}

const ALLOCATOR_LIST = 1
const ALLOCATOR_NODE = 3
const ALLOCATOR_SLIST = 2
const ALLOC_AND_FREE = 2
const ALLOC_ONLY = 1
const ANALYZER_ANALYZING = 1

// ASCII_DTOSTR_BUF_SIZE: good size for a buffer to be passed into
// glib.ASCIIDtostr(). It is guaranteed to be enough for all output of that
// function on systems with 64bit IEEE-compatible doubles.
//
// The typical usage would be something like:
//
//	char buf[G_ASCII_DTOSTR_BUF_SIZE];
//
//	fprintf (out, "value=s\n", g_ascii_dtostr (buf, sizeof (buf), value));.
const ASCII_DTOSTR_BUF_SIZE = 39

// ATOMIC_REF_COUNT_INIT evaluates to the initial reference count for
// gatomicrefcount.
//
// This macro is useful for initializing gatomicrefcount fields inside
// structures, for instance:
//
//	typedef struct {
//	  gatomicrefcount ref_count;
//	  char *name;
//	  char *address;
//	} Person;
//
//	static const Person default_person = {
//	  .ref_count = G_ATOMIC_REF_COUNT_INIT,
//	  .name = "Default name",
//	  .address = "Default address",
//	};.
const ATOMIC_REF_COUNT_INIT = 1
const BIG_ENDIAN = 4321

// CSET_A_2_Z: set of uppercase ASCII alphabet characters. Used for specifying
// valid identifier characters in Config.
const CSET_A_2_Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

// CSET_DIGITS: set of ASCII digits. Used for specifying valid identifier
// characters in Config.
const CSET_DIGITS = "0123456789"

// CSET_a_2_z: set of lowercase ASCII alphabet characters. Used for specifying
// valid identifier characters in Config.
const CSET_a_2_z = "abcdefghijklmnopqrstuvwxyz"
const C_STD_VERSION = 199000

// DATALIST_FLAGS_MASK: bitmask that restricts the possible flags
// passed to g_datalist_set_flags(). Passing a flags value where flags &
// ~G_DATALIST_FLAGS_MASK != 0 is an error.
const DATALIST_FLAGS_MASK = 3

// DATE_BAD_DAY represents an invalid Day.
const DATE_BAD_DAY = 0

// DATE_BAD_JULIAN represents an invalid Julian day number.
const DATE_BAD_JULIAN = 0

// DATE_BAD_YEAR represents an invalid year.
const DATE_BAD_YEAR = 0
const DIR_SEPARATOR = 47
const DIR_SEPARATOR_S = "/"
const E = 2.718282
const GINT16_FORMAT = "hi"
const GINT16_MODIFIER = "h"
const GINT32_FORMAT = "i"
const GINT32_MODIFIER = ""
const GINT64_FORMAT = "li"
const GINT64_MODIFIER = "l"
const GINTPTR_FORMAT = "li"
const GINTPTR_MODIFIER = "l"

// GNUC_FUNCTION expands to "" on all modern compilers, and to __FUNCTION__ on
// gcc version 2.x. Don't use it.
//
// Deprecated: Use G_STRFUNC() instead.
const GNUC_FUNCTION = ""

// GNUC_PRETTY_FUNCTION expands to "" on all modern compilers, and to
// __PRETTY_FUNCTION__ on gcc version 2.x. Don't use it.
//
// Deprecated: Use G_STRFUNC() instead.
const GNUC_PRETTY_FUNCTION = ""
const GSIZE_FORMAT = "lu"
const GSIZE_MODIFIER = "l"
const GSSIZE_FORMAT = "li"
const GSSIZE_MODIFIER = "l"
const GUINT16_FORMAT = "hu"
const GUINT32_FORMAT = "u"
const GUINT64_FORMAT = "lu"
const GUINTPTR_FORMAT = "lu"
const HAVE_GINT64 = 1
const HAVE_GNUC_VARARGS = 1
const HAVE_GNUC_VISIBILITY = 1
const HAVE_GROWING_STACK = 0
const HAVE_ISO_VARARGS = 1

// HOOK_FLAG_USER_SHIFT: position of the first bit which is not reserved for
// internal use be the #GHook implementation, i.e. 1 << G_HOOK_FLAG_USER_SHIFT
// is the first bit which can be used for application-defined flags.
const HOOK_FLAG_USER_SHIFT = 4
const IEEE754_DOUBLE_BIAS = 1023
const IEEE754_FLOAT_BIAS = 127

// KEY_FILE_DESKTOP_GROUP: name of the main group of a desktop
// entry file, as defined in the Desktop Entry Specification
// (http://freedesktop.org/Standards/desktop-entry-spec). Consult the
// specification for more details about the meanings of the keys below.
const KEY_FILE_DESKTOP_GROUP = "Desktop Entry"

// KEY_FILE_DESKTOP_KEY_ACTIONS: key under G_KEY_FILE_DESKTOP_GROUP, whose value
// is a string list giving the available application actions.
const KEY_FILE_DESKTOP_KEY_ACTIONS = "Actions"

// KEY_FILE_DESKTOP_KEY_CATEGORIES: key under G_KEY_FILE_DESKTOP_GROUP, whose
// value is a list of strings giving the categories in which the desktop entry
// should be shown in a menu.
const KEY_FILE_DESKTOP_KEY_CATEGORIES = "Categories"

// KEY_FILE_DESKTOP_KEY_COMMENT: key under G_KEY_FILE_DESKTOP_GROUP, whose value
// is a localized string giving the tooltip for the desktop entry.
const KEY_FILE_DESKTOP_KEY_COMMENT = "Comment"

// KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: key under G_KEY_FILE_DESKTOP_GROUP,
// whose value is a boolean set to true if the application is D-Bus activatable.
const KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE = "DBusActivatable"

// KEY_FILE_DESKTOP_KEY_EXEC: key under G_KEY_FILE_DESKTOP_GROUP, whose value
// is a string giving the command line to execute. It is only valid for desktop
// entries with the Application type.
const KEY_FILE_DESKTOP_KEY_EXEC = "Exec"

// KEY_FILE_DESKTOP_KEY_GENERIC_NAME: key under G_KEY_FILE_DESKTOP_GROUP, whose
// value is a localized string giving the generic name of the desktop entry.
const KEY_FILE_DESKTOP_KEY_GENERIC_NAME = "GenericName"

// KEY_FILE_DESKTOP_KEY_HIDDEN: key under G_KEY_FILE_DESKTOP_GROUP, whose value
// is a boolean stating whether the desktop entry has been deleted by the user.
const KEY_FILE_DESKTOP_KEY_HIDDEN = "Hidden"

// KEY_FILE_DESKTOP_KEY_ICON: key under G_KEY_FILE_DESKTOP_GROUP, whose value
// is a localized string giving the name of the icon to be displayed for the
// desktop entry.
const KEY_FILE_DESKTOP_KEY_ICON = "Icon"

// KEY_FILE_DESKTOP_KEY_MIME_TYPE: key under G_KEY_FILE_DESKTOP_GROUP, whose
// value is a list of strings giving the MIME types supported by this desktop
// entry.
const KEY_FILE_DESKTOP_KEY_MIME_TYPE = "MimeType"

// KEY_FILE_DESKTOP_KEY_NAME: key under G_KEY_FILE_DESKTOP_GROUP, whose value is
// a localized string giving the specific name of the desktop entry.
const KEY_FILE_DESKTOP_KEY_NAME = "Name"

// KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: key under G_KEY_FILE_DESKTOP_GROUP,
// whose value is a list of strings identifying the environments that should not
// display the desktop entry.
const KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN = "NotShowIn"

// KEY_FILE_DESKTOP_KEY_NO_DISPLAY: key under G_KEY_FILE_DESKTOP_GROUP,
// whose value is a boolean stating whether the desktop entry should be shown in
// menus.
const KEY_FILE_DESKTOP_KEY_NO_DISPLAY = "NoDisplay"

// KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: key under G_KEY_FILE_DESKTOP_GROUP,
// whose value is a list of strings identifying the environments that should
// display the desktop entry.
const KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN = "OnlyShowIn"

// KEY_FILE_DESKTOP_KEY_PATH: key under G_KEY_FILE_DESKTOP_GROUP, whose value is
// a string containing the working directory to run the program in. It is only
// valid for desktop entries with the Application type.
const KEY_FILE_DESKTOP_KEY_PATH = "Path"

// KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: key under G_KEY_FILE_DESKTOP_GROUP,
// whose value is a boolean stating whether the application
// supports the Startup Notification Protocol Specification
// (http://www.freedesktop.org/Standards/startup-notification-spec).
const KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY = "StartupNotify"

// KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: key under G_KEY_FILE_DESKTOP_GROUP,
// whose value is string identifying the WM class or name hint of a window
// that the application will create, which can be used to emulate Startup
// Notification with older applications.
const KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS = "StartupWMClass"

// KEY_FILE_DESKTOP_KEY_TERMINAL: key under G_KEY_FILE_DESKTOP_GROUP, whose
// value is a boolean stating whether the program should be run in a terminal
// window.
//
// It is only valid for desktop entries with the Application type.
const KEY_FILE_DESKTOP_KEY_TERMINAL = "Terminal"

// KEY_FILE_DESKTOP_KEY_TRY_EXEC: key under G_KEY_FILE_DESKTOP_GROUP, whose
// value is a string giving the file name of a binary on disk used to determine
// if the program is actually installed. It is only valid for desktop entries
// with the Application type.
const KEY_FILE_DESKTOP_KEY_TRY_EXEC = "TryExec"

// KEY_FILE_DESKTOP_KEY_TYPE: key under G_KEY_FILE_DESKTOP_GROUP, whose value is
// a string giving the type of the desktop entry.
//
// Usually G_KEY_FILE_DESKTOP_TYPE_APPLICATION, G_KEY_FILE_DESKTOP_TYPE_LINK,
// or G_KEY_FILE_DESKTOP_TYPE_DIRECTORY.
const KEY_FILE_DESKTOP_KEY_TYPE = "Type"

// KEY_FILE_DESKTOP_KEY_URL: key under G_KEY_FILE_DESKTOP_GROUP, whose value is
// a string giving the URL to access. It is only valid for desktop entries with
// the Link type.
const KEY_FILE_DESKTOP_KEY_URL = "URL"

// KEY_FILE_DESKTOP_KEY_VERSION: key under G_KEY_FILE_DESKTOP_GROUP, whose value
// is a string giving the version of the Desktop Entry Specification used for
// the desktop entry file.
const KEY_FILE_DESKTOP_KEY_VERSION = "Version"

// KEY_FILE_DESKTOP_TYPE_APPLICATION: value of the G_KEY_FILE_DESKTOP_KEY_TYPE,
// key for desktop entries representing applications.
const KEY_FILE_DESKTOP_TYPE_APPLICATION = "Application"

// KEY_FILE_DESKTOP_TYPE_DIRECTORY: value of the G_KEY_FILE_DESKTOP_KEY_TYPE,
// key for desktop entries representing directories.
const KEY_FILE_DESKTOP_TYPE_DIRECTORY = "Directory"

// KEY_FILE_DESKTOP_TYPE_LINK: value of the G_KEY_FILE_DESKTOP_KEY_TYPE,
// key for desktop entries representing links to documents.
const KEY_FILE_DESKTOP_TYPE_LINK = "Link"
const LITTLE_ENDIAN = 1234
const LN10 = 2.302585
const LN2 = 0.693147
const LOG_2_BASE_10 = 0.301030

// LOG_DOMAIN defines the log domain. See Log Domains (#log-domains).
//
// Libraries should define this so that any messages which they log can be
// differentiated from messages from other libraries and application code.
// But be careful not to define it in any public header files.
//
// Log domains must be unique, and it is recommended that they are the
// application or library name, optionally followed by a hyphen and a sub-domain
// name. For example, bloatpad or bloatpad-io.
//
// If undefined, it defaults to the default NULL (or "") log domain; this is
// not advisable, as it cannot be filtered against using the G_MESSAGES_DEBUG
// environment variable.
//
// For example, GTK uses this in its Makefile.am:
//
//	AM_CPPFLAGS = -DG_LOG_DOMAIN=\"Gtk\"
//
// Applications can choose to leave it as the default NULL (or "") domain.
// However, defining the domain offers the same advantages as above.
const LOG_DOMAIN = 0

// LOG_FATAL_MASK: GLib log levels that are considered fatal by default.
//
// This is not used if structured logging is enabled; see Using Structured
// Logging (logging.html#using-structured-logging).
const LOG_FATAL_MASK = 5

// LOG_LEVEL_USER_SHIFT: log levels below 1<<G_LOG_LEVEL_USER_SHIFT are used by
// GLib. Higher bits can be used for user-defined log levels.
const LOG_LEVEL_USER_SHIFT = 8

// MAJOR_VERSION: major version number of the GLib library.
//
// Like #glib_major_version, but from the headers used at application compile
// time, rather than from the library linked against at application run time.
const MAJOR_VERSION = 2
const MAXINT16 = 32767
const MAXINT32 = 2147483647
const MAXINT64 = 9223372036854775807
const MAXINT8 = 127
const MAXUINT16 = 65535
const MAXUINT32 = 4294967295
const MAXUINT64 = 18446744073709551615
const MAXUINT8 = 255

// MICRO_VERSION: micro version number of the GLib library.
//
// Like #gtk_micro_version, but from the headers used at application compile
// time, rather than from the library linked against at application run time.
const MICRO_VERSION = 2

// MININT16: minimum value which can be held in a #gint16.
const MININT16 = -32768

// MININT32: minimum value which can be held in a #gint32.
const MININT32 = -2147483648

// MININT64: minimum value which can be held in a #gint64.
const MININT64 = -9223372036854775808

// MININT8: minimum value which can be held in a #gint8.
const MININT8 = -128

// MINOR_VERSION: minor version number of the GLib library.
//
// Like #gtk_minor_version, but from the headers used at application compile
// time, rather than from the library linked against at application run time.
const MINOR_VERSION = 80
const MODULE_SUFFIX = "so"

// OPTION_REMAINING: if a long option in the main group has this name,
// it is not treated as a regular option. Instead it collects all
// non-option arguments which would otherwise be left in argv. The option
// must be of type G_OPTION_ARG_CALLBACK, G_OPTION_ARG_STRING_ARRAY or
// G_OPTION_ARG_FILENAME_ARRAY.
//
//	Using G_OPTION_REMAINING instead of simply scanning argv for leftover arguments has the advantage that GOption takes care of necessary encoding conversions for strings or filenames.
const OPTION_REMAINING = ""
const PDP_ENDIAN = 3412
const PI = 3.141593

// PID_FORMAT: format specifier that can be used in printf()-style format
// strings when printing a #GPid.
const PID_FORMAT = "i"
const PI_2 = 1.570796
const PI_4 = 0.785398

// POLLFD_FORMAT: format specifier that can be used in printf()-style format
// strings when printing the fd member of a FD.
const POLLFD_FORMAT = "%d"

// PRIORITY_DEFAULT: use this for default priority event sources.
//
// In GLib this priority is used when adding timeout functions with
// g_timeout_add(). In GDK this priority is used for events from the X server.
const PRIORITY_DEFAULT = 0

// PRIORITY_DEFAULT_IDLE: use this for default priority idle functions.
//
// In GLib this priority is used when adding idle functions with g_idle_add().
const PRIORITY_DEFAULT_IDLE = 200

// PRIORITY_HIGH: use this for high priority event sources.
//
// It is not used within GLib or GTK.
const PRIORITY_HIGH = -100

// PRIORITY_HIGH_IDLE: use this for high priority idle functions.
//
// GTK uses G_PRIORITY_HIGH_IDLE + 10 for resizing operations, and
// G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is done to ensure
// that any pending resizes are processed before any pending redraws, so that
// widgets are not redrawn twice unnecessarily.).
const PRIORITY_HIGH_IDLE = 100

// PRIORITY_LOW: use this for very low priority background tasks.
//
// It is not used within GLib or GTK.
const PRIORITY_LOW = 300

// REF_COUNT_INIT evaluates to the initial reference count for grefcount.
//
// This macro is useful for initializing grefcount fields inside structures,
// for instance:
//
//	typedef struct {
//	  grefcount ref_count;
//	  char *name;
//	  char *address;
//	} Person;
//
//	static const Person default_person = {
//	  .ref_count = G_REF_COUNT_INIT,
//	  .name = "Default name",
//	  .address = "Default address",
//	};.
const REF_COUNT_INIT = -1
const SEARCHPATH_SEPARATOR = 58
const SEARCHPATH_SEPARATOR_S = ":"
const SIZEOF_LONG = 8
const SIZEOF_SIZE_T = 8
const SIZEOF_SSIZE_T = 8
const SIZEOF_VOID_P = 8

// SOURCE_CONTINUE: use this macro as the return value of a Func to leave the
// #GSource in the main loop.
const SOURCE_CONTINUE = true

// SOURCE_REMOVE: use this macro as the return value of a Func to remove the
// #GSource from the main loop.
const SOURCE_REMOVE = false
const SQRT2 = 1.414214

// STR_DELIMITERS: standard delimiters, used in glib.Strdelimit().
const STR_DELIMITERS = "_-|> <."
const SYSDEF_AF_INET = 2
const SYSDEF_AF_INET6 = 10
const SYSDEF_AF_UNIX = 1
const SYSDEF_MSG_DONTROUTE = 4
const SYSDEF_MSG_OOB = 1
const SYSDEF_MSG_PEEK = 2

// TEST_OPTION_ISOLATE_DIRS creates a unique temporary directory for each
// unit test and uses g_set_user_dirs() to set XDG directories to point into
// subdirectories of it for the duration of the unit test. The directory
// tree is cleaned up after the test finishes successfully. Note that this
// doesn’t take effect until g_test_run() is called, so calls to (for example)
// g_get_user_home_dir() will return the system-wide value when made in a test
// program’s main() function.
//
// The following functions will return subdirectories of the temporary directory
// when this option is used. The specific subdirectory paths in use are not
// guaranteed to be stable API — always use a getter function to retrieve them.
//
//   - g_get_home_dir()
//   - g_get_user_cache_dir()
//   - g_get_system_config_dirs()
//   - g_get_user_config_dir()
//   - g_get_system_data_dirs()
//   - g_get_user_data_dir()
//   - g_get_user_state_dir()
//   - g_get_user_runtime_dir()
//
// The subdirectories may not be created by the test harness; as with normal
// calls to functions like g_get_user_cache_dir(), the caller must be prepared
// to create the directory if it doesn’t exist.
const TEST_OPTION_ISOLATE_DIRS = "isolate_dirs"

// TIME_SPAN_DAY evaluates to a time span of one day.
const TIME_SPAN_DAY = 86400000000

// TIME_SPAN_HOUR evaluates to a time span of one hour.
const TIME_SPAN_HOUR = 3600000000

// TIME_SPAN_MILLISECOND evaluates to a time span of one millisecond.
const TIME_SPAN_MILLISECOND = 1000

// TIME_SPAN_MINUTE evaluates to a time span of one minute.
const TIME_SPAN_MINUTE = 60000000

// TIME_SPAN_SECOND evaluates to a time span of one second.
const TIME_SPAN_SECOND = 1000000

// UNICHAR_MAX_DECOMPOSITION_LENGTH: maximum length (in codepoints) of a
// compatibility or canonical decomposition of a single Unicode character.
//
// This is as defined by Unicode 6.1.
const UNICHAR_MAX_DECOMPOSITION_LENGTH = 18

// URI_RESERVED_CHARS_GENERIC_DELIMITERS: generic delimiters characters as
// defined in RFC 3986 (https://tools.ietf.org/html/rfc3986). Includes :/?#[]@.
const URI_RESERVED_CHARS_GENERIC_DELIMITERS = ":/?#[]@"

// URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: subcomponent delimiter characters
// as defined in RFC 3986 (https://tools.ietf.org/html/rfc3986). Includes
// !$&'()*+,;=.
const URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = "!$&'()*+,;="

// USEC_PER_SEC: number of microseconds in one second (1 million). This macro is
// provided for code readability.
const USEC_PER_SEC = 1000000

// VERSION_MIN_REQUIRED: macro that should be defined by the user prior to
// including the glib.h header. The definition should be one of the predefined
// GLib version macros: GLIB_VERSION_2_26, GLIB_VERSION_2_28,...
//
// This macro defines the earliest version of GLib that the package is required
// to be able to compile against.
//
// If the compiler is configured to warn about the use of deprecated
// functions, then using functions that were deprecated in version
// GLIB_VERSION_MIN_REQUIRED or earlier will cause warnings (but using functions
// deprecated in later releases will not).
const VERSION_MIN_REQUIRED = 2
const WIN32_MSG_HANDLE = 19981206
const macro__has_attribute___noreturn__ = 0

// Quark is a non-zero integer which uniquely identifies a particular string.
//
// A GQuark value of zero is associated to NULL.
//
// Given either the string or the GQuark identifier it is possible to retrieve
// the other.
//
// Quarks are used for both datasets and keyed data lists
// (datalist-and-dataset.html).
//
// To create a new quark from a string, use glib.QuarkFromString() or
// glib.QuarkFromStaticString().
//
// To find the string corresponding to a given GQuark, use glib.QuarkToString().
//
// To find the GQuark corresponding to a given string, use
// glib.QuarkTryString().
//
// Another use for the string pool maintained for the quark functions is
// string interning, using glib.InternString() or glib.InternStaticString().
// An interned string is a canonical representation for a string. One important
// advantage of interned strings is that they can be compared for equality by a
// simple pointer comparison, rather than using strcmp().
type Quark = uint32

// TimeSpan: value representing an interval of time, in microseconds.
type TimeSpan = int64

// BookmarkFileError: error codes returned by bookmark file parsing.
type BookmarkFileError C.gint

const (
	// BookmarkFileErrorInvalidURI: URI was ill-formed.
	BookmarkFileErrorInvalidURI BookmarkFileError = iota
	// BookmarkFileErrorInvalidValue: requested field was not found.
	BookmarkFileErrorInvalidValue
	// BookmarkFileErrorAppNotRegistered: requested application did not register
	// a bookmark.
	BookmarkFileErrorAppNotRegistered
	// BookmarkFileErrorURINotFound: requested URI was not found.
	BookmarkFileErrorURINotFound
	// BookmarkFileErrorRead: document was ill formed.
	BookmarkFileErrorRead
	// BookmarkFileErrorUnknownEncoding: text being parsed was in an unknown
	// encoding.
	BookmarkFileErrorUnknownEncoding
	// BookmarkFileErrorWrite: error occurred while writing.
	BookmarkFileErrorWrite
	// BookmarkFileErrorFileNotFound: requested file was not found.
	BookmarkFileErrorFileNotFound
)

// String returns the name in string for BookmarkFileError.
func (b BookmarkFileError) String() string {
	switch b {
	case BookmarkFileErrorInvalidURI:
		return "InvalidURI"
	case BookmarkFileErrorInvalidValue:
		return "InvalidValue"
	case BookmarkFileErrorAppNotRegistered:
		return "AppNotRegistered"
	case BookmarkFileErrorURINotFound:
		return "URINotFound"
	case BookmarkFileErrorRead:
		return "Read"
	case BookmarkFileErrorUnknownEncoding:
		return "UnknownEncoding"
	case BookmarkFileErrorWrite:
		return "Write"
	case BookmarkFileErrorFileNotFound:
		return "FileNotFound"
	default:
		return fmt.Sprintf("BookmarkFileError(%d)", b)
	}
}

// ChecksumType: hashing algorithm to be used by #GChecksum when performing the
// digest of some data.
//
// Note that the Type enumeration may be extended at a later date to include new
// hashing algorithm types.
type ChecksumType C.gint

const (
	// ChecksumMD5: use the MD5 hashing algorithm.
	ChecksumMD5 ChecksumType = iota
	// ChecksumSHA1: use the SHA-1 hashing algorithm.
	ChecksumSHA1
	// ChecksumSHA256: use the SHA-256 hashing algorithm.
	ChecksumSHA256
	// ChecksumSHA512: use the SHA-512 hashing algorithm (Since: 2.36).
	ChecksumSHA512
	// ChecksumSHA384: use the SHA-384 hashing algorithm (Since: 2.51).
	ChecksumSHA384
)

// String returns the name in string for ChecksumType.
func (c ChecksumType) String() string {
	switch c {
	case ChecksumMD5:
		return "MD5"
	case ChecksumSHA1:
		return "SHA1"
	case ChecksumSHA256:
		return "SHA256"
	case ChecksumSHA512:
		return "SHA512"
	case ChecksumSHA384:
		return "SHA384"
	default:
		return fmt.Sprintf("ChecksumType(%d)", c)
	}
}

// ConvertError: error codes returned by character set conversion routines.
type ConvertError C.gint

const (
	// ConvertErrorNoConversion: conversion between the requested character sets
	// is not supported.
	ConvertErrorNoConversion ConvertError = iota
	// ConvertErrorIllegalSequence: invalid byte sequence in conversion input;
	// or the character sequence could not be represented in the target
	// character set.
	ConvertErrorIllegalSequence
	// ConvertErrorFailed: conversion failed for some reason.
	ConvertErrorFailed
	// ConvertErrorPartialInput: partial character sequence at end of input.
	ConvertErrorPartialInput
	// ConvertErrorBadURI: URI is invalid.
	ConvertErrorBadURI
	// ConvertErrorNotAbsolutePath: pathname is not an absolute path.
	ConvertErrorNotAbsolutePath
	// ConvertErrorNoMemory: no memory available. Since: 2.40.
	ConvertErrorNoMemory
	// ConvertErrorEmbeddedNUL: embedded NUL character is present in conversion
	// output where a NUL-terminated string is expected. Since: 2.56.
	ConvertErrorEmbeddedNUL
)

// String returns the name in string for ConvertError.
func (c ConvertError) String() string {
	switch c {
	case ConvertErrorNoConversion:
		return "NoConversion"
	case ConvertErrorIllegalSequence:
		return "IllegalSequence"
	case ConvertErrorFailed:
		return "Failed"
	case ConvertErrorPartialInput:
		return "PartialInput"
	case ConvertErrorBadURI:
		return "BadURI"
	case ConvertErrorNotAbsolutePath:
		return "NotAbsolutePath"
	case ConvertErrorNoMemory:
		return "NoMemory"
	case ConvertErrorEmbeddedNUL:
		return "EmbeddedNUL"
	default:
		return fmt.Sprintf("ConvertError(%d)", c)
	}
}

// ErrorType: possible errors, used in the v_error field of Value, when the
// token is a G_TOKEN_ERROR.
type ErrorType C.gint

const (
	// ErrUnknown: unknown error.
	ErrUnknown ErrorType = iota
	// ErrUnexpEOF: unexpected end of file.
	ErrUnexpEOF
	// ErrUnexpEOFInString: unterminated string constant.
	ErrUnexpEOFInString
	// ErrUnexpEOFInComment: unterminated comment.
	ErrUnexpEOFInComment
	// ErrNonDigitInConst: non-digit character in a number.
	ErrNonDigitInConst
	// ErrDigitRadix: digit beyond radix in a number.
	ErrDigitRadix
	// ErrFloatRadix: non-decimal floating point number.
	ErrFloatRadix
	// ErrFloatMalformed: malformed floating point number.
	ErrFloatMalformed
)

// String returns the name in string for ErrorType.
func (e ErrorType) String() string {
	switch e {
	case ErrUnknown:
		return "Unknown"
	case ErrUnexpEOF:
		return "UnexpEOF"
	case ErrUnexpEOFInString:
		return "UnexpEOFInString"
	case ErrUnexpEOFInComment:
		return "UnexpEOFInComment"
	case ErrNonDigitInConst:
		return "NonDigitInConst"
	case ErrDigitRadix:
		return "DigitRadix"
	case ErrFloatRadix:
		return "FloatRadix"
	case ErrFloatMalformed:
		return "FloatMalformed"
	default:
		return fmt.Sprintf("ErrorType(%d)", e)
	}
}

// FileError values corresponding to errno codes returned from file operations
// on UNIX. Unlike errno codes, GFileError values are available on all systems,
// even Windows. The exact meaning of each code depends on what sort of file
// operation you were performing; the UNIX documentation gives more details.
// The following error code descriptions come from the GNU C Library manual,
// and are under the copyright of that manual.
//
// It's not very portable to make detailed assumptions about exactly which
// errors will be returned from a given operation. Some errors don't occur on
// some systems, etc., sometimes there are subtle differences in when a system
// will report a given error, etc.
type FileError C.gint

const (
	// FileErrorExist: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorExist FileError = iota
	// FileErrorIsdir: file is a directory; you cannot open a directory for
	// writing, or create or remove hard links to it.
	FileErrorIsdir
	// FileErrorAcces: permission denied; the file permissions do not allow the
	// attempted operation.
	FileErrorAcces
	// FileErrorNametoolong: filename too long.
	FileErrorNametoolong
	// FileErrorNoent: no such file or directory. This is a "file doesn't exist"
	// error for ordinary files that are referenced in contexts where they are
	// expected to already exist.
	FileErrorNoent
	// FileErrorNotdir: file that isn't a directory was specified when a
	// directory is required.
	FileErrorNotdir
	// FileErrorNxio: no such device or address. The system tried to use the
	// device represented by a file you specified, and it couldn't find the
	// device. This can mean that the device file was installed incorrectly,
	// or that the physical device is missing or not correctly attached to the
	// computer.
	FileErrorNxio
	// FileErrorNodev: underlying file system of the specified file does not
	// support memory mapping.
	FileErrorNodev
	// FileErrorRofs: directory containing the new link can't be modified
	// because it's on a read-only file system.
	FileErrorRofs
	// FileErrorTxtbsy: text file busy.
	FileErrorTxtbsy
	// FileErrorFault: you passed in a pointer to bad memory. (GLib won't
	// reliably return this, don't pass in pointers to bad memory.).
	FileErrorFault
	// FileErrorLoop: too many levels of symbolic links were encountered in
	// looking up a file name. This often indicates a cycle of symbolic links.
	FileErrorLoop
	// FileErrorNospc: no space left on device; write operation on a file failed
	// because the disk is full.
	FileErrorNospc
	// FileErrorNOMEM: no memory available. The system cannot allocate more
	// virtual memory because its capacity is full.
	FileErrorNOMEM
	// FileErrorMfile: current process has too many files open and can't open
	// any more. Duplicate descriptors do count toward this limit.
	FileErrorMfile
	// FileErrorNfile: there are too many distinct file openings in the entire
	// system.
	FileErrorNfile
	// FileErrorBadf: bad file descriptor; for example, I/O on a descriptor that
	// has been closed or reading from a descriptor open only for writing (or
	// vice versa).
	FileErrorBadf
	// FileErrorInval: invalid argument. This is used to indicate various kinds
	// of problems with passing the wrong argument to a library function.
	FileErrorInval
	// FileErrorPipe: broken pipe; there is no process reading from the other
	// end of a pipe. Every library function that returns this error code also
	// generates a 'SIGPIPE' signal; this signal terminates the program if not
	// handled or blocked. Thus, your program will never actually see this code
	// unless it has handled or blocked 'SIGPIPE'.
	FileErrorPipe
	// FileErrorAgain: resource temporarily unavailable; the call might work if
	// you try again later.
	FileErrorAgain
	// FileErrorIntr: interrupted function call; an asynchronous signal occurred
	// and prevented completion of the call. When this happens, you should try
	// the call again.
	FileErrorIntr
	// FileErrorIO: input/output error; usually used for physical read or write
	// errors. i.e. the disk or other physical device hardware is returning
	// errors.
	FileErrorIO
	// FileErrorPerm: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorPerm
	// FileErrorNosys: function not implemented; this indicates that the system
	// is missing some functionality.
	FileErrorNosys
	// FileErrorFailed does not correspond to a UNIX error code; this is the
	// standard "failed for unspecified reason" error code present in all
	// #GError error code enumerations. Returned if no specific code applies.
	FileErrorFailed
)

// String returns the name in string for FileError.
func (f FileError) String() string {
	switch f {
	case FileErrorExist:
		return "Exist"
	case FileErrorIsdir:
		return "Isdir"
	case FileErrorAcces:
		return "Acces"
	case FileErrorNametoolong:
		return "Nametoolong"
	case FileErrorNoent:
		return "Noent"
	case FileErrorNotdir:
		return "Notdir"
	case FileErrorNxio:
		return "Nxio"
	case FileErrorNodev:
		return "Nodev"
	case FileErrorRofs:
		return "Rofs"
	case FileErrorTxtbsy:
		return "Txtbsy"
	case FileErrorFault:
		return "Fault"
	case FileErrorLoop:
		return "Loop"
	case FileErrorNospc:
		return "Nospc"
	case FileErrorNOMEM:
		return "NOMEM"
	case FileErrorMfile:
		return "Mfile"
	case FileErrorNfile:
		return "Nfile"
	case FileErrorBadf:
		return "Badf"
	case FileErrorInval:
		return "Inval"
	case FileErrorPipe:
		return "Pipe"
	case FileErrorAgain:
		return "Again"
	case FileErrorIntr:
		return "Intr"
	case FileErrorIO:
		return "IO"
	case FileErrorPerm:
		return "Perm"
	case FileErrorNosys:
		return "Nosys"
	case FileErrorFailed:
		return "Failed"
	default:
		return fmt.Sprintf("FileError(%d)", f)
	}
}

// IOChannelError: error codes returned by OChannel operations.
type IOChannelError C.gint

const (
	// IOChannelErrorFbig: file too large.
	IOChannelErrorFbig IOChannelError = iota
	// IOChannelErrorInval: invalid argument.
	IOChannelErrorInval
	// IOChannelErrorIO: IO error.
	IOChannelErrorIO
	// IOChannelErrorIsdir: file is a directory.
	IOChannelErrorIsdir
	// IOChannelErrorNospc: no space left on device.
	IOChannelErrorNospc
	// IOChannelErrorNxio: no such device or address.
	IOChannelErrorNxio
	// IOChannelErrorOverflow: value too large for defined datatype.
	IOChannelErrorOverflow
	// IOChannelErrorPipe: broken pipe.
	IOChannelErrorPipe
	// IOChannelErrorFailed: some other error.
	IOChannelErrorFailed
)

// String returns the name in string for IOChannelError.
func (i IOChannelError) String() string {
	switch i {
	case IOChannelErrorFbig:
		return "Fbig"
	case IOChannelErrorInval:
		return "Inval"
	case IOChannelErrorIO:
		return "IO"
	case IOChannelErrorIsdir:
		return "Isdir"
	case IOChannelErrorNospc:
		return "Nospc"
	case IOChannelErrorNxio:
		return "Nxio"
	case IOChannelErrorOverflow:
		return "Overflow"
	case IOChannelErrorPipe:
		return "Pipe"
	case IOChannelErrorFailed:
		return "Failed"
	default:
		return fmt.Sprintf("IOChannelError(%d)", i)
	}
}

// IOError is only used by the deprecated functions g_io_channel_read(),
// g_io_channel_write(), and g_io_channel_seek().
type IOError C.gint

const (
	// IOErrorNone: no error.
	IOErrorNone IOError = iota
	// IOErrorAgain: EAGAIN error occurred.
	IOErrorAgain
	// IOErrorInval: EINVAL error occurred.
	IOErrorInval
	// IOErrorUnknown: another error occurred.
	IOErrorUnknown
)

// String returns the name in string for IOError.
func (i IOError) String() string {
	switch i {
	case IOErrorNone:
		return "None"
	case IOErrorAgain:
		return "Again"
	case IOErrorInval:
		return "Inval"
	case IOErrorUnknown:
		return "Unknown"
	default:
		return fmt.Sprintf("IOError(%d)", i)
	}
}

// IOStatus statuses returned by most of the OFuncs functions.
type IOStatus C.gint

const (
	// IOStatusError: error occurred.
	IOStatusError IOStatus = iota
	// IOStatusNormal: success.
	IOStatusNormal
	// IOStatusEOF: end of file.
	IOStatusEOF
	// IOStatusAgain: resource temporarily unavailable.
	IOStatusAgain
)

// String returns the name in string for IOStatus.
func (i IOStatus) String() string {
	switch i {
	case IOStatusError:
		return "Error"
	case IOStatusNormal:
		return "Normal"
	case IOStatusEOF:
		return "EOF"
	case IOStatusAgain:
		return "Again"
	default:
		return fmt.Sprintf("IOStatus(%d)", i)
	}
}

// KeyFileError: error codes returned by key file parsing.
type KeyFileError C.gint

const (
	// KeyFileErrorUnknownEncoding: text being parsed was in an unknown
	// encoding.
	KeyFileErrorUnknownEncoding KeyFileError = iota
	// KeyFileErrorParse: document was ill-formed.
	KeyFileErrorParse
	// KeyFileErrorNotFound: file was not found.
	KeyFileErrorNotFound
	// KeyFileErrorKeyNotFound: requested key was not found.
	KeyFileErrorKeyNotFound
	// KeyFileErrorGroupNotFound: requested group was not found.
	KeyFileErrorGroupNotFound
	// KeyFileErrorInvalidValue: value could not be parsed.
	KeyFileErrorInvalidValue
)

// String returns the name in string for KeyFileError.
func (k KeyFileError) String() string {
	switch k {
	case KeyFileErrorUnknownEncoding:
		return "UnknownEncoding"
	case KeyFileErrorParse:
		return "Parse"
	case KeyFileErrorNotFound:
		return "NotFound"
	case KeyFileErrorKeyNotFound:
		return "KeyNotFound"
	case KeyFileErrorGroupNotFound:
		return "GroupNotFound"
	case KeyFileErrorInvalidValue:
		return "InvalidValue"
	default:
		return fmt.Sprintf("KeyFileError(%d)", k)
	}
}

// LogWriterOutput: return values from WriterFuncs to indicate whether the given
// log entry was successfully handled by the writer, or whether there was an
// error in handling it (and hence a fallback writer should be used).
//
// If a WriterFunc ignores a log entry, it should return G_LOG_WRITER_HANDLED.
type LogWriterOutput C.gint

const (
	// LogWriterHandled: log writer has handled the log entry.
	LogWriterHandled LogWriterOutput = 1
	// LogWriterUnhandled: log writer could not handle the log entry.
	LogWriterUnhandled LogWriterOutput = 0
)

// String returns the name in string for LogWriterOutput.
func (l LogWriterOutput) String() string {
	switch l {
	case LogWriterHandled:
		return "Handled"
	case LogWriterUnhandled:
		return "Unhandled"
	default:
		return fmt.Sprintf("LogWriterOutput(%d)", l)
	}
}

// MarkupError: error codes returned by markup parsing.
type MarkupError C.gint

const (
	// MarkupErrorBadUTF8: text being parsed was not valid UTF-8.
	MarkupErrorBadUTF8 MarkupError = iota
	// MarkupErrorEmpty: document contained nothing, or only whitespace.
	MarkupErrorEmpty
	// MarkupErrorParse: document was ill-formed.
	MarkupErrorParse
	// MarkupErrorUnknownElement: error should be set by Parser functions;
	// element wasn't known.
	MarkupErrorUnknownElement
	// MarkupErrorUnknownAttribute: error should be set by Parser functions;
	// attribute wasn't known.
	MarkupErrorUnknownAttribute
	// MarkupErrorInvalidContent: error should be set by Parser functions;
	// content was invalid.
	MarkupErrorInvalidContent
	// MarkupErrorMissingAttribute: error should be set by Parser functions;
	// a required attribute was missing.
	MarkupErrorMissingAttribute
)

// String returns the name in string for MarkupError.
func (m MarkupError) String() string {
	switch m {
	case MarkupErrorBadUTF8:
		return "BadUTF8"
	case MarkupErrorEmpty:
		return "Empty"
	case MarkupErrorParse:
		return "Parse"
	case MarkupErrorUnknownElement:
		return "UnknownElement"
	case MarkupErrorUnknownAttribute:
		return "UnknownAttribute"
	case MarkupErrorInvalidContent:
		return "InvalidContent"
	case MarkupErrorMissingAttribute:
		return "MissingAttribute"
	default:
		return fmt.Sprintf("MarkupError(%d)", m)
	}
}

// NormalizeMode defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with an accent
// is represented as a base character and combining accent or as a single
// precomposed character. Unicode strings should generally be normalized before
// comparing them.
type NormalizeMode C.gint

const (
	// NormalizeDefault: standardize differences that do not affect the text
	// content, such as the above-mentioned accent representation.
	NormalizeDefault NormalizeMode = 0
	// NormalizeNFD: another name for G_NORMALIZE_DEFAULT.
	NormalizeNFD NormalizeMode = 0
	// NormalizeDefaultCompose: like G_NORMALIZE_DEFAULT, but with composed
	// forms rather than a maximally decomposed form.
	NormalizeDefaultCompose NormalizeMode = 1
	// NormalizeNFC: another name for G_NORMALIZE_DEFAULT_COMPOSE.
	NormalizeNFC NormalizeMode = 1
	// NormalizeAll: beyond G_NORMALIZE_DEFAULT also standardize the
	// "compatibility" characters in Unicode, such as SUPERSCRIPT THREE to the
	// standard forms (in this case DIGIT THREE). Formatting information may be
	// lost but for most text operations such characters should be considered
	// the same.
	NormalizeAll NormalizeMode = 2
	// NormalizeNFKD: another name for G_NORMALIZE_ALL.
	NormalizeNFKD NormalizeMode = 2
	// NormalizeAllCompose: like G_NORMALIZE_ALL, but with composed forms rather
	// than a maximally decomposed form.
	NormalizeAllCompose NormalizeMode = 3
	// NormalizeNFKC: another name for G_NORMALIZE_ALL_COMPOSE.
	NormalizeNFKC NormalizeMode = 3
)

func marshalNormalizeMode(p uintptr) (interface{}, error) {
	return NormalizeMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NormalizeMode.
func (n NormalizeMode) String() string {
	switch n {
	case NormalizeDefault:
		return "Default"
	case NormalizeDefaultCompose:
		return "DefaultCompose"
	case NormalizeAll:
		return "All"
	case NormalizeAllCompose:
		return "AllCompose"
	default:
		return fmt.Sprintf("NormalizeMode(%d)", n)
	}
}

// OptionArg enum values determine which type of extra argument the options
// expect to find. If an option expects an extra argument, it can be specified
// in several ways; with a short option: -x arg, with a long option: --name arg
// or combined in a single argument: --name=arg.
type OptionArg C.gint

const (
	// OptionArgNone: no extra argument. This is useful for simple flags or
	// booleans.
	OptionArgNone OptionArg = iota
	// OptionArgString: option takes a UTF-8 string argument.
	OptionArgString
	// OptionArgInt: option takes an integer argument.
	OptionArgInt
	// OptionArgCallback: option provides a callback (of type ArgFunc) to parse
	// the extra argument.
	OptionArgCallback
	// OptionArgFilename: option takes a filename as argument, which will be in
	// the GLib filename encoding rather than UTF-8.
	OptionArgFilename
	// OptionArgStringArray: option takes a string argument, multiple uses of
	// the option are collected into an array of strings.
	OptionArgStringArray
	// OptionArgFilenameArray: option takes a filename as argument, multiple
	// uses of the option are collected into an array of strings.
	OptionArgFilenameArray
	// OptionArgDouble: option takes a double argument. The argument can be
	// formatted either for the user's locale or for the "C" locale. Since 2.12.
	OptionArgDouble
	// OptionArgInt64: option takes a 64-bit integer. Like G_OPTION_ARG_INT but
	// for larger numbers. The number can be in decimal base, or in hexadecimal
	// (when prefixed with 0x, for example, 0xffffffff). Since 2.12.
	OptionArgInt64
)

// String returns the name in string for OptionArg.
func (o OptionArg) String() string {
	switch o {
	case OptionArgNone:
		return "None"
	case OptionArgString:
		return "String"
	case OptionArgInt:
		return "Int"
	case OptionArgCallback:
		return "Callback"
	case OptionArgFilename:
		return "Filename"
	case OptionArgStringArray:
		return "StringArray"
	case OptionArgFilenameArray:
		return "FilenameArray"
	case OptionArgDouble:
		return "Double"
	case OptionArgInt64:
		return "Int64"
	default:
		return fmt.Sprintf("OptionArg(%d)", o)
	}
}

// OptionError: error codes returned by option parsing.
type OptionError C.gint

const (
	// OptionErrorUnknownOption: option was not known to the parser. This error
	// will only be reported, if the parser hasn't been instructed to ignore
	// unknown options, see g_option_context_set_ignore_unknown_options().
	OptionErrorUnknownOption OptionError = iota
	// OptionErrorBadValue: value couldn't be parsed.
	OptionErrorBadValue
	// OptionErrorFailed callback failed.
	OptionErrorFailed
)

// String returns the name in string for OptionError.
func (o OptionError) String() string {
	switch o {
	case OptionErrorUnknownOption:
		return "UnknownOption"
	case OptionErrorBadValue:
		return "BadValue"
	case OptionErrorFailed:
		return "Failed"
	default:
		return fmt.Sprintf("OptionError(%d)", o)
	}
}

// RegexError: error codes returned by regular expressions functions.
type RegexError C.gint

const (
	// RegexErrorCompile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace: replacement failed due to an ill-formed replacement
	// string.
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch: match process failed.
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal: internal error of the regular expression engine.
	// Since 2.16.
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash: "\\" at end of pattern. Since 2.16.
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar: "\\c" at end of pattern. Since 2.16.
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape: unrecognized character follows "\\".
	// Since 2.16.
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder numbers out of order in "{}" quantifier.
	// Since 2.16.
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig: number too big in "{}" quantifier. Since
	// 2.16.
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass: missing terminating "]" for
	// character class. Since 2.16.
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass: invalid escape sequence in
	// character class. Since 2.16.
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder: range out of order in character class.
	// Since 2.16.
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat: nothing to repeat. Since 2.16.
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter: unrecognized character after "(?",
	// "(?<" or "(?P". Since 2.16.
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass: POSIX named classes are supported
	// only within a class. Since 2.16.
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis: missing terminating ")" or ")" without
	// opening "(". Since 2.16.
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference: reference to non-existent
	// subpattern. Since 2.16.
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment: missing terminating ")" after comment.
	// Since 2.16.
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge: regular expression too large. Since 2.16.
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError: failed to get memory. Since 2.16.
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind: lookbehind assertion is not fixed
	// length. Since 2.16.
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition: malformed number or name after "(?(".
	// Since 2.16.
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches: conditional group contains more
	// than two branches. Since 2.16.
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected: assertion expected after "(?(". Since 2.16.
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName: unknown POSIX class name. Since 2.16.
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported: POSIX collating elements
	// are not supported. Since 2.16.
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge: character value in "\\x{...}" sequence is too
	// large. Since 2.16.
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition: invalid condition "(?(0)". Since 2.16.
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind: \\C not allowed in lookbehind
	// assertion. Since 2.16.
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop: recursive call could loop indefinitely. Since
	// 2.16.
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator: missing terminator in
	// subpattern name. Since 2.16.
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName: two named subpatterns have the same
	// name. Since 2.16.
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty: malformed "\\P" or "\\p" sequence. Since
	// 2.16.
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty: unknown property name after "\\P" or "\\p".
	// Since 2.16.
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16.
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns: too many named subpatterns (maximum
	// 10,000). Since 2.16.
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue: octal value is greater than "\\377".
	// Since 2.16.
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine: "DEFINE" group contains more than one
	// branch. Since 2.16.
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion: repeating a "DEFINE" group is not allowed.
	// This error is never raised. Since: 2.16 Deprecated: 2.34.
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions: inconsistent newline options.
	// Since 2.16.
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference: "\\g" is not followed by a braced,
	// angle-bracketed, or quoted name or number, or by a plain number. Since:
	// 2.16.
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference: relative reference must not be zero.
	// Since: 2.34.
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden: backtracing control
	// verb used does not allow an argument. Since: 2.34.
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb: unknown backtracing control
	// verb. Since: 2.34.
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig: number is too big in escape sequence. Since:
	// 2.34.
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName: missing subpattern name. Since: 2.34.
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit: missing digit. Since 2.34.
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter: in JavaScript compatibility mode,
	// "[" is an invalid data character. Since: 2.34.
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName: different names for subpatterns of the
	// same number are not allowed. Since: 2.34.
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired: backtracing control
	// verb requires an argument. Since: 2.34.
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar: "\\c" must be followed by an ASCII
	// character. Since: 2.34.
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName: "\\k" is not followed by a braced,
	// angle-bracketed, or quoted name. Since: 2.34.
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass: "\\N" is not supported in a class. Since:
	// 2.34.
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences: too many forward references. Since:
	// 2.34.
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong: name is too long in "(*MARK)", "(*PRUNE)",
	// "(*SKIP)", or "(*THEN)". Since: 2.34.
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge: character value in the \\u sequence is
	// too large. Since: 2.34.
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// String returns the name in string for RegexError.
func (r RegexError) String() string {
	switch r {
	case RegexErrorCompile:
		return "Compile"
	case RegexErrorOptimize:
		return "Optimize"
	case RegexErrorReplace:
		return "Replace"
	case RegexErrorMatch:
		return "Match"
	case RegexErrorInternal:
		return "Internal"
	case RegexErrorStrayBackslash:
		return "StrayBackslash"
	case RegexErrorMissingControlChar:
		return "MissingControlChar"
	case RegexErrorUnrecognizedEscape:
		return "UnrecognizedEscape"
	case RegexErrorQuantifiersOutOfOrder:
		return "QuantifiersOutOfOrder"
	case RegexErrorQuantifierTooBig:
		return "QuantifierTooBig"
	case RegexErrorUnterminatedCharacterClass:
		return "UnterminatedCharacterClass"
	case RegexErrorInvalidEscapeInCharacterClass:
		return "InvalidEscapeInCharacterClass"
	case RegexErrorRangeOutOfOrder:
		return "RangeOutOfOrder"
	case RegexErrorNothingToRepeat:
		return "NothingToRepeat"
	case RegexErrorUnrecognizedCharacter:
		return "UnrecognizedCharacter"
	case RegexErrorPosixNamedClassOutsideClass:
		return "PosixNamedClassOutsideClass"
	case RegexErrorUnmatchedParenthesis:
		return "UnmatchedParenthesis"
	case RegexErrorInexistentSubpatternReference:
		return "InexistentSubpatternReference"
	case RegexErrorUnterminatedComment:
		return "UnterminatedComment"
	case RegexErrorExpressionTooLarge:
		return "ExpressionTooLarge"
	case RegexErrorMemoryError:
		return "MemoryError"
	case RegexErrorVariableLengthLookbehind:
		return "VariableLengthLookbehind"
	case RegexErrorMalformedCondition:
		return "MalformedCondition"
	case RegexErrorTooManyConditionalBranches:
		return "TooManyConditionalBranches"
	case RegexErrorAssertionExpected:
		return "AssertionExpected"
	case RegexErrorUnknownPosixClassName:
		return "UnknownPosixClassName"
	case RegexErrorPosixCollatingElementsNotSupported:
		return "PosixCollatingElementsNotSupported"
	case RegexErrorHexCodeTooLarge:
		return "HexCodeTooLarge"
	case RegexErrorInvalidCondition:
		return "InvalidCondition"
	case RegexErrorSingleByteMatchInLookbehind:
		return "SingleByteMatchInLookbehind"
	case RegexErrorInfiniteLoop:
		return "InfiniteLoop"
	case RegexErrorMissingSubpatternNameTerminator:
		return "MissingSubpatternNameTerminator"
	case RegexErrorDuplicateSubpatternName:
		return "DuplicateSubpatternName"
	case RegexErrorMalformedProperty:
		return "MalformedProperty"
	case RegexErrorUnknownProperty:
		return "UnknownProperty"
	case RegexErrorSubpatternNameTooLong:
		return "SubpatternNameTooLong"
	case RegexErrorTooManySubpatterns:
		return "TooManySubpatterns"
	case RegexErrorInvalidOctalValue:
		return "InvalidOctalValue"
	case RegexErrorTooManyBranchesInDefine:
		return "TooManyBranchesInDefine"
	case RegexErrorDefineRepetion:
		return "DefineRepetion"
	case RegexErrorInconsistentNewlineOptions:
		return "InconsistentNewlineOptions"
	case RegexErrorMissingBackReference:
		return "MissingBackReference"
	case RegexErrorInvalidRelativeReference:
		return "InvalidRelativeReference"
	case RegexErrorBacktrackingControlVerbArgumentForbidden:
		return "BacktrackingControlVerbArgumentForbidden"
	case RegexErrorUnknownBacktrackingControlVerb:
		return "UnknownBacktrackingControlVerb"
	case RegexErrorNumberTooBig:
		return "NumberTooBig"
	case RegexErrorMissingSubpatternName:
		return "MissingSubpatternName"
	case RegexErrorMissingDigit:
		return "MissingDigit"
	case RegexErrorInvalidDataCharacter:
		return "InvalidDataCharacter"
	case RegexErrorExtraSubpatternName:
		return "ExtraSubpatternName"
	case RegexErrorBacktrackingControlVerbArgumentRequired:
		return "BacktrackingControlVerbArgumentRequired"
	case RegexErrorInvalidControlChar:
		return "InvalidControlChar"
	case RegexErrorMissingName:
		return "MissingName"
	case RegexErrorNotSupportedInClass:
		return "NotSupportedInClass"
	case RegexErrorTooManyForwardReferences:
		return "TooManyForwardReferences"
	case RegexErrorNameTooLong:
		return "NameTooLong"
	case RegexErrorCharacterValueTooLarge:
		return "CharacterValueTooLarge"
	default:
		return fmt.Sprintf("RegexError(%d)", r)
	}
}

// SeekType: enumeration specifying the base position for a
// g_io_channel_seek_position() operation.
type SeekType C.gint

const (
	// SeekCur: current position in the file.
	SeekCur SeekType = iota
	// SeekSet: start of the file.
	SeekSet
	// SeekEnd: end of the file.
	SeekEnd
)

// String returns the name in string for SeekType.
func (s SeekType) String() string {
	switch s {
	case SeekCur:
		return "Cur"
	case SeekSet:
		return "Set"
	case SeekEnd:
		return "End"
	default:
		return fmt.Sprintf("SeekType(%d)", s)
	}
}

// ShellError: error codes returned by shell functions.
type ShellError C.gint

const (
	// ShellErrorBadQuoting: mismatched or otherwise mangled quoting.
	ShellErrorBadQuoting ShellError = iota
	// ShellErrorEmptyString: string to be parsed was empty.
	ShellErrorEmptyString
	// ShellErrorFailed: some other error.
	ShellErrorFailed
)

// String returns the name in string for ShellError.
func (s ShellError) String() string {
	switch s {
	case ShellErrorBadQuoting:
		return "BadQuoting"
	case ShellErrorEmptyString:
		return "EmptyString"
	case ShellErrorFailed:
		return "Failed"
	default:
		return fmt.Sprintf("ShellError(%d)", s)
	}
}

// SpawnError: error codes returned by spawning processes.
type SpawnError C.gint

const (
	// SpawnErrorFork: fork failed due to lack of memory.
	SpawnErrorFork SpawnError = 0
	// SpawnErrorRead: read or select on pipes failed.
	SpawnErrorRead SpawnError = 1
	// SpawnErrorChdir: changing to working directory failed.
	SpawnErrorChdir SpawnError = 2
	// SpawnErrorAcces: execv() returned EACCES.
	SpawnErrorAcces SpawnError = 3
	// SpawnErrorPerm: execv() returned EPERM.
	SpawnErrorPerm SpawnError = 4
	// SpawnErrorTooBig: execv() returned E2BIG.
	SpawnErrorTooBig SpawnError = 5
	// SpawnError2Big: deprecated alias for G_SPAWN_ERROR_TOO_BIG (deprecated
	// since GLib 2.32).
	SpawnError2Big SpawnError = 5
	// SpawnErrorNoexec: execv() returned ENOEXEC.
	SpawnErrorNoexec SpawnError = 6
	// SpawnErrorNametoolong: execv() returned ENAMETOOLONG.
	SpawnErrorNametoolong SpawnError = 7
	// SpawnErrorNoent: execv() returned ENOENT.
	SpawnErrorNoent SpawnError = 8
	// SpawnErrorNOMEM: execv() returned ENOMEM.
	SpawnErrorNOMEM SpawnError = 9
	// SpawnErrorNotdir: execv() returned ENOTDIR.
	SpawnErrorNotdir SpawnError = 10
	// SpawnErrorLoop: execv() returned ELOOP.
	SpawnErrorLoop SpawnError = 11
	// SpawnErrorTxtbusy: execv() returned ETXTBUSY.
	SpawnErrorTxtbusy SpawnError = 12
	// SpawnErrorIO: execv() returned EIO.
	SpawnErrorIO SpawnError = 13
	// SpawnErrorNfile: execv() returned ENFILE.
	SpawnErrorNfile SpawnError = 14
	// SpawnErrorMfile: execv() returned EMFILE.
	SpawnErrorMfile SpawnError = 15
	// SpawnErrorInval: execv() returned EINVAL.
	SpawnErrorInval SpawnError = 16
	// SpawnErrorIsdir: execv() returned EISDIR.
	SpawnErrorIsdir SpawnError = 17
	// SpawnErrorLibbad: execv() returned ELIBBAD.
	SpawnErrorLibbad SpawnError = 18
	// SpawnErrorFailed: some other fatal failure, error->message should
	// explain.
	SpawnErrorFailed SpawnError = 19
)

// String returns the name in string for SpawnError.
func (s SpawnError) String() string {
	switch s {
	case SpawnErrorFork:
		return "Fork"
	case SpawnErrorRead:
		return "Read"
	case SpawnErrorChdir:
		return "Chdir"
	case SpawnErrorAcces:
		return "Acces"
	case SpawnErrorPerm:
		return "Perm"
	case SpawnErrorTooBig:
		return "TooBig"
	case SpawnErrorNoexec:
		return "Noexec"
	case SpawnErrorNametoolong:
		return "Nametoolong"
	case SpawnErrorNoent:
		return "Noent"
	case SpawnErrorNOMEM:
		return "NOMEM"
	case SpawnErrorNotdir:
		return "Notdir"
	case SpawnErrorLoop:
		return "Loop"
	case SpawnErrorTxtbusy:
		return "Txtbusy"
	case SpawnErrorIO:
		return "IO"
	case SpawnErrorNfile:
		return "Nfile"
	case SpawnErrorMfile:
		return "Mfile"
	case SpawnErrorInval:
		return "Inval"
	case SpawnErrorIsdir:
		return "Isdir"
	case SpawnErrorLibbad:
		return "Libbad"
	case SpawnErrorFailed:
		return "Failed"
	default:
		return fmt.Sprintf("SpawnError(%d)", s)
	}
}

// TimeType disambiguates a given time in two ways.
//
// First, specifies if the given time is in universal or local time.
//
// Second, if the time is in local time, specifies if it is local standard time
// or local daylight time. This is important for the case where the same local
// time occurs twice (during daylight savings time transitions, for example).
type TimeType C.gint

const (
	// TimeTypeStandard: time is in local standard time.
	TimeTypeStandard TimeType = iota
	// TimeTypeDaylight: time is in local daylight time.
	TimeTypeDaylight
	// TimeTypeUniversal: time is in UTC.
	TimeTypeUniversal
)

// String returns the name in string for TimeType.
func (t TimeType) String() string {
	switch t {
	case TimeTypeStandard:
		return "Standard"
	case TimeTypeDaylight:
		return "Daylight"
	case TimeTypeUniversal:
		return "Universal"
	default:
		return fmt.Sprintf("TimeType(%d)", t)
	}
}

// TokenType: possible types of token returned from each
// g_scanner_get_next_token() call.
type TokenType C.gint

const (
	// TokenEOF: end of the file.
	TokenEOF TokenType = 0
	// TokenLeftParen: '(' character.
	TokenLeftParen TokenType = 40
	// TokenRightParen: ')' character.
	TokenRightParen TokenType = 41
	// TokenLeftCurly: '{' character.
	TokenLeftCurly TokenType = 123
	// TokenRightCurly: '}' character.
	TokenRightCurly TokenType = 125
	// TokenLeftBrace: '[' character.
	TokenLeftBrace TokenType = 91
	// TokenRightBrace: ']' character.
	TokenRightBrace TokenType = 93
	// TokenEqualSign: '=' character.
	TokenEqualSign TokenType = 61
	// TokenComma: ',' character.
	TokenComma TokenType = 44
	// TokenNone: not a token.
	TokenNone TokenType = 256
	// TokenError: error occurred.
	TokenError TokenType = 257
	// TokenChar: character.
	TokenChar TokenType = 258
	// TokenBinary: binary integer.
	TokenBinary TokenType = 259
	// TokenOctal: octal integer.
	TokenOctal TokenType = 260
	// TokenInt: integer.
	TokenInt TokenType = 261
	// TokenHex: hex integer.
	TokenHex TokenType = 262
	// TokenFloat: floating point number.
	TokenFloat TokenType = 263
	// TokenString: string.
	TokenString TokenType = 264
	// TokenSymbol: symbol.
	TokenSymbol TokenType = 265
	// TokenIdentifier: identifier.
	TokenIdentifier TokenType = 266
	// TokenIdentifierNull: null identifier.
	TokenIdentifierNull TokenType = 267
	// TokenCommentSingle: one line comment.
	TokenCommentSingle TokenType = 268
	// TokenCommentMulti: multi line comment.
	TokenCommentMulti TokenType = 269
)

// String returns the name in string for TokenType.
func (t TokenType) String() string {
	switch t {
	case TokenEOF:
		return "EOF"
	case TokenLeftParen:
		return "LeftParen"
	case TokenRightParen:
		return "RightParen"
	case TokenLeftCurly:
		return "LeftCurly"
	case TokenRightCurly:
		return "RightCurly"
	case TokenLeftBrace:
		return "LeftBrace"
	case TokenRightBrace:
		return "RightBrace"
	case TokenEqualSign:
		return "EqualSign"
	case TokenComma:
		return "Comma"
	case TokenNone:
		return "None"
	case TokenError:
		return "Error"
	case TokenChar:
		return "Char"
	case TokenBinary:
		return "Binary"
	case TokenOctal:
		return "Octal"
	case TokenInt:
		return "Int"
	case TokenHex:
		return "Hex"
	case TokenFloat:
		return "Float"
	case TokenString:
		return "String"
	case TokenSymbol:
		return "Symbol"
	case TokenIdentifier:
		return "Identifier"
	case TokenIdentifierNull:
		return "IdentifierNull"
	case TokenCommentSingle:
		return "CommentSingle"
	case TokenCommentMulti:
		return "CommentMulti"
	default:
		return fmt.Sprintf("TokenType(%d)", t)
	}
}

// TraverseType specifies the type of traversal performed by g_tree_traverse(),
// g_node_traverse() and g_node_find(). The different orders are illustrated
// here:
//
// - In order: A, B, C, D, E, F, G, H, I ! (Sorted_binary_tree_inorder.svg)
//
// - Pre order: F, B, A, D, C, E, G, I, H ! (Sorted_binary_tree_preorder.svg)
//
// - Post order: A, C, E, D, B, H, I, G, F ! (Sorted_binary_tree_postorder.svg)
//
// - Level order: F, B, G, A, D, I, C, E, H !
// (Sorted_binary_tree_breadth-first_traversal.svg).
type TraverseType C.gint

const (
	// InOrder vists a node's left child first, then the node itself, then
	// its right child. This is the one to use if you want the output sorted
	// according to the compare function.
	InOrder TraverseType = iota
	// PreOrder visits a node, then its children.
	PreOrder
	// PostOrder visits the node's children, then the node itself.
	PostOrder
	// LevelOrder is not implemented for [balanced binary
	// trees][glib-Balanced-Binary-Trees]. For [n-ary trees][glib-N-ary-Trees],
	// it vists the root node first, then its children, then its grandchildren,
	// and so on. Note that this is less efficient than the other orders.
	LevelOrder
)

// String returns the name in string for TraverseType.
func (t TraverseType) String() string {
	switch t {
	case InOrder:
		return "InOrder"
	case PreOrder:
		return "PreOrder"
	case PostOrder:
		return "PostOrder"
	case LevelOrder:
		return "LevelOrder"
	default:
		return fmt.Sprintf("TraverseType(%d)", t)
	}
}

// UnicodeBreakType: these are the possible line break classifications.
//
// Since new Unicode versions may add new types here, applications
// should be ready to handle unknown values. They may be regarded as
// G_UNICODE_BREAK_UNKNOWN.
//
// See Unicode Line Breaking Algorithm (https://www.unicode.org/reports/tr14/).
type UnicodeBreakType C.gint

const (
	// UnicodeBreakMandatory: mandatory Break (BK).
	UnicodeBreakMandatory UnicodeBreakType = 0
	// UnicodeBreakCarriageReturn: carriage Return (CR).
	UnicodeBreakCarriageReturn UnicodeBreakType = 1
	// UnicodeBreakLineFeed: line Feed (LF).
	UnicodeBreakLineFeed UnicodeBreakType = 2
	// UnicodeBreakCombiningMark: attached Characters and Combining Marks (CM).
	UnicodeBreakCombiningMark UnicodeBreakType = 3
	// UnicodeBreakSurrogate surrogates (SG).
	UnicodeBreakSurrogate UnicodeBreakType = 4
	// UnicodeBreakZeroWidthSpace: zero Width Space (ZW).
	UnicodeBreakZeroWidthSpace UnicodeBreakType = 5
	// UnicodeBreakInseparable: inseparable (IN).
	UnicodeBreakInseparable UnicodeBreakType = 6
	// UnicodeBreakNonBreakingGlue: non-breaking ("Glue") (GL).
	UnicodeBreakNonBreakingGlue UnicodeBreakType = 7
	// UnicodeBreakContingent: contingent Break Opportunity (CB).
	UnicodeBreakContingent UnicodeBreakType = 8
	// UnicodeBreakSpace: space (SP).
	UnicodeBreakSpace UnicodeBreakType = 9
	// UnicodeBreakAfter: break Opportunity After (BA).
	UnicodeBreakAfter UnicodeBreakType = 10
	// UnicodeBreakBefore: break Opportunity Before (BB).
	UnicodeBreakBefore UnicodeBreakType = 11
	// UnicodeBreakBeforeAndAfter: break Opportunity Before and After (B2).
	UnicodeBreakBeforeAndAfter UnicodeBreakType = 12
	// UnicodeBreakHyphen: hyphen (HY).
	UnicodeBreakHyphen UnicodeBreakType = 13
	// UnicodeBreakNonStarter: nonstarter (NS).
	UnicodeBreakNonStarter UnicodeBreakType = 14
	// UnicodeBreakOpenPunctuation: opening Punctuation (OP).
	UnicodeBreakOpenPunctuation UnicodeBreakType = 15
	// UnicodeBreakClosePunctuation: closing Punctuation (CL).
	UnicodeBreakClosePunctuation UnicodeBreakType = 16
	// UnicodeBreakQuotation ambiguous Quotation (QU).
	UnicodeBreakQuotation UnicodeBreakType = 17
	// UnicodeBreakExclamation: exclamation/Interrogation (EX).
	UnicodeBreakExclamation UnicodeBreakType = 18
	// UnicodeBreakIdeographic: ideographic (ID).
	UnicodeBreakIdeographic UnicodeBreakType = 19
	// UnicodeBreakNumeric: numeric (NU).
	UnicodeBreakNumeric UnicodeBreakType = 20
	// UnicodeBreakInfixSeparator: infix Separator (Numeric) (IS).
	UnicodeBreakInfixSeparator UnicodeBreakType = 21
	// UnicodeBreakSymbol symbols Allowing Break After (SY).
	UnicodeBreakSymbol UnicodeBreakType = 22
	// UnicodeBreakAlphabetic: ordinary Alphabetic and Symbol Characters (AL).
	UnicodeBreakAlphabetic UnicodeBreakType = 23
	// UnicodeBreakPrefix: prefix (Numeric) (PR).
	UnicodeBreakPrefix UnicodeBreakType = 24
	// UnicodeBreakPostfix: postfix (Numeric) (PO).
	UnicodeBreakPostfix UnicodeBreakType = 25
	// UnicodeBreakComplexContext: complex Content Dependent (South East Asian)
	// (SA).
	UnicodeBreakComplexContext UnicodeBreakType = 26
	// UnicodeBreakAmbiguous ambiguous (Alphabetic or Ideographic) (AI).
	UnicodeBreakAmbiguous UnicodeBreakType = 27
	// UnicodeBreakUnknown: unknown (XX).
	UnicodeBreakUnknown UnicodeBreakType = 28
	// UnicodeBreakNextLine: next Line (NL).
	UnicodeBreakNextLine UnicodeBreakType = 29
	// UnicodeBreakWordJoiner: word Joiner (WJ).
	UnicodeBreakWordJoiner UnicodeBreakType = 30
	// UnicodeBreakHangulLJamo: hangul L Jamo (JL).
	UnicodeBreakHangulLJamo UnicodeBreakType = 31
	// UnicodeBreakHangulVJamo: hangul V Jamo (JV).
	UnicodeBreakHangulVJamo UnicodeBreakType = 32
	// UnicodeBreakHangulTJamo: hangul T Jamo (JT).
	UnicodeBreakHangulTJamo UnicodeBreakType = 33
	// UnicodeBreakHangulLvSyllable: hangul LV Syllable (H2).
	UnicodeBreakHangulLvSyllable UnicodeBreakType = 34
	// UnicodeBreakHangulLvtSyllable: hangul LVT Syllable (H3).
	UnicodeBreakHangulLvtSyllable UnicodeBreakType = 35
	// UnicodeBreakCloseParanthesis: closing Parenthesis (CP). Since 2.28.
	// Deprecated: 2.70: Use G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.
	UnicodeBreakCloseParanthesis UnicodeBreakType = 36
	// UnicodeBreakCloseParenthesis: closing Parenthesis (CP). Since 2.70.
	UnicodeBreakCloseParenthesis UnicodeBreakType = 36
	// UnicodeBreakConditionalJapaneseStarter: conditional Japanese Starter
	// (CJ). Since: 2.32.
	UnicodeBreakConditionalJapaneseStarter UnicodeBreakType = 37
	// UnicodeBreakHebrewLetter: hebrew Letter (HL). Since: 2.32.
	UnicodeBreakHebrewLetter UnicodeBreakType = 38
	// UnicodeBreakRegionalIndicator: regional Indicator (RI). Since: 2.36.
	UnicodeBreakRegionalIndicator UnicodeBreakType = 39
	// UnicodeBreakEmojiBase: emoji Base (EB). Since: 2.50.
	UnicodeBreakEmojiBase UnicodeBreakType = 40
	// UnicodeBreakEmojiModifier: emoji Modifier (EM). Since: 2.50.
	UnicodeBreakEmojiModifier UnicodeBreakType = 41
	// UnicodeBreakZeroWidthJoiner: zero Width Joiner (ZWJ). Since: 2.50.
	UnicodeBreakZeroWidthJoiner UnicodeBreakType = 42
	// UnicodeBreakAksara: aksara (AK). Since:
	// 2.80 G_UNICODE_BREAK_AKSARA_PRE_BASE (AP). Since:
	// 2.80 G_UNICODE_BREAK_AKSARA_START (AS). Since: 2.80
	// G_UNICODE_BREAK_VIRAMA_FINAL (VF). Since: 2.80 G_UNICODE_BREAK_VIRAMA
	// (VI). Since: 2.80.
	UnicodeBreakAksara        UnicodeBreakType = 43
	UnicodeBreakAksaraPreBase UnicodeBreakType = 44
	UnicodeBreakAksaraStart   UnicodeBreakType = 45
	UnicodeBreakViramaFinal   UnicodeBreakType = 46
	UnicodeBreakVirama        UnicodeBreakType = 47
)

func marshalUnicodeBreakType(p uintptr) (interface{}, error) {
	return UnicodeBreakType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for UnicodeBreakType.
func (u UnicodeBreakType) String() string {
	switch u {
	case UnicodeBreakMandatory:
		return "Mandatory"
	case UnicodeBreakCarriageReturn:
		return "CarriageReturn"
	case UnicodeBreakLineFeed:
		return "LineFeed"
	case UnicodeBreakCombiningMark:
		return "CombiningMark"
	case UnicodeBreakSurrogate:
		return "Surrogate"
	case UnicodeBreakZeroWidthSpace:
		return "ZeroWidthSpace"
	case UnicodeBreakInseparable:
		return "Inseparable"
	case UnicodeBreakNonBreakingGlue:
		return "NonBreakingGlue"
	case UnicodeBreakContingent:
		return "Contingent"
	case UnicodeBreakSpace:
		return "Space"
	case UnicodeBreakAfter:
		return "After"
	case UnicodeBreakBefore:
		return "Before"
	case UnicodeBreakBeforeAndAfter:
		return "BeforeAndAfter"
	case UnicodeBreakHyphen:
		return "Hyphen"
	case UnicodeBreakNonStarter:
		return "NonStarter"
	case UnicodeBreakOpenPunctuation:
		return "OpenPunctuation"
	case UnicodeBreakClosePunctuation:
		return "ClosePunctuation"
	case UnicodeBreakQuotation:
		return "Quotation"
	case UnicodeBreakExclamation:
		return "Exclamation"
	case UnicodeBreakIdeographic:
		return "Ideographic"
	case UnicodeBreakNumeric:
		return "Numeric"
	case UnicodeBreakInfixSeparator:
		return "InfixSeparator"
	case UnicodeBreakSymbol:
		return "Symbol"
	case UnicodeBreakAlphabetic:
		return "Alphabetic"
	case UnicodeBreakPrefix:
		return "Prefix"
	case UnicodeBreakPostfix:
		return "Postfix"
	case UnicodeBreakComplexContext:
		return "ComplexContext"
	case UnicodeBreakAmbiguous:
		return "Ambiguous"
	case UnicodeBreakUnknown:
		return "Unknown"
	case UnicodeBreakNextLine:
		return "NextLine"
	case UnicodeBreakWordJoiner:
		return "WordJoiner"
	case UnicodeBreakHangulLJamo:
		return "HangulLJamo"
	case UnicodeBreakHangulVJamo:
		return "HangulVJamo"
	case UnicodeBreakHangulTJamo:
		return "HangulTJamo"
	case UnicodeBreakHangulLvSyllable:
		return "HangulLvSyllable"
	case UnicodeBreakHangulLvtSyllable:
		return "HangulLvtSyllable"
	case UnicodeBreakCloseParanthesis:
		return "CloseParanthesis"
	case UnicodeBreakConditionalJapaneseStarter:
		return "ConditionalJapaneseStarter"
	case UnicodeBreakHebrewLetter:
		return "HebrewLetter"
	case UnicodeBreakRegionalIndicator:
		return "RegionalIndicator"
	case UnicodeBreakEmojiBase:
		return "EmojiBase"
	case UnicodeBreakEmojiModifier:
		return "EmojiModifier"
	case UnicodeBreakZeroWidthJoiner:
		return "ZeroWidthJoiner"
	case UnicodeBreakAksara:
		return "Aksara"
	case UnicodeBreakAksaraPreBase:
		return "AksaraPreBase"
	case UnicodeBreakAksaraStart:
		return "AksaraStart"
	case UnicodeBreakViramaFinal:
		return "ViramaFinal"
	case UnicodeBreakVirama:
		return "Virama"
	default:
		return fmt.Sprintf("UnicodeBreakType(%d)", u)
	}
}

// UnicodeScript enumeration identifies different writing systems. The values
// correspond to the names as defined in the Unicode standard. The enumeration
// has been added in GLib 2.14, and is interchangeable with Script.
//
// Note that new types may be added in the future. Applications should be
// ready to handle unknown values. See Unicode Standard Annex #24: Script names
// (http://www.unicode.org/reports/tr24/).
type UnicodeScript C.gint

const (
	// UnicodeScriptInvalidCode: value never returned from
	// g_unichar_get_script().
	UnicodeScriptInvalidCode UnicodeScript = -1
	// UnicodeScriptCommon: character used by multiple different scripts.
	UnicodeScriptCommon UnicodeScript = 0
	// UnicodeScriptInherited: mark glyph that takes its script from the base
	// glyph to which it is attached.
	UnicodeScriptInherited UnicodeScript = 1
	// UnicodeScriptArabic: arabic.
	UnicodeScriptArabic UnicodeScript = 2
	// UnicodeScriptArmenian: armenian.
	UnicodeScriptArmenian UnicodeScript = 3
	// UnicodeScriptBengali: bengali.
	UnicodeScriptBengali UnicodeScript = 4
	// UnicodeScriptBopomofo: bopomofo.
	UnicodeScriptBopomofo UnicodeScript = 5
	// UnicodeScriptCherokee: cherokee.
	UnicodeScriptCherokee UnicodeScript = 6
	// UnicodeScriptCoptic: coptic.
	UnicodeScriptCoptic UnicodeScript = 7
	// UnicodeScriptCyrillic: cyrillic.
	UnicodeScriptCyrillic UnicodeScript = 8
	// UnicodeScriptDeseret: deseret.
	UnicodeScriptDeseret UnicodeScript = 9
	// UnicodeScriptDevanagari: devanagari.
	UnicodeScriptDevanagari UnicodeScript = 10
	// UnicodeScriptEthiopic: ethiopic.
	UnicodeScriptEthiopic UnicodeScript = 11
	// UnicodeScriptGeorgian: georgian.
	UnicodeScriptGeorgian UnicodeScript = 12
	// UnicodeScriptGothic: gothic.
	UnicodeScriptGothic UnicodeScript = 13
	// UnicodeScriptGreek: greek.
	UnicodeScriptGreek UnicodeScript = 14
	// UnicodeScriptGujarati: gujarati.
	UnicodeScriptGujarati UnicodeScript = 15
	// UnicodeScriptGurmukhi: gurmukhi.
	UnicodeScriptGurmukhi UnicodeScript = 16
	// UnicodeScriptHan: han.
	UnicodeScriptHan UnicodeScript = 17
	// UnicodeScriptHangul: hangul.
	UnicodeScriptHangul UnicodeScript = 18
	// UnicodeScriptHebrew: hebrew.
	UnicodeScriptHebrew UnicodeScript = 19
	// UnicodeScriptHiragana: hiragana.
	UnicodeScriptHiragana UnicodeScript = 20
	// UnicodeScriptKannada: kannada.
	UnicodeScriptKannada UnicodeScript = 21
	// UnicodeScriptKatakana: katakana.
	UnicodeScriptKatakana UnicodeScript = 22
	// UnicodeScriptKhmer: khmer.
	UnicodeScriptKhmer UnicodeScript = 23
	// UnicodeScriptLao: lao.
	UnicodeScriptLao UnicodeScript = 24
	// UnicodeScriptLatin: latin.
	UnicodeScriptLatin UnicodeScript = 25
	// UnicodeScriptMalayalam: malayalam.
	UnicodeScriptMalayalam UnicodeScript = 26
	// UnicodeScriptMongolian: mongolian.
	UnicodeScriptMongolian UnicodeScript = 27
	// UnicodeScriptMyanmar: myanmar.
	UnicodeScriptMyanmar UnicodeScript = 28
	// UnicodeScriptOgham: ogham.
	UnicodeScriptOgham UnicodeScript = 29
	// UnicodeScriptOldItalic: old Italic.
	UnicodeScriptOldItalic UnicodeScript = 30
	// UnicodeScriptOriya: oriya.
	UnicodeScriptOriya UnicodeScript = 31
	// UnicodeScriptRunic: runic.
	UnicodeScriptRunic UnicodeScript = 32
	// UnicodeScriptSinhala: sinhala.
	UnicodeScriptSinhala UnicodeScript = 33
	// UnicodeScriptSyriac: syriac.
	UnicodeScriptSyriac UnicodeScript = 34
	// UnicodeScriptTamil: tamil.
	UnicodeScriptTamil UnicodeScript = 35
	// UnicodeScriptTelugu: telugu.
	UnicodeScriptTelugu UnicodeScript = 36
	// UnicodeScriptThaana: thaana.
	UnicodeScriptThaana UnicodeScript = 37
	// UnicodeScriptThai: thai.
	UnicodeScriptThai UnicodeScript = 38
	// UnicodeScriptTibetan: tibetan.
	UnicodeScriptTibetan UnicodeScript = 39
	// UnicodeScriptCanadianAboriginal: canadian Aboriginal.
	UnicodeScriptCanadianAboriginal UnicodeScript = 40
	// UnicodeScriptYi: yi.
	UnicodeScriptYi UnicodeScript = 41
	// UnicodeScriptTagalog: tagalog.
	UnicodeScriptTagalog UnicodeScript = 42
	// UnicodeScriptHanunoo: hanunoo.
	UnicodeScriptHanunoo UnicodeScript = 43
	// UnicodeScriptBuhid: buhid.
	UnicodeScriptBuhid UnicodeScript = 44
	// UnicodeScriptTagbanwa: tagbanwa.
	UnicodeScriptTagbanwa UnicodeScript = 45
	// UnicodeScriptBraille: braille.
	UnicodeScriptBraille UnicodeScript = 46
	// UnicodeScriptCypriot: cypriot.
	UnicodeScriptCypriot UnicodeScript = 47
	// UnicodeScriptLimbu: limbu.
	UnicodeScriptLimbu UnicodeScript = 48
	// UnicodeScriptOsmanya: osmanya.
	UnicodeScriptOsmanya UnicodeScript = 49
	// UnicodeScriptShavian: shavian.
	UnicodeScriptShavian UnicodeScript = 50
	// UnicodeScriptLinearB: linear B.
	UnicodeScriptLinearB UnicodeScript = 51
	// UnicodeScriptTaiLe: tai Le.
	UnicodeScriptTaiLe UnicodeScript = 52
	// UnicodeScriptUgaritic: ugaritic.
	UnicodeScriptUgaritic UnicodeScript = 53
	// UnicodeScriptNewTaiLue: new Tai Lue.
	UnicodeScriptNewTaiLue UnicodeScript = 54
	// UnicodeScriptBuginese: buginese.
	UnicodeScriptBuginese UnicodeScript = 55
	// UnicodeScriptGlagolitic: glagolitic.
	UnicodeScriptGlagolitic UnicodeScript = 56
	// UnicodeScriptTifinagh: tifinagh.
	UnicodeScriptTifinagh UnicodeScript = 57
	// UnicodeScriptSylotiNagri: syloti Nagri.
	UnicodeScriptSylotiNagri UnicodeScript = 58
	// UnicodeScriptOldPersian: old Persian.
	UnicodeScriptOldPersian UnicodeScript = 59
	// UnicodeScriptKharoshthi: kharoshthi.
	UnicodeScriptKharoshthi UnicodeScript = 60
	// UnicodeScriptUnknown: unassigned code point.
	UnicodeScriptUnknown UnicodeScript = 61
	// UnicodeScriptBalinese: balinese.
	UnicodeScriptBalinese UnicodeScript = 62
	// UnicodeScriptCuneiform: cuneiform.
	UnicodeScriptCuneiform UnicodeScript = 63
	// UnicodeScriptPhoenician: phoenician.
	UnicodeScriptPhoenician UnicodeScript = 64
	// UnicodeScriptPhagsPa: phags-pa.
	UnicodeScriptPhagsPa UnicodeScript = 65
	// UnicodeScriptNko: n'Ko.
	UnicodeScriptNko UnicodeScript = 66
	// UnicodeScriptKayahLi: kayah Li. Since 2.16.3.
	UnicodeScriptKayahLi UnicodeScript = 67
	// UnicodeScriptLepcha: lepcha. Since 2.16.3.
	UnicodeScriptLepcha UnicodeScript = 68
	// UnicodeScriptRejang: rejang. Since 2.16.3.
	UnicodeScriptRejang UnicodeScript = 69
	// UnicodeScriptSundanese: sundanese. Since 2.16.3.
	UnicodeScriptSundanese UnicodeScript = 70
	// UnicodeScriptSaurashtra: saurashtra. Since 2.16.3.
	UnicodeScriptSaurashtra UnicodeScript = 71
	// UnicodeScriptCham: cham. Since 2.16.3.
	UnicodeScriptCham UnicodeScript = 72
	// UnicodeScriptOlChiki: ol Chiki. Since 2.16.3.
	UnicodeScriptOlChiki UnicodeScript = 73
	// UnicodeScriptVai: vai. Since 2.16.3.
	UnicodeScriptVai UnicodeScript = 74
	// UnicodeScriptCarian: carian. Since 2.16.3.
	UnicodeScriptCarian UnicodeScript = 75
	// UnicodeScriptLycian: lycian. Since 2.16.3.
	UnicodeScriptLycian UnicodeScript = 76
	// UnicodeScriptLydian: lydian. Since 2.16.3.
	UnicodeScriptLydian UnicodeScript = 77
	// UnicodeScriptAvestan: avestan. Since 2.26.
	UnicodeScriptAvestan UnicodeScript = 78
	// UnicodeScriptBamum: bamum. Since 2.26.
	UnicodeScriptBamum UnicodeScript = 79
	// UnicodeScriptEgyptianHieroglyphs: egyptian Hieroglpyhs. Since 2.26.
	UnicodeScriptEgyptianHieroglyphs UnicodeScript = 80
	// UnicodeScriptImperialAramaic: imperial Aramaic. Since 2.26.
	UnicodeScriptImperialAramaic UnicodeScript = 81
	// UnicodeScriptInscriptionalPahlavi: inscriptional Pahlavi. Since 2.26.
	UnicodeScriptInscriptionalPahlavi UnicodeScript = 82
	// UnicodeScriptInscriptionalParthian: inscriptional Parthian. Since 2.26.
	UnicodeScriptInscriptionalParthian UnicodeScript = 83
	// UnicodeScriptJavanese: javanese. Since 2.26.
	UnicodeScriptJavanese UnicodeScript = 84
	// UnicodeScriptKaithi: kaithi. Since 2.26.
	UnicodeScriptKaithi UnicodeScript = 85
	// UnicodeScriptLisu: lisu. Since 2.26.
	UnicodeScriptLisu UnicodeScript = 86
	// UnicodeScriptMeeteiMayek: meetei Mayek. Since 2.26.
	UnicodeScriptMeeteiMayek UnicodeScript = 87
	// UnicodeScriptOldSouthArabian: old South Arabian. Since 2.26.
	UnicodeScriptOldSouthArabian UnicodeScript = 88
	// UnicodeScriptOldTurkic: old Turkic. Since 2.28.
	UnicodeScriptOldTurkic UnicodeScript = 89
	// UnicodeScriptSamaritan: samaritan. Since 2.26.
	UnicodeScriptSamaritan UnicodeScript = 90
	// UnicodeScriptTaiTham: tai Tham. Since 2.26.
	UnicodeScriptTaiTham UnicodeScript = 91
	// UnicodeScriptTaiViet: tai Viet. Since 2.26.
	UnicodeScriptTaiViet UnicodeScript = 92
	// UnicodeScriptBatak: batak. Since 2.28.
	UnicodeScriptBatak UnicodeScript = 93
	// UnicodeScriptBrahmi: brahmi. Since 2.28.
	UnicodeScriptBrahmi UnicodeScript = 94
	// UnicodeScriptMandaic: mandaic. Since 2.28.
	UnicodeScriptMandaic UnicodeScript = 95
	// UnicodeScriptChakma: chakma. Since: 2.32.
	UnicodeScriptChakma UnicodeScript = 96
	// UnicodeScriptMeroiticCursive: meroitic Cursive. Since: 2.32.
	UnicodeScriptMeroiticCursive UnicodeScript = 97
	// UnicodeScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 2.32.
	UnicodeScriptMeroiticHieroglyphs UnicodeScript = 98
	// UnicodeScriptMiao: miao. Since: 2.32.
	UnicodeScriptMiao UnicodeScript = 99
	// UnicodeScriptSharada: sharada. Since: 2.32.
	UnicodeScriptSharada UnicodeScript = 100
	// UnicodeScriptSoraSompeng: sora Sompeng. Since: 2.32.
	UnicodeScriptSoraSompeng UnicodeScript = 101
	// UnicodeScriptTakri: takri. Since: 2.32.
	UnicodeScriptTakri UnicodeScript = 102
	// UnicodeScriptBassaVah: bassa. Since: 2.42.
	UnicodeScriptBassaVah UnicodeScript = 103
	// UnicodeScriptCaucasianAlbanian: caucasian Albanian. Since: 2.42.
	UnicodeScriptCaucasianAlbanian UnicodeScript = 104
	// UnicodeScriptDuployan: duployan. Since: 2.42.
	UnicodeScriptDuployan UnicodeScript = 105
	// UnicodeScriptElbasan: elbasan. Since: 2.42.
	UnicodeScriptElbasan UnicodeScript = 106
	// UnicodeScriptGrantha: grantha. Since: 2.42.
	UnicodeScriptGrantha UnicodeScript = 107
	// UnicodeScriptKhojki: kjohki. Since: 2.42.
	UnicodeScriptKhojki UnicodeScript = 108
	// UnicodeScriptKhudawadi: khudawadi, Sindhi. Since: 2.42.
	UnicodeScriptKhudawadi UnicodeScript = 109
	// UnicodeScriptLinearA: linear A. Since: 2.42.
	UnicodeScriptLinearA UnicodeScript = 110
	// UnicodeScriptMahajani: mahajani. Since: 2.42.
	UnicodeScriptMahajani UnicodeScript = 111
	// UnicodeScriptManichaean: manichaean. Since: 2.42.
	UnicodeScriptManichaean UnicodeScript = 112
	// UnicodeScriptMendeKikakui: mende Kikakui. Since: 2.42.
	UnicodeScriptMendeKikakui UnicodeScript = 113
	// UnicodeScriptModi: modi. Since: 2.42.
	UnicodeScriptModi UnicodeScript = 114
	// UnicodeScriptMro: mro. Since: 2.42.
	UnicodeScriptMro UnicodeScript = 115
	// UnicodeScriptNabataean: nabataean. Since: 2.42.
	UnicodeScriptNabataean UnicodeScript = 116
	// UnicodeScriptOldNorthArabian: old North Arabian. Since: 2.42.
	UnicodeScriptOldNorthArabian UnicodeScript = 117
	// UnicodeScriptOldPermic: old Permic. Since: 2.42.
	UnicodeScriptOldPermic UnicodeScript = 118
	// UnicodeScriptPahawhHmong: pahawh Hmong. Since: 2.42.
	UnicodeScriptPahawhHmong UnicodeScript = 119
	// UnicodeScriptPalmyrene: palmyrene. Since: 2.42.
	UnicodeScriptPalmyrene UnicodeScript = 120
	// UnicodeScriptPauCinHau: pau Cin Hau. Since: 2.42.
	UnicodeScriptPauCinHau UnicodeScript = 121
	// UnicodeScriptPsalterPahlavi: psalter Pahlavi. Since: 2.42.
	UnicodeScriptPsalterPahlavi UnicodeScript = 122
	// UnicodeScriptSiddham: siddham. Since: 2.42.
	UnicodeScriptSiddham UnicodeScript = 123
	// UnicodeScriptTirhuta: tirhuta. Since: 2.42.
	UnicodeScriptTirhuta UnicodeScript = 124
	// UnicodeScriptWarangCiti: warang Citi. Since: 2.42.
	UnicodeScriptWarangCiti UnicodeScript = 125
	// UnicodeScriptAhom: ahom. Since: 2.48.
	UnicodeScriptAhom UnicodeScript = 126
	// UnicodeScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 2.48.
	UnicodeScriptAnatolianHieroglyphs UnicodeScript = 127
	// UnicodeScriptHatran: hatran. Since: 2.48.
	UnicodeScriptHatran UnicodeScript = 128
	// UnicodeScriptMultani: multani. Since: 2.48.
	UnicodeScriptMultani UnicodeScript = 129
	// UnicodeScriptOldHungarian: old Hungarian. Since: 2.48.
	UnicodeScriptOldHungarian UnicodeScript = 130
	// UnicodeScriptSignwriting: signwriting. Since: 2.48.
	UnicodeScriptSignwriting UnicodeScript = 131
	// UnicodeScriptAdlam: adlam. Since: 2.50.
	UnicodeScriptAdlam UnicodeScript = 132
	// UnicodeScriptBhaiksuki: bhaiksuki. Since: 2.50.
	UnicodeScriptBhaiksuki UnicodeScript = 133
	// UnicodeScriptMarchen: marchen. Since: 2.50.
	UnicodeScriptMarchen UnicodeScript = 134
	// UnicodeScriptNewa: newa. Since: 2.50.
	UnicodeScriptNewa UnicodeScript = 135
	// UnicodeScriptOsage: osage. Since: 2.50.
	UnicodeScriptOsage UnicodeScript = 136
	// UnicodeScriptTangut: tangut. Since: 2.50.
	UnicodeScriptTangut UnicodeScript = 137
	// UnicodeScriptMasaramGondi: masaram Gondi. Since: 2.54.
	UnicodeScriptMasaramGondi UnicodeScript = 138
	// UnicodeScriptNushu: nushu. Since: 2.54.
	UnicodeScriptNushu UnicodeScript = 139
	// UnicodeScriptSoyombo: soyombo. Since: 2.54.
	UnicodeScriptSoyombo UnicodeScript = 140
	// UnicodeScriptZanabazarSquare: zanabazar Square. Since: 2.54.
	UnicodeScriptZanabazarSquare UnicodeScript = 141
	// UnicodeScriptDogra: dogra. Since: 2.58.
	UnicodeScriptDogra UnicodeScript = 142
	// UnicodeScriptGunjalaGondi: gunjala Gondi. Since: 2.58.
	UnicodeScriptGunjalaGondi UnicodeScript = 143
	// UnicodeScriptHanifiRohingya: hanifi Rohingya. Since: 2.58.
	UnicodeScriptHanifiRohingya UnicodeScript = 144
	// UnicodeScriptMakasar: makasar. Since: 2.58.
	UnicodeScriptMakasar UnicodeScript = 145
	// UnicodeScriptMedefaidrin: medefaidrin. Since: 2.58.
	UnicodeScriptMedefaidrin UnicodeScript = 146
	// UnicodeScriptOldSogdian: old Sogdian. Since: 2.58.
	UnicodeScriptOldSogdian UnicodeScript = 147
	// UnicodeScriptSogdian: sogdian. Since: 2.58.
	UnicodeScriptSogdian UnicodeScript = 148
	// UnicodeScriptElymaic: elym. Since: 2.62.
	UnicodeScriptElymaic UnicodeScript = 149
	// UnicodeScriptNandinagari: nand. Since: 2.62.
	UnicodeScriptNandinagari UnicodeScript = 150
	// UnicodeScriptNyiakengPuachueHmong: rohg. Since: 2.62.
	UnicodeScriptNyiakengPuachueHmong UnicodeScript = 151
	// UnicodeScriptWancho: wcho. Since: 2.62.
	UnicodeScriptWancho UnicodeScript = 152
	// UnicodeScriptChorasmian: chorasmian. Since: 2.66.
	UnicodeScriptChorasmian UnicodeScript = 153
	// UnicodeScriptDivesAkuru dives Akuru. Since: 2.66.
	UnicodeScriptDivesAkuru UnicodeScript = 154
	// UnicodeScriptKhitanSmallScript: khitan small script. Since: 2.66.
	UnicodeScriptKhitanSmallScript UnicodeScript = 155
	// UnicodeScriptYezidi: yezidi. Since: 2.66.
	UnicodeScriptYezidi UnicodeScript = 156
	// UnicodeScriptCyproMinoan: cypro-Minoan. Since: 2.72.
	UnicodeScriptCyproMinoan UnicodeScript = 157
	// UnicodeScriptOldUyghur: old Uyghur. Since: 2.72.
	UnicodeScriptOldUyghur UnicodeScript = 158
	// UnicodeScriptTangsa: tangsa. Since: 2.72.
	UnicodeScriptTangsa UnicodeScript = 159
	// UnicodeScriptToto: toto. Since: 2.72.
	UnicodeScriptToto UnicodeScript = 160
	// UnicodeScriptVithkuqi: vithkuqi. Since: 2.72.
	UnicodeScriptVithkuqi UnicodeScript = 161
	// UnicodeScriptMath: mathematical notation. Since: 2.72.
	UnicodeScriptMath UnicodeScript = 162
	// UnicodeScriptKawi: kawi. Since 2.74.
	UnicodeScriptKawi UnicodeScript = 163
	// UnicodeScriptNagMundari: nag Mundari. Since 2.74.
	UnicodeScriptNagMundari UnicodeScript = 164
)

func marshalUnicodeScript(p uintptr) (interface{}, error) {
	return UnicodeScript(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for UnicodeScript.
func (u UnicodeScript) String() string {
	switch u {
	case UnicodeScriptInvalidCode:
		return "InvalidCode"
	case UnicodeScriptCommon:
		return "Common"
	case UnicodeScriptInherited:
		return "Inherited"
	case UnicodeScriptArabic:
		return "Arabic"
	case UnicodeScriptArmenian:
		return "Armenian"
	case UnicodeScriptBengali:
		return "Bengali"
	case UnicodeScriptBopomofo:
		return "Bopomofo"
	case UnicodeScriptCherokee:
		return "Cherokee"
	case UnicodeScriptCoptic:
		return "Coptic"
	case UnicodeScriptCyrillic:
		return "Cyrillic"
	case UnicodeScriptDeseret:
		return "Deseret"
	case UnicodeScriptDevanagari:
		return "Devanagari"
	case UnicodeScriptEthiopic:
		return "Ethiopic"
	case UnicodeScriptGeorgian:
		return "Georgian"
	case UnicodeScriptGothic:
		return "Gothic"
	case UnicodeScriptGreek:
		return "Greek"
	case UnicodeScriptGujarati:
		return "Gujarati"
	case UnicodeScriptGurmukhi:
		return "Gurmukhi"
	case UnicodeScriptHan:
		return "Han"
	case UnicodeScriptHangul:
		return "Hangul"
	case UnicodeScriptHebrew:
		return "Hebrew"
	case UnicodeScriptHiragana:
		return "Hiragana"
	case UnicodeScriptKannada:
		return "Kannada"
	case UnicodeScriptKatakana:
		return "Katakana"
	case UnicodeScriptKhmer:
		return "Khmer"
	case UnicodeScriptLao:
		return "Lao"
	case UnicodeScriptLatin:
		return "Latin"
	case UnicodeScriptMalayalam:
		return "Malayalam"
	case UnicodeScriptMongolian:
		return "Mongolian"
	case UnicodeScriptMyanmar:
		return "Myanmar"
	case UnicodeScriptOgham:
		return "Ogham"
	case UnicodeScriptOldItalic:
		return "OldItalic"
	case UnicodeScriptOriya:
		return "Oriya"
	case UnicodeScriptRunic:
		return "Runic"
	case UnicodeScriptSinhala:
		return "Sinhala"
	case UnicodeScriptSyriac:
		return "Syriac"
	case UnicodeScriptTamil:
		return "Tamil"
	case UnicodeScriptTelugu:
		return "Telugu"
	case UnicodeScriptThaana:
		return "Thaana"
	case UnicodeScriptThai:
		return "Thai"
	case UnicodeScriptTibetan:
		return "Tibetan"
	case UnicodeScriptCanadianAboriginal:
		return "CanadianAboriginal"
	case UnicodeScriptYi:
		return "Yi"
	case UnicodeScriptTagalog:
		return "Tagalog"
	case UnicodeScriptHanunoo:
		return "Hanunoo"
	case UnicodeScriptBuhid:
		return "Buhid"
	case UnicodeScriptTagbanwa:
		return "Tagbanwa"
	case UnicodeScriptBraille:
		return "Braille"
	case UnicodeScriptCypriot:
		return "Cypriot"
	case UnicodeScriptLimbu:
		return "Limbu"
	case UnicodeScriptOsmanya:
		return "Osmanya"
	case UnicodeScriptShavian:
		return "Shavian"
	case UnicodeScriptLinearB:
		return "LinearB"
	case UnicodeScriptTaiLe:
		return "TaiLe"
	case UnicodeScriptUgaritic:
		return "Ugaritic"
	case UnicodeScriptNewTaiLue:
		return "NewTaiLue"
	case UnicodeScriptBuginese:
		return "Buginese"
	case UnicodeScriptGlagolitic:
		return "Glagolitic"
	case UnicodeScriptTifinagh:
		return "Tifinagh"
	case UnicodeScriptSylotiNagri:
		return "SylotiNagri"
	case UnicodeScriptOldPersian:
		return "OldPersian"
	case UnicodeScriptKharoshthi:
		return "Kharoshthi"
	case UnicodeScriptUnknown:
		return "Unknown"
	case UnicodeScriptBalinese:
		return "Balinese"
	case UnicodeScriptCuneiform:
		return "Cuneiform"
	case UnicodeScriptPhoenician:
		return "Phoenician"
	case UnicodeScriptPhagsPa:
		return "PhagsPa"
	case UnicodeScriptNko:
		return "Nko"
	case UnicodeScriptKayahLi:
		return "KayahLi"
	case UnicodeScriptLepcha:
		return "Lepcha"
	case UnicodeScriptRejang:
		return "Rejang"
	case UnicodeScriptSundanese:
		return "Sundanese"
	case UnicodeScriptSaurashtra:
		return "Saurashtra"
	case UnicodeScriptCham:
		return "Cham"
	case UnicodeScriptOlChiki:
		return "OlChiki"
	case UnicodeScriptVai:
		return "Vai"
	case UnicodeScriptCarian:
		return "Carian"
	case UnicodeScriptLycian:
		return "Lycian"
	case UnicodeScriptLydian:
		return "Lydian"
	case UnicodeScriptAvestan:
		return "Avestan"
	case UnicodeScriptBamum:
		return "Bamum"
	case UnicodeScriptEgyptianHieroglyphs:
		return "EgyptianHieroglyphs"
	case UnicodeScriptImperialAramaic:
		return "ImperialAramaic"
	case UnicodeScriptInscriptionalPahlavi:
		return "InscriptionalPahlavi"
	case UnicodeScriptInscriptionalParthian:
		return "InscriptionalParthian"
	case UnicodeScriptJavanese:
		return "Javanese"
	case UnicodeScriptKaithi:
		return "Kaithi"
	case UnicodeScriptLisu:
		return "Lisu"
	case UnicodeScriptMeeteiMayek:
		return "MeeteiMayek"
	case UnicodeScriptOldSouthArabian:
		return "OldSouthArabian"
	case UnicodeScriptOldTurkic:
		return "OldTurkic"
	case UnicodeScriptSamaritan:
		return "Samaritan"
	case UnicodeScriptTaiTham:
		return "TaiTham"
	case UnicodeScriptTaiViet:
		return "TaiViet"
	case UnicodeScriptBatak:
		return "Batak"
	case UnicodeScriptBrahmi:
		return "Brahmi"
	case UnicodeScriptMandaic:
		return "Mandaic"
	case UnicodeScriptChakma:
		return "Chakma"
	case UnicodeScriptMeroiticCursive:
		return "MeroiticCursive"
	case UnicodeScriptMeroiticHieroglyphs:
		return "MeroiticHieroglyphs"
	case UnicodeScriptMiao:
		return "Miao"
	case UnicodeScriptSharada:
		return "Sharada"
	case UnicodeScriptSoraSompeng:
		return "SoraSompeng"
	case UnicodeScriptTakri:
		return "Takri"
	case UnicodeScriptBassaVah:
		return "BassaVah"
	case UnicodeScriptCaucasianAlbanian:
		return "CaucasianAlbanian"
	case UnicodeScriptDuployan:
		return "Duployan"
	case UnicodeScriptElbasan:
		return "Elbasan"
	case UnicodeScriptGrantha:
		return "Grantha"
	case UnicodeScriptKhojki:
		return "Khojki"
	case UnicodeScriptKhudawadi:
		return "Khudawadi"
	case UnicodeScriptLinearA:
		return "LinearA"
	case UnicodeScriptMahajani:
		return "Mahajani"
	case UnicodeScriptManichaean:
		return "Manichaean"
	case UnicodeScriptMendeKikakui:
		return "MendeKikakui"
	case UnicodeScriptModi:
		return "Modi"
	case UnicodeScriptMro:
		return "Mro"
	case UnicodeScriptNabataean:
		return "Nabataean"
	case UnicodeScriptOldNorthArabian:
		return "OldNorthArabian"
	case UnicodeScriptOldPermic:
		return "OldPermic"
	case UnicodeScriptPahawhHmong:
		return "PahawhHmong"
	case UnicodeScriptPalmyrene:
		return "Palmyrene"
	case UnicodeScriptPauCinHau:
		return "PauCinHau"
	case UnicodeScriptPsalterPahlavi:
		return "PsalterPahlavi"
	case UnicodeScriptSiddham:
		return "Siddham"
	case UnicodeScriptTirhuta:
		return "Tirhuta"
	case UnicodeScriptWarangCiti:
		return "WarangCiti"
	case UnicodeScriptAhom:
		return "Ahom"
	case UnicodeScriptAnatolianHieroglyphs:
		return "AnatolianHieroglyphs"
	case UnicodeScriptHatran:
		return "Hatran"
	case UnicodeScriptMultani:
		return "Multani"
	case UnicodeScriptOldHungarian:
		return "OldHungarian"
	case UnicodeScriptSignwriting:
		return "Signwriting"
	case UnicodeScriptAdlam:
		return "Adlam"
	case UnicodeScriptBhaiksuki:
		return "Bhaiksuki"
	case UnicodeScriptMarchen:
		return "Marchen"
	case UnicodeScriptNewa:
		return "Newa"
	case UnicodeScriptOsage:
		return "Osage"
	case UnicodeScriptTangut:
		return "Tangut"
	case UnicodeScriptMasaramGondi:
		return "MasaramGondi"
	case UnicodeScriptNushu:
		return "Nushu"
	case UnicodeScriptSoyombo:
		return "Soyombo"
	case UnicodeScriptZanabazarSquare:
		return "ZanabazarSquare"
	case UnicodeScriptDogra:
		return "Dogra"
	case UnicodeScriptGunjalaGondi:
		return "GunjalaGondi"
	case UnicodeScriptHanifiRohingya:
		return "HanifiRohingya"
	case UnicodeScriptMakasar:
		return "Makasar"
	case UnicodeScriptMedefaidrin:
		return "Medefaidrin"
	case UnicodeScriptOldSogdian:
		return "OldSogdian"
	case UnicodeScriptSogdian:
		return "Sogdian"
	case UnicodeScriptElymaic:
		return "Elymaic"
	case UnicodeScriptNandinagari:
		return "Nandinagari"
	case UnicodeScriptNyiakengPuachueHmong:
		return "NyiakengPuachueHmong"
	case UnicodeScriptWancho:
		return "Wancho"
	case UnicodeScriptChorasmian:
		return "Chorasmian"
	case UnicodeScriptDivesAkuru:
		return "DivesAkuru"
	case UnicodeScriptKhitanSmallScript:
		return "KhitanSmallScript"
	case UnicodeScriptYezidi:
		return "Yezidi"
	case UnicodeScriptCyproMinoan:
		return "CyproMinoan"
	case UnicodeScriptOldUyghur:
		return "OldUyghur"
	case UnicodeScriptTangsa:
		return "Tangsa"
	case UnicodeScriptToto:
		return "Toto"
	case UnicodeScriptVithkuqi:
		return "Vithkuqi"
	case UnicodeScriptMath:
		return "Math"
	case UnicodeScriptKawi:
		return "Kawi"
	case UnicodeScriptNagMundari:
		return "NagMundari"
	default:
		return fmt.Sprintf("UnicodeScript(%d)", u)
	}
}

// UnicodeScriptFromISO15924 looks up the Unicode script for iso15924. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. This function accepts four letter codes encoded as a guint32 in a
// big-endian fashion. That is, the code expected for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
//
// The function takes the following parameters:
//
//   - iso15924: unicode script.
//
// The function returns the following values:
//
//   - unicodeScript: unicode script for iso15924, or of
//     G_UNICODE_SCRIPT_INVALID_CODE if iso15924 is zero and
//     G_UNICODE_SCRIPT_UNKNOWN if iso15924 is unknown.
func UnicodeScriptFromISO15924(iso15924 uint32) UnicodeScript {
	var _arg1 C.guint32        // out
	var _cret C.GUnicodeScript // in

	_arg1 = C.guint32(iso15924)

	_cret = C.g_unicode_script_from_iso15924(_arg1)
	runtime.KeepAlive(iso15924)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicodeScriptToISO15924 looks up the ISO 15924 code for script. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. The four letter codes are encoded as a guint32 by this function in a
// big-endian fashion. That is, the code returned for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
//
// The function takes the following parameters:
//
//   - script: unicode script.
//
// The function returns the following values:
//
//   - guint32: ISO 15924 code for script, encoded as an integer, of zero if
//     script is G_UNICODE_SCRIPT_INVALID_CODE or ISO 15924 code 'Zzzz' (script
//     code for UNKNOWN) if script is not understood.
func UnicodeScriptToISO15924(script UnicodeScript) uint32 {
	var _arg1 C.GUnicodeScript // out
	var _cret C.guint32        // in

	_arg1 = C.GUnicodeScript(script)

	_cret = C.g_unicode_script_to_iso15924(_arg1)
	runtime.KeepAlive(script)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// UnicodeType: these are the possible character classifications
// from the Unicode specification. See Unicode Character Database
// (http://www.unicode.org/reports/tr44/Category_Values).
type UnicodeType C.gint

const (
	// UnicodeControl: general category "Other, Control" (Cc).
	UnicodeControl UnicodeType = iota
	// UnicodeFormat: general category "Other, Format" (Cf).
	UnicodeFormat
	// UnicodeUnassigned: general category "Other, Not Assigned" (Cn).
	UnicodeUnassigned
	// UnicodePrivateUse: general category "Other, Private Use" (Co).
	UnicodePrivateUse
	// UnicodeSurrogate: general category "Other, Surrogate" (Cs).
	UnicodeSurrogate
	// UnicodeLowercaseLetter: general category "Letter, Lowercase" (Ll).
	UnicodeLowercaseLetter
	// UnicodeModifierLetter: general category "Letter, Modifier" (Lm).
	UnicodeModifierLetter
	// UnicodeOtherLetter: general category "Letter, Other" (Lo).
	UnicodeOtherLetter
	// UnicodeTitlecaseLetter: general category "Letter, Titlecase" (Lt).
	UnicodeTitlecaseLetter
	// UnicodeUppercaseLetter: general category "Letter, Uppercase" (Lu).
	UnicodeUppercaseLetter
	// UnicodeSpacingMark: general category "Mark, Spacing" (Mc).
	UnicodeSpacingMark
	// UnicodeEnclosingMark: general category "Mark, Enclosing" (Me).
	UnicodeEnclosingMark
	// UnicodeNonSpacingMark: general category "Mark, Nonspacing" (Mn).
	UnicodeNonSpacingMark
	// UnicodeDecimalNumber: general category "Number, Decimal Digit" (Nd).
	UnicodeDecimalNumber
	// UnicodeLetterNumber: general category "Number, Letter" (Nl).
	UnicodeLetterNumber
	// UnicodeOtherNumber: general category "Number, Other" (No).
	UnicodeOtherNumber
	// UnicodeConnectPunctuation: general category "Punctuation, Connector"
	// (Pc).
	UnicodeConnectPunctuation
	// UnicodeDashPunctuation: general category "Punctuation, Dash" (Pd).
	UnicodeDashPunctuation
	// UnicodeClosePunctuation: general category "Punctuation, Close" (Pe).
	UnicodeClosePunctuation
	// UnicodeFinalPunctuation: general category "Punctuation, Final quote"
	// (Pf).
	UnicodeFinalPunctuation
	// UnicodeInitialPunctuation: general category "Punctuation, Initial quote"
	// (Pi).
	UnicodeInitialPunctuation
	// UnicodeOtherPunctuation: general category "Punctuation, Other" (Po).
	UnicodeOtherPunctuation
	// UnicodeOpenPunctuation: general category "Punctuation, Open" (Ps).
	UnicodeOpenPunctuation
	// UnicodeCurrencySymbol: general category "Symbol, Currency" (Sc).
	UnicodeCurrencySymbol
	// UnicodeModifierSymbol: general category "Symbol, Modifier" (Sk).
	UnicodeModifierSymbol
	// UnicodeMathSymbol: general category "Symbol, Math" (Sm).
	UnicodeMathSymbol
	// UnicodeOtherSymbol: general category "Symbol, Other" (So).
	UnicodeOtherSymbol
	// UnicodeLineSeparator: general category "Separator, Line" (Zl).
	UnicodeLineSeparator
	// UnicodeParagraphSeparator: general category "Separator, Paragraph" (Zp).
	UnicodeParagraphSeparator
	// UnicodeSpaceSeparator: general category "Separator, Space" (Zs).
	UnicodeSpaceSeparator
)

func marshalUnicodeType(p uintptr) (interface{}, error) {
	return UnicodeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for UnicodeType.
func (u UnicodeType) String() string {
	switch u {
	case UnicodeControl:
		return "Control"
	case UnicodeFormat:
		return "Format"
	case UnicodeUnassigned:
		return "Unassigned"
	case UnicodePrivateUse:
		return "PrivateUse"
	case UnicodeSurrogate:
		return "Surrogate"
	case UnicodeLowercaseLetter:
		return "LowercaseLetter"
	case UnicodeModifierLetter:
		return "ModifierLetter"
	case UnicodeOtherLetter:
		return "OtherLetter"
	case UnicodeTitlecaseLetter:
		return "TitlecaseLetter"
	case UnicodeUppercaseLetter:
		return "UppercaseLetter"
	case UnicodeSpacingMark:
		return "SpacingMark"
	case UnicodeEnclosingMark:
		return "EnclosingMark"
	case UnicodeNonSpacingMark:
		return "NonSpacingMark"
	case UnicodeDecimalNumber:
		return "DecimalNumber"
	case UnicodeLetterNumber:
		return "LetterNumber"
	case UnicodeOtherNumber:
		return "OtherNumber"
	case UnicodeConnectPunctuation:
		return "ConnectPunctuation"
	case UnicodeDashPunctuation:
		return "DashPunctuation"
	case UnicodeClosePunctuation:
		return "ClosePunctuation"
	case UnicodeFinalPunctuation:
		return "FinalPunctuation"
	case UnicodeInitialPunctuation:
		return "InitialPunctuation"
	case UnicodeOtherPunctuation:
		return "OtherPunctuation"
	case UnicodeOpenPunctuation:
		return "OpenPunctuation"
	case UnicodeCurrencySymbol:
		return "CurrencySymbol"
	case UnicodeModifierSymbol:
		return "ModifierSymbol"
	case UnicodeMathSymbol:
		return "MathSymbol"
	case UnicodeOtherSymbol:
		return "OtherSymbol"
	case UnicodeLineSeparator:
		return "LineSeparator"
	case UnicodeParagraphSeparator:
		return "ParagraphSeparator"
	case UnicodeSpaceSeparator:
		return "SpaceSeparator"
	default:
		return fmt.Sprintf("UnicodeType(%d)", u)
	}
}

// URIError: error codes returned by #GUri methods.
type URIError C.gint

const (
	// URIErrorFailed: generic error if no more specific error is available.
	// See the error message for details.
	URIErrorFailed URIError = iota
	// URIErrorBadScheme: scheme of a URI could not be parsed.
	URIErrorBadScheme
	// URIErrorBadUser: user/userinfo of a URI could not be parsed.
	URIErrorBadUser
	// URIErrorBadPassword: password of a URI could not be parsed.
	URIErrorBadPassword
	// URIErrorBadAuthParams: authentication parameters of a URI could not be
	// parsed.
	URIErrorBadAuthParams
	// URIErrorBadHost: host of a URI could not be parsed.
	URIErrorBadHost
	// URIErrorBadPort: port of a URI could not be parsed.
	URIErrorBadPort
	// URIErrorBadPath: path of a URI could not be parsed.
	URIErrorBadPath
	// URIErrorBadQuery: query of a URI could not be parsed.
	URIErrorBadQuery
	// URIErrorBadFragment: fragment of a URI could not be parsed.
	URIErrorBadFragment
)

// String returns the name in string for URIError.
func (u URIError) String() string {
	switch u {
	case URIErrorFailed:
		return "Failed"
	case URIErrorBadScheme:
		return "BadScheme"
	case URIErrorBadUser:
		return "BadUser"
	case URIErrorBadPassword:
		return "BadPassword"
	case URIErrorBadAuthParams:
		return "BadAuthParams"
	case URIErrorBadHost:
		return "BadHost"
	case URIErrorBadPort:
		return "BadPort"
	case URIErrorBadPath:
		return "BadPath"
	case URIErrorBadQuery:
		return "BadQuery"
	case URIErrorBadFragment:
		return "BadFragment"
	default:
		return fmt.Sprintf("URIError(%d)", u)
	}
}

// UserDirectory: these are logical ids for special directories
// which are defined depending on the platform used. You should use
// g_get_user_special_dir() to retrieve the full path associated to the logical
// id.
//
// The Directory enumeration can be extended at later date. Not every platform
// has a directory for every logical id in this enumeration.
type UserDirectory C.gint

const (
	// UserDirectoryDesktop user's Desktop directory.
	UserDirectoryDesktop UserDirectory = iota
	// UserDirectoryDocuments user's Documents directory.
	UserDirectoryDocuments
	// UserDirectoryDownload user's Downloads directory.
	UserDirectoryDownload
	// UserDirectoryMusic user's Music directory.
	UserDirectoryMusic
	// UserDirectoryPictures user's Pictures directory.
	UserDirectoryPictures
	// UserDirectoryPublicShare user's shared directory.
	UserDirectoryPublicShare
	// UserDirectoryTemplates user's Templates directory.
	UserDirectoryTemplates
	// UserDirectoryVideos user's Movies directory.
	UserDirectoryVideos
	// UserNDirectories: number of enum values.
	UserNDirectories
)

// String returns the name in string for UserDirectory.
func (u UserDirectory) String() string {
	switch u {
	case UserDirectoryDesktop:
		return "DirectoryDesktop"
	case UserDirectoryDocuments:
		return "DirectoryDocuments"
	case UserDirectoryDownload:
		return "DirectoryDownload"
	case UserDirectoryMusic:
		return "DirectoryMusic"
	case UserDirectoryPictures:
		return "DirectoryPictures"
	case UserDirectoryPublicShare:
		return "DirectoryPublicShare"
	case UserDirectoryTemplates:
		return "DirectoryTemplates"
	case UserDirectoryVideos:
		return "DirectoryVideos"
	case UserNDirectories:
		return "NDirectories"
	default:
		return fmt.Sprintf("UserDirectory(%d)", u)
	}
}

// VariantClass: range of possible top-level types of #GVariant instances.
type VariantClass C.gint

const (
	// VariantClassBoolean is a boolean.
	VariantClassBoolean VariantClass = 98
	// VariantClassByte is a byte.
	VariantClassByte VariantClass = 121
	// VariantClassInt16 is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// VariantClassUint16 is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// VariantClassInt32 is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// VariantClassUint32 is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// VariantClassInt64 is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// VariantClassUint64 is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// VariantClassHandle is a file handle index.
	VariantClassHandle VariantClass = 104
	// VariantClassDouble is a double precision floating point value.
	VariantClassDouble VariantClass = 100
	// VariantClassString is a normal string.
	VariantClassString VariantClass = 115
	// VariantClassObjectPath is a D-Bus object path string.
	VariantClassObjectPath VariantClass = 111
	// VariantClassSignature is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// VariantClassVariant is a variant.
	VariantClassVariant VariantClass = 118
	// VariantClassMaybe is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// VariantClassArray is an array.
	VariantClassArray VariantClass = 97
	// VariantClassTuple is a tuple.
	VariantClassTuple VariantClass = 40
	// VariantClassDictEntry is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)

// String returns the name in string for VariantClass.
func (v VariantClass) String() string {
	switch v {
	case VariantClassBoolean:
		return "Boolean"
	case VariantClassByte:
		return "Byte"
	case VariantClassInt16:
		return "Int16"
	case VariantClassUint16:
		return "Uint16"
	case VariantClassInt32:
		return "Int32"
	case VariantClassUint32:
		return "Uint32"
	case VariantClassInt64:
		return "Int64"
	case VariantClassUint64:
		return "Uint64"
	case VariantClassHandle:
		return "Handle"
	case VariantClassDouble:
		return "Double"
	case VariantClassString:
		return "String"
	case VariantClassObjectPath:
		return "ObjectPath"
	case VariantClassSignature:
		return "Signature"
	case VariantClassVariant:
		return "Variant"
	case VariantClassMaybe:
		return "Maybe"
	case VariantClassArray:
		return "Array"
	case VariantClassTuple:
		return "Tuple"
	case VariantClassDictEntry:
		return "DictEntry"
	default:
		return fmt.Sprintf("VariantClass(%d)", v)
	}
}

// VariantParseError: error codes returned by parsing text-format GVariants.
type VariantParseError C.gint

const (
	// VariantParseErrorFailed: generic error (unused).
	VariantParseErrorFailed VariantParseError = iota
	// VariantParseErrorBasicTypeExpected: non-basic Type was given where a
	// basic type was expected.
	VariantParseErrorBasicTypeExpected
	// VariantParseErrorCannotInferType: cannot infer the Type.
	VariantParseErrorCannotInferType
	// VariantParseErrorDefiniteTypeExpected: indefinite Type was given where a
	// definite type was expected.
	VariantParseErrorDefiniteTypeExpected
	// VariantParseErrorInputNotAtEnd: extra data after parsing finished.
	VariantParseErrorInputNotAtEnd
	// VariantParseErrorInvalidCharacter: invalid character in number or unicode
	// escape.
	VariantParseErrorInvalidCharacter
	// VariantParseErrorInvalidFormatString: not a valid #GVariant format
	// string.
	VariantParseErrorInvalidFormatString
	// VariantParseErrorInvalidObjectPath: not a valid object path.
	VariantParseErrorInvalidObjectPath
	// VariantParseErrorInvalidSignature: not a valid type signature.
	VariantParseErrorInvalidSignature
	// VariantParseErrorInvalidTypeString: not a valid #GVariant type string.
	VariantParseErrorInvalidTypeString
	// VariantParseErrorNoCommonType: could not find a common type for array
	// entries.
	VariantParseErrorNoCommonType
	// VariantParseErrorNumberOutOfRange: numerical value is out of range of the
	// given type.
	VariantParseErrorNumberOutOfRange
	// VariantParseErrorNumberTooBig: numerical value is out of range for any
	// type.
	VariantParseErrorNumberTooBig
	// VariantParseErrorTypeError: cannot parse as variant of the specified
	// type.
	VariantParseErrorTypeError
	// VariantParseErrorUnexpectedToken: unexpected token was encountered.
	VariantParseErrorUnexpectedToken
	// VariantParseErrorUnknownKeyword: unknown keyword was encountered.
	VariantParseErrorUnknownKeyword
	// VariantParseErrorUnterminatedStringConstant: unterminated string
	// constant.
	VariantParseErrorUnterminatedStringConstant
	// VariantParseErrorValueExpected: no value given.
	VariantParseErrorValueExpected
	// VariantParseErrorRecursion: variant was too deeply nested; #GVariant is
	// only guaranteed to handle nesting up to 64 levels (Since: 2.64).
	VariantParseErrorRecursion
)

// String returns the name in string for VariantParseError.
func (v VariantParseError) String() string {
	switch v {
	case VariantParseErrorFailed:
		return "Failed"
	case VariantParseErrorBasicTypeExpected:
		return "BasicTypeExpected"
	case VariantParseErrorCannotInferType:
		return "CannotInferType"
	case VariantParseErrorDefiniteTypeExpected:
		return "DefiniteTypeExpected"
	case VariantParseErrorInputNotAtEnd:
		return "InputNotAtEnd"
	case VariantParseErrorInvalidCharacter:
		return "InvalidCharacter"
	case VariantParseErrorInvalidFormatString:
		return "InvalidFormatString"
	case VariantParseErrorInvalidObjectPath:
		return "InvalidObjectPath"
	case VariantParseErrorInvalidSignature:
		return "InvalidSignature"
	case VariantParseErrorInvalidTypeString:
		return "InvalidTypeString"
	case VariantParseErrorNoCommonType:
		return "NoCommonType"
	case VariantParseErrorNumberOutOfRange:
		return "NumberOutOfRange"
	case VariantParseErrorNumberTooBig:
		return "NumberTooBig"
	case VariantParseErrorTypeError:
		return "TypeError"
	case VariantParseErrorUnexpectedToken:
		return "UnexpectedToken"
	case VariantParseErrorUnknownKeyword:
		return "UnknownKeyword"
	case VariantParseErrorUnterminatedStringConstant:
		return "UnterminatedStringConstant"
	case VariantParseErrorValueExpected:
		return "ValueExpected"
	case VariantParseErrorRecursion:
		return "Recursion"
	default:
		return fmt.Sprintf("VariantParseError(%d)", v)
	}
}

// FileSetContentsFlags flags to pass to g_file_set_contents_full() to affect
// its safety and performance.
type FileSetContentsFlags C.guint

const (
	// FileSetContentsNone: no guarantees about file consistency or durability.
	// The most dangerous setting, which is slightly faster than other settings.
	FileSetContentsNone FileSetContentsFlags = 0b0
	// FileSetContentsConsistent: guarantee file consistency: after a crash,
	// either the old version of the file or the new version of the file will be
	// available, but not a mixture. On Unix systems this equates to an fsync()
	// on the file and use of an atomic rename() of the new version of the file
	// over the old.
	FileSetContentsConsistent FileSetContentsFlags = 0b1
	// FileSetContentsDurable: guarantee file durability: after a crash, the
	// new version of the file will be available. On Unix systems this equates
	// to an fsync() on the file (if G_FILE_SET_CONTENTS_CONSISTENT is unset),
	// or the effects of G_FILE_SET_CONTENTS_CONSISTENT plus an fsync() on the
	// directory containing the file after calling rename().
	FileSetContentsDurable FileSetContentsFlags = 0b10
	// FileSetContentsOnlyExisting: only apply consistency and durability
	// guarantees if the file already exists. This may speed up file operations
	// if the file doesn’t currently exist, but may result in a corrupted
	// version of the new file if the system crashes while writing it.
	FileSetContentsOnlyExisting FileSetContentsFlags = 0b100
)

// String returns the names in string for FileSetContentsFlags.
func (f FileSetContentsFlags) String() string {
	if f == 0 {
		return "FileSetContentsFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(96)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileSetContentsNone:
			builder.WriteString("None|")
		case FileSetContentsConsistent:
			builder.WriteString("Consistent|")
		case FileSetContentsDurable:
			builder.WriteString("Durable|")
		case FileSetContentsOnlyExisting:
			builder.WriteString("OnlyExisting|")
		default:
			builder.WriteString(fmt.Sprintf("FileSetContentsFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileSetContentsFlags) Has(other FileSetContentsFlags) bool {
	return (f & other) == other
}

// FileTest: test to perform on a file using g_file_test().
type FileTest C.guint

const (
	// FileTestIsRegular: TRUE if the file is a regular file (not a directory).
	// Note that this test will also return TRUE if the tested file is a symlink
	// to a regular file.
	FileTestIsRegular FileTest = 0b1
	// FileTestIsSymlink: TRUE if the file is a symlink.
	FileTestIsSymlink FileTest = 0b10
	// FileTestIsDir: TRUE if the file is a directory.
	FileTestIsDir FileTest = 0b100
	// FileTestIsExecutable: TRUE if the file is executable.
	FileTestIsExecutable FileTest = 0b1000
	// FileTestExists: TRUE if the file exists. It may or may not be a regular
	// file.
	FileTestExists FileTest = 0b10000
)

// String returns the names in string for FileTest.
func (f FileTest) String() string {
	if f == 0 {
		return "FileTest(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileTestIsRegular:
			builder.WriteString("IsRegular|")
		case FileTestIsSymlink:
			builder.WriteString("IsSymlink|")
		case FileTestIsDir:
			builder.WriteString("IsDir|")
		case FileTestIsExecutable:
			builder.WriteString("IsExecutable|")
		case FileTestExists:
			builder.WriteString("Exists|")
		default:
			builder.WriteString(fmt.Sprintf("FileTest(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileTest) Has(other FileTest) bool {
	return (f & other) == other
}

// FormatSizeFlags flags to modify the format of the string returned by
// g_format_size_full().
type FormatSizeFlags C.guint

const (
	// FormatSizeDefault: behave the same as g_format_size().
	FormatSizeDefault FormatSizeFlags = 0b0
	// FormatSizeLongFormat: include the exact number of bytes as part of the
	// returned string. For example, "45.6 kB (45,612 bytes)".
	FormatSizeLongFormat FormatSizeFlags = 0b1
	// FormatSizeIecUnits: use IEC (base 1024) units with "KiB"-style suffixes.
	// IEC units should only be used for reporting things with a strong "power
	// of 2" basis, like RAM sizes or RAID stripe sizes. Network and storage
	// sizes should be reported in the normal SI units.
	FormatSizeIecUnits FormatSizeFlags = 0b10
	// FormatSizeBits: set the size as a quantity in bits, rather than bytes,
	// and return units in bits. For example, ‘Mbit’ rather than ‘MB’.
	FormatSizeBits FormatSizeFlags = 0b100
	// FormatSizeOnlyValue: return only value, without unit; this should not be
	// used together with G_FORMAT_SIZE_LONG_FORMAT nor G_FORMAT_SIZE_ONLY_UNIT.
	// Since: 2.74.
	FormatSizeOnlyValue FormatSizeFlags = 0b1000
	// FormatSizeOnlyUnit: return only unit, without value; this
	// should not be used together with G_FORMAT_SIZE_LONG_FORMAT nor
	// G_FORMAT_SIZE_ONLY_VALUE. Since: 2.74.
	FormatSizeOnlyUnit FormatSizeFlags = 0b10000
)

// String returns the names in string for FormatSizeFlags.
func (f FormatSizeFlags) String() string {
	if f == 0 {
		return "FormatSizeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(111)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FormatSizeDefault:
			builder.WriteString("Default|")
		case FormatSizeLongFormat:
			builder.WriteString("LongFormat|")
		case FormatSizeIecUnits:
			builder.WriteString("IecUnits|")
		case FormatSizeBits:
			builder.WriteString("Bits|")
		case FormatSizeOnlyValue:
			builder.WriteString("OnlyValue|")
		case FormatSizeOnlyUnit:
			builder.WriteString("OnlyUnit|")
		default:
			builder.WriteString(fmt.Sprintf("FormatSizeFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FormatSizeFlags) Has(other FormatSizeFlags) bool {
	return (f & other) == other
}

// IOCondition: bitwise combination representing a condition to watch for on an
// event source.
type IOCondition C.guint

const (
	// IOIn: there is data to read.
	IOIn IOCondition = 0b1
	// IOOut: data can be written (without blocking).
	IOOut IOCondition = 0b100
	// IOPri: there is urgent data to read.
	IOPri IOCondition = 0b10
	// IOErr: error condition.
	IOErr IOCondition = 0b1000
	// IOHup: hung up (the connection has been broken, usually for pipes and
	// sockets).
	IOHup IOCondition = 0b10000
	// IONval: invalid request. The file descriptor is not open.
	IONval IOCondition = 0b100000
)

func marshalIOCondition(p uintptr) (interface{}, error) {
	return IOCondition(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for IOCondition.
func (i IOCondition) String() string {
	if i == 0 {
		return "IOCondition(0)"
	}

	var builder strings.Builder
	builder.Grow(35)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IOIn:
			builder.WriteString("In|")
		case IOOut:
			builder.WriteString("Out|")
		case IOPri:
			builder.WriteString("Pri|")
		case IOErr:
			builder.WriteString("Err|")
		case IOHup:
			builder.WriteString("Hup|")
		case IONval:
			builder.WriteString("Nval|")
		default:
			builder.WriteString(fmt.Sprintf("IOCondition(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IOCondition) Has(other IOCondition) bool {
	return (i & other) == other
}

// IOFlags specifies properties of a OChannel. Some of the flags can
// only be read with g_io_channel_get_flags(), but not changed with
// g_io_channel_set_flags().
type IOFlags C.guint

const (
	// IOFlagNone: no special flags set. Since: 2.74.
	IOFlagNone IOFlags = 0b0
	// IOFlagAppend turns on append mode, corresponds to O_APPEND (see the
	// documentation of the UNIX open() syscall).
	IOFlagAppend IOFlags = 0b1
	// IOFlagNonblock turns on nonblocking mode, corresponds to
	// O_NONBLOCK/O_NDELAY (see the documentation of the UNIX open() syscall).
	IOFlagNonblock IOFlags = 0b10
	// IOFlagIsReadable indicates that the io channel is readable. This flag
	// cannot be changed.
	IOFlagIsReadable IOFlags = 0b100
	// IOFlagIsWritable indicates that the io channel is writable. This flag
	// cannot be changed.
	IOFlagIsWritable IOFlags = 0b1000
	// IOFlagIsWriteable: misspelled version of G_IO_FLAG_IS_WRITABLE that
	// existed before the spelling was fixed in GLib 2.30. It is kept here for
	// compatibility reasons. Deprecated since 2.30.
	IOFlagIsWriteable IOFlags = 0b1000
	// IOFlagIsSeekable indicates that the io channel is seekable, i.e.
	// that g_io_channel_seek_position() can be used on it. This flag cannot be
	// changed.
	IOFlagIsSeekable IOFlags = 0b10000
	// IOFlagMask: mask that specifies all the valid flags.
	IOFlagMask IOFlags = 0b11111
	// IOFlagGetMask: mask of the flags that are returned from
	// g_io_channel_get_flags().
	IOFlagGetMask IOFlags = 0b11111
	// IOFlagSetMask: mask of the flags that the user can modify with
	// g_io_channel_set_flags().
	IOFlagSetMask IOFlags = 0b11
)

// String returns the names in string for IOFlags.
func (i IOFlags) String() string {
	if i == 0 {
		return "IOFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(146)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IOFlagNone:
			builder.WriteString("None|")
		case IOFlagAppend:
			builder.WriteString("Append|")
		case IOFlagNonblock:
			builder.WriteString("Nonblock|")
		case IOFlagIsReadable:
			builder.WriteString("IsReadable|")
		case IOFlagIsWritable:
			builder.WriteString("IsWritable|")
		case IOFlagIsSeekable:
			builder.WriteString("IsSeekable|")
		case IOFlagMask:
			builder.WriteString("Mask|")
		case IOFlagSetMask:
			builder.WriteString("SetMask|")
		default:
			builder.WriteString(fmt.Sprintf("IOFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IOFlags) Has(other IOFlags) bool {
	return (i & other) == other
}

// KeyFileFlags flags which influence the parsing.
type KeyFileFlags C.guint

const (
	// KeyFileNone: no flags, default behaviour.
	KeyFileNone KeyFileFlags = 0b0
	// KeyFileKeepComments: use this flag if you plan to write the (possibly
	// modified) contents of the key file back to a file; otherwise all comments
	// will be lost when the key file is written back.
	KeyFileKeepComments KeyFileFlags = 0b1
	// KeyFileKeepTranslations: use this flag if you plan to write the (possibly
	// modified) contents of the key file back to a file; otherwise only the
	// translations for the current language will be written back.
	KeyFileKeepTranslations KeyFileFlags = 0b10
)

// String returns the names in string for KeyFileFlags.
func (k KeyFileFlags) String() string {
	if k == 0 {
		return "KeyFileFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(55)

	for k != 0 {
		next := k & (k - 1)
		bit := k - next

		switch bit {
		case KeyFileNone:
			builder.WriteString("None|")
		case KeyFileKeepComments:
			builder.WriteString("KeepComments|")
		case KeyFileKeepTranslations:
			builder.WriteString("KeepTranslations|")
		default:
			builder.WriteString(fmt.Sprintf("KeyFileFlags(0b%b)|", bit))
		}

		k = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if k contains other.
func (k KeyFileFlags) Has(other KeyFileFlags) bool {
	return (k & other) == other
}

// LogLevelFlags flags specifying the level of log messages.
//
// It is possible to change how GLib treats messages of the various levels using
// glib.LogSetHandler() and glib.LogSetFatalMask().
type LogLevelFlags C.guint

const (
	// LogFlagRecursion: internal flag.
	LogFlagRecursion LogLevelFlags = 0b1
	// LogFlagFatal: internal flag.
	LogFlagFatal LogLevelFlags = 0b10
	// LogLevelError: log level for errors, see glib.Error(). This level is also
	// used for messages produced by glib.Assert().
	LogLevelError LogLevelFlags = 0b100
	// LogLevelCritical: log level for critical warning messages,
	// see glib.Critical(). This level is also used for messages produced by
	// glib.ReturnIfFail() and glib.ReturnValIfFail().
	LogLevelCritical LogLevelFlags = 0b1000
	// LogLevelWarning: log level for warnings, see glib.Warning().
	LogLevelWarning LogLevelFlags = 0b10000
	// LogLevelMessage: log level for messages, see glib.Message().
	LogLevelMessage LogLevelFlags = 0b100000
	// LogLevelInfo: log level for informational messages, see glib.Info().
	LogLevelInfo LogLevelFlags = 0b1000000
	// LogLevelDebug: log level for debug messages, see glib.Debug().
	LogLevelDebug LogLevelFlags = 0b10000000
)

// String returns the names in string for LogLevelFlags.
func (l LogLevelFlags) String() string {
	if l == 0 {
		return "LogLevelFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(119)

	for l != 0 {
		next := l & (l - 1)
		bit := l - next

		switch bit {
		case LogFlagRecursion:
			builder.WriteString("FlagRecursion|")
		case LogFlagFatal:
			builder.WriteString("FlagFatal|")
		case LogLevelError:
			builder.WriteString("LevelError|")
		case LogLevelCritical:
			builder.WriteString("LevelCritical|")
		case LogLevelWarning:
			builder.WriteString("LevelWarning|")
		case LogLevelMessage:
			builder.WriteString("LevelMessage|")
		case LogLevelInfo:
			builder.WriteString("LevelInfo|")
		case LogLevelDebug:
			builder.WriteString("LevelDebug|")
		default:
			builder.WriteString(fmt.Sprintf("LogLevelFlags(0b%b)|", bit))
		}

		l = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if l contains other.
func (l LogLevelFlags) Has(other LogLevelFlags) bool {
	return (l & other) == other
}

// MainContextFlags flags to pass to g_main_context_new_with_flags() which
// affect the behaviour of a Context.
type MainContextFlags C.guint

const (
	// MainContextFlagsNone: default behaviour.
	MainContextFlagsNone MainContextFlags = 0b0
	// MainContextFlagsOwnerlessPolling: assume that polling for events will
	// free the thread to process other jobs. That's useful if you're using
	// g_main_context_{prepare,query,check,dispatch} to integrate GMainContext
	// in other event loops.
	MainContextFlagsOwnerlessPolling MainContextFlags = 0b1
)

// String returns the names in string for MainContextFlags.
func (m MainContextFlags) String() string {
	if m == 0 {
		return "MainContextFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(53)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MainContextFlagsNone:
			builder.WriteString("None|")
		case MainContextFlagsOwnerlessPolling:
			builder.WriteString("OwnerlessPolling|")
		default:
			builder.WriteString(fmt.Sprintf("MainContextFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MainContextFlags) Has(other MainContextFlags) bool {
	return (m & other) == other
}

// MarkupCollectType: mixed enumerated type and flags field. You must specify
// one type (string, strdup, boolean, tristate). Additionally, you may
// optionally bitwise OR the type with the flag G_MARKUP_COLLECT_OPTIONAL.
//
// It is likely that this enum will be extended in the future to support other
// types.
type MarkupCollectType C.guint

const (
	// MarkupCollectInvalid: used to terminate the list of attributes to
	// collect.
	MarkupCollectInvalid MarkupCollectType = 0b0
	// MarkupCollectString: collect the string pointer directly from the
	// attribute_values[] array. Expects a parameter of type (const char **).
	// If G_MARKUP_COLLECT_OPTIONAL is specified and the attribute isn't present
	// then the pointer will be set to NULL.
	MarkupCollectString MarkupCollectType = 0b1
	// MarkupCollectStrdup as with G_MARKUP_COLLECT_STRING, but expects a
	// parameter of type (char **) and g_strdup()s the returned pointer.
	// The pointer must be freed with g_free().
	MarkupCollectStrdup MarkupCollectType = 0b10
	// MarkupCollectBoolean expects a parameter of type (gboolean *) and parses
	// the attribute value as a boolean. Sets FALSE if the attribute isn't
	// present. Valid boolean values consist of (case-insensitive) "false", "f",
	// "no", "n", "0" and "true", "t", "yes", "y", "1".
	MarkupCollectBoolean MarkupCollectType = 0b11
	// MarkupCollectTristate as with G_MARKUP_COLLECT_BOOLEAN, but in the case
	// of a missing attribute a value is set that compares equal to neither
	// FALSE nor TRUE G_MARKUP_COLLECT_OPTIONAL is implied.
	MarkupCollectTristate MarkupCollectType = 0b100
	// MarkupCollectOptional: can be bitwise ORed with the other fields.
	// If present, allows the attribute not to appear. A default value is set
	// depending on what value type is used.
	MarkupCollectOptional MarkupCollectType = 0b10000000000000000
)

// String returns the names in string for MarkupCollectType.
func (m MarkupCollectType) String() string {
	if m == 0 {
		return "MarkupCollectType(0)"
	}

	var builder strings.Builder
	builder.Grow(125)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MarkupCollectInvalid:
			builder.WriteString("Invalid|")
		case MarkupCollectString:
			builder.WriteString("String|")
		case MarkupCollectStrdup:
			builder.WriteString("Strdup|")
		case MarkupCollectBoolean:
			builder.WriteString("Boolean|")
		case MarkupCollectTristate:
			builder.WriteString("Tristate|")
		case MarkupCollectOptional:
			builder.WriteString("Optional|")
		default:
			builder.WriteString(fmt.Sprintf("MarkupCollectType(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MarkupCollectType) Has(other MarkupCollectType) bool {
	return (m & other) == other
}

// MarkupParseFlags flags that affect the behaviour of the parser.
type MarkupParseFlags C.guint

const (
	// MarkupDefaultFlags: no special behaviour. Since: 2.74.
	MarkupDefaultFlags MarkupParseFlags = 0b0
	// MarkupDoNotUseThisUnsupportedFlag: flag you should not use.
	MarkupDoNotUseThisUnsupportedFlag MarkupParseFlags = 0b1
	// MarkupTreatCdataAsText: when this flag is set, CDATA marked sections are
	// not passed literally to the passthrough function of the parser. Instead,
	// the content of the section (without the <![CDATA[ and ]]>) is passed to
	// the text function. This flag was added in GLib 2.12.
	MarkupTreatCdataAsText MarkupParseFlags = 0b10
	// MarkupPrefixErrorPosition: normally errors caught by GMarkup itself
	// have line/column information prefixed to them to let the caller know the
	// location of the error. When this flag is set the location information is
	// also prefixed to errors generated by the Parser implementation functions.
	MarkupPrefixErrorPosition MarkupParseFlags = 0b100
	// MarkupIgnoreQualified: ignore (don't report) qualified attributes and
	// tags, along with their contents. A qualified attribute or tag is one that
	// contains ':' in its name (ie: is in another namespace). Since: 2.40.
	MarkupIgnoreQualified MarkupParseFlags = 0b1000
)

// String returns the names in string for MarkupParseFlags.
func (m MarkupParseFlags) String() string {
	if m == 0 {
		return "MarkupParseFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(123)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MarkupDefaultFlags:
			builder.WriteString("DefaultFlags|")
		case MarkupDoNotUseThisUnsupportedFlag:
			builder.WriteString("DoNotUseThisUnsupportedFlag|")
		case MarkupTreatCdataAsText:
			builder.WriteString("TreatCdataAsText|")
		case MarkupPrefixErrorPosition:
			builder.WriteString("PrefixErrorPosition|")
		case MarkupIgnoreQualified:
			builder.WriteString("IgnoreQualified|")
		default:
			builder.WriteString(fmt.Sprintf("MarkupParseFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MarkupParseFlags) Has(other MarkupParseFlags) bool {
	return (m & other) == other
}

// OptionFlags flags which modify individual options.
type OptionFlags C.guint

const (
	// OptionFlagNone: no flags. Since: 2.42.
	OptionFlagNone OptionFlags = 0b0
	// OptionFlagHidden: option doesn't appear in --help output.
	OptionFlagHidden OptionFlags = 0b1
	// OptionFlagInMain: option appears in the main section of the --help
	// output, even if it is defined in a group.
	OptionFlagInMain OptionFlags = 0b10
	// OptionFlagReverse: for options of the G_OPTION_ARG_NONE kind, this flag
	// indicates that the sense of the option is reversed. i.e. FALSE will be
	// stored into the argument rather than TRUE.
	OptionFlagReverse OptionFlags = 0b100
	// OptionFlagNoArg: for options of the G_OPTION_ARG_CALLBACK kind,
	// this flag indicates that the callback does not take any argument (like a
	// G_OPTION_ARG_NONE option). Since 2.8.
	OptionFlagNoArg OptionFlags = 0b1000
	// OptionFlagFilename: for options of the G_OPTION_ARG_CALLBACK kind,
	// this flag indicates that the argument should be passed to the callback in
	// the GLib filename encoding rather than UTF-8. Since 2.8.
	OptionFlagFilename OptionFlags = 0b10000
	// OptionFlagOptionalArg: for options of the G_OPTION_ARG_CALLBACK kind,
	// this flag indicates that the argument supply is optional. If no argument
	// is given then data of GOptionParseFunc will be set to NULL. Since 2.8.
	OptionFlagOptionalArg OptionFlags = 0b100000
	// OptionFlagNoalias: this flag turns off the automatic conflict resolution
	// which prefixes long option names with groupname- if there is a conflict.
	// This option should only be used in situations where aliasing is necessary
	// to model some legacy commandline interface. It is not safe to use
	// this option, unless all option groups are under your direct control.
	// Since 2.8.
	OptionFlagNoalias OptionFlags = 0b1000000
)

// String returns the names in string for OptionFlags.
func (o OptionFlags) String() string {
	if o == 0 {
		return "OptionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(141)

	for o != 0 {
		next := o & (o - 1)
		bit := o - next

		switch bit {
		case OptionFlagNone:
			builder.WriteString("None|")
		case OptionFlagHidden:
			builder.WriteString("Hidden|")
		case OptionFlagInMain:
			builder.WriteString("InMain|")
		case OptionFlagReverse:
			builder.WriteString("Reverse|")
		case OptionFlagNoArg:
			builder.WriteString("NoArg|")
		case OptionFlagFilename:
			builder.WriteString("Filename|")
		case OptionFlagOptionalArg:
			builder.WriteString("OptionalArg|")
		case OptionFlagNoalias:
			builder.WriteString("Noalias|")
		default:
			builder.WriteString(fmt.Sprintf("OptionFlags(0b%b)|", bit))
		}

		o = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if o contains other.
func (o OptionFlags) Has(other OptionFlags) bool {
	return (o & other) == other
}

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags C.guint

const (
	// RegexDefault: no special options set. Since: 2.74.
	RegexDefault RegexCompileFlags = 0b0
	// RegexCaseless letters in the pattern match both upper- and lowercase
	// letters. This option can be changed within a pattern by a "(?i)" option
	// setting.
	RegexCaseless RegexCompileFlags = 0b1
	// RegexMultiline: by default, GRegex treats the strings as consisting of
	// a single line of characters (even if it actually contains newlines).
	// The "start of line" metacharacter ("^") matches only at the start of
	// the string, while the "end of line" metacharacter ("$") matches only
	// at the end of the string, or before a terminating newline (unless
	// G_REGEX_DOLLAR_ENDONLY is set). When G_REGEX_MULTILINE is set, the "start
	// of line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexMultiline RegexCompileFlags = 0b10
	// RegexDotall: dot metacharacter (".") in the pattern matches all
	// characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexDotall RegexCompileFlags = 0b100
	// RegexExtended: whitespace data characters in the pattern are totally
	// ignored except when escaped or inside a character class. Whitespace
	// does not include the VT character (code 11). In addition, characters
	// between an unescaped "#" outside a character class and the next newline
	// character, inclusive, are also ignored. This can be changed within a
	// pattern by a "(?x)" option setting.
	RegexExtended RegexCompileFlags = 0b1000
	// RegexAnchored: pattern is forced to be "anchored", that is, it is
	// constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexAnchored RegexCompileFlags = 0b10000
	// RegexDollarEndonly: dollar metacharacter ("$") in the pattern matches
	// only at the end of the string. Without this option, a dollar also matches
	// immediately before the final character if it is a newline (but not before
	// any other newlines). This option is ignored if G_REGEX_MULTILINE is set.
	RegexDollarEndonly RegexCompileFlags = 0b100000
	// RegexUngreedy inverts the "greediness" of the quantifiers so that they
	// are not greedy by default, but become greedy if followed by "?". It can
	// also be set by a "(?U)" option setting within the pattern.
	RegexUngreedy RegexCompileFlags = 0b1000000000
	// RegexRaw: usually strings must be valid UTF-8 strings, using this flag
	// they are considered as a raw sequence of bytes.
	RegexRaw RegexCompileFlags = 0b100000000000
	// RegexNoAutoCapture disables the use of numbered capturing parentheses in
	// the pattern. Any opening parenthesis that is not followed by "?" behaves
	// as if it were followed by "?:" but named parentheses can still be used
	// for capturing (and they acquire numbers in the usual way).
	RegexNoAutoCapture RegexCompileFlags = 0b1000000000000
	// RegexOptimize: since 2.74 and the port to pcre2, requests JIT
	// compilation, which, if the just-in-time compiler is available, further
	// processes a compiled pattern into machine code that executes much faster.
	// However, it comes at the cost of extra processing before the match is
	// performed, so it is most beneficial to use this when the same compiled
	// pattern is used for matching many times. Before 2.74 this option used the
	// built-in non-JIT optimizations in pcre1.
	RegexOptimize RegexCompileFlags = 0b10000000000000
	// RegexFirstline limits an unanchored pattern to match before (or at) the
	// first newline. Since: 2.34.
	RegexFirstline RegexCompileFlags = 0b1000000000000000000
	// RegexDupnames names used to identify capturing subpatterns need not be
	// unique. This can be helpful for certain types of pattern when it is known
	// that only one instance of the named subpattern can ever be matched.
	RegexDupnames RegexCompileFlags = 0b10000000000000000000
	// RegexNewlineCr: usually any newline character or character sequence is
	// recognized. If this option is set, the only recognized newline character
	// is '\r'.
	RegexNewlineCr RegexCompileFlags = 0b100000000000000000000
	// RegexNewlineLf: usually any newline character or character sequence is
	// recognized. If this option is set, the only recognized newline character
	// is '\n'.
	RegexNewlineLf RegexCompileFlags = 0b1000000000000000000000
	// RegexNewlineCrlf: usually any newline character or character sequence is
	// recognized. If this option is set, the only recognized newline character
	// sequence is '\r\n'.
	RegexNewlineCrlf RegexCompileFlags = 0b1100000000000000000000
	// RegexNewlineAnycrlf: usually any newline character or character sequence
	// is recognized. If this option is set, the only recognized newline
	// character sequences are '\r', '\n', and '\r\n'. Since: 2.34.
	RegexNewlineAnycrlf RegexCompileFlags = 0b10100000000000000000000
	// RegexBsrAnycrlf: usually any newline character or character sequence is
	// recognised. If this option is set, then "\R" only recognizes the newline
	// characters '\r', '\n' and '\r\n'. Since: 2.34.
	RegexBsrAnycrlf RegexCompileFlags = 0b100000000000000000000000
	// RegexJavascriptCompat changes behaviour so that it is compatible with
	// JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,
	// as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74.
	RegexJavascriptCompat RegexCompileFlags = 0b10000000000000000000000000
)

// String returns the names in string for RegexCompileFlags.
func (r RegexCompileFlags) String() string {
	if r == 0 {
		return "RegexCompileFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RegexDefault:
			builder.WriteString("Default|")
		case RegexCaseless:
			builder.WriteString("Caseless|")
		case RegexMultiline:
			builder.WriteString("Multiline|")
		case RegexDotall:
			builder.WriteString("Dotall|")
		case RegexExtended:
			builder.WriteString("Extended|")
		case RegexAnchored:
			builder.WriteString("Anchored|")
		case RegexDollarEndonly:
			builder.WriteString("DollarEndonly|")
		case RegexUngreedy:
			builder.WriteString("Ungreedy|")
		case RegexRaw:
			builder.WriteString("Raw|")
		case RegexNoAutoCapture:
			builder.WriteString("NoAutoCapture|")
		case RegexOptimize:
			builder.WriteString("Optimize|")
		case RegexFirstline:
			builder.WriteString("Firstline|")
		case RegexDupnames:
			builder.WriteString("Dupnames|")
		case RegexNewlineCr:
			builder.WriteString("NewlineCr|")
		case RegexNewlineLf:
			builder.WriteString("NewlineLf|")
		case RegexNewlineCrlf:
			builder.WriteString("NewlineCrlf|")
		case RegexNewlineAnycrlf:
			builder.WriteString("NewlineAnycrlf|")
		case RegexBsrAnycrlf:
			builder.WriteString("BsrAnycrlf|")
		case RegexJavascriptCompat:
			builder.WriteString("JavascriptCompat|")
		default:
			builder.WriteString(fmt.Sprintf("RegexCompileFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RegexCompileFlags) Has(other RegexCompileFlags) bool {
	return (r & other) == other
}

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags C.guint

const (
	// RegexMatchDefault: no special options set. Since: 2.74.
	RegexMatchDefault RegexMatchFlags = 0b0
	// RegexMatchAnchored: pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchAnchored RegexMatchFlags = 0b10000
	// RegexMatchNotbol specifies that first character of the string is not the
	// beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without G_REGEX_MULTILINE (at compile time)
	// causes circumflex never to match. This option affects only the behaviour
	// of the circumflex metacharacter, it does not affect "\A".
	RegexMatchNotbol RegexMatchFlags = 0b10000000
	// RegexMatchNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without G_REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter,
	// it does not affect "\Z" or "\z".
	RegexMatchNoteol RegexMatchFlags = 0b100000000
	// RegexMatchNotempty: empty string is not considered to be a valid match
	// if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string,
	// the entire match fails. For example, if the pattern "a?b?" is applied to
	// a string not beginning with "a" or "b", it matches the empty string at
	// the start of the string. With this flag set, this match is not valid,
	// so GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchNotempty RegexMatchFlags = 0b10000000000
	// RegexMatchPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchPartial RegexMatchFlags = 0b1000000000000000
	// RegexMatchNewlineCr overrides the newline definition set when creating a
	// new #GRegex, setting the '\r' character as line terminator.
	RegexMatchNewlineCr RegexMatchFlags = 0b100000000000000000000
	// RegexMatchNewlineLf overrides the newline definition set when creating a
	// new #GRegex, setting the '\n' character as line terminator.
	RegexMatchNewlineLf RegexMatchFlags = 0b1000000000000000000000
	// RegexMatchNewlineCrlf overrides the newline definition set when creating
	// a new #GRegex, setting the '\r\n' characters sequence as line terminator.
	RegexMatchNewlineCrlf RegexMatchFlags = 0b1100000000000000000000
	// RegexMatchNewlineAny overrides the newline definition set when creating
	// a new #GRegex, any Unicode newline sequence is recognised as a newline.
	// These are '\r', '\n' and '\rn', and the single characters U+000B LINE
	// TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028 LINE
	// SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchNewlineAny RegexMatchFlags = 0b10000000000000000000000
	// RegexMatchNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34.
	RegexMatchNewlineAnycrlf RegexMatchFlags = 0b10100000000000000000000
	// RegexMatchBsrAnycrlf overrides the newline definition for "\R" set when
	// creating a new #GRegex; only '\r', '\n', or '\r\n' character sequences
	// are recognized as a newline by "\R". Since: 2.34.
	RegexMatchBsrAnycrlf RegexMatchFlags = 0b100000000000000000000000
	// RegexMatchBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34.
	RegexMatchBsrAny RegexMatchFlags = 0b1000000000000000000000000
	// RegexMatchPartialSoft alias for G_REGEX_MATCH_PARTIAL. Since: 2.34.
	RegexMatchPartialSoft RegexMatchFlags = 0b1000000000000000
	// RegexMatchPartialHard turns on the partial matching feature. In contrast
	// to to G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34.
	RegexMatchPartialHard RegexMatchFlags = 0b1000000000000000000000000000
	// RegexMatchNotemptyAtstart: like G_REGEX_MATCH_NOTEMPTY, but only applied
	// to the start of the matched string. For anchored patterns this can only
	// happen for pattern containing "\K". Since: 2.34.
	RegexMatchNotemptyAtstart RegexMatchFlags = 0b10000000000000000000000000000
)

// String returns the names in string for RegexMatchFlags.
func (r RegexMatchFlags) String() string {
	if r == 0 {
		return "RegexMatchFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RegexMatchDefault:
			builder.WriteString("Default|")
		case RegexMatchAnchored:
			builder.WriteString("Anchored|")
		case RegexMatchNotbol:
			builder.WriteString("Notbol|")
		case RegexMatchNoteol:
			builder.WriteString("Noteol|")
		case RegexMatchNotempty:
			builder.WriteString("Notempty|")
		case RegexMatchPartial:
			builder.WriteString("Partial|")
		case RegexMatchNewlineCr:
			builder.WriteString("NewlineCr|")
		case RegexMatchNewlineLf:
			builder.WriteString("NewlineLf|")
		case RegexMatchNewlineCrlf:
			builder.WriteString("NewlineCrlf|")
		case RegexMatchNewlineAny:
			builder.WriteString("NewlineAny|")
		case RegexMatchNewlineAnycrlf:
			builder.WriteString("NewlineAnycrlf|")
		case RegexMatchBsrAnycrlf:
			builder.WriteString("BsrAnycrlf|")
		case RegexMatchBsrAny:
			builder.WriteString("BsrAny|")
		case RegexMatchPartialHard:
			builder.WriteString("PartialHard|")
		case RegexMatchNotemptyAtstart:
			builder.WriteString("NotemptyAtstart|")
		default:
			builder.WriteString(fmt.Sprintf("RegexMatchFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RegexMatchFlags) Has(other RegexMatchFlags) bool {
	return (r & other) == other
}

// SpawnFlags flags passed to g_spawn_sync(), g_spawn_async() and
// g_spawn_async_with_pipes().
type SpawnFlags C.guint

const (
	// SpawnDefault: no flags, default behaviour.
	SpawnDefault SpawnFlags = 0b0
	// SpawnLeaveDescriptorsOpen parent's open file descriptors will be
	// inherited by the child; otherwise all descriptors except stdin, stdout
	// and stderr will be closed before calling exec() in the child.
	SpawnLeaveDescriptorsOpen SpawnFlags = 0b1
	// SpawnDoNotReapChild: child will not be automatically reaped; you must
	// use g_child_watch_add() yourself (or call waitpid() or handle SIGCHLD
	// yourself), or the child will become a zombie.
	SpawnDoNotReapChild SpawnFlags = 0b10
	// SpawnSearchPath: argv[0] need not be an absolute path, it will be looked
	// for in the user's PATH.
	SpawnSearchPath SpawnFlags = 0b100
	// SpawnStdoutToDevNull child's standard output will be discarded, instead
	// of going to the same location as the parent's standard output.
	SpawnStdoutToDevNull SpawnFlags = 0b1000
	// SpawnStderrToDevNull child's standard error will be discarded.
	SpawnStderrToDevNull SpawnFlags = 0b10000
	// SpawnChildInheritsStdin: child will inherit the parent's standard input
	// (by default, the child's standard input is attached to /dev/null).
	SpawnChildInheritsStdin SpawnFlags = 0b100000
	// SpawnFileAndArgvZero: first element of argv is the file to execute,
	// while the remaining elements are the actual argument vector to pass to
	// the file. Normally g_spawn_async_with_pipes() uses argv[0] as the file to
	// execute, and passes all of argv to the child.
	SpawnFileAndArgvZero SpawnFlags = 0b1000000
	// SpawnSearchPathFromEnvp: if argv[0] is not an absolute path, it will be
	// looked for in the PATH from the passed child environment. Since: 2.34.
	SpawnSearchPathFromEnvp SpawnFlags = 0b10000000
	// SpawnCloexecPipes: create all pipes with the O_CLOEXEC flag set. Since:
	// 2.40.
	SpawnCloexecPipes SpawnFlags = 0b100000000
	// SpawnChildInheritsStdout: child will inherit the parent's standard
	// output.
	SpawnChildInheritsStdout SpawnFlags = 0b1000000000
	// SpawnChildInheritsStderr: child will inherit the parent's standard error.
	SpawnChildInheritsStderr SpawnFlags = 0b10000000000
	// SpawnStdinFromDevNull child's standard input is attached to /dev/null.
	SpawnStdinFromDevNull SpawnFlags = 0b100000000000
)

// String returns the names in string for SpawnFlags.
func (s SpawnFlags) String() string {
	if s == 0 {
		return "SpawnFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SpawnDefault:
			builder.WriteString("Default|")
		case SpawnLeaveDescriptorsOpen:
			builder.WriteString("LeaveDescriptorsOpen|")
		case SpawnDoNotReapChild:
			builder.WriteString("DoNotReapChild|")
		case SpawnSearchPath:
			builder.WriteString("SearchPath|")
		case SpawnStdoutToDevNull:
			builder.WriteString("StdoutToDevNull|")
		case SpawnStderrToDevNull:
			builder.WriteString("StderrToDevNull|")
		case SpawnChildInheritsStdin:
			builder.WriteString("ChildInheritsStdin|")
		case SpawnFileAndArgvZero:
			builder.WriteString("FileAndArgvZero|")
		case SpawnSearchPathFromEnvp:
			builder.WriteString("SearchPathFromEnvp|")
		case SpawnCloexecPipes:
			builder.WriteString("CloexecPipes|")
		case SpawnChildInheritsStdout:
			builder.WriteString("ChildInheritsStdout|")
		case SpawnChildInheritsStderr:
			builder.WriteString("ChildInheritsStderr|")
		case SpawnStdinFromDevNull:
			builder.WriteString("StdinFromDevNull|")
		default:
			builder.WriteString(fmt.Sprintf("SpawnFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SpawnFlags) Has(other SpawnFlags) bool {
	return (s & other) == other
}

// TraverseFlags specifies which nodes are visited during several of the tree
// functions, including g_node_traverse() and g_node_find().
type TraverseFlags C.guint

const (
	// TraverseLeaves: only leaf nodes should be visited. This name has been
	// introduced in 2.6, for older version use G_TRAVERSE_LEAFS.
	TraverseLeaves TraverseFlags = 0b1
	// TraverseNonLeaves: only non-leaf nodes should be visited. This name has
	// been introduced in 2.6, for older version use G_TRAVERSE_NON_LEAFS.
	TraverseNonLeaves TraverseFlags = 0b10
	// TraverseAll: all nodes should be visited.
	TraverseAll TraverseFlags = 0b11
	// TraverseMask: mask of all traverse flags.
	TraverseMask TraverseFlags = 0b11
	// TraverseLeafs: identical to G_TRAVERSE_LEAVES.
	TraverseLeafs TraverseFlags = 0b1
	// TraverseNonLeafs: identical to G_TRAVERSE_NON_LEAVES.
	TraverseNonLeafs TraverseFlags = 0b10
)

// String returns the names in string for TraverseFlags.
func (t TraverseFlags) String() string {
	if t == 0 {
		return "TraverseFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(88)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TraverseLeaves:
			builder.WriteString("Leaves|")
		case TraverseNonLeaves:
			builder.WriteString("NonLeaves|")
		case TraverseAll:
			builder.WriteString("All|")
		default:
			builder.WriteString(fmt.Sprintf("TraverseFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TraverseFlags) Has(other TraverseFlags) bool {
	return (t & other) == other
}

// URIFlags flags that describe a URI.
//
// When parsing a URI, if you need to choose different flags based on the type
// of URI, you can use g_uri_peek_scheme() on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
type URIFlags C.guint

const (
	// URIFlagsNone: no flags set.
	URIFlagsNone URIFlags = 0b0
	// URIFlagsParseRelaxed: parse the URI more relaxedly than the RFC 3986
	// (https://tools.ietf.org/html/rfc3986) grammar specifies, fixing up or
	// ignoring common mistakes in URIs coming from external sources. This is
	// also needed for some obscure URI schemes where ; separates the host from
	// the path. Don’t use this flag unless you need to.
	URIFlagsParseRelaxed URIFlags = 0b1
	// URIFlagsHasPassword: userinfo field may contain a password, which will be
	// separated from the username by :.
	URIFlagsHasPassword URIFlags = 0b10
	// URIFlagsHasAuthParams: userinfo may contain additional
	// authentication-related parameters, which will be separated from the
	// username and/or password by ;.
	URIFlagsHasAuthParams URIFlags = 0b100
	// URIFlagsEncoded: when parsing a URI, this indicates that %-encoded
	// characters in the userinfo, path, query, and fragment fields should not
	// be decoded. (And likewise the host field if G_URI_FLAGS_NON_DNS is also
	// set.) When building a URI, it indicates that you have already %-encoded
	// the components, and so #GUri should not do any encoding itself.
	URIFlagsEncoded URIFlags = 0b1000
	// URIFlagsNonDns: host component should not be assumed to be a DNS hostname
	// or IP address (for example, for smb URIs with NetBIOS hostnames).
	URIFlagsNonDns URIFlags = 0b10000
	// URIFlagsEncodedQuery: same as G_URI_FLAGS_ENCODED, for the query field
	// only.
	URIFlagsEncodedQuery URIFlags = 0b100000
	// URIFlagsEncodedPath: same as G_URI_FLAGS_ENCODED, for the path only.
	URIFlagsEncodedPath URIFlags = 0b1000000
	// URIFlagsEncodedFragment: same as G_URI_FLAGS_ENCODED, for the fragment
	// only.
	URIFlagsEncodedFragment URIFlags = 0b10000000
	// URIFlagsSchemeNormalize: scheme-based normalization will be applied.
	// For example, when parsing an HTTP URI changing omitted path to / and
	// omitted port to 80; and when building a URI, changing empty path to / and
	// default port 80). This only supports a subset of known schemes. (Since:
	// 2.68).
	URIFlagsSchemeNormalize URIFlags = 0b100000000
)

// String returns the names in string for URIFlags.
func (u URIFlags) String() string {
	if u == 0 {
		return "URIFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(195)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case URIFlagsNone:
			builder.WriteString("None|")
		case URIFlagsParseRelaxed:
			builder.WriteString("ParseRelaxed|")
		case URIFlagsHasPassword:
			builder.WriteString("HasPassword|")
		case URIFlagsHasAuthParams:
			builder.WriteString("HasAuthParams|")
		case URIFlagsEncoded:
			builder.WriteString("Encoded|")
		case URIFlagsNonDns:
			builder.WriteString("NonDns|")
		case URIFlagsEncodedQuery:
			builder.WriteString("EncodedQuery|")
		case URIFlagsEncodedPath:
			builder.WriteString("EncodedPath|")
		case URIFlagsEncodedFragment:
			builder.WriteString("EncodedFragment|")
		case URIFlagsSchemeNormalize:
			builder.WriteString("SchemeNormalize|")
		default:
			builder.WriteString(fmt.Sprintf("URIFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u URIFlags) Has(other URIFlags) bool {
	return (u & other) == other
}

// URIHideFlags flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that G_URI_HIDE_PASSWORD and
// G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with the
// corresponding flags.
type URIHideFlags C.guint

const (
	// URIHideNone: no flags set.
	URIHideNone URIHideFlags = 0b0
	// URIHideUserinfo: hide the userinfo.
	URIHideUserinfo URIHideFlags = 0b1
	// URIHidePassword: hide the password.
	URIHidePassword URIHideFlags = 0b10
	// URIHideAuthParams: hide the auth_params.
	URIHideAuthParams URIHideFlags = 0b100
	// URIHideQuery: hide the query.
	URIHideQuery URIHideFlags = 0b1000
	// URIHideFragment: hide the fragment.
	URIHideFragment URIHideFlags = 0b10000
)

// String returns the names in string for URIHideFlags.
func (u URIHideFlags) String() string {
	if u == 0 {
		return "URIHideFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(90)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case URIHideNone:
			builder.WriteString("None|")
		case URIHideUserinfo:
			builder.WriteString("Userinfo|")
		case URIHidePassword:
			builder.WriteString("Password|")
		case URIHideAuthParams:
			builder.WriteString("AuthParams|")
		case URIHideQuery:
			builder.WriteString("Query|")
		case URIHideFragment:
			builder.WriteString("Fragment|")
		default:
			builder.WriteString(fmt.Sprintf("URIHideFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u URIHideFlags) Has(other URIHideFlags) bool {
	return (u & other) == other
}

// URIParamsFlags flags modifying the way parameters are handled by
// g_uri_parse_params() and ParamsIter.
type URIParamsFlags C.guint

const (
	// URIParamsNone: no flags set.
	URIParamsNone URIParamsFlags = 0b0
	// URIParamsCaseInsensitive: parameter names are case insensitive.
	URIParamsCaseInsensitive URIParamsFlags = 0b1
	// URIParamsWwwForm: replace + with space character. Only useful for URLs on
	// the web, using the https or http schemas.
	URIParamsWwwForm URIParamsFlags = 0b10
	// URIParamsParseRelaxed: see G_URI_FLAGS_PARSE_RELAXED.
	URIParamsParseRelaxed URIParamsFlags = 0b100
)

// String returns the names in string for URIParamsFlags.
func (u URIParamsFlags) String() string {
	if u == 0 {
		return "URIParamsFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(77)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case URIParamsNone:
			builder.WriteString("None|")
		case URIParamsCaseInsensitive:
			builder.WriteString("CaseInsensitive|")
		case URIParamsWwwForm:
			builder.WriteString("WwwForm|")
		case URIParamsParseRelaxed:
			builder.WriteString("ParseRelaxed|")
		default:
			builder.WriteString(fmt.Sprintf("URIParamsFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u URIParamsFlags) Has(other URIParamsFlags) bool {
	return (u & other) == other
}

// CompareDataFunc specifies the type of a comparison function used to compare
// two values. The function should return a negative integer if the first value
// comes before the second, 0 if they are equal, or a positive integer if the
// first value comes after the second.
type CompareDataFunc func(a, b unsafe.Pointer) (gint int)

// EqualFuncFull specifies the type of a function used to test two values for
// equality. The function should return TRUE if both values are equal and FALSE
// otherwise.
//
// This is a version of Func which provides a user_data closure from the caller.
type EqualFuncFull func(a, b unsafe.Pointer) (ok bool)

// Func specifies the type of functions passed to g_list_foreach() and
// g_slist_foreach().
type Func func(data unsafe.Pointer)

// HFunc specifies the type of the function passed to g_hash_table_foreach().
// It is called with each key/value pair, together with the user_data parameter
// which is passed to g_hash_table_foreach().
type HFunc func(key, value unsafe.Pointer)

// HRFunc specifies the type of the function passed to
// g_hash_table_foreach_remove(). It is called with each
// key/value pair, together with the user_data parameter passed to
// g_hash_table_foreach_remove(). It should return TRUE if the key/value pair
// should be removed from the Table.
type HRFunc func(key, value unsafe.Pointer) (ok bool)

// LogFunc specifies the prototype of log handler functions.
//
// The default log handler, glib.LogDefaultHandler(), automatically appends a
// new-line character to message when printing it. It is advised that any custom
// log handler functions behave similarly, so that logging calls in user code
// do not need modifying to add a new-line character to the message if the log
// handler is changed.
//
// This is not used if structured logging is enabled; see Using Structured
// Logging (logging.html#using-structured-logging).
type LogFunc func(logDomain string, logLevel LogLevelFlags, message string)

// LogWriterFunc: writer function for log entries. A log entry is a collection
// of one or more Fields, using the standard [field names from journal
// specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
// See g_log_structured() for more information.
//
// Writer functions must ignore fields which they do not recognise, unless they
// can write arbitrary binary output, as field values may be arbitrary binary.
//
// log_level is guaranteed to be included in fields as the PRIORITY field,
// but is provided separately for convenience of deciding whether or where to
// output the log entry.
//
// Writer functions should return G_LOG_WRITER_HANDLED if they handled the log
// message successfully or if they deliberately ignored it. If there was an
// error handling the message (for example, if the writer function is meant
// to send messages to a remote logging server and there is a network error),
// it should return G_LOG_WRITER_UNHANDLED. This allows writer functions to be
// chained and fall back to simpler handlers in case of failure.
type LogWriterFunc func(logLevel LogLevelFlags, fields []LogField) (logWriterOutput LogWriterOutput)

// SourceFunc specifies the type of function passed to g_timeout_add(),
// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
//
// When calling g_source_set_callback(), you may need to cast a function of a
// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
// incompatible function types.
type SourceFunc func() (ok bool)

// SourceOnceFunc: source function that is only called once before being removed
// from the main context automatically.
//
// See: g_idle_add_once(), g_timeout_add_once().
type SourceOnceFunc func()

// The function takes the following parameters:
//
//   - logDomain
//   - file
//   - line
//   - prettyFunction
//   - expression
func AssertWarning(logDomain, file string, line int, prettyFunction, expression string) {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _arg3 C.int   // out
	var _arg4 *C.char // out
	var _arg5 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(line)
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(prettyFunction)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.char)(unsafe.Pointer(C.CString(expression)))
	defer C.free(unsafe.Pointer(_arg5))

	C.g_assert_warning(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(prettyFunction)
	runtime.KeepAlive(expression)
}

// Basename gets the name of the file without any leading directory components.
// It returns a pointer into the given file name string.
//
// Deprecated: Use g_path_get_basename() instead, but notice that
// g_path_get_basename() allocates new memory for the returned string, unlike
// this function which returns a pointer into the argument.
//
// The function takes the following parameters:
//
//   - fileName: name of the file.
//
// The function returns the following values:
//
//   - filename: name of the file without any leading directory components.
func Basename(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_basename(_arg1)
	runtime.KeepAlive(fileName)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// BitNthLSF: find the position of the first bit set in mask, searching
// from (but not including) nth_bit upwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the 0th bit, set nth_bit to -1.
//
// The function takes the following parameters:
//
//   - mask containing flags.
//   - nthBit: index of the bit to start the search from.
//
// The function returns the following values:
//
//   - gint: index of the first bit set which is higher than nth_bit, or -1 if
//     no higher bits are set.
func BitNthLSF(mask uint32, nthBit int) int {
	var _arg1 C.gulong // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = C.gulong(mask)
	_arg2 = C.gint(nthBit)

	_cret = C.g_bit_nth_lsf(_arg1, _arg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BitNthMSF: find the position of the first bit set in mask, searching from
// (but not including) nth_bit downwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the last bit, set nth_bit to -1 or GLIB_SIZEOF_LONG * 8.
//
// The function takes the following parameters:
//
//   - mask containing flags.
//   - nthBit: index of the bit to start the search from.
//
// The function returns the following values:
//
//   - gint: index of the first bit set which is lower than nth_bit, or -1 if no
//     lower bits are set.
func BitNthMSF(mask uint32, nthBit int) int {
	var _arg1 C.gulong // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = C.gulong(mask)
	_arg2 = C.gint(nthBit)

	_cret = C.g_bit_nth_msf(_arg1, _arg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BitStorage gets the number of bits used to hold number, e.g. if number is 4,
// 3 bits are needed.
//
// The function takes the following parameters:
//
//   - number: #guint.
//
// The function returns the following values:
//
//   - guint: number of bits used to hold number.
func BitStorage(number uint32) uint {
	var _arg1 C.gulong // out
	var _cret C.guint  // in

	_arg1 = C.gulong(number)

	_cret = C.g_bit_storage(_arg1)
	runtime.KeepAlive(number)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func BlowChunks() {
	C.g_blow_chunks()
}

// BuildFilenamev creates a filename from a vector of elements using the correct
// separator for the current platform.
//
// This function behaves exactly like g_build_filename(), but takes the path
// elements as a string array, instead of varargs. This function is mainly meant
// for language bindings.
//
// If you are building a path programmatically you may want to use Buf instead.
//
// The function takes the following parameters:
//
//   - args: NULL-terminated array of strings containing the path elements.
//
// The function returns the following values:
//
//   - filename: newly allocated path.
func BuildFilenamev(args []string) string {
	var _arg1 **C.gchar // out
	var _cret *C.gchar  // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(args) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(args)+1)
			var zero *C.gchar
			out[len(args)] = zero
			for i := range args {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(args[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.g_build_filenamev(_arg1)
	runtime.KeepAlive(args)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// BuildPathv behaves exactly like g_build_path(), but takes the path elements
// as a string array, instead of variadic arguments.
//
// This function is mainly meant for language bindings.
//
// The function takes the following parameters:
//
//   - separator: string used to separator the elements of the path.
//   - args: NULL-terminated array of strings containing the path elements.
//
// The function returns the following values:
//
//   - filename: newly-allocated string that must be freed with g_free().
func BuildPathv(separator string, args []string) string {
	var _arg1 *C.gchar  // out
	var _arg2 **C.gchar // out
	var _cret *C.gchar  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(separator)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(args) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(args)+1)
			var zero *C.gchar
			out[len(args)] = zero
			for i := range args {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(args[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.g_build_pathv(_arg1, _arg2)
	runtime.KeepAlive(separator)
	runtime.KeepAlive(args)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// CanonicalizeFilename gets the canonical file name from filename. All triple
// slashes are turned into single slashes, and all .. and .s resolved against
// relative_to.
//
// Symlinks are not followed, and the returned path is guaranteed to be
// absolute.
//
// If filename is an absolute path, relative_to is ignored. Otherwise,
// relative_to will be prepended to filename to make it absolute. relative_to
// must be an absolute path, or NULL. If relative_to is NULL, it'll fallback to
// g_get_current_dir().
//
// This function never fails, and will canonicalize file paths even if they
// don't exist.
//
// No file system I/O is done.
//
// The function takes the following parameters:
//
//   - filename: name of the file.
//   - relativeTo (optional): relative directory, or NULL to use the current
//     working directory.
//
// The function returns the following values:
//
//   - ret: newly allocated string with the canonical file path.
func CanonicalizeFilename(filename, relativeTo string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	if relativeTo != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(relativeTo)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_canonicalize_filename(_arg1, _arg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(relativeTo)

	var _ret string // out

	_ret = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _ret
}

// CheckVersion checks that the GLib library in use is compatible with the given
// version.
//
// Generally you would pass in the constants GLIB_MAJOR_VERSION,
// GLIB_MINOR_VERSION, GLIB_MICRO_VERSION as the three arguments to this
// function; that produces a check that the library in use is compatible with
// the version of GLib the application or module was compiled against.
//
// Compatibility is defined by two things: first the
// version of the running library is newer than the version
// required_major.required_minor.required_micro. Second the
// running library must be binary compatible with the version
// required_major.required_minor.required_micro (same major version.).
//
// The function takes the following parameters:
//
//   - requiredMajor: required major version.
//   - requiredMinor: required minor version.
//   - requiredMicro: required micro version.
//
// The function returns the following values:
//
//   - utf8 (optional): NULL if the GLib library is compatible with the given
//     version, or a string describing the version mismatch. The returned string
//     is owned by GLib and must not be modified or freed.
func CheckVersion(requiredMajor, requiredMinor, requiredMicro uint) string {
	var _arg1 C.guint  // out
	var _arg2 C.guint  // out
	var _arg3 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(requiredMajor)
	_arg2 = C.guint(requiredMinor)
	_arg3 = C.guint(requiredMicro)

	_cret = C.glib_check_version(_arg1, _arg2, _arg3)
	runtime.KeepAlive(requiredMajor)
	runtime.KeepAlive(requiredMinor)
	runtime.KeepAlive(requiredMicro)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ComputeChecksumForBytes computes the checksum for a binary data. This is
// a convenience wrapper for g_checksum_new(), g_checksum_get_string() and
// g_checksum_free().
//
// The hexadecimal string returned will be in lower case.
//
// The function takes the following parameters:
//
//   - checksumType: Type.
//   - data: binary blob to compute the digest of.
//
// The function returns the following values:
//
//   - utf8 (optional): digest of the binary data as a string in hexadecimal,
//     or NULL if g_checksum_new() fails for checksum_type. The returned string
//     should be freed with g_free() when done using it.
func ComputeChecksumForBytes(checksumType ChecksumType, data *Bytes) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.GBytes       // out
	var _cret *C.gchar        // in

	_arg1 = C.GChecksumType(checksumType)
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.g_compute_checksum_for_bytes(_arg1, _arg2)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(data)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ComputeChecksumForData computes the checksum for a binary data of length.
// This is a convenience wrapper for g_checksum_new(), g_checksum_get_string()
// and g_checksum_free().
//
// The hexadecimal string returned will be in lower case.
//
// The function takes the following parameters:
//
//   - checksumType: Type.
//   - data: binary blob to compute the digest of.
//
// The function returns the following values:
//
//   - utf8 (optional): digest of the binary data as a string in hexadecimal,
//     or NULL if g_checksum_new() fails for checksum_type. The returned string
//     should be freed with g_free() when done using it.
func ComputeChecksumForData(checksumType ChecksumType, data []byte) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.guchar       // out
	var _arg3 C.gsize
	var _cret *C.gchar // in

	_arg1 = C.GChecksumType(checksumType)
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guchar)(unsafe.Pointer(&data[0]))
	}

	_cret = C.g_compute_checksum_for_data(_arg1, _arg2, _arg3)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(data)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ComputeChecksumForString computes the checksum of a string.
//
// The hexadecimal string returned will be in lower case.
//
// The function takes the following parameters:
//
//   - checksumType: Type.
//   - str: string to compute the checksum of.
//
// The function returns the following values:
//
//   - utf8 (optional): checksum as a hexadecimal string, or NULL if
//     g_checksum_new() fails for checksum_type. The returned string should be
//     freed with g_free() when done using it.
func ComputeChecksumForString(checksumType ChecksumType, str string) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.gchar        // out
	var _arg3 C.gssize
	var _cret *C.gchar // in

	_arg1 = C.GChecksumType(checksumType)
	_arg3 = (C.gssize)(len(str))
	_arg2 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_compute_checksum_for_string(_arg1, _arg2, _arg3)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(str)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ComputeHMACForBytes computes the HMAC for a binary data. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string() and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
//
// The function takes the following parameters:
//
//   - digestType to use for the HMAC.
//   - key to use in the HMAC.
//   - data: binary blob to compute the HMAC of.
//
// The function returns the following values:
//
//   - utf8: HMAC of the binary data as a string in hexadecimal. The returned
//     string should be freed with g_free() when done using it.
func ComputeHMACForBytes(digestType ChecksumType, key, data *Bytes) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.GBytes       // out
	var _arg3 *C.GBytes       // out
	var _cret *C.gchar        // in

	_arg1 = C.GChecksumType(digestType)
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(key)))
	_arg3 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.g_compute_hmac_for_bytes(_arg1, _arg2, _arg3)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(data)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ComputeHMACForData computes the HMAC for a binary data of length. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string() and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
//
// The function takes the following parameters:
//
//   - digestType to use for the HMAC.
//   - key to use in the HMAC.
//   - data: binary blob to compute the HMAC of.
//
// The function returns the following values:
//
//   - utf8: HMAC of the binary data as a string in hexadecimal. The returned
//     string should be freed with g_free() when done using it.
func ComputeHMACForData(digestType ChecksumType, key, data []byte) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.guchar       // out
	var _arg3 C.gsize
	var _arg4 *C.guchar // out
	var _arg5 C.gsize
	var _cret *C.gchar // in

	_arg1 = C.GChecksumType(digestType)
	_arg3 = (C.gsize)(len(key))
	if len(key) > 0 {
		_arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	}
	_arg5 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg4 = (*C.guchar)(unsafe.Pointer(&data[0]))
	}

	_cret = C.g_compute_hmac_for_data(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(data)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ComputeHMACForString computes the HMAC for a string.
//
// The hexadecimal string returned will be in lower case.
//
// The function takes the following parameters:
//
//   - digestType to use for the HMAC.
//   - key to use in the HMAC.
//   - str: string to compute the HMAC for.
//
// The function returns the following values:
//
//   - utf8: HMAC as a hexadecimal string. The returned string should be freed
//     with g_free() when done using it.
func ComputeHMACForString(digestType ChecksumType, key []byte, str string) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.guchar       // out
	var _arg3 C.gsize
	var _arg4 *C.gchar // out
	var _arg5 C.gssize
	var _cret *C.gchar // in

	_arg1 = C.GChecksumType(digestType)
	_arg3 = (C.gsize)(len(key))
	if len(key) > 0 {
		_arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	}
	_arg5 = (C.gssize)(len(str))
	_arg4 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg4)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_compute_hmac_for_string(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Convert converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that bytes_read can return information about partial characters,
// the g_convert_... functions are not generally suitable for streaming.
// If the underlying converter maintains internal state, then this won't be
// preserved across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
//
// Using extensions such as "//TRANSLIT" may not work (or may not work well) on
// many platforms. Consider using g_str_to_ascii() instead.
//
// The function takes the following parameters:
//
//   - str: the string to convert.
//   - toCodeset: name of character set into which to convert str.
//   - fromCodeset: character set of str.
//
// The function returns the following values:
//
//   - bytesRead (optional): location to store the number of bytes in
//     the input string that were successfully converted, or NULL.
//     Even if the conversion was successful, this may be less than len if
//     there were partial characters at the end of the input. If the error
//     G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//     byte offset after the last valid input sequence.
//   - guint8s: If the conversion was successful, a newly allocated buffer
//     containing the converted string, which must be freed with g_free().
//     Otherwise NULL and error will be set.
func Convert(str, toCodeset, fromCodeset string) (uint, []byte, error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 *C.gchar  // out
	var _arg4 *C.gchar  // out
	var _arg5 C.gsize   // in
	var _cret *C.gchar  // in
	var _arg6 C.gsize   // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_convert(_arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)

	var _bytesRead uint // out
	var _guint8s []byte // out
	var _goerr error    // out

	_bytesRead = uint(_arg5)
	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg6)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg6))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _guint8s, _goerr
}

func ConvertErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_convert_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// ConvertWithFallback converts a string from one character set to another,
// possibly including fallback sequences for characters not representable in
// the output. Note that it is not guaranteed that the specification for the
// fallback sequences in fallback will be honored. Some systems may do an
// approximate conversion from from_codeset to to_codeset in their iconv()
// functions, in which case GLib will simply return that approximate conversion.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that bytes_read can return information about partial characters,
// the g_convert_... functions are not generally suitable for streaming.
// If the underlying converter maintains internal state, then this won't be
// preserved across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.).
//
// The function takes the following parameters:
//
//   - str: the string to convert.
//   - toCodeset: name of character set into which to convert str.
//   - fromCodeset: character set of str.
//   - fallback: UTF-8 string to use in place of characters not present in
//     the target encoding. (The string must be representable in the target
//     encoding). If NULL, characters not in the target encoding will be
//     represented as Unicode escapes \uxxxx or \Uxxxxyyyy.
//
// The function returns the following values:
//
//   - bytesRead (optional): location to store the number of bytes in the input
//     string that were successfully converted, or NULL. Even if the conversion
//     was successful, this may be less than len if there were partial
//     characters at the end of the input.
//   - guint8s: If the conversion was successful, a newly allocated buffer
//     containing the converted string, which must be freed with g_free().
//     Otherwise NULL and error will be set.
func ConvertWithFallback(str, toCodeset, fromCodeset, fallback string) (uint, []byte, error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 *C.gchar  // out
	var _arg4 *C.gchar  // out
	var _arg5 *C.gchar  // out
	var _arg6 C.gsize   // in
	var _cret *C.gchar  // in
	var _arg7 C.gsize   // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(fallback)))
	defer C.free(unsafe.Pointer(_arg5))

	_cret = C.g_convert_with_fallback(_arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, &_arg7, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)
	runtime.KeepAlive(fallback)

	var _bytesRead uint // out
	var _guint8s []byte // out
	var _goerr error    // out

	_bytesRead = uint(_arg6)
	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg7)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg7))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _guint8s, _goerr
}

// Dcgettext: this is a variant of g_dgettext() that allows specifying a
// locale category instead of always using LC_MESSAGES. See g_dgettext() for
// more information about how this functions differs from calling dcgettext()
// directly.
//
// The function takes the following parameters:
//
//   - domain (optional): translation domain to use, or NULL to use the domain
//     set with textdomain().
//   - msgid: message to translate.
//   - category: locale category.
//
// The function returns the following values:
//
//   - utf8: translated string for the given locale category.
func Dcgettext(domain, msgid string, category int) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gint   // out
	var _cret *C.gchar // in

	if domain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(category)

	_cret = C.g_dcgettext(_arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(category)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Dgettext: this function is a wrapper of dgettext() which does not
// translate the message if the default domain as set with textdomain() has no
// translations for the current locale.
//
// The advantage of using this function over dgettext() proper is that libraries
// using this function (like GTK) will not use translations if the application
// using the library does not have translations for the current locale.
// This results in a consistent English-only interface instead of one having
// partial translations. For this feature to work, the call to textdomain() and
// setlocale() should precede any g_dgettext() invocations. For GTK, it means
// calling textdomain() before gtk_init or its variants.
//
// This function disables translations if and only if upon its first call all
// the following conditions hold:
//
// - domain is not NULL
//
// - textdomain() has been called to set a default text domain
//
// - there is no translations available for the default text domain and the
// current locale
//
// - current locale is not "C" or any English locales (those starting with
// "en_")
//
// Note that this behavior may not be desired for example if an application has
// its untranslated messages in a language other than English. In those cases
// the application should call textdomain() after initializing GTK.
//
// Applications should normally not use this function directly, but use the _()
// macro for translations.
//
// The function takes the following parameters:
//
//   - domain (optional): translation domain to use, or NULL to use the domain
//     set with textdomain().
//   - msgid: message to translate.
//
// The function returns the following values:
//
//   - utf8: translated string.
func Dgettext(domain, msgid string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	if domain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dgettext(_arg1, _arg2)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DirectEqual compares two #gpointer arguments and returns TRUE if they
// are equal. It can be passed to g_hash_table_new() as the key_equal_func
// parameter, when using opaque pointers compared by pointer value as keys in a
// Table.
//
// This equality function is also appropriate for keys that are integers stored
// in pointers, such as GINT_TO_POINTER (n).
//
// The function takes the following parameters:
//
//   - v1 (optional): key.
//   - v2 (optional): key to compare with v1.
//
// The function returns the following values:
//
//   - ok: TRUE if the two keys match.
func DirectEqual(v1, v2 unsafe.Pointer) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_direct_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DirectHash converts a gpointer to a hash value. It can be passed to
// g_hash_table_new() as the hash_func parameter, when using opaque pointers
// compared by pointer value as keys in a Table.
//
// This hash function is also appropriate for keys that are integers stored in
// pointers, such as GINT_TO_POINTER (n).
//
// The function takes the following parameters:
//
//   - v (optional): #gpointer key.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to the key.
func DirectHash(v unsafe.Pointer) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_direct_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Dngettext: this function is a wrapper of dngettext() which does not
// translate the message if the default domain as set with textdomain() has no
// translations for the current locale.
//
// See g_dgettext() for details of how this differs from dngettext() proper.
//
// The function takes the following parameters:
//
//   - domain (optional): translation domain to use, or NULL to use the domain
//     set with textdomain().
//   - msgid: message to translate.
//   - msgidPlural: plural form of the message.
//   - n: quantity for which translation is needed.
//
// The function returns the following values:
//
//   - utf8: translated string.
func Dngettext(domain, msgid, msgidPlural string, n uint32) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out
	var _arg4 C.gulong // out
	var _cret *C.gchar // in

	if domain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(msgidPlural)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.gulong(n)

	_cret = C.g_dngettext(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(msgidPlural)
	runtime.KeepAlive(n)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DoubleEqual compares the two #gdouble values being pointed to and returns
// TRUE if they are equal. It can be passed to g_hash_table_new() as the
// key_equal_func parameter, when using non-NULL pointers to doubles as keys in
// a Table.
//
// The function takes the following parameters:
//
//   - v1: pointer to a #gdouble key.
//   - v2: pointer to a #gdouble key to compare with v1.
//
// The function returns the following values:
//
//   - ok: TRUE if the two keys match.
func DoubleEqual(v1, v2 unsafe.Pointer) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_double_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DoubleHash converts a pointer to a #gdouble to a hash value. It can be
// passed to g_hash_table_new() as the hash_func parameter, It can be passed to
// g_hash_table_new() as the hash_func parameter, when using non-NULL pointers
// to doubles as keys in a Table.
//
// The function takes the following parameters:
//
//   - v: pointer to a #gdouble key.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to the key.
func DoubleHash(v unsafe.Pointer) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_double_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Dpgettext: this function is a variant of g_dgettext() which supports a
// disambiguating message context. GNU gettext uses the '\004' character to
// separate the message context and message id in msgctxtid. If 0 is passed as
// msgidoffset, this function will fall back to trying to use the deprecated
// convention of using "|" as a separation character.
//
// This uses g_dgettext() internally. See that functions for differences with
// dgettext() proper.
//
// Applications should normally not use this function directly, but use the C_()
// macro for translations with context.
//
// The function takes the following parameters:
//
//   - domain (optional): translation domain to use, or NULL to use the domain
//     set with textdomain().
//   - msgctxtid: combined message context and message id, separated by a \004
//     character.
//   - msgidoffset: offset of the message id in msgctxid.
//
// The function returns the following values:
//
//   - utf8: translated string.
func Dpgettext(domain, msgctxtid string, msgidoffset uint) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gsize  // out
	var _cret *C.gchar // in

	if domain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgctxtid)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gsize(msgidoffset)

	_cret = C.g_dpgettext(_arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgctxtid)
	runtime.KeepAlive(msgidoffset)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Dpgettext2: this function is a variant of g_dgettext() which supports a
// disambiguating message context. GNU gettext uses the '\004' character to
// separate the message context and message id in msgctxtid.
//
// This uses g_dgettext() internally. See that functions for differences with
// dgettext() proper.
//
// This function differs from C_() in that it is not a macro and thus you may
// use non-string-literals as context and msgid arguments.
//
// The function takes the following parameters:
//
//   - domain (optional): translation domain to use, or NULL to use the domain
//     set with textdomain().
//   - context: message context.
//   - msgid: message.
//
// The function returns the following values:
//
//   - utf8: translated string.
func Dpgettext2(domain, context, msgid string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out
	var _cret *C.gchar // in

	if domain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(context)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dpgettext2(_arg1, _arg2, _arg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(context)
	runtime.KeepAlive(msgid)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EnvironGetenv returns the value of the environment variable variable in the
// provided list envp.
//
// The function takes the following parameters:
//
//   - envp (optional): an environment list (eg, as returned from
//     g_get_environ()), or NULL for an empty environment list.
//   - variable: environment variable to get.
//
// The function returns the following values:
//
//   - filename (optional): value of the environment variable, or NULL if the
//     environment variable is not set in envp. The returned string is owned by
//     envp, and will be freed if variable is set or unset again.
func EnvironGetenv(envp []string, variable string) string {
	var _arg1 **C.gchar // out
	var _arg2 *C.gchar  // out
	var _cret *C.gchar  // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(envp) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(envp)+1)
			var zero *C.gchar
			out[len(envp)] = zero
			for i := range envp {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(envp[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_environ_getenv(_arg1, _arg2)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// EnvironSetenv sets the environment variable variable in the provided list
// envp to value.
//
// The function takes the following parameters:
//
//   - envp (optional): an environment list that can be freed using g_strfreev()
//     (e.g., as returned from g_get_environ()), or NULL for an empty
//     environment list.
//   - variable: environment variable to set, must not contain '='.
//   - value for to set the variable to.
//   - overwrite: whether to change the variable if it already exists.
//
// The function returns the following values:
//
//   - filenames: the updated environment list. Free it using g_strfreev().
func EnvironSetenv(envp []string, variable, value string, overwrite bool) []string {
	var _arg1 **C.gchar  // out
	var _arg2 *C.gchar   // out
	var _arg3 *C.gchar   // out
	var _arg4 C.gboolean // out
	var _cret **C.gchar  // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(envp) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice(_arg1, len(envp)+1)
			var zero *C.gchar
			out[len(envp)] = zero
			for i := range envp {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(envp[i])))
			}
		}
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg3))
	if overwrite {
		_arg4 = C.TRUE
	}

	_cret = C.g_environ_setenv(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
	runtime.KeepAlive(overwrite)

	var _filenames []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// EnvironUnsetenv removes the environment variable variable from the provided
// environment envp.
//
// The function takes the following parameters:
//
//   - envp (optional): an environment list that can be freed using g_strfreev()
//     (e.g., as returned from g_get_environ()), or NULL for an empty
//     environment list.
//   - variable: environment variable to remove, must not contain '='.
//
// The function returns the following values:
//
//   - filenames: the updated environment list. Free it using g_strfreev().
func EnvironUnsetenv(envp []string, variable string) []string {
	var _arg1 **C.gchar // out
	var _arg2 *C.gchar  // out
	var _cret **C.gchar // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(envp) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice(_arg1, len(envp)+1)
			var zero *C.gchar
			out[len(envp)] = zero
			for i := range envp {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(envp[i])))
			}
		}
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_environ_unsetenv(_arg1, _arg2)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)

	var _filenames []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// FileErrorFromErrno gets a Error constant based on the passed-in err_no.
//
// For example, if you pass in EEXIST this function returns G_FILE_ERROR_EXIST.
// Unlike errno values, you can portably assume that all Error values will
// exist.
//
// Normally a Error value goes into a #GError returned from a function
// that manipulates files. So you would use g_file_error_from_errno() when
// constructing a #GError.
//
// The function takes the following parameters:
//
//   - errNo: "errno" value.
//
// The function returns the following values:
//
//   - fileError corresponding to the given err_no.
func FileErrorFromErrno(errNo int) FileError {
	var _arg1 C.gint       // out
	var _cret C.GFileError // in

	_arg1 = C.gint(errNo)

	_cret = C.g_file_error_from_errno(_arg1)
	runtime.KeepAlive(errNo)

	var _fileError FileError // out

	_fileError = FileError(_cret)

	return _fileError
}

func FileErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_file_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// FileGetContents reads an entire file into allocated memory, with good error
// checking.
//
// If the call was successful, it returns TRUE and sets contents to the
// file contents and length to the length of the file contents in bytes.
// The string stored in contents will be nul-terminated, so for text files
// you can pass NULL for the length argument. If the call was not successful,
// it returns FALSE and sets error. The error domain is G_FILE_ERROR.
// Possible error codes are those in the Error enumeration. In the error case,
// contents is set to NULL and length is set to zero.
//
// The function takes the following parameters:
//
//   - filename: name of a file to read contents from, in the GLib file name
//     encoding.
//
// The function returns the following values:
//
//   - contents: location to store an allocated string, use g_free() to free the
//     returned string.
func FileGetContents(filename string) ([]byte, error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // in
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_get_contents(_arg1, &_arg2, &_arg3, &_cerr)
	runtime.KeepAlive(filename)

	var _contents []byte // out
	var _goerr error     // out

	defer C.free(unsafe.Pointer(_arg2))
	_contents = make([]byte, _arg3)
	copy(_contents, unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _contents, _goerr
}

// FileOpenTmp opens a file for writing in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is NULL, a default template is used.
//
// Note that in contrast to g_mkstemp() (and mkstemp()) tmpl is not modified,
// and might thus be a read-only literal string.
//
// Upon success, and if name_used is non-NULL, the actual name used is returned
// in name_used. This string should be freed with g_free() when not needed any
// longer. The returned name is in the GLib file name encoding.
//
// The function takes the following parameters:
//
//   - tmpl (optional): template for file name, as in g_mkstemp(), basename
//     only, or NULL for a default template.
//
// The function returns the following values:
//
//   - nameUsed: location to store actual name used, or NULL.
//   - gint: file handle (as from open()) to the file opened for reading and
//     writing. The file is opened in binary mode on platforms where there is
//     a difference. The file handle should be closed with close(). In case of
//     errors, -1 is returned and error will be set.
func FileOpenTmp(tmpl string) (string, int, error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // in
	var _cret C.gint    // in
	var _cerr *C.GError // in

	if tmpl != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_file_open_tmp(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(tmpl)

	var _nameUsed string // out
	var _gint int        // out
	var _goerr error     // out

	_nameUsed = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	defer C.free(unsafe.Pointer(_arg2))
	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _nameUsed, _gint, _goerr
}

// FileReadLink reads the contents of the symbolic link filename like the POSIX
// readlink() function.
//
// The returned string is in the encoding used for filenames. Use
// g_filename_to_utf8() to convert it to UTF-8.
//
// The returned string may also be a relative path. Use g_build_filename() to
// convert it to an absolute path:
//
//	g_autoptr(GError) local_error = NULL;
//	g_autofree gchar *link_target = g_file_read_link ("/etc/localtime", &local_error);
//
//	if (local_error != NULL)
//	  g_error ("Error reading link: s", local_error->message);
//
//	if (!g_path_is_absolute (link_target))
//	  {
//	    g_autofree gchar *absolute_link_target = g_build_filename ("/etc", link_target, NULL);
//	    g_free (link_target);
//	    link_target = g_steal_pointer (&absolute_link_target);
//	  }.
//
// The function takes the following parameters:
//
//   - filename: symbolic link.
//
// The function returns the following values:
//
//   - ret: newly-allocated string with the contents of the symbolic link,
//     or NULL if an error occurred.
func FileReadLink(filename string) (string, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_read_link(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _ret string  // out
	var _goerr error // out

	_ret = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// FileSetContents writes all of contents to a file named filename. This is a
// convenience wrapper around calling g_file_set_contents_full() with flags set
// to G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING and
// mode set to 0666.
//
// The function takes the following parameters:
//
//   - filename: name of a file to write contents to, in the GLib file name
//     encoding.
//   - contents: string to write to the file.
func FileSetContents(filename, contents string) error {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gssize
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (C.gssize)(len(contents))
	_arg2 = (*C.gchar)(C.calloc(C.size_t((len(contents) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(contents)), contents)
	defer C.free(unsafe.Pointer(_arg2))

	C.g_file_set_contents(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contents)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FileSetContentsFull writes all of contents to a file named filename,
// with good error checking. If a file called filename already exists it will be
// overwritten.
//
// flags control the properties of the write operation: whether it’s atomic,
// and what the tradeoff is between returning quickly or being resilient to
// system crashes.
//
// As this function performs file I/O, it is recommended to not call it
// anywhere where blocking would cause problems, such as in the main loop of
// a graphical application. In particular, if flags has any value other than
// G_FILE_SET_CONTENTS_NONE then this function may call fsync().
//
// If G_FILE_SET_CONTENTS_CONSISTENT is set in flags, the operation is atomic in
// the sense that it is first written to a temporary file which is then renamed
// to the final name.
//
// Notes:
//
// - On UNIX, if filename already exists hard links to filename will break.
// Also since the file is recreated, existing permissions, access control lists,
// metadata etc. may be lost. If filename is a symbolic link, the link itself
// will be replaced, not the linked file.
//
// - On UNIX, if filename already exists and is non-empty, and if the
// system supports it (via a journalling filesystem or equivalent),
// and if G_FILE_SET_CONTENTS_CONSISTENT is set in flags, the fsync() call (or
// equivalent) will be used to ensure atomic replacement: filename will contain
// either its old contents or contents, even in the face of system power loss,
// the disk being unsafely removed, etc.
//
// - On UNIX, if filename does not already exist or is empty,
// there is a possibility that system power loss etc. after calling this
// function will leave filename empty or full of NUL bytes, depending
// on the underlying filesystem, unless G_FILE_SET_CONTENTS_DURABLE and
// G_FILE_SET_CONTENTS_CONSISTENT are set in flags.
//
// - On Windows renaming a file will not remove an existing file with the new
// name, so on Windows there is a race condition between the existing file being
// removed and the temporary file being renamed.
//
// - On Windows there is no way to remove a file that is open to some process,
// or mapped into memory. Thus, this function will fail if filename already
// exists and is open.
//
// If the call was successful, it returns TRUE. If the call was not successful,
// it returns FALSE and sets error. The error domain is G_FILE_ERROR. Possible
// error codes are those in the Error enumeration.
//
// Note that the name for the temporary file is constructed by appending up to 7
// characters to filename.
//
// If the file didn’t exist before and is created, it will be given the
// permissions from mode. Otherwise, the permissions of the existing file may be
// changed to mode depending on flags, or they may remain unchanged.
//
// The function takes the following parameters:
//
//   - filename: name of a file to write contents to, in the GLib file name
//     encoding.
//   - contents: string to write to the file.
//   - flags controlling the safety vs speed of the operation.
//   - mode: file mode, as passed to open(); typically this will be 0666.
func FileSetContentsFull(filename, contents string, flags FileSetContentsFlags, mode int) error {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gssize
	var _arg4 C.GFileSetContentsFlags // out
	var _arg5 C.int                   // out
	var _cerr *C.GError               // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (C.gssize)(len(contents))
	_arg2 = (*C.gchar)(C.calloc(C.size_t((len(contents) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(contents)), contents)
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = C.GFileSetContentsFlags(flags)
	_arg5 = C.int(mode)

	C.g_file_set_contents_full(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mode)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// TestFile returns TRUE if any of the tests in the bitfield test are TRUE.
// For example, (G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR) will return TRUE if
// the file exists; the check whether it's a directory doesn't matter since the
// existence test is TRUE. With the current set of available tests, there's no
// point passing in more than one test at a time.
//
// Apart from G_FILE_TEST_IS_SYMLINK all tests follow symbolic links, so for
// a symbolic link to a regular file g_file_test() will return TRUE for both
// G_FILE_TEST_IS_SYMLINK and G_FILE_TEST_IS_REGULAR.
//
// Note, that for a dangling symbolic link g_file_test() will return TRUE for
// G_FILE_TEST_IS_SYMLINK and FALSE for all other flags.
//
// You should never use g_file_test() to test whether it is safe to
// perform an operation, because there is always the possibility of the
// condition changing before you actually perform the operation, see TOCTOU
// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use).
//
// For example, you might think you could use G_FILE_TEST_IS_SYMLINK to know
// whether it is safe to write to a file without being tricked into writing into
// a different location. It doesn't work!
//
//	// DON'T DO THIS
//	if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
//	  {
//	    fd = g_open (filename, O_WRONLY);
//	    // write to fd
//	  }
//
//	// DO THIS INSTEAD
//	fd = g_open (filename, O_WRONLY | O_NOFOLLOW | O_CLOEXEC);
//	if (fd == -1)
//	  {
//	    // check error
//	    if (errno == ELOOP)
//	      // file is a symlink and can be ignored
//	    else
//	      // handle errors as before
//	  }
//	else
//	  {
//	    // write to fd
//	  }
//
// Another thing to note is that G_FILE_TEST_EXISTS and
// G_FILE_TEST_IS_EXECUTABLE are implemented using the access() system call.
// This usually doesn't matter, but if your program is setuid or setgid it means
// that these tests will give you the answer for the real user ID and group ID,
// rather than the effective user ID and group ID.
//
// On Windows, there are no symlinks, so testing for G_FILE_TEST_IS_SYMLINK will
// always return FALSE. Testing for G_FILE_TEST_IS_EXECUTABLE will just check
// that the file exists and its name indicates that it is executable, checking
// for well-known extensions and those listed in the PATHEXT environment
// variable.
//
// This type has been renamed from file_test.
//
// The function takes the following parameters:
//
//   - filename to test in the GLib file name encoding.
//   - test: bitfield of Test flags.
//
// The function returns the following values:
//
//   - ok: whether a test was TRUE.
func TestFile(filename string, test FileTest) bool {
	var _arg1 *C.gchar    // out
	var _arg2 C.GFileTest // out
	var _cret C.gboolean  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileTest(test)

	_cret = C.g_file_test(_arg1, _arg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(test)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FilenameDisplayBasename returns the display basename for the particular
// filename, guaranteed to be valid UTF-8. The display name might not be
// identical to the filename, for instance there might be problems converting it
// to UTF-8, and some files can be translated in the display.
//
// If GLib cannot make sense of the encoding of filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if filename was in an invalid
// encoding.
//
// You must pass the whole absolute pathname to this functions so that
// translation of well known locations can be done.
//
// This function is preferred over g_filename_display_name() if you know the
// whole path, as it allows translation.
//
// The function takes the following parameters:
//
//   - filename: absolute pathname in the GLib file name encoding.
//
// The function returns the following values:
//
//   - utf8: newly allocated string containing a rendition of the basename of
//     the filename in valid UTF-8.
func FilenameDisplayBasename(filename string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_display_basename(_arg1)
	runtime.KeepAlive(filename)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FilenameDisplayName converts a filename into a valid UTF-8 string.
// The conversion is not necessarily reversible, so you should keep the original
// around and use the return value of this function only for display purposes.
// Unlike g_filename_to_utf8(), the result is guaranteed to be non-NULL even if
// the filename actually isn't in the GLib file name encoding.
//
// If GLib cannot make sense of the encoding of filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if filename was in an invalid
// encoding.
//
// If you know the whole pathname of the file you should use
// g_filename_display_basename(), since that allows location-based translation
// of filenames.
//
// The function takes the following parameters:
//
//   - filename: pathname hopefully in the GLib file name encoding.
//
// The function returns the following values:
//
//   - utf8: newly allocated string containing a rendition of the filename in
//     valid UTF-8.
func FilenameDisplayName(filename string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_display_name(_arg1)
	runtime.KeepAlive(filename)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FilenameFromURI converts an escaped ASCII-encoded URI to a local filename in
// the encoding used for filenames.
//
// Since GLib 2.78, the query string and fragment can be present in the URI,
// but are not part of the resulting filename. We take inspiration from
// https://url.spec.whatwg.org/#file-state, but we don't support the entire
// standard.
//
// The function takes the following parameters:
//
//   - uri describing a filename (escaped, encoded in ASCII).
//
// The function returns the following values:
//
//   - hostname (optional): location to store hostname for the URI. If there is
//     no hostname in the URI, NULL will be stored in this location.
//   - filename: newly-allocated string holding the resulting filename, or NULL
//     on an error.
func FilenameFromURI(uri string) (hostname, filename string, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_from_uri(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(uri)

	var _hostname string // out
	var _filename string // out
	var _goerr error     // out

	if _arg2 != nil {
		_hostname = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _hostname, _filename, _goerr
}

// FilenameFromUTF8 converts a string from UTF-8 to the encoding GLib uses
// for filenames. Note that on Windows GLib uses UTF-8 for filenames;
// on other platforms, this function indirectly depends on the [current
// locale][setlocale].
//
// The input string shall not contain nul characters even if the len argument
// is positive. A nul character found inside the string will result in
// error G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is not
// UTF-8 and the conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns NULL.
//
// The function takes the following parameters:
//
//   - utf8String: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - bytesRead (optional): location to store the number of bytes in
//     the input string that were successfully converted, or NULL.
//     Even if the conversion was successful, this may be less than len if
//     there were partial characters at the end of the input. If the error
//     G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//     byte offset after the last valid input sequence.
//   - bytesWritten (optional): number of bytes stored in the output buffer (not
//     including the terminating nul).
//   - filename: The converted string, or NULL on an error.
func FilenameFromUTF8(utf8String string) (bytesRead, bytesWritten uint, filename string, goerr error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(utf8String))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(utf8String) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(utf8String)), utf8String)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_from_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(utf8String)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _filename string   // out
	var _goerr error       // out

	_bytesRead = uint(_arg3)
	_bytesWritten = uint(_arg4)
	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _filename, _goerr
}

// FilenameToURI converts an absolute filename to an escaped ASCII-encoded URI,
// with the path component following Section 3.3. of RFC 2396.
//
// The function takes the following parameters:
//
//   - filename: absolute filename specified in the GLib file name encoding,
//     which is the on-disk file name bytes on Unix, and UTF-8 on Windows.
//   - hostname (optional): UTF-8 encoded hostname, or NULL for none.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string holding the resulting URI, or NULL on an
//     error.
func FilenameToURI(filename, hostname string) (string, error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	if hostname != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_filename_to_uri(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(hostname)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// FilenameToUTF8 converts a string which is in the encoding used by GLib
// for filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8
// for filenames; on other platforms, this function indirectly depends on the
// [current locale][setlocale].
//
// The input string shall not contain nul characters even if the len argument
// is positive. A nul character found inside the string will result in
// error G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the source encoding is not
// UTF-8 and the conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns NULL. Use
// g_convert() to produce output that may contain embedded nul characters.
//
// The function takes the following parameters:
//
//   - opsysstring: string in the encoding for filenames.
//
// The function returns the following values:
//
//   - bytesRead (optional): location to store the number of bytes in
//     the input string that were successfully converted, or NULL.
//     Even if the conversion was successful, this may be less than len if
//     there were partial characters at the end of the input. If the error
//     G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//     byte offset after the last valid input sequence.
//   - bytesWritten (optional): number of bytes stored in the output buffer (not
//     including the terminating nul).
//   - utf8: converted string, or NULL on an error.
func FilenameToUTF8(opsysstring string) (bytesRead, bytesWritten uint, utf8 string, goerr error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(opsysstring))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(opsysstring) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(opsysstring)), opsysstring)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(opsysstring)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _utf8 string       // out
	var _goerr error       // out

	_bytesRead = uint(_arg3)
	_bytesWritten = uint(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _utf8, _goerr
}

// FindProgramInPath locates the first executable named program in the user's
// path, in the same way that execvp() would locate it. Returns an allocated
// string with the absolute path name, or NULL if the program is not found
// in the path. If program is already an absolute path, returns a copy of
// program if program exists and is executable, and NULL otherwise. On Windows,
// if program does not have a file type suffix, tries with the suffixes .exe,
// .cmd, .bat and .com, and the suffixes in the PATHEXT environment variable.
//
// On Windows, it looks for the file in the same way as CreateProcess() would.
// This means first in the directory where the executing program was loaded
// from, then in the current directory, then in the Windows 32-bit system
// directory, then in the Windows directory, and finally in the directories
// in the PATH environment variable. If the program is found, the return value
// contains the full name including the type suffix.
//
// The function takes the following parameters:
//
//   - program name in the GLib file name encoding.
//
// The function returns the following values:
//
//   - filename (optional): newly-allocated string with the absolute path,
//     or NULL.
func FindProgramInPath(program string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(program)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_find_program_in_path(_arg1)
	runtime.KeepAlive(program)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// FormatSize formats a size (for example the size of a file) into a human
// readable string. Sizes are rounded to the nearest size prefix (kB, MB,
// GB) and are displayed rounded to the nearest tenth. E.g. the file size
// 3292528 bytes will be converted into the string "3.2 MB". The returned string
// is UTF-8, and may use a non-breaking space to separate the number and units,
// to ensure they aren’t separated when line wrapped.
//
// The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
//
// This string should be freed with g_free() when not needed any longer.
//
// See g_format_size_full() for more options about how the size might be
// formatted.
//
// The function takes the following parameters:
//
//   - size in bytes.
//
// The function returns the following values:
//
//   - utf8: newly-allocated formatted string containing a human readable file
//     size.
func FormatSize(size uint64) string {
	var _arg1 C.guint64 // out
	var _cret *C.gchar  // in

	_arg1 = C.guint64(size)

	_cret = C.g_format_size(_arg1)
	runtime.KeepAlive(size)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FormatSizeForDisplay formats a size (for example the size of a file) into
// a human readable string. Sizes are rounded to the nearest size prefix (KB,
// MB, GB) and are displayed rounded to the nearest tenth. E.g. the file size
// 3292528 bytes will be converted into the string "3.1 MB".
//
// The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).
//
// This string should be freed with g_free() when not needed any longer.
//
// Deprecated: This function is broken due to its use of SI suffixes to denote
// IEC units. Use g_format_size() instead.
//
// The function takes the following parameters:
//
//   - size in bytes.
//
// The function returns the following values:
//
//   - utf8: newly-allocated formatted string containing a human readable file
//     size.
func FormatSizeForDisplay(size int64) string {
	var _arg1 C.goffset // out
	var _cret *C.gchar  // in

	_arg1 = C.goffset(size)

	_cret = C.g_format_size_for_display(_arg1)
	runtime.KeepAlive(size)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FormatSizeFull formats a size.
//
// This function is similar to g_format_size() but allows for flags that modify
// the output. See SizeFlags.
//
// The function takes the following parameters:
//
//   - size in bytes.
//   - flags to modify the output.
//
// The function returns the following values:
//
//   - utf8: newly-allocated formatted string containing a human readable file
//     size.
func FormatSizeFull(size uint64, flags FormatSizeFlags) string {
	var _arg1 C.guint64          // out
	var _arg2 C.GFormatSizeFlags // out
	var _cret *C.gchar           // in

	_arg1 = C.guint64(size)
	_arg2 = C.GFormatSizeFlags(flags)

	_cret = C.g_format_size_full(_arg1, _arg2)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetApplicationName gets a human-readable name for the application, as set
// by g_set_application_name(). This name should be localized if possible,
// and is intended for display to the user. Contrast with g_get_prgname(), which
// gets a non-localized name. If g_set_application_name() has not been called,
// returns the result of g_get_prgname() (which may be NULL if g_set_prgname()
// has also not been called).
//
// The function returns the following values:
//
//   - utf8 (optional): human-readable application name. May return NULL.
func GetApplicationName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_application_name()

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// GetCharset obtains the character set for the [current locale][setlocale];
// you might use this character set as an argument to g_convert(), to convert
// from the current locale's encoding to some other encoding. (Frequently
// g_locale_to_utf8() and g_locale_from_utf8() are nice shortcuts, though.)
//
// On Windows the character set returned by this function is the so-called
// system default ANSI code-page. That is the character set used by the "narrow"
// versions of C library and Win32 functions that handle file names. It might be
// different from the character set used by the C library's current locale.
//
// On Linux, the character set is found by consulting nl_langinfo() if
// available. If not, the environment variables LC_ALL, LC_CTYPE, LANG and
// CHARSET are queried in order. nl_langinfo() returns the C locale if no locale
// has been loaded by setlocale().
//
// The return value is TRUE if the locale's encoding is UTF-8, in that case you
// can perhaps avoid calling g_convert().
//
// The string returned in charset is not allocated, and should not be freed.
//
// The function returns the following values:
//
//   - charset (optional): return location for character set name, or NULL.
//   - ok: TRUE if the returned charset is UTF-8.
func GetCharset() (string, bool) {
	var _arg1 *C.char    // in
	var _cret C.gboolean // in

	_cret = C.g_get_charset(&_arg1)

	var _charset string // out
	var _ok bool        // out

	if _arg1 != nil {
		_charset = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _charset, _ok
}

// GetCodeset gets the character set for the current locale.
//
// The function returns the following values:
//
//   - utf8: newly allocated string containing the name of the character set.
//     This string must be freed with g_free().
func GetCodeset() string {
	var _cret *C.gchar // in

	_cret = C.g_get_codeset()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetConsoleCharset obtains the character set used by the console attached to
// the process, which is suitable for printing output to the terminal.
//
// Usually this matches the result returned by g_get_charset(), but in
// environments where the locale's character set does not match the encoding of
// the console this function tries to guess a more suitable value instead.
//
// On Windows the character set returned by this function is the output code
// page used by the console associated with the calling process. If the codepage
// can't be determined (for example because there is no console attached) UTF-8
// is assumed.
//
// The return value is TRUE if the locale's encoding is UTF-8, in that case you
// can perhaps avoid calling g_convert().
//
// The string returned in charset is not allocated, and should not be freed.
//
// The function returns the following values:
//
//   - charset (optional): return location for character set name, or NULL.
//   - ok: TRUE if the returned charset is UTF-8.
func GetConsoleCharset() (string, bool) {
	var _arg1 *C.char    // in
	var _cret C.gboolean // in

	_cret = C.g_get_console_charset(&_arg1)

	var _charset string // out
	var _ok bool        // out

	if _arg1 != nil {
		_charset = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _charset, _ok
}

// GetCurrentDir gets the current directory.
//
// The returned string should be freed when no longer needed. The encoding of
// the returned string is system defined. On Windows, it is always UTF-8.
//
// Since GLib 2.40, this function will return the value of the "PWD" environment
// variable if it is set and it happens to be the same as the current directory.
// This can make a difference in the case that the current directory is the
// target of a symbolic link.
//
// The function returns the following values:
//
//   - filename: current directory.
func GetCurrentDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_current_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// GetCurrentTime: equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
//
// Deprecated: Val is not year-2038-safe. Use g_get_real_time() instead.
//
// The function takes the following parameters:
//
//   - result structure in which to store current time.
func GetCurrentTime(result *TimeVal) {
	var _arg1 *C.GTimeVal // out

	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(result)))

	C.g_get_current_time(_arg1)
	runtime.KeepAlive(result)
}

// GetEnviron gets the list of environment variables for the current process.
//
// The list is NULL terminated and each item in the list is of the form
// 'NAME=VALUE'.
//
// This is equivalent to direct access to the 'environ' global variable,
// except portable.
//
// The return value is freshly allocated and it should be freed with
// g_strfreev() when it is no longer needed.
//
// The function returns the following values:
//
//   - filenames: the list of environment variables.
func GetEnviron() []string {
	var _cret **C.gchar // in

	_cret = C.g_get_environ()

	var _filenames []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// GetFilenameCharsets determines the preferred character sets used for
// filenames. The first character set from the charsets is the filename
// encoding, the subsequent character sets are used when trying to generate a
// displayable representation of a filename, see g_filename_display_name().
//
// On Unix, the character sets are determined by consulting the environment
// variables G_FILENAME_ENCODING and G_BROKEN_FILENAMES. On Windows,
// the character set used in the GLib API is always UTF-8 and said environment
// variables have no effect.
//
// G_FILENAME_ENCODING may be set to a comma-separated list of character set
// names. The special token "\locale" is taken to mean the character set
// for the [current locale][setlocale]. If G_FILENAME_ENCODING is not set,
// but G_BROKEN_FILENAMES is, the character set of the current locale is taken
// as the filename encoding. If neither environment variable is set, UTF-8 is
// taken as the filename encoding, but the character set of the current locale
// is also put in the list of encodings.
//
// The returned charsets belong to GLib and must not be freed.
//
// Note that on Unix, regardless of the locale character set or
// G_FILENAME_ENCODING value, the actual file names present on a system might be
// in any random encoding or just gibberish.
//
// The function returns the following values:
//
//   - filenameCharsets: return location for the NULL-terminated list of
//     encoding names.
//   - ok: TRUE if the filename encoding is UTF-8.
func GetFilenameCharsets() ([]string, bool) {
	var _arg1 **C.gchar  // in
	var _cret C.gboolean // in

	_cret = C.g_get_filename_charsets(&_arg1)

	var _filenameCharsets []string // out
	var _ok bool                   // out

	{
		var i int
		var z *C.gchar
		for p := _arg1; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_arg1, i)
		_filenameCharsets = make([]string, i)
		for i := range src {
			_filenameCharsets[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _filenameCharsets, _ok
}

// GetHomeDir gets the current user's home directory.
//
// As with most UNIX tools, this function will return the value of the HOME
// environment variable if it is set to an existing absolute path name, falling
// back to the passwd file in the case that it is unset.
//
// If the path given in HOME is non-absolute, does not exist, or is not a
// directory, the result is undefined.
//
// Before version 2.36 this function would ignore the HOME environment variable,
// taking the value from the passwd database instead. This was changed to
// increase the compatibility of GLib with other programs (and the XDG basedir
// specification) and to increase testability of programs based on GLib (by
// making it easier to run them from test frameworks).
//
// If your program has a strong requirement for either the new or the old
// behaviour (and if you don't wish to increase your GLib dependency to ensure
// that the new behaviour is in effect) then you should either directly check
// the HOME environment variable yourself or unset it before calling any
// functions in GLib.
//
// The function returns the following values:
//
//   - filename: current user's home directory.
func GetHomeDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_home_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetHostName: return a name for the machine.
//
// The returned name is not necessarily a fully-qualified domain name,
// or even present in DNS or some other name service at all. It need not even
// be unique on your local network or site, but usually it is. Callers should
// not rely on the return value having any specific properties like uniqueness
// for security purposes. Even if the name of the machine is changed while an
// application is running, the return value from this function does not change.
// The returned string is owned by GLib and should not be modified or freed.
// If no name can be determined, a default fixed string "localhost" is returned.
//
// The encoding of the returned string is UTF-8.
//
// The function returns the following values:
//
//   - utf8: host name of the machine.
func GetHostName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_host_name()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GetLanguageNames computes a list of applicable locale names, which can
// be used to e.g. construct locale-dependent filenames or search paths.
// The returned list is sorted from most desirable to least desirable and always
// contains the default locale "C".
//
// For example, if LANGUAGE=de:en_US, then the returned list is "de", "en_US",
// "en", "C".
//
// This function consults the environment variables LANGUAGE, LC_ALL,
// LC_MESSAGES and LANG to find the list of locales specified by the user.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings owned by GLib that must not be
//     modified or freed.
func GetLanguageNames() []string {
	var _cret **C.gchar // in

	_cret = C.g_get_language_names()

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// GetLanguageNamesWithCategory computes a list of applicable locale names
// with a locale category name, which can be used to construct the fallback
// locale-dependent filenames or search paths. The returned list is sorted from
// most desirable to least desirable and always contains the default locale "C".
//
// This function consults the environment variables LANGUAGE, LC_ALL,
// category_name, and LANG to find the list of locales specified by the user.
//
// g_get_language_names() returns
// g_get_language_names_with_category("LC_MESSAGES").
//
// The function takes the following parameters:
//
//   - categoryName: locale category name.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings owned by the thread
//     g_get_language_names_with_category was called from. It must not be
//     modified or freed. It must be copied if planned to be used in another
//     thread.
func GetLanguageNamesWithCategory(categoryName string) []string {
	var _arg1 *C.gchar  // out
	var _cret **C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(categoryName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_get_language_names_with_category(_arg1)
	runtime.KeepAlive(categoryName)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// GetLocaleVariants returns a list of derived variants of locale, which can
// be used to e.g. construct locale-dependent filenames or search paths. The
// returned list is sorted from most desirable to least desirable. This function
// handles territory, charset and extra locale modifiers. See setlocale(3)
// (man:setlocale) for information about locales and their format.
//
// locale itself is guaranteed to be returned in the output.
//
// For example, if locale is fr_BE, then the returned list is fr_BE, fr.
// If locale is en_GB.UTF-8euro, then the returned list is en_GB.UTF-8euro,
// en_GB.UTF-8, en_GBeuro, en_GB, en.UTF-8euro, en.UTF-8, eneuro, en.
//
// If you need the list of variants for the current locale, use
// g_get_language_names().
//
// The function takes the following parameters:
//
//   - locale identifier.
//
// The function returns the following values:
//
//   - utf8s: newly allocated array of newly allocated strings with the locale
//     variants. Free with g_strfreev().
func GetLocaleVariants(locale string) []string {
	var _arg1 *C.gchar  // out
	var _cret **C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_get_locale_variants(_arg1)
	runtime.KeepAlive(locale)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// GetMonotonicTime queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer discontinuities
// when the user (or NTP) changes the system time. It may or may not continue to
// tick during times where the machine is suspended.
//
// We try to use the clock that corresponds as closely as possible to the
// passage of time as measured by system calls such as poll() but it may not
// always be possible to do this.
//
// The function returns the following values:
//
//   - gint64: monotonic time, in microseconds.
func GetMonotonicTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_monotonic_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// GetOsInfo: get information about the operating system.
//
// On Linux this comes from the /etc/os-release file. On other systems,
// it may come from a variety of sources. You can either use the standard key
// names like G_OS_INFO_KEY_NAME or pass any UTF-8 string key name. For example,
// /etc/os-release provides a number of other less commonly used values that may
// be useful. No key is guaranteed to be provided, so the caller should always
// check if the result is NULL.
//
// The function takes the following parameters:
//
//   - keyName: key for the OS info being requested, for example
//     G_OS_INFO_KEY_NAME.
//
// The function returns the following values:
//
//   - utf8 (optional): associated value for the requested key or NULL if this
//     information is not provided.
func GetOsInfo(keyName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(keyName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_get_os_info(_arg1)
	runtime.KeepAlive(keyName)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// GetPrgname gets the name of the program. This name should not be localized,
// in contrast to g_get_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of argv[0].
//
// The function returns the following values:
//
//   - utf8 (optional): name of the program, or NULL if it has not been set yet.
//     The returned string belongs to GLib and must not be modified or freed.
func GetPrgname() string {
	var _cret *C.gchar // in

	_cret = C.g_get_prgname()

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// GetRealName gets the real name of the user. This usually comes from the
// user's entry in the passwd file. The encoding of the returned string is
// system-defined. (On Windows, it is, however, always UTF-8.) If the real user
// name cannot be determined, the string "Unknown" is returned.
//
// The function returns the following values:
//
//   - filename user's real name.
func GetRealName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_real_name()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetRealTime queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except that the
// return value is often more convenient than dealing with a Val.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. g_get_monotonic_time() is probably more useful for measuring
// intervals.
//
// The function returns the following values:
//
//   - gint64: number of microseconds since January 1, 1970 UTC.
func GetRealTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_real_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// GetSystemConfigDirs returns an ordered list of base directories in which to
// access system-wide configuration information.
//
// On UNIX platforms this is determined using the mechanisms
// described in the XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the list of
// directories retrieved will be XDG_CONFIG_DIRS.
//
// On Windows it follows XDG Base Directory Specification if XDG_CONFIG_DIRS
// is defined. If XDG_CONFIG_DIRS is undefined, the directory that contains
// application data for all users is used instead. A typical path is
// C:\Documents and Settings\All Users\Application Data. This folder is used for
// application data that is not user specific. For example, an application can
// store a spell-check dictionary, a database of clip art, or a log file in the
// FOLDERID_ProgramData folder. This information will not roam and is available
// to anyone using the computer.
//
// The return value is cached and modifying it at runtime is not supported,
// as it’s not thread-safe to modify environment variables at runtime.
//
// The function returns the following values:
//
//   - filenames: a NULL-terminated array of strings owned by GLib that must not
//     be modified or freed.
func GetSystemConfigDirs() []string {
	var _cret **C.gchar // in

	_cret = C.g_get_system_config_dirs()

	var _filenames []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _filenames
}

// GetSystemDataDirs returns an ordered list of base directories in which to
// access system-wide application data.
//
// On UNIX platforms this is determined using the mechanisms
// described in the XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec) In this case the list of
// directories retrieved will be XDG_DATA_DIRS.
//
// On Windows it follows XDG Base Directory Specification if XDG_DATA_DIRS is
// defined. If XDG_DATA_DIRS is undefined, the first elements in the list are
// the Application Data and Documents folders for All Users. (These can be
// determined only on Windows 2000 or later and are not present in the list
// on other Windows versions.) See documentation for FOLDERID_ProgramData and
// FOLDERID_PublicDocuments.
//
// Then follows the "share" subfolder in the installation folder for the package
// containing the DLL that calls this function, if it can be determined.
//
// Finally the list contains the "share" subfolder in the installation folder
// for GLib, and in the installation folder for the package the application's
// .exe file belongs to.
//
// The installation folders above are determined by looking up the folder where
// the module (DLL or EXE) in question is located. If the folder's name is
// "bin", its parent is used, otherwise the folder itself.
//
// Note that on Windows the returned list can vary depending on where this
// function is called.
//
// The return value is cached and modifying it at runtime is not supported,
// as it’s not thread-safe to modify environment variables at runtime.
//
// The function returns the following values:
//
//   - filenames: a NULL-terminated array of strings owned by GLib that must not
//     be modified or freed.
func GetSystemDataDirs() []string {
	var _cret **C.gchar // in

	_cret = C.g_get_system_data_dirs()

	var _filenames []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _filenames
}

// GetTmpDir gets the directory to use for temporary files.
//
// On UNIX, this is taken from the TMPDIR environment variable. If the variable
// is not set, P_tmpdir is used, as defined by the system C library. Failing
// that, a hard-coded default of "/tmp" is returned.
//
// On Windows, the TEMP environment variable is used, with the root directory of
// the Windows installation (eg: "C:\") used as a default.
//
// The encoding of the returned string is system-defined. On Windows, it is
// always UTF-8. The return value is never NULL or the empty string.
//
// The function returns the following values:
//
//   - filename: directory to use for temporary files.
func GetTmpDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_tmp_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetUserCacheDir returns a base directory in which to store non-essential,
// cached data specific to particular user.
//
// On UNIX platforms this is determined using the mechanisms
// described in the XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be XDG_CACHE_HOME.
//
// On Windows it follows XDG Base Directory Specification if XDG_CACHE_HOME
// is defined. If XDG_CACHE_HOME is undefined, the directory that serves
// as a common repository for temporary Internet files is used instead.
// A typical path is C:\Documents and Settings\username\Local Settings\Temporary
// Internet Files. See the documentation for FOLDERID_InternetCache
// (https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
//
// The return value is cached and modifying it at runtime is not supported,
// as it’s not thread-safe to modify environment variables at runtime.
//
// The function returns the following values:
//
//   - filename: string owned by GLib that must not be modified or freed.
func GetUserCacheDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_cache_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetUserConfigDir returns a base directory in which to store user-specific
// application configuration information such as user preferences and settings.
//
// On UNIX platforms this is determined using the mechanisms
// described in the XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be XDG_CONFIG_HOME.
//
// On Windows it follows XDG Base Directory Specification if
// XDG_CONFIG_HOME is defined. If XDG_CONFIG_HOME is undefined,
// the folder to use for local (as opposed to roaming) application data
// is used instead. See the documentation for FOLDERID_LocalAppData
// (https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be the same as what
// g_get_user_data_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported,
// as it’s not thread-safe to modify environment variables at runtime.
//
// The function returns the following values:
//
//   - filename: string owned by GLib that must not be modified or freed.
func GetUserConfigDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_config_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetUserDataDir returns a base directory in which to access application data
// such as icons that is customized for a particular user.
//
// On UNIX platforms this is determined using the mechanisms
// described in the XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be XDG_DATA_HOME.
//
// On Windows it follows XDG Base Directory Specification if
// XDG_DATA_HOME is defined. If XDG_DATA_HOME is undefined,
// the folder to use for local (as opposed to roaming) application data
// is used instead. See the documentation for FOLDERID_LocalAppData
// (https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be the same as what
// g_get_user_config_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported,
// as it’s not thread-safe to modify environment variables at runtime.
//
// The function returns the following values:
//
//   - filename: string owned by GLib that must not be modified or freed.
func GetUserDataDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_data_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetUserName gets the user name of the current user. The encoding of the
// returned string is system-defined. On UNIX, it might be the preferred file
// name encoding, or something else, and there is no guarantee that it is even
// consistent on a machine. On Windows, it is always UTF-8.
//
// The function returns the following values:
//
//   - filename: user name of the current user.
func GetUserName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_name()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetUserRuntimeDir returns a directory that is unique to the current user on
// the local system.
//
// This is determined using the mechanisms described in the XDG Base Directory
// Specification (http://www.freedesktop.org/Standards/basedir-spec).
// This is the directory specified in the XDG_RUNTIME_DIR environment variable.
// In the case that this variable is not set, we return the value of
// g_get_user_cache_dir(), after verifying that it exists.
//
// The return value is cached and modifying it at runtime is not supported,
// as it’s not thread-safe to modify environment variables at runtime.
//
// The function returns the following values:
//
//   - filename: string owned by GLib that must not be modified or freed.
func GetUserRuntimeDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_runtime_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetUserSpecialDir returns the full path of a special directory using its
// logical id.
//
// On UNIX this is done using the XDG special user directories. For
// compatibility with existing practise, G_USER_DIRECTORY_DESKTOP falls back to
// $HOME/Desktop when XDG special user directories have not been set up.
//
// Depending on the platform, the user might be able to change the path of the
// special directory without requiring the session to restart; GLib will not
// reflect any change once the special directories are loaded.
//
// The function takes the following parameters:
//
//   - directory: logical id of special directory.
//
// The function returns the following values:
//
//   - filename (optional): path to the specified special directory, or NULL if
//     the logical id was not found. The returned string is owned by GLib and
//     should not be modified or freed.
func GetUserSpecialDir(directory UserDirectory) string {
	var _arg1 C.GUserDirectory // out
	var _cret *C.gchar         // in

	_arg1 = C.GUserDirectory(directory)

	_cret = C.g_get_user_special_dir(_arg1)
	runtime.KeepAlive(directory)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// GetUserStateDir returns a base directory in which to store state files
// specific to particular user.
//
// On UNIX platforms this is determined using the mechanisms
// described in the XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be XDG_STATE_HOME.
//
// On Windows it follows XDG Base Directory Specification if
// XDG_STATE_HOME is defined. If XDG_STATE_HOME is undefined,
// the folder to use for local (as opposed to roaming) application data
// is used instead. See the documentation for FOLDERID_LocalAppData
// (https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be the same as what
// g_get_user_data_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported,
// as it’s not thread-safe to modify environment variables at runtime.
//
// The function returns the following values:
//
//   - filename: string owned by GLib that must not be modified or freed.
func GetUserStateDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_state_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Getenv returns the value of an environment variable.
//
// On UNIX, the name and value are byte strings which might or might not be in
// some consistent character set and encoding. On Windows, they are in UTF-8.
// On Windows, in case the environment variable's value contains references to
// other environment variables, they are expanded.
//
// The function takes the following parameters:
//
//   - variable: environment variable to get.
//
// The function returns the following values:
//
//   - filename (optional): value of the environment variable, or NULL if the
//     environment variable is not found. The returned string may be overwritten
//     by the next call to g_getenv(), g_setenv() or g_unsetenv().
func Getenv(variable string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_getenv(_arg1)
	runtime.KeepAlive(variable)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// HostnameIsASCIIEncoded tests if hostname contains segments with an
// ASCII-compatible encoding of an Internationalized Domain Name. If this
// returns TRUE, you should decode the hostname with g_hostname_to_unicode()
// before displaying it to the user.
//
// Note that a hostname might contain a mix of encoded and unencoded
// segments, and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return TRUE for a name.
//
// The function takes the following parameters:
//
//   - hostname: hostname.
//
// The function returns the following values:
//
//   - ok: TRUE if hostname contains any ASCII-encoded segments.
func HostnameIsASCIIEncoded(hostname string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_is_ascii_encoded(_arg1)
	runtime.KeepAlive(hostname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HostnameIsIPAddress tests if hostname is the string form of an IPv4 or IPv6
// address. (Eg, "192.168.0.1".)
//
// Since 2.66, IPv6 addresses with a zone-id are accepted (RFC6874).
//
// The function takes the following parameters:
//
//   - hostname (or IP address in string form).
//
// The function returns the following values:
//
//   - ok: TRUE if hostname is an IP address.
func HostnameIsIPAddress(hostname string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_is_ip_address(_arg1)
	runtime.KeepAlive(hostname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HostnameIsNonASCII tests if hostname contains Unicode characters. If this
// returns TRUE, you need to encode the hostname with g_hostname_to_ascii()
// before using it in non-IDN-aware contexts.
//
// Note that a hostname might contain a mix of encoded and unencoded
// segments, and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return TRUE for a name.
//
// The function takes the following parameters:
//
//   - hostname: hostname.
//
// The function returns the following values:
//
//   - ok: TRUE if hostname contains any non-ASCII characters.
func HostnameIsNonASCII(hostname string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_is_non_ascii(_arg1)
	runtime.KeepAlive(hostname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HostnameToASCII converts hostname to its canonical ASCII form; an ASCII-only
// string containing no uppercase letters and not ending with a trailing dot.
//
// The function takes the following parameters:
//
//   - hostname: valid UTF-8 or ASCII hostname.
//
// The function returns the following values:
//
//   - utf8 (optional): ASCII hostname, which must be freed, or NULL if hostname
//     is in some way invalid.
func HostnameToASCII(hostname string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_to_ascii(_arg1)
	runtime.KeepAlive(hostname)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// HostnameToUnicode converts hostname to its canonical presentation form;
// a UTF-8 string in Unicode normalization form C, containing no uppercase
// letters, no forbidden characters, and no ASCII-encoded segments, and not
// ending with a trailing dot.
//
// Of course if hostname is not an internationalized hostname, then the
// canonical presentation form will be entirely ASCII.
//
// The function takes the following parameters:
//
//   - hostname: valid UTF-8 or ASCII hostname.
//
// The function returns the following values:
//
//   - utf8 (optional): UTF-8 hostname, which must be freed, or NULL if hostname
//     is in some way invalid.
func HostnameToUnicode(hostname string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_to_unicode(_arg1)
	runtime.KeepAlive(hostname)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// IdleRemoveByData removes the idle function with the given data.
//
// The function takes the following parameters:
//
//   - data (optional) for the idle source's callback.
//
// The function returns the following values:
//
//   - ok: TRUE if an idle source was found and removed.
func IdleRemoveByData(data unsafe.Pointer) bool {
	var _arg1 C.gpointer // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.g_idle_remove_by_data(_arg1)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewIdleSource creates a new idle source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed. Note that the
// default priority for idle sources is G_PRIORITY_DEFAULT_IDLE, as compared to
// other sources which have a default priority of G_PRIORITY_DEFAULT.
//
// The function returns the following values:
//
//   - source: newly-created idle source.
func NewIdleSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_idle_source_new()

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// Int64Equal compares the two #gint64 values being pointed to and returns
// TRUE if they are equal. It can be passed to g_hash_table_new() as the
// key_equal_func parameter, when using non-NULL pointers to 64-bit integers as
// keys in a Table.
//
// The function takes the following parameters:
//
//   - v1: pointer to a #gint64 key.
//   - v2: pointer to a #gint64 key to compare with v1.
//
// The function returns the following values:
//
//   - ok: TRUE if the two keys match.
func Int64Equal(v1, v2 unsafe.Pointer) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_int64_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Int64Hash converts a pointer to a #gint64 to a hash value.
//
// It can be passed to g_hash_table_new() as the hash_func parameter, when using
// non-NULL pointers to 64-bit integer values as keys in a Table.
//
// The function takes the following parameters:
//
//   - v: pointer to a #gint64 key.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to the key.
func Int64Hash(v unsafe.Pointer) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_int64_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IntEqual compares the two #gint values being pointed to and returns TRUE if
// they are equal. It can be passed to g_hash_table_new() as the key_equal_func
// parameter, when using non-NULL pointers to integers as keys in a Table.
//
// Note that this function acts on pointers to #gint, not on #gint directly:
// if your hash table's keys are of the form GINT_TO_POINTER (n), use
// g_direct_equal() instead.
//
// The function takes the following parameters:
//
//   - v1: pointer to a #gint key.
//   - v2: pointer to a #gint key to compare with v1.
//
// The function returns the following values:
//
//   - ok: TRUE if the two keys match.
func IntEqual(v1, v2 unsafe.Pointer) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_int_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IntHash converts a pointer to a #gint to a hash value. It can be passed to
// g_hash_table_new() as the hash_func parameter, when using non-NULL pointers
// to integer values as keys in a Table.
//
// Note that this function acts on pointers to #gint, not on #gint directly:
// if your hash table's keys are of the form GINT_TO_POINTER (n), use
// g_direct_hash() instead.
//
// The function takes the following parameters:
//
//   - v: pointer to a #gint key.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to the key.
func IntHash(v unsafe.Pointer) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_int_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// InternStaticString returns a canonical representation for string.
// Interned strings can be compared for equality by comparing the pointers,
// instead of using strcmp(). g_intern_static_string() does not copy the string,
// therefore string must not be freed or modified.
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
//
// The function takes the following parameters:
//
//   - str (optional): static string.
//
// The function returns the following values:
//
//   - utf8: canonical representation for the string.
func InternStaticString(str string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_intern_static_string(_arg1)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// InternString returns a canonical representation for string. Interned strings
// can be compared for equality by comparing the pointers, instead of using
// strcmp().
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
//
// The function takes the following parameters:
//
//   - str (optional): string.
//
// The function returns the following values:
//
//   - utf8: canonical representation for the string.
func InternString(str string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_intern_string(_arg1)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IOCreateWatch creates a #GSource that's dispatched when condition is met for
// the given channel. For example, if condition is G_IO_IN, the source will be
// dispatched when there's data available for reading.
//
// The callback function invoked by the #GSource should be added with
// g_source_set_callback(), but it has type OFunc (not Func).
//
// g_io_add_watch() is a simpler interface to this same functionality, for the
// case where you want to add the source to the default main loop context at the
// default priority.
//
// On Windows, polling a #GSource created to watch a channel for a socket puts
// the socket in non-blocking mode. This is a side-effect of the implementation
// and unavoidable.
//
// The function takes the following parameters:
//
//   - channel to watch.
//   - condition conditions to watch for.
//
// The function returns the following values:
//
//   - source: new #GSource.
func IOCreateWatch(channel *IOChannel, condition IOCondition) *Source {
	var _arg1 *C.GIOChannel  // out
	var _arg2 C.GIOCondition // out
	var _cret *C.GSource     // in

	_arg1 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg2 = C.GIOCondition(condition)

	_cret = C.g_io_create_watch(_arg1, _arg2)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(condition)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// Listenv gets the names of all variables set in the environment.
//
// Programs that want to be portable to Windows should typically use this
// function and g_getenv() instead of using the environ array from the C library
// directly. On Windows, the strings in the environ array are in system codepage
// encoding, while in most of the typical use cases for environment variables
// in GLib-using programs you want the UTF-8 encoding that this function and
// g_getenv() provide.
//
// The function returns the following values:
//
//   - filenames: a NULL-terminated list of strings which must be freed with
//     g_strfreev().
func Listenv() []string {
	var _cret **C.gchar // in

	_cret = C.g_listenv()

	var _filenames []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// LocaleFromUTF8 converts a string from UTF-8 to the encoding used for strings
// by the C runtime (usually the same as that used by the operating system) in
// the [current locale][setlocale]. On Windows this means the system codepage.
//
// The input string shall not contain nul characters even if the len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert input that may
// contain embedded nul characters.
//
// The function takes the following parameters:
//
//   - utf8String: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - bytesRead (optional): location to store the number of bytes in
//     the input string that were successfully converted, or NULL.
//     Even if the conversion was successful, this may be less than len if
//     there were partial characters at the end of the input. If the error
//     G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//     byte offset after the last valid input sequence.
//   - guint8s: A newly-allocated buffer containing the converted string,
//     or NULL on an error, and error will be set.
func LocaleFromUTF8(utf8String string) (uint, []byte, error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.gsize   // in
	var _cret *C.gchar  // in
	var _arg4 C.gsize   // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(utf8String))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(utf8String) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(utf8String)), utf8String)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_locale_from_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(utf8String)

	var _bytesRead uint // out
	var _guint8s []byte // out
	var _goerr error    // out

	_bytesRead = uint(_arg3)
	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg4)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg4))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _guint8s, _goerr
}

// LocaleToUTF8 converts a string which is in the encoding used for strings by
// the C runtime (usually the same as that used by the operating system) in the
// [current locale][setlocale] into a UTF-8 string.
//
// If the source encoding is not UTF-8 and the conversion output contains a nul
// character, the error G_CONVERT_ERROR_EMBEDDED_NUL is set and the function
// returns NULL. If the source encoding is UTF-8, an embedded nul character
// is treated with the G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward
// compatibility with earlier versions of this library. Use g_convert() to
// produce output that may contain embedded nul characters.
//
// The function takes the following parameters:
//
//   - opsysstring: string in the encoding of the current locale. On Windows
//     this means the system codepage.
//
// The function returns the following values:
//
//   - bytesRead (optional): location to store the number of bytes in
//     the input string that were successfully converted, or NULL.
//     Even if the conversion was successful, this may be less than len if
//     there were partial characters at the end of the input. If the error
//     G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//     byte offset after the last valid input sequence.
//   - bytesWritten (optional): number of bytes stored in the output buffer (not
//     including the terminating nul).
//   - utf8: converted string, or NULL on an error.
func LocaleToUTF8(opsysstring string) (bytesRead, bytesWritten uint, utf8 string, goerr error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(opsysstring))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(opsysstring) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(opsysstring)), opsysstring)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_locale_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(opsysstring)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _utf8 string       // out
	var _goerr error       // out

	_bytesRead = uint(_arg3)
	_bytesWritten = uint(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _utf8, _goerr
}

// LogDefaultHandler: default log handler set up by GLib;
// glib.LogSetDefaultHandler() allows to install an alternate default log
// handler.
//
// This is used if no log handler has been set for the particular log domain
// and log level combination. It outputs the message to stderr or stdout and if
// the log level is fatal it calls glib.BREAKPOINT(). It automatically prints
// a new-line character after the message, so one does not need to be manually
// included in message.
//
// The behavior of this log handler can be influenced by a number of environment
// variables:
//
//   - G_MESSAGES_PREFIXED: A :-separated list of log levels for which messages
//     should be prefixed by the program name and PID of the application.
//   - G_MESSAGES_DEBUG: A space-separated list of log domains for which debug
//     and informational messages are printed. By default these messages
//     are not printed. If you need to set the allowed domains at runtime,
//     use glib.LogWriterDefaultSetDebugDomains().
//
// stderr is used for levels glib.LogLevelFlags.LEVELERROR,
// glib.LogLevelFlags.LEVELCRITICAL, glib.LogLevelFlags.LEVELWARNING and
// glib.LogLevelFlags.LEVELMESSAGE. stdout is used for the rest, unless stderr
// was requested by glib.LogWriterDefaultSetUseStderr().
//
// This has no effect if structured logging is enabled; see Using Structured
// Logging (logging.html#using-structured-logging).
//
// The function takes the following parameters:
//
//   - logDomain (optional): log domain of the message, or NULL for the default
//     "" application domain.
//   - logLevel: level of the message.
//   - message (optional): message.
//   - unusedData (optional): data passed from glib.Log() which is unused.
func LogDefaultHandler(logDomain string, logLevel LogLevelFlags, message string, unusedData unsafe.Pointer) {
	var _arg1 *C.gchar         // out
	var _arg2 C.GLogLevelFlags // out
	var _arg3 *C.gchar         // out
	var _arg4 C.gpointer       // out

	if logDomain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GLogLevelFlags(logLevel)
	if message != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(unusedData))

	C.g_log_default_handler(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(message)
	runtime.KeepAlive(unusedData)
}

// LogGetDebugEnabled: return whether debug output from the GLib logging system
// is enabled.
//
// Note that this should not be used to conditionalise calls to glib.Debug()
// or other logging functions; it should only be used from glib.LogWriterFunc
// implementations.
//
// Note also that the value of this does not depend on G_MESSAGES_DEBUG,
// nor glib.LogWriterDefaultSetDebugDomains(); see the docs for
// glib.LogSetDebugEnabled().
//
// The function returns the following values:
//
//   - ok: TRUE if debug output is enabled, FALSE otherwise.
func LogGetDebugEnabled() bool {
	var _cret C.gboolean // in

	_cret = C.g_log_get_debug_enabled()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogRemoveHandler removes the log handler.
//
// This has no effect if structured logging is enabled; see Using Structured
// Logging (logging.html#using-structured-logging).
//
// The function takes the following parameters:
//
//   - logDomain: log domain.
//   - handlerId: ID of the handler, which was returned in glib.LogSetHandler().
func LogRemoveHandler(logDomain string, handlerId uint) {
	var _arg1 *C.gchar // out
	var _arg2 C.guint  // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(handlerId)

	C.g_log_remove_handler(_arg1, _arg2)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(handlerId)
}

// LogSetAlwaysFatal sets the message levels which are always fatal, in any log
// domain.
//
// When a message with any of these levels is logged the program
// terminates. You can only set the levels defined by GLib to be fatal.
// glib.LogLevelFlags.LEVELERROR is always fatal.
//
// You can also make some message levels fatal at runtime by setting the G_DEBUG
// environment variable (see Running GLib Applications (glib-running.html)).
//
// Libraries should not call this function, as it affects all messages logged by
// a process, including those from other libraries.
//
// Structured log messages (using glib.LogStructured() and
// glib.LogStructuredArray()) are fatal only if the default log writer is used;
// otherwise it is up to the writer function to determine which log messages are
// fatal. See Using Structured Logging (logging.html#using-structured-logging).
//
// The function takes the following parameters:
//
//   - fatalMask: mask containing bits set for each level of error which is to
//     be fatal.
//
// The function returns the following values:
//
//   - logLevelFlags: old fatal mask.
func LogSetAlwaysFatal(fatalMask LogLevelFlags) LogLevelFlags {
	var _arg1 C.GLogLevelFlags // out
	var _cret C.GLogLevelFlags // in

	_arg1 = C.GLogLevelFlags(fatalMask)

	_cret = C.g_log_set_always_fatal(_arg1)
	runtime.KeepAlive(fatalMask)

	var _logLevelFlags LogLevelFlags // out

	_logLevelFlags = LogLevelFlags(_cret)

	return _logLevelFlags
}

// LogSetDebugEnabled: enable or disable debug output from the GLib logging
// system for all domains.
//
// This value interacts disjunctively with G_MESSAGES_DEBUG and
// glib.LogWriterDefaultSetDebugDomains() — if any of them would allow a debug
// message to be outputted, it will be.
//
// Note that this should not be used from within library code to enable debug
// output — it is intended for external use.
//
// The function takes the following parameters:
//
//   - enabled: TRUE to enable debug output, FALSE otherwise.
func LogSetDebugEnabled(enabled bool) {
	var _arg1 C.gboolean // out

	if enabled {
		_arg1 = C.TRUE
	}

	C.g_log_set_debug_enabled(_arg1)
	runtime.KeepAlive(enabled)
}

// LogSetFatalMask sets the log levels which are fatal in the given domain.
//
// glib.LogLevelFlags.LEVELERROR is always fatal.
//
// This has no effect on structured log messages (using glib.LogStructured()
// or glib.LogStructuredArray()). To change the fatal behaviour for
// specific log messages, programs must install a custom log writer
// function using glib.LogSetWriterFunc(). See Using Structured Logging
// (logging.html#using-structured-logging).
//
// This function is mostly intended to be used with
// glib.LogLevelFlags.LEVELCRITICAL. You should typically not set
// glib.LogLevelFlags.LEVELWARNING, glib.LogLevelFlags.LEVELMESSAGE,
// glib.LogLevelFlags.LEVELINFO or glib.LogLevelFlags.LEVELDEBUG as fatal except
// inside of test programs.
//
// The function takes the following parameters:
//
//   - logDomain: log domain.
//   - fatalMask: new fatal mask.
//
// The function returns the following values:
//
//   - logLevelFlags: old fatal mask for the log domain.
func LogSetFatalMask(logDomain string, fatalMask LogLevelFlags) LogLevelFlags {
	var _arg1 *C.gchar         // out
	var _arg2 C.GLogLevelFlags // out
	var _cret C.GLogLevelFlags // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GLogLevelFlags(fatalMask)

	_cret = C.g_log_set_fatal_mask(_arg1, _arg2)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(fatalMask)

	var _logLevelFlags LogLevelFlags // out

	_logLevelFlags = LogLevelFlags(_cret)

	return _logLevelFlags
}

// LogStructuredArray: log a message with structured data.
//
// The message will be passed through to the log writer set by the application
// using glib.LogSetWriterFunc(). If the message is fatal (i.e. its log level
// is glib.LogLevelFlags.LEVELERROR), the program will be aborted at the end of
// this function.
//
// See glib.LogStructured() for more documentation.
//
// This assumes that log_level is already present in fields (typically as the
// PRIORITY field).
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - fields: key–value pairs of structured data to add to the log message.
func LogStructuredArray(logLevel LogLevelFlags, fields []LogField) {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}

	C.g_log_structured_array(_arg1, _arg2, _arg3)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
}

// LogVariant: log a message with structured data, accepting the data within a
// glib.Variant.
//
// This version is especially useful for use in other languages, via
// introspection.
//
// The only mandatory item in the fields dictionary is the "MESSAGE" which must
// contain the text shown to the user.
//
// The values in the fields dictionary are likely to be of type
// G_VARIANT_TYPE_STRING. Array of bytes (G_VARIANT_TYPE_BYTESTRING) is
// also supported. In this case the message is handled as binary and will
// be forwarded to the log writer as such. The size of the array should not
// be higher than G_MAXSSIZE. Otherwise it will be truncated to this size.
// For other types glib.Variant.Print() will be used to convert the value into a
// string.
//
// For more details on its usage and about the parameters, see
// glib.LogStructured().
//
// The function takes the following parameters:
//
//   - logDomain (optional): log domain, usually G_LOG_DOMAIN.
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - fields: dictionary (glib.Variant of the type G_VARIANT_TYPE_VARDICT)
//     containing the key-value pairs of message data.
func LogVariant(logDomain string, logLevel LogLevelFlags, fields *Variant) {
	var _arg1 *C.gchar         // out
	var _arg2 C.GLogLevelFlags // out
	var _arg3 *C.GVariant      // out

	if logDomain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GLogLevelFlags(logLevel)
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(fields)))

	C.g_log_variant(_arg1, _arg2, _arg3)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
}

// LogWriterDefault: format a structured log message and output it to the
// default log destination for the platform.
//
// On Linux, this is typically the systemd journal, falling back to stdout or
// stderr if running from the terminal or if output is being redirected to a
// file.
//
// Support for other platform-specific logging mechanisms may be added in
// future. Distributors of GLib may modify this function to impose their own
// (documented) platform-specific log writing policies.
//
// This is suitable for use as a glib.LogWriterFunc, and is the default writer
// used if no other is set using glib.LogSetWriterFunc().
//
// As with glib.LogDefaultHandler(), this function drops debug and
// informational messages unless their log domain (or all) is listed in the
// space-separated G_MESSAGES_DEBUG environment variable, or set at runtime by
// glib.LogWriterDefaultSetDebugDomains().
//
// glib.LogWriterDefault() uses the mask set by glib.LogSetAlwaysFatal() to
// determine which messages are fatal. When using a custom writer function
// instead it is up to the writer function to determine which log messages are
// fatal.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - fields: key–value pairs of structured data forming the log message.
//   - userData (optional): user data passed to glib.LogSetWriterFunc().
//
// The function returns the following values:
//
//   - logWriterOutput: glib.LogWriterOutput.HANDLED on success,
//     glib.LogWriterOutput.UNHANDLED otherwise.
func LogWriterDefault(logLevel LogLevelFlags, fields []LogField, userData unsafe.Pointer) LogWriterOutput {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gpointer         // out
	var _cret C.GLogWriterOutput // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_log_writer_default(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(userData)

	var _logWriterOutput LogWriterOutput // out

	_logWriterOutput = LogWriterOutput(_cret)

	return _logWriterOutput
}

// LogWriterDefaultSetUseStderr: configure whether the built-in log functions
// will output all log messages to stderr.
//
// The built-in log functions are glib.LogDefaultHandler() for the old-style
// API, and both glib.LogWriterDefault() and glib.LogWriterStandardStreams() for
// the structured API.
//
// By default, log messages of levels glib.LogLevelFlags.LEVELINFO and
// glib.LogLevelFlags.LEVELDEBUG are sent to stdout, and other log messages are
// sent to stderr. This is problematic for applications that intend to reserve
// stdout for structured output such as JSON or XML.
//
// This function sets global state. It is not thread-aware, and should be called
// at the very start of a program, before creating any other threads or creating
// objects that could create worker threads of their own.
//
// The function takes the following parameters:
//
//   - useStderr: if TRUE, use stderr for log messages that would normally have
//     appeared on stdout.
func LogWriterDefaultSetUseStderr(useStderr bool) {
	var _arg1 C.gboolean // out

	if useStderr {
		_arg1 = C.TRUE
	}

	C.g_log_writer_default_set_use_stderr(_arg1)
	runtime.KeepAlive(useStderr)
}

// LogWriterDefaultWouldDrop: check whether glib.LogWriterDefault() and
// glib.LogDefaultHandler() would ignore a message with the given domain and
// level.
//
// As with glib.LogDefaultHandler(), this function drops debug and
// informational messages unless their log domain (or all) is listed
// in the space-separated G_MESSAGES_DEBUG environment variable, or by
// glib.LogWriterDefaultSetDebugDomains().
//
// This can be used when implementing log writers with the same filtering
// behaviour as the default, but a different destination or output format:
//
//	if (g_log_writer_default_would_drop (log_level, log_domain))
//	  return G_LOG_WRITER_HANDLED;
//	]|
//
//	or to skip an expensive computation if it is only needed for a debugging
//	message, and G_MESSAGES_DEBUG is not set:
//
// c if (!g_log_writer_default_would_drop (G_LOG_LEVEL_DEBUG, G_LOG_DOMAIN)) {
// g_autofree gchar *result = expensive_computation (my_object);
//
//	  g_debug ("my_object result: s", result);
//	}.
//
// `
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - logDomain (optional): log domain.
//
// The function returns the following values:
//
//   - ok: TRUE if the log message would be dropped by GLib’s default log
//     handlers.
func LogWriterDefaultWouldDrop(logLevel LogLevelFlags, logDomain string) bool {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.char          // out
	var _cret C.gboolean       // in

	_arg1 = C.GLogLevelFlags(logLevel)
	if logDomain != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_log_writer_default_would_drop(_arg1, _arg2)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(logDomain)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogWriterFormatFields: format a structured log message as a string suitable
// for outputting to the terminal (or elsewhere).
//
// This will include the values of all fields it knows how to interpret,
// which includes MESSAGE and GLIB_DOMAIN (see the documentation for
// glib.LogStructured()). It does not include values from unknown fields.
//
// The returned string does **not** have a trailing new-line character. It is
// encoded in the character set of the current locale, which is not necessarily
// UTF-8.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - fields: key–value pairs of structured data forming the log message.
//   - useColor: TRUE to use ANSI color escape sequences
//     (https://en.wikipedia.org/wiki/ANSI_escape_code) when formatting the
//     message, FALSE to not.
//
// The function returns the following values:
//
//   - utf8: string containing the formatted log message, in the character set
//     of the current locale.
func LogWriterFormatFields(logLevel LogLevelFlags, fields []LogField, useColor bool) string {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gboolean // out
	var _cret *C.gchar   // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	if useColor {
		_arg4 = C.TRUE
	}

	_cret = C.g_log_writer_format_fields(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(useColor)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// LogWriterIsJournald: check whether the given output_fd file descriptor is
// a connection to the systemd journal, or something else (like a log file or
// stdout or stderr).
//
// Invalid file descriptors are accepted and return FALSE, which allows for the
// following construct without needing any additional error handling:
//
//	is_journald = g_log_writer_is_journald (fileno (stderr));.
//
// The function takes the following parameters:
//
//   - outputFd: output file descriptor to check.
//
// The function returns the following values:
//
//   - ok: TRUE if output_fd points to the journal, FALSE otherwise.
func LogWriterIsJournald(outputFd int) bool {
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = C.gint(outputFd)

	_cret = C.g_log_writer_is_journald(_arg1)
	runtime.KeepAlive(outputFd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogWriterJournald: format a structured log message and send it to the systemd
// journal as a set of key–value pairs.
//
// All fields are sent to the journal, but if a field has length zero
// (indicating program-specific data) then only its key will be sent.
//
// This is suitable for use as a glib.LogWriterFunc.
//
// If GLib has been compiled without systemd support, this function is still
// defined, but will always return glib.LogWriterOutput.UNHANDLED.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - fields: key–value pairs of structured data forming the log message.
//   - userData (optional): user data passed to glib.LogSetWriterFunc().
//
// The function returns the following values:
//
//   - logWriterOutput: glib.LogWriterOutput.HANDLED on success,
//     glib.LogWriterOutput.UNHANDLED otherwise.
func LogWriterJournald(logLevel LogLevelFlags, fields []LogField, userData unsafe.Pointer) LogWriterOutput {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gpointer         // out
	var _cret C.GLogWriterOutput // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_log_writer_journald(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(userData)

	var _logWriterOutput LogWriterOutput // out

	_logWriterOutput = LogWriterOutput(_cret)

	return _logWriterOutput
}

// LogWriterStandardStreams: format a structured log message and print it to
// either stdout or stderr, depending on its log level.
//
// glib.LogLevelFlags.LEVELINFO and glib.LogLevelFlags.LEVELDEBUG
// messages are sent to stdout, or to stderr if requested by
// glib.LogWriterDefaultSetUseStderr(); all other log levels are sent to stderr.
// Only fields which are understood by this function are included in the
// formatted string which is printed.
//
// If the output stream supports ANSI color escape sequences
// (https://en.wikipedia.org/wiki/ANSI_escape_code), they will be used in the
// output.
//
// A trailing new-line character is added to the log message when it is printed.
//
// This is suitable for use as a glib.LogWriterFunc.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - fields: key–value pairs of structured data forming the log message.
//   - userData (optional): user data passed to glib.LogSetWriterFunc().
//
// The function returns the following values:
//
//   - logWriterOutput: glib.LogWriterOutput.HANDLED on success,
//     glib.LogWriterOutput.UNHANDLED otherwise.
func LogWriterStandardStreams(logLevel LogLevelFlags, fields []LogField, userData unsafe.Pointer) LogWriterOutput {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gpointer         // out
	var _cret C.GLogWriterOutput // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_log_writer_standard_streams(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(userData)

	var _logWriterOutput LogWriterOutput // out

	_logWriterOutput = LogWriterOutput(_cret)

	return _logWriterOutput
}

// LogWriterSupportsColor: check whether the given output_fd
// file descriptor supports ANSI color escape sequences
// (https://en.wikipedia.org/wiki/ANSI_escape_code).
//
// If so, they can safely be used when formatting log messages.
//
// The function takes the following parameters:
//
//   - outputFd: output file descriptor to check.
//
// The function returns the following values:
//
//   - ok: TRUE if ANSI color escapes are supported, FALSE otherwise.
func LogWriterSupportsColor(outputFd int) bool {
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = C.gint(outputFd)

	_cret = C.g_log_writer_supports_color(_arg1)
	runtime.KeepAlive(outputFd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogWriterSyslog: format a structured log message and send it to the syslog
// daemon. Only fields which are understood by this function are included in the
// formatted string which is printed.
//
// Log facility will be defined via the SYSLOG_FACILITY field and accepts the
// following values: "auth", "daemon", and "user". If SYSLOG_FACILITY is not
// specified, LOG_USER facility will be used.
//
// This is suitable for use as a glib.LogWriterFunc.
//
// If syslog is not supported, this function is still defined, but will always
// return glib.LogWriterOutput.UNHANDLED.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from glib.LogLevelFlags, or a user-defined
//     level.
//   - fields: key–value pairs of structured data forming the log message.
//   - userData (optional): user data passed to glib.LogSetWriterFunc().
//
// The function returns the following values:
//
//   - logWriterOutput: glib.LogWriterOutput.HANDLED on success,
//     glib.LogWriterOutput.UNHANDLED otherwise.
func LogWriterSyslog(logLevel LogLevelFlags, fields []LogField, userData unsafe.Pointer) LogWriterOutput {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gpointer         // out
	var _cret C.GLogWriterOutput // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_log_writer_syslog(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(userData)

	var _logWriterOutput LogWriterOutput // out

	_logWriterOutput = LogWriterOutput(_cret)

	return _logWriterOutput
}

// MainCurrentSource returns the currently firing source for this thread.
//
// The function returns the following values:
//
//   - source (optional): currently firing source or NULL.
func MainCurrentSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_main_current_source()

	var _source *Source // out

	if _cret != nil {
		_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_source_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_source)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_source_unref((*C.GSource)(intern.C))
			},
		)
	}

	return _source
}

// MainDepth returns the depth of the stack of calls to
// g_main_context_dispatch() on any Context in the current thread. That is,
// when called from the toplevel, it gives 0. When called from within a
// callback from g_main_context_iteration() (or g_main_loop_run(), etc.)
// it returns 1. When called from within a callback to a recursive call to
// g_main_context_iteration(), it returns 2. And so forth.
//
// This function is useful in a situation like the following: Imagine an
// extremely simple "garbage collected" system.
//
//	gpointer
//	allocate_memory (gsize size)
//	{
//	  FreeListBlock *block = g_new (FreeListBlock, 1);
//	  block->mem = g_malloc (size);
//	  block->depth = g_main_depth ();
//	  free_list = g_list_prepend (free_list, block);
//	  return block->mem;
//	}
//
//	void
//	free_allocated_memory (void)
//	{
//	  GList *l;
//
//	  int depth = g_main_depth ();
//	  for (l = free_list; l; );
//	    {
//	      GList *next = l->next;
//	      FreeListBlock *block = l->data;
//	      if (block->depth > depth)
//	        {
//	          g_free (block->mem);
//	          g_free (block);
//	          free_list = g_list_delete_link (free_list, l);
//	        }
//
//	      l = next;
//	    }
//	  }
//
// There is a temptation to use g_main_depth() to solve problems with
// reentrancy. For instance, while waiting for data to be received from the
// network in response to a menu item, the menu item might be selected again.
// It might seem that one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1. However,
// this should be avoided since the user then sees selecting the menu item do
// nothing. Furthermore, you'll find yourself adding these checks all over your
// code, since there are doubtless many, many things that the user could do.
// Instead, you can use the following techniques:
//
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent the user from
// interacting with elements while the main loop is recursing.
//
// 2. Avoid main loop recursion in situations where you can't handle arbitrary
// callbacks. Instead, structure your code so that you simply return to the main
// loop and then get called again when there is more work to do.
//
// The function returns the following values:
//
//   - gint: main loop recursion level in the current thread.
func MainDepth() int {
	var _cret C.gint // in

	_cret = C.g_main_depth()

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func MarkupErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_markup_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// MarkupEscapeText escapes text so that the markup parser will parse it
// verbatim. Less than, greater than, ampersand, etc. are replaced with the
// corresponding entities. This function would typically be used when writing
// out a file to be parsed with the markup parser.
//
// Note that this function doesn't protect whitespace and line endings from
// being processed according to the XML rules for normalization of line endings
// and attribute values.
//
// Note also that this function will produce character references in the range
// of &#x1; ... &#x1f; for all control sequences except for tabstop, newline
// and carriage return. The character references in this range are not valid XML
// 1.0, but they are valid XML 1.1 and will be accepted by the GMarkup parser.
//
// The function takes the following parameters:
//
//   - text: some valid UTF-8 text.
//
// The function returns the following values:
//
//   - utf8: newly allocated string with the escaped text.
func MarkupEscapeText(text string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(text))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_markup_escape_text(_arg1, _arg2)
	runtime.KeepAlive(text)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// MkdirWithParents: create a directory if it doesn't already exist. Create
// intermediate parent directories as needed, too.
//
// The function takes the following parameters:
//
//   - pathname in the GLib file name encoding.
//   - mode permissions to use for newly created directories.
//
// The function returns the following values:
//
//   - gint: 0 if the directory already exists, or was successfully created.
//     Returns -1 if an error occurred, with errno set.
func MkdirWithParents(pathname string, mode int) int {
	var _arg1 *C.gchar // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pathname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(mode)

	_cret = C.g_mkdir_with_parents(_arg1, _arg2)
	runtime.KeepAlive(pathname)
	runtime.KeepAlive(mode)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func NumberParserErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_number_parser_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

func OptionErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_option_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// ParseDebugString parses a string containing debugging options into a guint
// containing bit flags. This is used within GDK and GTK to parse the debug
// options passed on the command line or through environment variables.
//
// If string is equal to "all", all flags are set. Any flags specified along
// with "all" in string are inverted; thus, "all,foo,bar" or "foo,bar,all" sets
// all flags except those corresponding to "foo" and "bar".
//
// If string is equal to "help", all the available keys in keys are printed out
// to standard error.
//
// The function takes the following parameters:
//
//   - str (optional): list of debug options separated by colons, spaces,
//     or commas, or NULL.
//   - keys: pointer to an array of Key which associate strings with bit flags.
//
// The function returns the following values:
//
//   - guint: combined set of bit flags.
func ParseDebugString(str string, keys []DebugKey) uint {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GDebugKey // out
	var _arg3 C.guint
	var _cret C.guint // in

	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg3 = (C.guint)(len(keys))
	_arg2 = (*C.GDebugKey)(C.calloc(C.size_t(len(keys)), C.size_t(C.sizeof_GDebugKey)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GDebugKey)(_arg2), len(keys))
		for i := range keys {
			out[i] = *(*C.GDebugKey)(gextras.StructNative(unsafe.Pointer((&keys[i]))))
		}
	}

	_cret = C.g_parse_debug_string(_arg1, _arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(keys)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PathGetBasename gets the last component of the filename.
//
// If file_name ends with a directory separator it gets the component before
// the last slash. If file_name consists only of directory separators (and
// on Windows, possibly a drive letter), a single separator is returned.
// If file_name is empty, it gets ".".
//
// The function takes the following parameters:
//
//   - fileName: name of the file.
//
// The function returns the following values:
//
//   - filename: newly allocated string containing the last component of the
//     filename.
func PathGetBasename(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_get_basename(_arg1)
	runtime.KeepAlive(fileName)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// PathGetDirname gets the directory components of a file name. For example,
// the directory component of /usr/bin/test is /usr/bin. The directory component
// of / is /.
//
// If the file name has no directory components "." is returned. The returned
// string should be freed when no longer needed.
//
// The function takes the following parameters:
//
//   - fileName: name of the file.
//
// The function returns the following values:
//
//   - filename: directory components of the file.
func PathGetDirname(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_get_dirname(_arg1)
	runtime.KeepAlive(fileName)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// PathIsAbsolute returns TRUE if the given file_name is an absolute file name.
// Note that this is a somewhat vague concept on Windows.
//
// On POSIX systems, an absolute file name is well-defined. It always starts
// from the single root directory. For example "/usr/local".
//
// On Windows, the concepts of current drive and drive-specific current
// directory introduce vagueness. This function interprets as an absolute file
// name one that either begins with a directory separator such as "\Users\tml"
// or begins with the root on a drive, for example "C:\Windows". The first
// case also includes UNC paths such as "\\\\myserver\docs\foo". In all cases,
// either slashes or backslashes are accepted.
//
// Note that a file name relative to the current drive root does not truly
// specify a file uniquely over time and across processes, as the current drive
// is a per-process value and can be changed.
//
// File names relative the current directory on some specific drive,
// such as "D:foo/bar", are not interpreted as absolute by this function, but
// they obviously are not relative to the normal current directory as returned
// by getcwd() or g_get_current_dir() either. Such paths should be avoided,
// or need to be handled using Windows-specific code.
//
// The function takes the following parameters:
//
//   - fileName: file name.
//
// The function returns the following values:
//
//   - ok: TRUE if file_name is absolute.
func PathIsAbsolute(fileName string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_is_absolute(_arg1)
	runtime.KeepAlive(fileName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PathSkipRoot returns a pointer into file_name after the root component, i.e.
// after the "/" in UNIX or "C:\" under Windows. If file_name is not an absolute
// path it returns NULL.
//
// The function takes the following parameters:
//
//   - fileName: file name.
//
// The function returns the following values:
//
//   - filename (optional): pointer into file_name after the root component.
func PathSkipRoot(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_skip_root(_arg1)
	runtime.KeepAlive(fileName)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// PatternMatchSimple matches a string against a pattern given as a string.
// If this function is to be called in a loop, it's more efficient to compile
// the pattern once with g_pattern_spec_new() and call g_pattern_match_string()
// repeatedly.
//
// The function takes the following parameters:
//
//   - pattern: UTF-8 encoded pattern.
//   - str: UTF-8 encoded string to match.
//
// The function returns the following values:
//
//   - ok: TRUE if string matches pspec.
func PatternMatchSimple(pattern, str string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_pattern_match_simple(_arg1, _arg2)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QsortWithData: this is just like the standard C qsort() function, but the
// comparison routine accepts a user data argument.
//
// This is guaranteed to be a stable sort since version 2.32.
//
// The function takes the following parameters:
//
//   - pbase: start of array to sort.
//   - totalElems elements in the array.
//   - size of each element.
//   - compareFunc: function to compare elements.
func QsortWithData(pbase unsafe.Pointer, totalElems int, size uint, compareFunc CompareDataFunc) {
	var _arg1 C.gconstpointer    // out
	var _arg2 C.gint             // out
	var _arg3 C.gsize            // out
	var _arg4 C.GCompareDataFunc // out
	var _arg5 C.gpointer

	_arg1 = (C.gconstpointer)(unsafe.Pointer(pbase))
	_arg2 = C.gint(totalElems)
	_arg3 = C.gsize(size)
	_arg4 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
	_arg5 = C.gpointer(gbox.Assign(compareFunc))
	defer gbox.Delete(uintptr(_arg5))

	C.g_qsort_with_data(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(pbase)
	runtime.KeepAlive(totalElems)
	runtime.KeepAlive(size)
	runtime.KeepAlive(compareFunc)
}

// QuarkFromStaticString gets the #GQuark identifying the given (static) string.
// If the string does not currently have an associated #GQuark, a new #GQuark is
// created, linked to the given string.
//
// Note that this function is identical to g_quark_from_string() except that if
// a new #GQuark is created the string itself is used rather than a copy. This
// saves memory, but can only be used if the string will continue to exist until
// the program terminates. It can be used with statically allocated strings in
// the main program, but not with statically allocated memory in dynamically
// loaded modules, if you expect to ever unload the module again (e.g. do not
// use this function in GTK theme engines).
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
//
// The function takes the following parameters:
//
//   - str (optional): string.
//
// The function returns the following values:
//
//   - quark identifying the string, or 0 if string is NULL.
func QuarkFromStaticString(str string) Quark {
	var _arg1 *C.gchar // out
	var _cret C.GQuark // in

	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_quark_from_static_string(_arg1)
	runtime.KeepAlive(str)

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// QuarkFromString gets the #GQuark identifying the given string. If the string
// does not currently have an associated #GQuark, a new #GQuark is created,
// using a copy of the string.
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
//
// The function takes the following parameters:
//
//   - str (optional): string.
//
// The function returns the following values:
//
//   - quark identifying the string, or 0 if string is NULL.
func QuarkFromString(str string) Quark {
	var _arg1 *C.gchar // out
	var _cret C.GQuark // in

	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_quark_from_string(_arg1)
	runtime.KeepAlive(str)

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// QuarkToString gets the string associated with the given #GQuark.
//
// The function takes the following parameters:
//
//   - quark: #GQuark.
//
// The function returns the following values:
//
//   - utf8: string associated with the #GQuark.
func QuarkToString(quark Quark) string {
	var _arg1 C.GQuark // out
	var _cret *C.gchar // in

	_arg1 = C.GQuark(quark)

	_cret = C.g_quark_to_string(_arg1)
	runtime.KeepAlive(quark)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// QuarkTryString gets the #GQuark associated with the given string, or 0 if
// string is NULL or it has no associated #GQuark.
//
// If you want the GQuark to be created if it doesn't already exist, use
// g_quark_from_string() or g_quark_from_static_string().
//
// This function must not be used before library constructors have finished
// running.
//
// The function takes the following parameters:
//
//   - str (optional): string.
//
// The function returns the following values:
//
//   - quark associated with the string, or 0 if string is NULL or there is no
//     #GQuark associated with it.
func QuarkTryString(str string) Quark {
	var _arg1 *C.gchar // out
	var _cret C.GQuark // in

	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_quark_try_string(_arg1)
	runtime.KeepAlive(str)

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// RandomDouble returns a random #gdouble equally distributed over the range
// [0..1).
//
// The function returns the following values:
//
//   - gdouble: random number.
func RandomDouble() float64 {
	var _cret C.gdouble // in

	_cret = C.g_random_double()

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// RandomDoubleRange returns a random #gdouble equally distributed over the
// range [begin..end).
//
// The function takes the following parameters:
//
//   - begin: lower closed bound of the interval.
//   - end: upper open bound of the interval.
//
// The function returns the following values:
//
//   - gdouble: random number.
func RandomDoubleRange(begin, end float64) float64 {
	var _arg1 C.gdouble // out
	var _arg2 C.gdouble // out
	var _cret C.gdouble // in

	_arg1 = C.gdouble(begin)
	_arg2 = C.gdouble(end)

	_cret = C.g_random_double_range(_arg1, _arg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// RandomInt: return a random #guint32 equally distributed over the range
// [0..2^32-1].
//
// The function returns the following values:
//
//   - guint32: random number.
func RandomInt() uint32 {
	var _cret C.guint32 // in

	_cret = C.g_random_int()

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// RandomIntRange returns a random #gint32 equally distributed over the range
// [begin..end-1].
//
// The function takes the following parameters:
//
//   - begin: lower closed bound of the interval.
//   - end: upper open bound of the interval.
//
// The function returns the following values:
//
//   - gint32: random number.
func RandomIntRange(begin, end int32) int32 {
	var _arg1 C.gint32 // out
	var _arg2 C.gint32 // out
	var _cret C.gint32 // in

	_arg1 = C.gint32(begin)
	_arg2 = C.gint32(end)

	_cret = C.g_random_int_range(_arg1, _arg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// RandomSetSeed sets the seed for the global random number generator, which is
// used by the g_random_* functions, to seed.
//
// The function takes the following parameters:
//
//   - seed: value to reinitialize the global random number generator.
func RandomSetSeed(seed uint32) {
	var _arg1 C.guint32 // out

	_arg1 = C.guint32(seed)

	C.g_random_set_seed(_arg1)
	runtime.KeepAlive(seed)
}

// ReloadUserSpecialDirsCache resets the cache used for
// g_get_user_special_dir(), so that the latest on-disk version is used.
// Call this only if you just changed the data on disk yourself.
//
// Due to thread safety issues this may cause leaking of strings that were
// previously returned from g_get_user_special_dir() that can't be freed.
// We ensure to only leak the data for the directories that actually changed
// value though.
func ReloadUserSpecialDirsCache() {
	C.g_reload_user_special_dirs_cache()
}

// SetApplicationName sets a human-readable name for the application.
// This name should be localized if possible, and is intended for display
// to the user. Contrast with g_set_prgname(), which sets a non-localized
// name. g_set_prgname() will be called automatically by gtk_init(), but
// g_set_application_name() will not.
//
// Note that for thread safety reasons, this function can only be called once.
//
// The application name will be used in contexts such as error messages, or when
// displaying an application's name in the task list.
//
// The function takes the following parameters:
//
//   - applicationName: localized name of the application.
func SetApplicationName(applicationName string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_set_application_name(_arg1)
	runtime.KeepAlive(applicationName)
}

// SetPrgname sets the name of the program. This name should not be localized,
// in contrast to g_set_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of argv[0].
//
// Since GLib 2.72, this function can be called multiple times and is fully
// thread safe. Prior to GLib 2.72, this function could only be called once per
// process.
//
// The function takes the following parameters:
//
//   - prgname: name of the program.
func SetPrgname(prgname string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_set_prgname(_arg1)
	runtime.KeepAlive(prgname)
}

// Setenv sets an environment variable. On UNIX, both the variable's name and
// value can be arbitrary byte strings, except that the variable's name cannot
// contain '='. On Windows, they should be in UTF-8.
//
// Note that on some systems, when variables are overwritten, the memory used
// for the previous variables and its value isn't reclaimed.
//
// You should be mindful of the fact that environment variable handling in UNIX
// is not thread-safe, and your program may crash if one thread calls g_setenv()
// while another thread is calling getenv(). (And note that many functions,
// such as gettext(), call getenv() internally.) This function is only safe to
// use at the very start of your program, before creating any other threads (or
// creating objects that create worker threads of their own).
//
// If you need to set up the environment for a child process, you can
// use g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that array
// directly to execvpe(), g_spawn_async(), or the like.
//
// The function takes the following parameters:
//
//   - variable: environment variable to set, must not contain '='.
//   - value for to set the variable to.
//   - overwrite: whether to change the variable if it already exists.
//
// The function returns the following values:
//
//   - ok: FALSE if the environment variable couldn't be set.
func Setenv(variable, value string, overwrite bool) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	_cret = C.g_setenv(_arg1, _arg2, _arg3)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
	runtime.KeepAlive(overwrite)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func ShellErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_shell_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// ShellParseArgv parses a command line into an argument vector, in much the
// same way the shell would, but without many of the expansions the shell would
// perform (variable expansion, globs, operators, filename expansion, etc.
// are not supported).
//
// The results are defined to be the same as those you would get from a
// UNIX98 /bin/sh, as long as the input contains none of the unsupported shell
// expansions. If the input does contain such expansions, they are passed
// through literally.
//
// Possible errors are those from the G_SHELL_ERROR domain.
//
// In particular, if command_line is an empty string (or a string containing
// only whitespace), G_SHELL_ERROR_EMPTY_STRING will be returned. It’s
// guaranteed that argvp will be a non-empty array if this function returns
// successfully.
//
// Free the returned vector with g_strfreev().
//
// The function takes the following parameters:
//
//   - commandLine: command line to parse.
//
// The function returns the following values:
//
//   - argvp (optional): return location for array of args.
func ShellParseArgv(commandLine string) ([]string, error) {
	var _arg1 *C.gchar  // out
	var _arg3 **C.gchar // in
	var _arg2 C.gint    // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_shell_parse_argv(_arg1, &_arg2, &_arg3, &_cerr)
	runtime.KeepAlive(commandLine)

	var _argvp []string // out
	var _goerr error    // out

	if _arg3 != nil {
		defer C.free(unsafe.Pointer(_arg3))
		{
			src := unsafe.Slice((**C.gchar)(_arg3), _arg2)
			_argvp = make([]string, _arg2)
			for i := 0; i < int(_arg2); i++ {
				_argvp[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _argvp, _goerr
}

// ShellQuote quotes a string so that the shell (/bin/sh) will interpret the
// quoted string to mean unquoted_string.
//
// If you pass a filename to the shell, for example, you should first quote it
// with this function.
//
// The return value must be freed with g_free().
//
// The quoting style used is undefined (single or double quotes may be used).
//
// The function takes the following parameters:
//
//   - unquotedString: literal string.
//
// The function returns the following values:
//
//   - filename: quoted string.
func ShellQuote(unquotedString string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(unquotedString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_shell_quote(_arg1)
	runtime.KeepAlive(unquotedString)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// ShellUnquote unquotes a string as the shell (/bin/sh) would.
//
// This function only handles quotes; if a string contains file globs,
// arithmetic operators, variables, backticks, redirections, or other
// special-to-the-shell features, the result will be different from the result
// a real shell would produce (the variables, backticks, etc. will be passed
// through literally instead of being expanded).
//
// This function is guaranteed to succeed if applied to the result of
// g_shell_quote(). If it fails, it returns NULL and sets the error.
//
// The quoted_string need not actually contain quoted or escaped text;
// g_shell_unquote() simply goes through the string and unquotes/unescapes
// anything that the shell would. Both single and double quotes are handled,
// as are escapes including escaped newlines.
//
// The return value must be freed with g_free().
//
// Possible errors are in the G_SHELL_ERROR domain.
//
// Shell quoting rules are a bit strange. Single quotes preserve the literal
// string exactly. escape sequences are not allowed; not even \' - if you
// want a ' in the quoted text, you have to do something like 'foo'\”bar'.
// Double quotes allow $, , ", \`, and newline to be escaped with backslash.
// Otherwise double quotes preserve things literally.
//
// The function takes the following parameters:
//
//   - quotedString: shell-quoted string.
//
// The function returns the following values:
//
//   - filename: unquoted string.
func ShellUnquote(quotedString string) (string, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(quotedString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_shell_unquote(_arg1, &_cerr)
	runtime.KeepAlive(quotedString)

	var _filename string // out
	var _goerr error     // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _filename, _goerr
}

// SpacedPrimesClosest gets the smallest prime number from a built-in array of
// primes which is larger than num. This is used within GLib to calculate the
// optimum size of a Table.
//
// The built-in array of primes ranges from 11 to 13845163 such that each prime
// is approximately 1.5-2 times the previous prime.
//
// The function takes the following parameters:
//
//   - num: #guint.
//
// The function returns the following values:
//
//   - guint: smallest prime number from a built-in array of primes which is
//     larger than num.
func SpacedPrimesClosest(num uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(num)

	_cret = C.g_spaced_primes_closest(_arg1)
	runtime.KeepAlive(num)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SpawnCheckExitStatus: old name for g_spawn_check_wait_status(), deprecated
// because its name is misleading.
//
// Despite the name of the function, wait_status must be the wait status as
// returned by g_spawn_sync(), g_subprocess_get_status(), waitpid(), etc.
// On Unix platforms, it is incorrect for it to be the exit status as passed to
// exit() or returned by g_subprocess_get_exit_status() or WEXITSTATUS().
//
// Deprecated: Use g_spawn_check_wait_status() instead, and check whether your
// code is conflating wait and exit statuses.
//
// The function takes the following parameters:
//
//   - waitStatus status as returned from g_spawn_sync().
func SpawnCheckExitStatus(waitStatus int) error {
	var _arg1 C.gint    // out
	var _cerr *C.GError // in

	_arg1 = C.gint(waitStatus)

	C.g_spawn_check_exit_status(_arg1, &_cerr)
	runtime.KeepAlive(waitStatus)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SpawnCheckWaitStatus: set error if wait_status indicates the child exited
// abnormally (e.g. with a nonzero exit code, or via a fatal signal).
//
// The g_spawn_sync() and g_child_watch_add() family of APIs return the
// status of subprocesses encoded in a platform-specific way. On Unix, this is
// guaranteed to be in the same format waitpid() returns, and on Windows it is
// guaranteed to be the result of GetExitCodeProcess().
//
// Prior to the introduction of this function in GLib 2.34, interpreting
// wait_status required use of platform-specific APIs, which is problematic for
// software using GLib as a cross-platform layer.
//
// Additionally, many programs simply want to determine whether or not the child
// exited successfully, and either propagate a #GError or print a message to
// standard error. In that common case, this function can be used. Note that the
// error message in error will contain human-readable information about the wait
// status.
//
// The domain and code of error have special semantics in the case where the
// process has an "exit code", as opposed to being killed by a signal. On Unix,
// this happens if WIFEXITED() would be true of wait_status. On Windows,
// it is always the case.
//
// The special semantics are that the actual exit code will be the code set
// in error, and the domain will be G_SPAWN_EXIT_ERROR. This allows you to
// differentiate between different exit codes.
//
// If the process was terminated by some means other than an exit status (for
// example if it was killed by a signal), the domain will be G_SPAWN_ERROR and
// the code will be G_SPAWN_ERROR_FAILED.
//
// This function just offers convenience; you can of course also check the
// available platform via a macro such as G_OS_UNIX, and use WIFEXITED() and
// WEXITSTATUS() on wait_status directly. Do not attempt to scan or parse the
// error message string; it may be translated and/or change in future versions
// of GLib.
//
// Prior to version 2.70, g_spawn_check_exit_status() provides the same
// functionality, although under a misleading name.
//
// The function takes the following parameters:
//
//   - waitStatus: platform-specific wait status as returned from
//     g_spawn_sync().
func SpawnCheckWaitStatus(waitStatus int) error {
	var _arg1 C.gint    // out
	var _cerr *C.GError // in

	_arg1 = C.gint(waitStatus)

	C.g_spawn_check_wait_status(_arg1, &_cerr)
	runtime.KeepAlive(waitStatus)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SpawnCommandLineAsync: simple version of g_spawn_async() that parses a
// command line with g_shell_parse_argv() and passes it to g_spawn_async().
//
// Runs a command line in the background. Unlike g_spawn_async(),
// the G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note that
// G_SPAWN_SEARCH_PATH can have security implications, so consider using
// g_spawn_async() directly if appropriate. Possible errors are those from
// g_shell_parse_argv() and g_spawn_async().
//
// The same concerns on Windows apply as for g_spawn_command_line_sync().
//
// The function takes the following parameters:
//
//   - commandLine: command line.
func SpawnCommandLineAsync(commandLine string) error {
	var _arg1 *C.gchar  // out
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_spawn_command_line_async(_arg1, &_cerr)
	runtime.KeepAlive(commandLine)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SpawnCommandLineSync: simple version of g_spawn_sync() with little-used
// parameters removed, taking a command line instead of an argument vector.
//
// See g_spawn_sync() for full details.
//
// The command_line argument will be parsed by g_shell_parse_argv().
//
// Unlike g_spawn_sync(), the G_SPAWN_SEARCH_PATH flag is enabled. Note that
// G_SPAWN_SEARCH_PATH can have security implications, so consider using
// g_spawn_sync() directly if appropriate.
//
// Possible errors are those from g_spawn_sync() and those from
// g_shell_parse_argv().
//
// If wait_status is non-NULL, the platform-specific status of the child is
// stored there; see the documentation of g_spawn_check_wait_status() for how to
// use and interpret this. On Unix platforms, note that it is usually not equal
// to the integer passed to exit() or returned from main().
//
// On Windows, please note the implications of g_shell_parse_argv() parsing
// command_line. Parsing is done according to Unix shell rules, not Windows
// command interpreter rules. Space is a separator, and backslashes are special.
// Thus you cannot simply pass a command_line containing canonical Windows
// paths, like "c:\\program files\\app\\app.exe", as the backslashes will
// be eaten, and the space will act as a separator. You need to enclose
// such paths with single quotes, like "'c:\\program files\\app\\app.exe'
// 'e:\\folder\\argument.txt'".
//
// The function takes the following parameters:
//
//   - commandLine: command line.
//
// The function returns the following values:
//
//   - standardOutput (optional): return location for child output.
//   - standardError (optional): return location for child errors.
//   - waitStatus (optional): return location for child wait status, as returned
//     by waitpid().
func SpawnCommandLineSync(commandLine string) (standardOutput, standardError []byte, waitStatus int, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // in
	var _arg3 *C.gchar  // in
	var _arg4 C.gint    // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_spawn_command_line_sync(_arg1, &_arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(commandLine)

	var _standardOutput []byte // out
	var _standardError []byte  // out
	var _waitStatus int        // out
	var _goerr error           // out

	if _arg2 != nil {
		defer C.free(unsafe.Pointer(_arg2))
		{
			var i int
			var z C.gchar
			for p := _arg2; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_arg2, i)
			_standardOutput = make([]byte, i)
			for i := range src {
				_standardOutput[i] = byte(src[i])
			}
		}
	}
	if _arg3 != nil {
		defer C.free(unsafe.Pointer(_arg3))
		{
			var i int
			var z C.gchar
			for p := _arg3; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_arg3, i)
			_standardError = make([]byte, i)
			for i := range src {
				_standardError[i] = byte(src[i])
			}
		}
	}
	_waitStatus = int(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _standardOutput, _standardError, _waitStatus, _goerr
}

func SpawnErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_spawn_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

func SpawnExitErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_spawn_exit_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// StrEqual compares two strings for byte-by-byte equality and returns TRUE if
// they are equal. It can be passed to g_hash_table_new() as the key_equal_func
// parameter, when using non-NULL strings as keys in a Table.
//
// This function is typically used for hash table comparisons, but can be used
// for general purpose comparisons of non-NULL strings. For a NULL-safe string
// comparison function, see g_strcmp0().
//
// The function takes the following parameters:
//
//   - v1: key.
//   - v2: key to compare with v1.
//
// The function returns the following values:
//
//   - ok: TRUE if the two keys match.
func StrEqual(v1, v2 unsafe.Pointer) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_str_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StrHash converts a string to a hash value.
//
// This function implements the widely used "djb" hash apparently posted by
// Daniel Bernstein to comp.lang.c some time ago. The 32 bit unsigned hash value
// starts at 5381 and for each byte 'c' in the string, is updated: hash = hash *
// 33 + c. This function uses the signed value of each byte.
//
// It can be passed to g_hash_table_new() as the hash_func parameter, when using
// non-NULL strings as keys in a Table.
//
// Note that this function may not be a perfect fit for all use cases.
// For example, it produces some hash collisions with strings as short as 2.
//
// The function takes the following parameters:
//
//   - v: string key.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to the key.
func StrHash(v unsafe.Pointer) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_str_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// StripContext: auxiliary function for gettext() support (see Q_()).
//
// The function takes the following parameters:
//
//   - msgid: string.
//   - msgval: another string.
//
// The function returns the following values:
//
//   - utf8: msgval, unless msgval is identical to msgid and contains a '|'
//     character, in which case a pointer to the substring of msgid after the
//     first '|' character is returned.
func StripContext(msgid, msgval string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgval)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_strip_context(_arg1, _arg2)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(msgval)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

func StrvGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.g_strv_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// NewTimeoutSource creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The interval given is in terms of monotonic time, not wall clock time.
// See g_get_monotonic_time().
//
// The function takes the following parameters:
//
//   - interval: timeout interval in milliseconds.
//
// The function returns the following values:
//
//   - source: newly-created timeout source.
func NewTimeoutSource(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new(_arg1)
	runtime.KeepAlive(interval)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// TimeoutSourceNewSeconds creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The scheduling granularity/accuracy of this timeout source will be in
// seconds.
//
// The interval given is in terms of monotonic time, not wall clock time.
// See g_get_monotonic_time().
//
// The function takes the following parameters:
//
//   - interval: timeout interval in seconds.
//
// The function returns the following values:
//
//   - source: newly-created timeout source.
func TimeoutSourceNewSeconds(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new_seconds(_arg1)
	runtime.KeepAlive(interval)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// UCS4ToUTF16: convert a string from UCS-4 to UTF-16. A 0 character will be
// added to the result after the converted text.
//
// The function takes the following parameters:
//
//   - str: UCS-4 encoded string.
//
// The function returns the following values:
//
//   - itemsRead (optional): location to store number of bytes read, or NULL.
//     If an error occurs then the index of the invalid input is stored here.
//   - itemsWritten (optional): location to store number of #gunichar2 written,
//     or NULL. The value stored here does not include the trailing 0.
//   - guint16: pointer to a newly allocated UTF-16 string. This value must be
//     freed with g_free(). If an error occurs, NULL will be returned and error
//     set.
func UCS4ToUTF16(str []uint32) (itemsRead, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gunichar // out
	var _arg2 C.glong
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg2 = (C.glong)(len(str))
	if len(str) > 0 {
		_arg1 = (*C.gunichar)(unsafe.Pointer(&str[0]))
	}

	_cret = C.g_ucs4_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_guint16 = (*uint16)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// UCS4ToUTF8: convert a string from a 32-bit fixed width representation as
// UCS-4. to UTF-8. The result will be terminated with a 0 byte.
//
// The function takes the following parameters:
//
//   - str: UCS-4 encoded string.
//
// The function returns the following values:
//
//   - itemsRead (optional): location to store number of characters read,
//     or NULL.
//   - itemsWritten (optional): location to store number of bytes written or
//     NULL. The value here stored does not include the trailing 0 byte.
//   - utf8: pointer to a newly allocated UTF-8 string. This value must be freed
//     with g_free(). If an error occurs, NULL will be returned and error set.
//     In that case, items_read will be set to the position of the first invalid
//     input character.
func UCS4ToUTF8(str []uint32) (itemsRead, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar // out
	var _arg2 C.glong
	var _arg3 C.glong   // in
	var _arg4 C.glong   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg2 = (C.glong)(len(str))
	if len(str) > 0 {
		_arg1 = (*C.gunichar)(unsafe.Pointer(&str[0]))
	}

	_cret = C.g_ucs4_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UnicharBreakType determines the break type of c. c should be a
// Unicode character (to derive a character from UTF-8 encoded text,
// use g_utf8_get_char()). The break type is used to find word and line breaks
// ("text boundaries"), Pango implements the Unicode boundary resolution
// algorithms and normally you would use a function such as pango_break()
// instead of caring about break types yourself.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - unicodeBreakType: break type of c.
func UnicharBreakType(c uint32) UnicodeBreakType {
	var _arg1 C.gunichar          // out
	var _cret C.GUnicodeBreakType // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_break_type(_arg1)
	runtime.KeepAlive(c)

	var _unicodeBreakType UnicodeBreakType // out

	_unicodeBreakType = UnicodeBreakType(_cret)

	return _unicodeBreakType
}

// UnicharCombiningClass determines the canonical combining class of a Unicode
// character.
//
// The function takes the following parameters:
//
//   - uc: unicode character.
//
// The function returns the following values:
//
//   - gint: combining class of the character.
func UnicharCombiningClass(uc uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(uc)

	_cret = C.g_unichar_combining_class(_arg1)
	runtime.KeepAlive(uc)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicharCompose performs a single composition step of the Unicode canonical
// composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition, but it is not
// exactly the inverse of g_unichar_decompose(). No composition can have either
// of a or b equal to zero. To be precise, this function composes if and only
// if there exists a Primary Composite P which is canonically equivalent to
// the sequence <a,b>. See the Unicode Standard for the definition of Primary
// Composite.
//
// If a and b do not compose a new character, ch is set to zero.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//   - a: unicode character.
//   - b: unicode character.
//
// The function returns the following values:
//
//   - ch: return location for the composed character.
//   - ok: TRUE if the characters could be composed.
func UnicharCompose(a, b uint32) (uint32, bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // out
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(a)
	_arg2 = C.gunichar(b)

	_cret = C.g_unichar_compose(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _ch uint32 // out
	var _ok bool   // out

	_ch = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ch, _ok
}

// UnicharDecompose performs a single decomposition step of the Unicode
// canonical decomposition algorithm.
//
// This function does not include compatibility decompositions. It does,
// however, include algorithmic Hangul Jamo decomposition, as well as
// 'singleton' decompositions which replace a character by a single other
// character. In the case of singletons *b will be set to zero.
//
// If ch is not decomposable, *a is set to ch and *b is set to zero.
//
// Note that the way Unicode decomposition pairs are defined, it is guaranteed
// that b would not decompose further, but a may itself decompose. To get the
// full canonical decomposition for ch, one would need to recursively call this
// function on a. Or use g_unichar_fully_decompose().
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - a: return location for the first component of ch.
//   - b: return location for the second component of ch.
//   - ok: TRUE if the character could be decomposed.
func UnicharDecompose(ch uint32) (a, b uint32, ok bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // in
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_decompose(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(ch)

	var _a uint32 // out
	var _b uint32 // out
	var _ok bool  // out

	_a = uint32(_arg2)
	_b = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _a, _b, _ok
}

// UnicharDigitValue determines the numeric value of a character as a decimal
// digit.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - gint: if c is a decimal digit (according to g_unichar_isdigit()),
//     its numeric value. Otherwise, -1.
func UnicharDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_digit_value(_arg1)
	runtime.KeepAlive(c)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicharFullyDecompose computes the canonical or compatibility decomposition
// of a Unicode character. For compatibility decomposition, pass TRUE for
// compat; for canonical decomposition pass FALSE for compat.
//
// The decomposed sequence is placed in result. Only up to result_len characters
// are written into result. The length of the full decomposition (irrespective
// of result_len) is returned by the function. For canonical decomposition,
// currently all decompositions are of length at most 4, but this may change
// in the future (very unlikely though). At any rate, Unicode does guarantee
// that a buffer of length 18 is always enough for both compatibility and
// canonical decompositions, so that is the size recommended. This is provided
// as G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//   - compat: whether perform canonical or compatibility decomposition.
//   - resultLen: length of result.
//
// The function returns the following values:
//
//   - result (optional): location to store decomposed result, or NULL.
//   - gsize: length of the full decomposition.
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var _arg1 C.gunichar // out
	var _arg2 C.gboolean // out
	var _arg3 C.gunichar // in
	var _arg4 C.gsize    // out
	var _cret C.gsize    // in

	_arg1 = C.gunichar(ch)
	if compat {
		_arg2 = C.TRUE
	}
	_arg4 = C.gsize(resultLen)

	_cret = C.g_unichar_fully_decompose(_arg1, _arg2, &_arg3, _arg4)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(compat)
	runtime.KeepAlive(resultLen)

	var _result uint32 // out
	var _gsize uint    // out

	_result = uint32(_arg3)
	_gsize = uint(_cret)

	return _result, _gsize
}

// UnicharGetMirrorChar: in Unicode, some characters are "mirrored". This
// means that their images are mirrored horizontally in text that is laid out
// from right to left. For instance, "(" would become its mirror image, ")",
// in right-to-left text.
//
// If ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of ch's glyph
// and mirrored_ch is set, it puts that character in the address pointed to by
// mirrored_ch. Otherwise the original character is put.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - mirroredCh: location to store the mirrored character.
//   - ok: TRUE if ch has a mirrored character, FALSE otherwise.
func UnicharGetMirrorChar(ch uint32) (uint32, bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_get_mirror_char(_arg1, &_arg2)
	runtime.KeepAlive(ch)

	var _mirroredCh uint32 // out
	var _ok bool           // out

	_mirroredCh = uint32(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _mirroredCh, _ok
}

// UnicharGetScript looks up the Script for a particular character (as defined
// by Unicode Standard Annex \#24). No check is made for ch being a valid
// Unicode character; if you pass in invalid character, the result is undefined.
//
// This function is equivalent to pango_script_for_unichar() and the two are
// interchangeable.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - unicodeScript for the character.
func UnicharGetScript(ch uint32) UnicodeScript {
	var _arg1 C.gunichar       // out
	var _cret C.GUnicodeScript // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_get_script(_arg1)
	runtime.KeepAlive(ch)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicharIsalnum determines whether a character is alphanumeric. Given some
// UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is an alphanumeric character.
func UnicharIsalnum(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isalnum(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsalpha determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is an alphabetic character.
func UnicharIsalpha(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isalpha(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIscntrl determines whether a character is a control character.
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is a control character.
func UnicharIscntrl(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iscntrl(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdefined determines if a given character is assigned in the Unicode
// standard.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if the character has an assigned value.
func UnicharIsdefined(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isdefined(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdigit determines whether a character is numeric (i.e. a digit).
// This covers ASCII 0-9 and also digits in other languages/scripts. Given some
// UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is a digit.
func UnicharIsdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isdigit(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsgraph determines whether a character is printable and not a space
// (returns FALSE for control characters, format characters, and spaces).
// g_unichar_isprint() is similar, but returns TRUE for spaces. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is printable unless it's a space.
func UnicharIsgraph(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isgraph(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIslower determines whether a character is a lowercase letter. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is a lowercase letter.
func UnicharIslower(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_islower(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsmark determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak). Given some UTF-8 text,
// obtain a character value with g_utf8_get_char().
//
// Note: in most cases where isalpha characters are allowed, ismark characters
// should be allowed to as they are essential for writing most European
// languages as well as many non-Latin scripts.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is a mark character.
func UnicharIsmark(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_ismark(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsprint determines whether a character is printable. Unlike
// g_unichar_isgraph(), returns TRUE for spaces. Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is printable.
func UnicharIsprint(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isprint(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIspunct determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is a punctuation or symbol character.
func UnicharIspunct(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_ispunct(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsspace determines whether a character is a space, tab, or line
// separator (newline, carriage return, etc.). Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// (Note: don't use this to do word breaking; you have to use Pango or
// equivalent to get word breaking right, the algorithm is fairly complex.).
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is a space character.
func UnicharIsspace(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isspace(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIstitle determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph have three case variants
// instead of just two. The titlecase form is used at the beginning of a word
// where only the first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if the character is titlecase.
func UnicharIstitle(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_istitle(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsupper determines if a character is uppercase.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if c is an uppercase character.
func UnicharIsupper(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isupper(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswide determines if a character is typically rendered in a
// double-width cell.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if the character is wide.
func UnicharIswide(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iswide(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswideCjk determines if a character is typically rendered in a
// double-width cell under legacy East Asian locales. If a character is wide
// according to g_unichar_iswide(), then it is also reported wide with this
// function, but the converse is not necessarily true. See the Unicode Standard
// Annex #11 (http://www.unicode.org/reports/tr11/) for details.
//
// If a character passes the g_unichar_iswide() test then it will also pass this
// test, but not the other way around. Note that some characters may pass both
// this test and g_unichar_iszerowidth().
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if the character is wide in legacy East Asian locales.
func UnicharIswideCjk(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iswide_cjk(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsxdigit determines if a character is a hexadecimal digit.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if the character is a hexadecimal digit.
func UnicharIsxdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isxdigit(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIszerowidth determines if a given character typically takes zero width
// when rendered. The return value is TRUE for all non-spacing and enclosing
// marks (e.g., combining accents), format characters, zero-width space, but not
// U+00AD SOFT HYPHEN.
//
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals). However, note that not all
// terminals support zero-width rendering of zero-width marks.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if the character has zero width.
func UnicharIszerowidth(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iszerowidth(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharToLower converts a character to lower case.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - gunichar: result of converting c to lower case. If c is not an upperlower
//     or titlecase character, or has no lowercase equivalent c is returned
//     unchanged.
func UnicharToLower(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_tolower(_arg1)
	runtime.KeepAlive(c)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharToTitle converts a character to the titlecase.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - gunichar: result of converting c to titlecase. If c is not an uppercase
//     or lowercase character, c is returned unchanged.
func UnicharToTitle(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_totitle(_arg1)
	runtime.KeepAlive(c)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharToUpper converts a character to uppercase.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - gunichar: result of converting c to uppercase. If c is not a lowercase
//     or titlecase character, or has no upper case equivalent c is returned
//     unchanged.
func UnicharToUpper(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_toupper(_arg1)
	runtime.KeepAlive(c)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharType classifies a Unicode character by type.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - unicodeType: type of the character.
func UnicharType(c uint32) UnicodeType {
	var _arg1 C.gunichar     // out
	var _cret C.GUnicodeType // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_type(_arg1)
	runtime.KeepAlive(c)

	var _unicodeType UnicodeType // out

	_unicodeType = UnicodeType(_cret)

	return _unicodeType
}

// UnicharValidate checks whether ch is a valid Unicode character. Some possible
// integer values of ch will not be valid. 0 is considered a valid character,
// though it's normally a string terminator.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//
// The function returns the following values:
//
//   - ok: TRUE if ch is a valid Unicode character.
func UnicharValidate(ch uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_validate(_arg1)
	runtime.KeepAlive(ch)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharXDigitValue determines the numeric value of a character as a
// hexadecimal digit.
//
// The function takes the following parameters:
//
//   - c: unicode character.
//
// The function returns the following values:
//
//   - gint: if c is a hex digit (according to g_unichar_isxdigit()), its
//     numeric value. Otherwise, -1.
func UnicharXDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_xdigit_value(_arg1)
	runtime.KeepAlive(c)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicodeCanonicalDecomposition computes the canonical decomposition of a
// Unicode character.
//
// Deprecated: Use the more flexible g_unichar_fully_decompose() instead.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
//   - resultLen: location to store the length of the return value.
//
// The function returns the following values:
//
//   - gunichar: newly allocated string of Unicode characters. result_len is set
//     to the resulting length of the string.
func UnicodeCanonicalDecomposition(ch uint32, resultLen *uint) *uint32 {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gsize    // out
	var _cret *C.gunichar // in

	_arg1 = C.gunichar(ch)
	_arg2 = (*C.gsize)(unsafe.Pointer(resultLen))

	_cret = C.g_unicode_canonical_decomposition(_arg1, _arg2)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(resultLen)

	var _gunichar *uint32 // out

	_gunichar = (*uint32)(unsafe.Pointer(_cret))

	return _gunichar
}

// UnicodeCanonicalOrdering computes the canonical ordering of a string
// in-place. This rearranges decomposed characters in the string according to
// their combining classes. See the Unicode manual for more information.
//
// The function takes the following parameters:
//
//   - str: UCS-4 encoded string.
func UnicodeCanonicalOrdering(str []uint32) {
	var _arg1 *C.gunichar // out
	var _arg2 C.gsize

	_arg2 = (C.gsize)(len(str))
	if len(str) > 0 {
		_arg1 = (*C.gunichar)(unsafe.Pointer(&str[0]))
	}

	C.g_unicode_canonical_ordering(_arg1, _arg2)
	runtime.KeepAlive(str)
}

// Unsetenv removes an environment variable from the environment.
//
// Note that on some systems, when variables are overwritten, the memory used
// for the previous variables and its value isn't reclaimed.
//
// You should be mindful of the fact that environment variable handling in
// UNIX is not thread-safe, and your program may crash if one thread calls
// g_unsetenv() while another thread is calling getenv(). (And note that many
// functions, such as gettext(), call getenv() internally.) This function is
// only safe to use at the very start of your program, before creating any other
// threads (or creating objects that create worker threads of their own).
//
// If you need to set up the environment for a child process, you can
// use g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that array
// directly to execvpe(), g_spawn_async(), or the like.
//
// The function takes the following parameters:
//
//   - variable: environment variable to remove, must not contain '='.
func Unsetenv(variable string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_unsetenv(_arg1)
	runtime.KeepAlive(variable)
}

// Usleep pauses the current thread for the given number of microseconds.
//
// There are 1 million microseconds per second (represented by the
// G_USEC_PER_SEC macro). g_usleep() may have limited precision, depending on
// hardware and operating system; don't rely on the exact length of the sleep.
//
// The function takes the following parameters:
//
//   - microseconds: number of microseconds to pause.
func Usleep(microseconds uint32) {
	var _arg1 C.gulong // out

	_arg1 = C.gulong(microseconds)

	C.g_usleep(_arg1)
	runtime.KeepAlive(microseconds)
}

// UTF16ToUCS4: convert a string from UTF-16 to UCS-4. The result will be
// nul-terminated.
//
// The function takes the following parameters:
//
//   - str: UTF-16 encoded string.
//
// The function returns the following values:
//
//   - itemsRead (optional): location to store number of words read, or NULL.
//     If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be returned in case str
//     contains a trailing partial character. If an error occurs then the index
//     of the invalid input is stored here.
//   - itemsWritten (optional): location to store number of characters written,
//     or NULL. The value stored here does not include the trailing 0 character.
//   - gunichar: pointer to a newly allocated UCS-4 string. This value must be
//     freed with g_free(). If an error occurs, NULL will be returned and error
//     set.
func UTF16ToUCS4(str []uint16) (itemsRead, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gunichar // in
	var _cerr *C.GError   // in

	_arg2 = (C.glong)(len(str))
	if len(str) > 0 {
		_arg1 = (*C.gunichar2)(unsafe.Pointer(&str[0]))
	}

	_cret = C.g_utf16_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF16ToUTF8: convert a string from UTF-16 to UTF-8. The result will be
// terminated with a 0 byte.
//
// Note that the input is expected to be already in native endianness,
// an initial byte-order-mark character is not handled specially. g_convert()
// can be used to convert a byte buffer of UTF-16 data of ambiguous endianness.
//
// Further note that this function does not validate the result string;
// it may e.g. include embedded NUL characters. The only validation done by this
// function is to ensure that the input can be correctly interpreted as UTF-16,
// i.e. it doesn't contain unpaired surrogates or partial character sequences.
//
// The function takes the following parameters:
//
//   - str: UTF-16 encoded string.
//
// The function returns the following values:
//
//   - itemsRead (optional): location to store number of words read, or NULL.
//     If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be returned in case str
//     contains a trailing partial character. If an error occurs then the index
//     of the invalid input is stored here. It’s guaranteed to be non-negative.
//   - itemsWritten (optional): location to store number of bytes written,
//     or NULL. The value stored here does not include the trailing 0 byte.
//     It’s guaranteed to be non-negative.
//   - utf8: pointer to a newly allocated UTF-8 string. This value must be freed
//     with g_free(). If an error occurs, NULL will be returned and error set.
func UTF16ToUTF8(str []uint16) (itemsRead, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong
	var _arg3 C.glong   // in
	var _arg4 C.glong   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg2 = (C.glong)(len(str))
	if len(str) > 0 {
		_arg1 = (*C.gunichar2)(unsafe.Pointer(&str[0]))
	}

	_cret = C.g_utf16_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UTF8Casefold converts a string into a form that is independent of case.
// The result will not correspond to any particular case, but can be compared
// for equality or ordered with the results of calling g_utf8_casefold() on
// other strings.
//
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is only an
// approximation to the correct linguistic case insensitive ordering, though
// it is a fairly good one. Getting this exactly right would require a more
// sophisticated collation function that takes case sensitivity into account.
// GLib does not currently provide such a function.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - utf8: newly allocated string, that is a case independent form of str.
func UTF8Casefold(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_casefold(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Collate compares two strings for ordering using the linguistically
// correct rules for the [current locale][setlocale]. When sorting a large
// number of strings, it will be significantly faster to obtain collation keys
// with g_utf8_collate_key() and compare the keys with strcmp() when sorting
// instead of sorting the original strings.
//
// If the two strings are not comparable due to being in different collation
// sequences, the result is undefined. This can happen if the strings are in
// different language scripts, for example.
//
// The function takes the following parameters:
//
//   - str1: UTF-8 encoded string.
//   - str2: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - gint: < 0 if str1 compares before str2, 0 if they compare equal, > 0 if
//     str1 compares after str2.
func UTF8Collate(str1, str2 string) int {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.gint   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str1)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str2)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_collate(_arg1, _arg2)
	runtime.KeepAlive(str1)
	runtime.KeepAlive(str2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UTF8CollateKey converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
//
// The results of comparing the collation keys of two strings with strcmp() will
// always be the same as comparing the two original keys with g_utf8_collate().
//
// Note that this function depends on the [current locale][setlocale].
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - utf8: newly allocated string. This string should be freed with g_free()
//     when you are done with it.
func UTF8CollateKey(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_collate_key(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8CollateKeyForFilename converts a string into a collation key that can
// be compared with other collation keys produced by the same function using
// strcmp().
//
// In order to sort filenames correctly, this function treats the dot '.' as a
// special case. Most dictionary orderings seem to consider it insignificant,
// thus producing the ordering "event.c" "eventgenerator.c" "event.h" instead of
// "event.c" "event.h" "eventgenerator.c". Also, we would like to treat numbers
// intelligently so that "file1" "file10" "file5" is sorted as "file1" "file5"
// "file10".
//
// Note that this function depends on the [current locale][setlocale].
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - utf8: newly allocated string. This string should be freed with g_free()
//     when you are done with it.
func UTF8CollateKeyForFilename(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_collate_key_for_filename(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8FindNextChar finds the start of the next UTF-8 character in the string
// after p.
//
// p does not have to be at the beginning of a UTF-8 character. No check is made
// to see if the character found is actually valid other than it starts with an
// appropriate byte.
//
// If end is NULL, the return value will never be NULL: if the end of the string
// is reached, a pointer to the terminating nul byte is returned. If end is
// non-NULL, the return value will be NULL if the end of the string is reached.
//
// The function takes the following parameters:
//
//   - p: pointer to a position within a UTF-8 encoded string.
//   - end (optional): pointer to the byte following the end of the string,
//     or NULL to indicate that the string is nul-terminated.
//
// The function returns the following values:
//
//   - utf8 (optional): pointer to the found character or NULL if end is set and
//     is reached.
func UTF8FindNextChar(p, end string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))
	if end != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(end)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_utf8_find_next_char(_arg1, _arg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(end)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8FindPrevChar: given a position p with a UTF-8 encoded string str, find
// the start of the previous UTF-8 character starting before p. Returns NULL if
// no UTF-8 characters are present in str before p.
//
// p does not have to be at the beginning of a UTF-8 character. No check is made
// to see if the character found is actually valid other than it starts with an
// appropriate byte.
//
// The function takes the following parameters:
//
//   - str: pointer to the beginning of a UTF-8 encoded string.
//   - p: pointer to some position within str.
//
// The function returns the following values:
//
//   - utf8 (optional): pointer to the found character or NULL.
func UTF8FindPrevChar(str, p string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_find_prev_char(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(p)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8GetChar converts a sequence of bytes encoded as UTF-8 to a Unicode
// character.
//
// If p does not point to a valid UTF-8 encoded character, results are
// undefined. If you are not sure that the bytes are complete valid Unicode
// characters, you should use g_utf8_get_char_validated() instead.
//
// The function takes the following parameters:
//
//   - p: pointer to Unicode character encoded as UTF-8.
//
// The function returns the following values:
//
//   - gunichar: resulting character.
func UTF8GetChar(p string) uint32 {
	var _arg1 *C.gchar   // out
	var _cret C.gunichar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_get_char(_arg1)
	runtime.KeepAlive(p)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UTF8GetCharValidated: convert a sequence of bytes encoded as UTF-8 to a
// Unicode character. This function checks for incomplete characters, for
// invalid characters such as characters that are out of the range of Unicode,
// and for overlong encodings of valid characters.
//
// Note that g_utf8_get_char_validated() returns (gunichar)-2 if max_len is
// positive and any of the bytes in the first UTF-8 character sequence are nul.
//
// The function takes the following parameters:
//
//   - p: pointer to Unicode character encoded as UTF-8.
//
// The function returns the following values:
//
//   - gunichar: resulting character. If p points to a partial sequence at the
//     end of a string that could begin a valid character (or if max_len is
//     zero), returns (gunichar)-2; otherwise, if p does not point to a valid
//     UTF-8 encoded Unicode character, returns (gunichar)-1.
func UTF8GetCharValidated(p string) uint32 {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret C.gunichar // in

	_arg2 = (C.gssize)(len(p))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(p) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(p)), p)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_get_char_validated(_arg1, _arg2)
	runtime.KeepAlive(p)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UTF8MakeValid: if the provided string is valid UTF-8, return a copy of it.
// If not, return a copy in which bytes that could not be interpreted as valid
// Unicode are replaced with the Unicode replacement character (U+FFFD).
//
// For example, this is an appropriate function to use if you have received
// a string that was incorrectly declared to be UTF-8, and you need a valid
// UTF-8 version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly readable
// as-is.
//
// The function takes the following parameters:
//
//   - str: string to coerce into UTF-8.
//
// The function returns the following values:
//
//   - utf8: valid UTF-8 string whose content resembles str.
func UTF8MakeValid(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_make_valid(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Normalize converts a string into canonical form, standardizing such
// issues as whether a character with an accent is represented as a base
// character and combining accent or as a single precomposed character.
// The string has to be valid UTF-8, otherwise NULL is returned. You should
// generally call g_utf8_normalize() before comparing two Unicode strings.
//
// The normalization mode G_NORMALIZE_DEFAULT only standardizes differences
// that do not affect the text content, such as the above-mentioned accent
// representation. G_NORMALIZE_ALL also standardizes the "compatibility"
// characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in
// this case DIGIT THREE). Formatting information may be lost but for most text
// operations such characters should be considered the same.
//
// G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE are like
// G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL, but returned a result with composed
// forms rather than a maximally decomposed form. This is often useful if you
// intend to convert the string to a legacy encoding or pass it to a system with
// less capable Unicode handling.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//   - mode: type of normalization to perform.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string, that is the normalized form of
//     str, or NULL if str is not valid UTF-8.
func UTF8Normalize(str string, mode NormalizeMode) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.GNormalizeMode // out
	var _cret *C.gchar         // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.GNormalizeMode(mode)

	_cret = C.g_utf8_normalize(_arg1, _arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(mode)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// UTF8OffsetToPointer converts from an integer character offset to a pointer to
// a position within the string.
//
// Since 2.10, this function allows to pass a negative offset to step backwards.
// It is usually worth stepping backwards from the end instead of forwards if
// offset is in the last fourth of the string, since moving forward is about 3
// times faster than moving backward.
//
// Note that this function doesn't abort when reaching the end of str. Therefore
// you should be sure that offset is within string boundaries before calling
// that function. Call g_utf8_strlen() when unsure. This limitation exists as
// this function is called frequently during text rendering and therefore has to
// be as fast as possible.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//   - offset: character offset within str.
//
// The function returns the following values:
//
//   - utf8: resulting pointer.
func UTF8OffsetToPointer(str string, offset int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(offset)

	_cret = C.g_utf8_offset_to_pointer(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(offset)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UTF8PointerToOffset converts from a pointer to position within a string to an
// integer character offset.
//
// Since 2.10, this function allows pos to be before str, and returns a negative
// offset in this case.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//   - pos: pointer to a position within str.
//
// The function returns the following values:
//
//   - glong: resulting character offset.
func UTF8PointerToOffset(str, pos string) int32 {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(pos)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_pointer_to_offset(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(pos)

	var _glong int32 // out

	_glong = int32(_cret)

	return _glong
}

// UTF8PrevChar finds the previous UTF-8 character in the string before p.
//
// p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte. If p might be the first character of the string,
// you must use g_utf8_find_prev_char() instead.
//
// The function takes the following parameters:
//
//   - p: pointer to a position within a UTF-8 encoded string.
//
// The function returns the following values:
//
//   - utf8: pointer to the found character.
func UTF8PrevChar(p string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_prev_char(_arg1)
	runtime.KeepAlive(p)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UTF8Strchr finds the leftmost occurrence of the given Unicode character in a
// UTF-8 encoded string, while limiting the search to len bytes. If len is -1,
// allow unbounded search.
//
// The function takes the following parameters:
//
//   - p: nul-terminated UTF-8 encoded string.
//   - c: unicode character.
//
// The function returns the following values:
//
//   - utf8 (optional): NULL if the string does not contain the character,
//     otherwise, a pointer to the start of the leftmost occurrence of the
//     character in the string.
func UTF8Strchr(p string, c uint32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg2 = (C.gssize)(len(p))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(p) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(p)), p)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gunichar(c)

	_cret = C.g_utf8_strchr(_arg1, _arg2, _arg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(c)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8Strdown converts all Unicode characters in the string that have a case to
// lowercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string changing.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - utf8: newly allocated string, with all characters converted to lowercase.
func UTF8Strdown(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_strdown(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strlen computes the length of the string in characters, not including
// the terminating nul character. If the max'th byte falls in the middle of a
// character, the last (partial) character is not counted.
//
// The function takes the following parameters:
//
//   - p: pointer to the start of a UTF-8 encoded string.
//   - max: maximum number of bytes to examine. If max is less than 0, then
//     the string is assumed to be nul-terminated. If max is 0, p will not be
//     examined and may be NULL. If max is greater than 0, up to max bytes are
//     examined.
//
// The function returns the following values:
//
//   - glong: length of the string in characters.
func UTF8Strlen(p string, max int) int32 {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(max)

	_cret = C.g_utf8_strlen(_arg1, _arg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(max)

	var _glong int32 // out

	_glong = int32(_cret)

	return _glong
}

// UTF8Strncpy: like the standard C strncpy() function, but copies a given
// number of characters instead of a given number of bytes. The src string must
// be valid UTF-8 encoded text. (Use g_utf8_validate() on all text before trying
// to use UTF-8 utility functions with it.)
//
// Note you must ensure dest is at least 4 * n + 1 to fit the largest possible
// UTF-8 characters.
//
// The function takes the following parameters:
//
//   - dest: buffer to fill with characters from src.
//   - src: UTF-8 encoded string.
//   - n: character count.
//
// The function returns the following values:
//
//   - utf8: dest.
func UTF8Strncpy(dest, src string, n uint) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gsize  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gsize(n)

	_cret = C.g_utf8_strncpy(_arg1, _arg2, _arg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(n)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UTF8Strrchr: find the rightmost occurrence of the given Unicode character in
// a UTF-8 encoded string, while limiting the search to len bytes. If len is -1,
// allow unbounded search.
//
// The function takes the following parameters:
//
//   - p: nul-terminated UTF-8 encoded string.
//   - c: unicode character.
//
// The function returns the following values:
//
//   - utf8 (optional): NULL if the string does not contain the character,
//     otherwise, a pointer to the start of the rightmost occurrence of the
//     character in the string.
func UTF8Strrchr(p string, c uint32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg2 = (C.gssize)(len(p))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(p) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(p)), p)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gunichar(c)

	_cret = C.g_utf8_strrchr(_arg1, _arg2, _arg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(c)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8Strreverse reverses a UTF-8 string. str must be valid UTF-8 encoded text.
// (Use g_utf8_validate() on all text before trying to use UTF-8 utility
// functions with it.)
//
// This function is intended for programmatic uses of reversed strings. It pays
// no attention to decomposed characters, combining marks, byte order marks,
// directional indicators (LRM, LRO, etc) and similar characters which might
// need special handling when reversing a string for display purposes.
//
// Note that unlike g_strreverse(), this function returns newly-allocated
// memory, which should be freed with g_free() when no longer needed.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string which is the reverse of str.
func UTF8Strreverse(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_strreverse(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strup converts all Unicode characters in the string that have a case to
// uppercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string increasing. (For
// instance, the German ess-zet will be changed to SS.).
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - utf8: newly allocated string, with all characters converted to uppercase.
func UTF8Strup(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _cret *C.gchar // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_strup(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Substring copies a substring out of a UTF-8 encoded string. The substring
// will contain end_pos - start_pos characters.
//
// Since GLib 2.72, -1 can be passed to end_pos to indicate the end of the
// string.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//   - startPos: character offset within str.
//   - endPos: another character offset within str, or -1 to indicate the end of
//     the string.
//
// The function returns the following values:
//
//   - utf8: newly allocated copy of the requested substring. Free with g_free()
//     when no longer needed.
func UTF8Substring(str string, startPos, endPos int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _arg3 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(startPos)
	_arg3 = C.glong(endPos)

	_cret = C.g_utf8_substring(_arg1, _arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8ToUCS4: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4. A trailing 0 character will be added to the string
// after the converted text.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - itemsRead (optional): location to store number of bytes read, or NULL.
//     If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be returned in case str
//     contains a trailing partial character. If an error occurs then the index
//     of the invalid input is stored here.
//   - itemsWritten (optional): location to store number of characters written
//     or NULL. The value here stored does not include the trailing 0 character.
//   - gunichar: pointer to a newly allocated UCS-4 string. This value must be
//     freed with g_free(). If an error occurs, NULL will be returned and error
//     set.
func UTF8ToUCS4(str string) (itemsRead, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gchar // out
	var _arg2 C.glong
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gunichar // in
	var _cerr *C.GError   // in

	_arg2 = (C.glong)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF8ToUCS4Fast: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input. This function is roughly
// twice as fast as g_utf8_to_ucs4() but does no error checking on the input.
// A trailing 0 character will be added to the string after the converted text.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - itemsWritten (optional): location to store the number of characters in
//     the result, or NULL.
//   - gunichar: pointer to a newly allocated UCS-4 string. This value must be
//     freed with g_free().
func UTF8ToUCS4Fast(str string) (int32, *uint32) {
	var _arg1 *C.gchar // out
	var _arg2 C.glong
	var _arg3 C.glong     // in
	var _cret *C.gunichar // in

	_arg2 = (C.glong)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_to_ucs4_fast(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)

	var _itemsWritten int32 // out
	var _gunichar *uint32   // out

	_itemsWritten = int32(_arg3)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))

	return _itemsWritten, _gunichar
}

// UTF8ToUTF16: convert a string from UTF-8 to UTF-16. A 0 character will be
// added to the result after the converted text.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string.
//
// The function returns the following values:
//
//   - itemsRead (optional): location to store number of bytes read, or NULL.
//     If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be returned in case str
//     contains a trailing partial character. If an error occurs then the index
//     of the invalid input is stored here.
//   - itemsWritten (optional): location to store number of #gunichar2 written,
//     or NULL. The value stored here does not include the trailing 0.
//   - guint16: pointer to a newly allocated UTF-16 string. This value must be
//     freed with g_free(). If an error occurs, NULL will be returned and error
//     set.
func UTF8ToUTF16(str string) (itemsRead, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gchar // out
	var _arg2 C.glong
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg2 = (C.glong)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_guint16 = (*uint16)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// UTF8TruncateMiddle cuts off the middle of the string, preserving half of
// truncate_length characters at the beginning and half at the end.
//
// If string is already short enough, this returns a copy of string.
// If truncate_length is 0, an empty string is returned.
//
// The function takes the following parameters:
//
//   - str: nul-terminated UTF-8 encoded string.
//   - truncateLength: new size of string, in characters, including the ellipsis
//     character.
//
// The function returns the following values:
//
//   - utf8: newly-allocated copy of string ellipsized in the middle.
func UTF8TruncateMiddle(str string, truncateLength uint) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gsize  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gsize(truncateLength)

	_cret = C.g_utf8_truncate_middle(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(truncateLength)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Validate validates UTF-8 encoded text. str is the text to validate;
// if str is nul-terminated, then max_len can be -1, otherwise max_len should
// be the number of bytes to validate. If end is non-NULL, then the end of
// the valid range will be stored there (i.e. the start of the first invalid
// character if some bytes were invalid, or the end of the text being validated
// otherwise).
//
// Note that g_utf8_validate() returns FALSE if max_len is positive and any of
// the max_len bytes are nul.
//
// Returns TRUE if all of str was valid. Many GLib and GTK routines require
// valid UTF-8 as input; so data read from a file or the network should be
// checked with g_utf8_validate() before doing anything else with it.
//
// The function takes the following parameters:
//
//   - str: pointer to character data.
//
// The function returns the following values:
//
//   - end (optional): return location for end of valid data.
//   - ok: TRUE if the text was valid UTF-8.
func UTF8Validate(str string) (string, bool) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_validate(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)

	var _end string // out
	var _ok bool    // out

	if _arg3 != nil {
		_end = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// UTF8ValidateLen validates UTF-8 encoded text.
//
// As with g_utf8_validate(), but max_len must be set, and hence this function
// will always return FALSE if any of the bytes of str are nul.
//
// The function takes the following parameters:
//
//   - str: pointer to character data.
//
// The function returns the following values:
//
//   - end (optional): return location for end of valid data.
//   - ok: TRUE if the text was valid UTF-8.
func UTF8ValidateLen(str string) (string, bool) {
	var _arg1 *C.gchar // out
	var _arg2 C.gsize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = (C.gsize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_validate_len(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)

	var _end string // out
	var _ok bool    // out

	if _arg3 != nil {
		_end = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// UUIDStringIsValid parses the string str and verify if it is a UUID.
//
// The function accepts the following syntax:
//
// - simple forms (e.g. f81d4fae-7dec-11d0-a765-00a0c91e6bf6)
//
// Note that hyphens are required within the UUID string itself, as per the
// aforementioned RFC.
//
// The function takes the following parameters:
//
//   - str: string representing a UUID.
//
// The function returns the following values:
//
//   - ok: TRUE if str is a valid UUID, FALSE otherwise.
func UUIDStringIsValid(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uuid_string_is_valid(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UUIDStringRandom generates a random UUID (RFC 4122 version 4) as a string.
// It has the same randomness guarantees as #GRand, so must not be used for
// cryptographic purposes such as key generation, nonces, salts or one-time
// pads.
//
// The function returns the following values:
//
//   - utf8: string that should be freed with g_free().
func UUIDStringRandom() string {
	var _cret *C.gchar // in

	_cret = C.g_uuid_string_random()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func VariantGetGType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.g_variant_get_gtype()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Array contains the public fields of a GArray.
//
// An instance of this type is always passed by reference.
type Array struct {
	*array
}

// array is the struct that's finalized.
type array struct {
	native *C.GArray
}

// Data: pointer to the element data. The data may be moved as elements are
// added to the #GArray.
func (a *Array) Data() string {
	valptr := &a.native.data
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Len: number of elements in the #GArray not including the possible terminating
// zero element.
func (a *Array) Len() uint {
	valptr := &a.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of elements in the #GArray not including the possible terminating
// zero element.
func (a *Array) SetLen(len uint) {
	valptr := &a.native.len
	*valptr = C.guint(len)
}

// BookmarkFile: GBookmarkFile lets you parse, edit or create files containing
// bookmarks.
//
// Bookmarks refer to a URI, along with some meta-data about the resource
// pointed by the URI like its MIME type, the application that is
// registering the bookmark and the icon that should be used to represent
// the bookmark. The data is stored using the Desktop Bookmark Specification
// (http://www.gnome.org/~ebassi/bookmark-spec).
//
// The syntax of the bookmark files is described in detail inside the Desktop
// Bookmark Specification, here is a quick summary: bookmark files use a
// sub-class of the XML Bookmark Exchange Language specification, consisting
// of valid UTF-8 encoded XML, under the <xbel> root element; each bookmark is
// stored inside a <bookmark> element, using its URI: no relative paths can be
// used inside a bookmark file. The bookmark may have a user defined title and
// description, to be used instead of the URI. Under the <metadata> element,
// with its owner attribute set to http://freedesktop.org, is stored the
// meta-data about a resource pointed by its URI. The meta-data consists of
// the resource's MIME type; the applications that have registered a bookmark;
// the groups to which a bookmark belongs to; a visibility flag, used to set the
// bookmark as "private" to the applications and groups that has it registered;
// the URI and MIME type of an icon, to be used when displaying the bookmark
// inside a GUI.
//
// Here is an example of a bookmark file: bookmarks.xbel
// (https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/glib/tests/bookmarks.xbel)
//
// A bookmark file might contain more than one bookmark; each bookmark is
// accessed through its URI.
//
// The important caveat of bookmark files is that when you add a new
// bookmark you must also add the application that is registering it, using
// glib.BookmarkFile.AddApplication() or glib.BookmarkFile.SetApplicationInfo().
// If a bookmark has no applications then it won't be dumped when creating
// the on disk representation, using glib.BookmarkFile.ToData() or
// glib.BookmarkFile.ToFile().
//
// An instance of this type is always passed by reference.
type BookmarkFile struct {
	*bookmarkFile
}

// bookmarkFile is the struct that's finalized.
type bookmarkFile struct {
	native *C.GBookmarkFile
}

func marshalBookmarkFile(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &BookmarkFile{&bookmarkFile{(*C.GBookmarkFile)(b)}}, nil
}

// NewBookmarkFile constructs a struct BookmarkFile.
func NewBookmarkFile() *BookmarkFile {
	var _cret *C.GBookmarkFile // in

	_cret = C.g_bookmark_file_new()

	var _bookmarkFile *BookmarkFile // out

	_bookmarkFile = (*BookmarkFile)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bookmarkFile)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bookmark_file_free((*C.GBookmarkFile)(intern.C))
		},
	)

	return _bookmarkFile
}

// AddApplication adds the application with name and exec to the list of
// applications that have registered a bookmark for uri into bookmark.
//
// Every bookmark inside a File must have at least an application registered.
// Each application must provide a name, a command line useful for launching
// the bookmark, the number of times the bookmark has been registered by the
// application and the last time the application registered this bookmark.
//
// If name is NULL, the name of the application will be the same returned
// by g_get_application_name(); if exec is NULL, the command line will be a
// composition of the program name as returned by g_get_prgname() and the "\u"
// modifier, which will be expanded to the bookmark's URI.
//
// This function will automatically take care of updating the registrations
// count and timestamping in case an application with the same name had already
// registered a bookmark for uri inside bookmark.
//
// If no bookmark for uri is found, one is created.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - name (optional) of the application registering the bookmark or NULL.
//   - exec (optional): command line to be used to launch the bookmark or NULL.
func (bookmark *BookmarkFile) AddApplication(uri string, name string, exec string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if exec != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(exec)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_bookmark_file_add_application(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)
	runtime.KeepAlive(exec)
}

// AddGroup adds group to the list of groups to which the bookmark for uri
// belongs to.
//
// If no bookmark for uri is found then it is created.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - group name to be added.
func (bookmark *BookmarkFile) AddGroup(uri string, group string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_add_group(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)
}

// Copy: deeply copies a bookmark File object to a new one.
//
// The function returns the following values:
//
//   - bookmarkFile: copy of bookmark. Use g_bookmark_free() when finished using
//     it.
func (bookmark *BookmarkFile) Copy() *BookmarkFile {
	var _arg0 *C.GBookmarkFile // out
	var _cret *C.GBookmarkFile // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))

	_cret = C.g_bookmark_file_copy(_arg0)
	runtime.KeepAlive(bookmark)

	var _bookmarkFile *BookmarkFile // out

	_bookmarkFile = (*BookmarkFile)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bookmarkFile)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bookmark_file_free((*C.GBookmarkFile)(intern.C))
		},
	)

	return _bookmarkFile
}

// AddedDateTime gets the time the bookmark for uri was added to bookmark
//
// In the event the URI cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - dateTime: Time.
func (bookmark *BookmarkFile) AddedDateTime(uri string) (*DateTime, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _cret *C.GDateTime     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_added_date_time(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _dateTime *DateTime // out
	var _goerr error        // out

	_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_date_time_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dateTime, _goerr
}

// ApplicationInfo gets the registration information of app_name for the
// bookmark for uri. See g_bookmark_file_set_application_info() for more
// information about the returned data.
//
// The string returned in app_exec must be freed.
//
// In the event the URI cannot be found, FALSE is returned and error is set
// to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application
// with name app_name has registered a bookmark for uri, FALSE is returned and
// error is set to G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that
// unquoting the command line fails, an error of the G_SHELL_ERROR domain is set
// and FALSE is returned.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - name application's name.
//
// The function returns the following values:
//
//   - exec (optional): return location for the command line of the application,
//     or NULL.
//   - count (optional): return location for the registration count, or NULL.
//   - stamp (optional): return location for the last registration time,
//     or NULL.
func (bookmark *BookmarkFile) ApplicationInfo(uri string, name string) (string, uint, *DateTime, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _arg2 *C.char          // out
	var _arg3 *C.char          // in
	var _arg4 C.uint           // in
	var _arg5 *C.GDateTime     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_get_application_info(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)

	var _exec string     // out
	var _count uint      // out
	var _stamp *DateTime // out
	var _goerr error     // out

	if _arg3 != nil {
		_exec = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_count = uint(_arg4)
	if _arg5 != nil {
		_stamp = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
		C.g_date_time_ref(_arg5)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_stamp)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _exec, _count, _stamp, _goerr
}

// Applications retrieves the names of the applications that have registered the
// bookmark for uri.
//
// In the event the URI cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - utf8s: newly allocated NULL-terminated array of strings. Use g_strfreev()
//     to free it.
func (bookmark *BookmarkFile) Applications(uri string) ([]string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret **C.gchar        // in
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_applications(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg2)
		_utf8s = make([]string, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// Description retrieves the description of the bookmark for uri.
//
// In the event the URI cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - utf8: newly allocated string or NULL if the specified URI cannot be
//     found.
func (bookmark *BookmarkFile) Description(uri string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_description(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// Groups retrieves the list of group names of the bookmark for uri.
//
// In the event the URI cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The returned array is NULL terminated, so length may optionally be NULL.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - utf8s: newly allocated NULL-terminated array of group names. Use
//     g_strfreev() to free it.
func (bookmark *BookmarkFile) Groups(uri string) ([]string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret **C.gchar        // in
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_groups(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg2)
		_utf8s = make([]string, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// Icon gets the icon of the bookmark for uri.
//
// In the event the URI cannot be found, FALSE is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - href (optional): return location for the icon's location or NULL.
//   - mimeType (optional): return location for the icon's MIME type or NULL.
func (bookmark *BookmarkFile) Icon(uri string) (href string, mimeType string, goerr error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // in
	var _arg3 *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_get_icon(_arg0, _arg1, &_arg2, &_arg3, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _href string     // out
	var _mimeType string // out
	var _goerr error     // out

	if _arg2 != nil {
		_href = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_mimeType = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _href, _mimeType, _goerr
}

// IsPrivate gets whether the private flag of the bookmark for uri is set.
//
// In the event the URI cannot be found, FALSE is returned and error
// is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that the
// private flag cannot be found, FALSE is returned and error is set to
// G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
func (bookmark *BookmarkFile) IsPrivate(uri string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_get_is_private(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MIMEType retrieves the MIME type of the resource pointed by uri.
//
// In the event the URI cannot be found, NULL is returned and error
// is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that
// the MIME type cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - utf8: newly allocated string or NULL if the specified URI cannot be
//     found.
func (bookmark *BookmarkFile) MIMEType(uri string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_mime_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// ModifiedDateTime gets the time when the bookmark for uri was last modified.
//
// In the event the URI cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - dateTime: Time.
func (bookmark *BookmarkFile) ModifiedDateTime(uri string) (*DateTime, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _cret *C.GDateTime     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_modified_date_time(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _dateTime *DateTime // out
	var _goerr error        // out

	_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_date_time_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dateTime, _goerr
}

// Size gets the number of bookmarks inside bookmark.
//
// The function returns the following values:
//
//   - gint: number of bookmarks.
func (bookmark *BookmarkFile) Size() int {
	var _arg0 *C.GBookmarkFile // out
	var _cret C.gint           // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))

	_cret = C.g_bookmark_file_get_size(_arg0)
	runtime.KeepAlive(bookmark)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Title returns the title of the bookmark for uri.
//
// If uri is NULL, the title of bookmark is returned.
//
// In the event the URI cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri (optional): valid URI or NULL.
//
// The function returns the following values:
//
//   - utf8: newly allocated string or NULL if the specified URI cannot be
//     found.
func (bookmark *BookmarkFile) Title(uri string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_bookmark_file_get_title(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// URIs returns all URIs of the bookmarks in the bookmark file bookmark.
// The array of returned URIs will be NULL-terminated, so length may optionally
// be NULL.
//
// The function returns the following values:
//
//   - utf8s: newly allocated NULL-terminated array of strings. Use g_strfreev()
//     to free it.
func (bookmark *BookmarkFile) URIs() []string {
	var _arg0 *C.GBookmarkFile // out
	var _cret **C.gchar        // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))

	_cret = C.g_bookmark_file_get_uris(_arg0, &_arg1)
	runtime.KeepAlive(bookmark)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// VisitedDateTime gets the time the bookmark for uri was last visited.
//
// In the event the URI cannot be found, NULL is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - dateTime: Time.
func (bookmark *BookmarkFile) VisitedDateTime(uri string) (*DateTime, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _cret *C.GDateTime     // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_visited_date_time(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _dateTime *DateTime // out
	var _goerr error        // out

	_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_date_time_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dateTime, _goerr
}

// HasApplication checks whether the bookmark for uri inside bookmark has been
// registered by application name.
//
// In the event the URI cannot be found, FALSE is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - name of the application.
func (bookmark *BookmarkFile) HasApplication(uri string, name string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_has_application(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// HasGroup checks whether group appears in the list of groups to which the
// bookmark for uri belongs to.
//
// In the event the URI cannot be found, FALSE is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - group name to be searched.
func (bookmark *BookmarkFile) HasGroup(uri string, group string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_has_group(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// HasItem looks whether the desktop bookmark has an item with its URI set to
// uri.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - ok: TRUE if uri is inside bookmark, FALSE otherwise.
func (bookmark *BookmarkFile) HasItem(uri string) bool {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_has_item(_arg0, _arg1)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadFromData loads a bookmark file from memory into an empty File structure.
// If the object cannot be created then error is set to a FileError.
//
// The function takes the following parameters:
//
//   - data: desktop bookmarks loaded in memory.
func (bookmark *BookmarkFile) LoadFromData(data string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gsize
	var _cerr *C.GError // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg2 = (C.gsize)(len(data))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(data) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(data)), data)
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_load_from_data(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadFromDataDirs: this function looks for a desktop bookmark file
// named file in the paths returned from g_get_user_data_dir() and
// g_get_system_data_dirs(), loads the file into bookmark and returns the file's
// full path in full_path. If the file could not be loaded then error is set to
// either a Error or FileError.
//
// The function takes the following parameters:
//
//   - file: relative path to a filename to open and parse.
//
// The function returns the following values:
//
//   - fullPath (optional): return location for a string containing the full
//     path of the file, or NULL.
func (bookmark *BookmarkFile) LoadFromDataDirs(file string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_load_from_data_dirs(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(file)

	var _fullPath string // out
	var _goerr error     // out

	if _arg2 != nil {
		_fullPath = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fullPath, _goerr
}

// LoadFromFile loads a desktop bookmark file into an empty File structure.
// If the file could not be loaded then error is set to either a Error or
// FileError.
//
// The function takes the following parameters:
//
//   - filename: path of a filename to load, in the GLib file name encoding.
func (bookmark *BookmarkFile) LoadFromFile(filename string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_load_from_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// MoveItem changes the URI of a bookmark item from old_uri to new_uri.
// Any existing bookmark for new_uri will be overwritten. If new_uri is NULL,
// then the bookmark is removed.
//
// In the event the URI cannot be found, FALSE is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - oldUri: valid URI.
//   - newUri (optional): valid URI, or NULL.
func (bookmark *BookmarkFile) MoveItem(oldUri string, newUri string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(oldUri)))
	defer C.free(unsafe.Pointer(_arg1))
	if newUri != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(newUri)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.g_bookmark_file_move_item(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(oldUri)
	runtime.KeepAlive(newUri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveApplication removes application registered with name from the list of
// applications that have registered a bookmark for uri inside bookmark.
//
// In the event the URI cannot be found, FALSE is returned and error is set to
// G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with
// name app_name has registered a bookmark for uri, FALSE is returned and error
// is set to G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - name of the application.
func (bookmark *BookmarkFile) RemoveApplication(uri string, name string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_remove_application(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveGroup removes group from the list of groups to which the bookmark for
// uri belongs to.
//
// In the event the URI cannot be found, FALSE is returned and error is set
// to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event no group was defined,
// FALSE is returned and error is set to G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - group name to be removed.
func (bookmark *BookmarkFile) RemoveGroup(uri string, group string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_remove_group(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveItem removes the bookmark for uri from the bookmark file bookmark.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
func (bookmark *BookmarkFile) RemoveItem(uri string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_remove_item(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAddedDateTime sets the time the bookmark for uri was added into bookmark.
//
// If no bookmark for uri is found then it is created.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - added: Time.
func (bookmark *BookmarkFile) SetAddedDateTime(uri string, added *DateTime) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _arg2 *C.GDateTime     // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(added)))

	C.g_bookmark_file_set_added_date_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(added)
}

// SetApplicationInfo sets the meta-data of application name inside the list of
// applications that have registered a bookmark for uri inside bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// name can be any UTF-8 encoded string used to identify an application.
// exec can have one of these two modifiers: "\f", which will be
// expanded as the local file name retrieved from the bookmark's URI;
// "\u", which will be expanded as the bookmark's URI. The expansion is
// done automatically when retrieving the stored command line using the
// g_bookmark_file_get_application_info() function. count is the number of
// times the application has registered the bookmark; if is < 0, the current
// registration count will be increased by one, if is 0, the application with
// name will be removed from the list of registered applications. stamp is the
// Unix time of the last registration.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for uri is found, FALSE is returned and error is
// set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly, in the event that
// no application name has registered a bookmark for uri, FALSE is returned
// and error is set to G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. Otherwise,
// if no bookmark for uri is found, one is created.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - name application's name.
//   - exec application's command line.
//   - count: number of registrations done for this application.
//   - stamp (optional): time of the last registration for this application,
//     which may be NULL if count is 0.
func (bookmark *BookmarkFile) SetApplicationInfo(uri string, name string, exec string, count int, stamp *DateTime) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _arg2 *C.char          // out
	var _arg3 *C.char          // out
	var _arg4 C.int            // out
	var _arg5 *C.GDateTime     // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(exec)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.int(count)
	if stamp != nil {
		_arg5 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(stamp)))
	}

	C.g_bookmark_file_set_application_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)
	runtime.KeepAlive(exec)
	runtime.KeepAlive(count)
	runtime.KeepAlive(stamp)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetDescription sets description as the description of the bookmark for uri.
//
// If uri is NULL, the description of bookmark is set.
//
// If a bookmark for uri cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - uri (optional): valid URI or NULL.
//   - description: string.
func (bookmark *BookmarkFile) SetDescription(uri string, description string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_description(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(description)
}

// SetGroups sets a list of group names for the item with URI uri. Each
// previously set group name list is removed.
//
// If uri cannot be found then an item for it is created.
//
// The function takes the following parameters:
//
//   - uri item's URI.
//   - groups (optional): array of group names, or NULL to remove all groups.
func (bookmark *BookmarkFile) SetGroups(uri string, groups []string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 **C.gchar        // out
	var _arg3 C.gsize

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (C.gsize)(len(groups))
	_arg2 = (**C.gchar)(C.calloc(C.size_t(len(groups)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((**C.gchar)(_arg2), len(groups))
		for i := range groups {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(groups[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_bookmark_file_set_groups(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(groups)
}

// SetIcon sets the icon for the bookmark for uri. If href is NULL, unsets the
// currently set icon. href can either be a full URL for the icon file or the
// icon name following the Icon Naming specification.
//
// If no bookmark for uri is found one is created.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - href (optional): URI of the icon for the bookmark, or NULL.
//   - mimeType: MIME type of the icon for the bookmark.
func (bookmark *BookmarkFile) SetIcon(uri string, href string, mimeType string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if href != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(href)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_bookmark_file_set_icon(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(href)
	runtime.KeepAlive(mimeType)
}

// SetIsPrivate sets the private flag of the bookmark for uri.
//
// If a bookmark for uri cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - isPrivate: TRUE if the bookmark should be marked as private.
func (bookmark *BookmarkFile) SetIsPrivate(uri string, isPrivate bool) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if isPrivate {
		_arg2 = C.TRUE
	}

	C.g_bookmark_file_set_is_private(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(isPrivate)
}

// SetMIMEType sets mime_type as the MIME type of the bookmark for uri.
//
// If a bookmark for uri cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - mimeType: MIME type.
func (bookmark *BookmarkFile) SetMIMEType(uri string, mimeType string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_mime_type(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(mimeType)
}

// SetModifiedDateTime sets the last time the bookmark for uri was last
// modified.
//
// If no bookmark for uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's
// meta-data was actually changed. Every function of File that
// modifies a bookmark also changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - modified: Time.
func (bookmark *BookmarkFile) SetModifiedDateTime(uri string, modified *DateTime) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _arg2 *C.GDateTime     // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(modified)))

	C.g_bookmark_file_set_modified_date_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(modified)
}

// SetTitle sets title as the title of the bookmark for uri inside the bookmark
// file bookmark.
//
// If uri is NULL, the title of bookmark is set.
//
// If a bookmark for uri cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - uri (optional): valid URI or NULL.
//   - title: UTF-8 encoded string.
func (bookmark *BookmarkFile) SetTitle(uri string, title string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_title(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(title)
}

// SetVisitedDateTime sets the time the bookmark for uri was last visited.
//
// If no bookmark for uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched, either
// using the command line retrieved by g_bookmark_file_get_application_info()
// or by the default application for the bookmark's MIME type, retrieved using
// g_bookmark_file_get_mime_type(). Changing the "visited" time does not affect
// the "modified" time.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - visited: Time.
func (bookmark *BookmarkFile) SetVisitedDateTime(uri string, visited *DateTime) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.char          // out
	var _arg2 *C.GDateTime     // out

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(visited)))

	C.g_bookmark_file_set_visited_date_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(visited)
}

// ToData: this function outputs bookmark as a string.
//
// The function returns the following values:
//
//   - guint8s: a newly allocated string holding the contents of the File.
func (bookmark *BookmarkFile) ToData() ([]byte, error) {
	var _arg0 *C.GBookmarkFile // out
	var _cret *C.gchar         // in
	var _arg1 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))

	_cret = C.g_bookmark_file_to_data(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(bookmark)

	var _guint8s []byte // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint8s, _goerr
}

// ToFile: this function outputs bookmark into a file. The write process is
// guaranteed to be atomic by using g_file_set_contents() internally.
//
// The function takes the following parameters:
//
//   - filename: path of the output file.
func (bookmark *BookmarkFile) ToFile(filename string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(gextras.StructNative(unsafe.Pointer(bookmark)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func BookmarkFileErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_bookmark_file_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// ByteArray contains the public fields of a GByteArray.
//
// An instance of this type is always passed by reference.
type ByteArray struct {
	*byteArray
}

// byteArray is the struct that's finalized.
type byteArray struct {
	native *C.GByteArray
}

// Data: pointer to the element data. The data may be moved as elements are
// added to the Array.
func (b *ByteArray) Data() *byte {
	valptr := &b.native.data
	var _v *byte // out
	_v = (*byte)(unsafe.Pointer(*valptr))
	return _v
}

// Len: number of elements in the Array.
func (b *ByteArray) Len() uint {
	valptr := &b.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of elements in the Array.
func (b *ByteArray) SetLen(len uint) {
	valptr := &b.native.len
	*valptr = C.guint(len)
}

// Bytes: simple refcounted data type representing an immutable sequence of zero
// or more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds alive for
// as long as anyone holds a reference to the bytes. When the last reference
// count is dropped, the memory is released. Multiple unrelated callers
// can use byte data in the #GBytes without coordinating their activities,
// resting assured that the byte data will not change or move while they hold a
// reference.
//
// A #GBytes can come from many different origins that may have different
// procedures for freeing the memory region. Examples are memory from
// g_malloc(), from memory slices, from a File or memory from other allocators.
//
// #GBytes work well as keys in Table. Use g_bytes_equal() and g_bytes_hash()
// as parameters to g_hash_table_new() or g_hash_table_new_full(). #GBytes can
// also be used as keys in a #GTree by passing the g_bytes_compare() function to
// g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable array
// of bytes see Array. Use g_bytes_unref_to_array() to create a mutable array
// for a #GBytes sequence. To create an immutable #GBytes from a mutable Array,
// use the g_byte_array_free_to_bytes() function.
//
// An instance of this type is always passed by reference.
type Bytes struct {
	*bytes
}

// bytes is the struct that's finalized.
type bytes struct {
	native *C.GBytes
}

// NewBytes constructs a struct Bytes.
func NewBytes(data []byte) *Bytes {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gsize
	var _cret *C.GBytes // in

	_arg2 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.g_bytes_new(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _bytes *Bytes // out

	_bytes = (*Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Compare compares the two #GBytes values.
//
// This function can be used to sort GBytes instances in lexicographical order.
//
// If bytes1 and bytes2 have different length but the shorter one is a prefix of
// the longer one then the shorter one is considered to be less than the longer
// one. Otherwise the first byte where both differ is used for comparison.
// If bytes1 has a smaller value at that position it is considered less,
// otherwise greater than bytes2.
//
// The function takes the following parameters:
//
//   - bytes2: pointer to a #GBytes to compare with bytes1.
//
// The function returns the following values:
//
//   - gint: negative value if bytes1 is less than bytes2, a positive value if
//     bytes1 is greater than bytes2, and zero if bytes1 is equal to bytes2.
func (bytes1 *Bytes) Compare(bytes2 *Bytes) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(bytes1)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(bytes2)))

	_cret = C.g_bytes_compare(_arg0, _arg1)
	runtime.KeepAlive(bytes1)
	runtime.KeepAlive(bytes2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Equal compares the two #GBytes values being pointed to and returns TRUE if
// they are equal.
//
// This function can be passed to g_hash_table_new() as the key_equal_func
// parameter, when using non-NULL #GBytes pointers as keys in a Table.
//
// The function takes the following parameters:
//
//   - bytes2: pointer to a #GBytes to compare with bytes1.
//
// The function returns the following values:
//
//   - ok: TRUE if the two keys match.
func (bytes1 *Bytes) Equal(bytes2 *Bytes) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(bytes1)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(bytes2)))

	_cret = C.g_bytes_equal(_arg0, _arg1)
	runtime.KeepAlive(bytes1)
	runtime.KeepAlive(bytes2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Data: get the byte data in the #GBytes. This data should not be modified.
//
// This function will always return the same pointer for a given #GBytes.
//
// NULL may be returned if size is 0. This is not guaranteed, as the #GBytes may
// represent an empty string with data non-NULL and size as 0. NULL will not be
// returned if size is non-zero.
//
// The function returns the following values:
//
//   - guint8s (optional): a pointer to the byte data, or NULL.
func (bytes *Bytes) Data() []byte {
	var _arg0 *C.GBytes       // out
	var _cret C.gconstpointer // in
	var _arg1 C.gsize         // in

	_arg0 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.g_bytes_get_data(_arg0, &_arg1)
	runtime.KeepAlive(bytes)

	var _guint8s []byte // out

	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// Region gets a pointer to a region in bytes.
//
// The region starts at offset many bytes from the start of the data and
// contains n_elements many elements of element_size size.
//
// n_elements may be zero, but element_size must always be non-zero. Ideally,
// element_size is a static constant (eg: sizeof a struct).
//
// This function does careful bounds checking (including checking for arithmetic
// overflows) and returns a non-NULL pointer if the specified region lies
// entirely within the bytes. If the region is in some way out of range,
// or if an overflow has occurred, then NULL is returned.
//
// Note: it is possible to have a valid zero-size region. In this case,
// the returned pointer will be equal to the base pointer of the data of bytes,
// plus offset. This will be non-NULL except for the case where bytes itself
// was a zero-sized region. Since it is unlikely that you will be using this
// function to check for a zero-sized region in a zero-sized bytes, NULL
// effectively always means "error".
//
// The function takes the following parameters:
//
//   - elementSize: non-zero element size.
//   - offset to the start of the region within the bytes.
//   - nElements: number of elements in the region.
//
// The function returns the following values:
//
//   - gpointer (optional): requested region, or NULL in case of an error.
func (bytes *Bytes) Region(elementSize uint, offset uint, nElements uint) unsafe.Pointer {
	var _arg0 *C.GBytes       // out
	var _arg1 C.gsize         // out
	var _arg2 C.gsize         // out
	var _arg3 C.gsize         // out
	var _cret C.gconstpointer // in

	_arg0 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	_arg1 = C.gsize(elementSize)
	_arg2 = C.gsize(offset)
	_arg3 = C.gsize(nElements)

	_cret = C.g_bytes_get_region(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(elementSize)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(nElements)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Size: get the size of the byte data in the #GBytes.
//
// This function will always return the same value for a given #GBytes.
//
// The function returns the following values:
//
//   - gsize: size.
func (bytes *Bytes) Size() uint {
	var _arg0 *C.GBytes // out
	var _cret C.gsize   // in

	_arg0 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.g_bytes_get_size(_arg0)
	runtime.KeepAlive(bytes)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Hash creates an integer hash code for the byte data in the #GBytes.
//
// This function can be passed to g_hash_table_new() as the key_hash_func
// parameter, when using non-NULL #GBytes pointers as keys in a Table.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to the key.
func (bytes *Bytes) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.g_bytes_hash(_arg0)
	runtime.KeepAlive(bytes)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NewFromBytes creates a #GBytes which is a subsection of another #GBytes.
// The offset + length may not be longer than the size of bytes.
//
// A reference to bytes will be held by the newly created #GBytes until the byte
// data is no longer needed.
//
// Since 2.56, if offset is 0 and length matches the size of bytes, then bytes
// will be returned with the reference count incremented by 1. If bytes is a
// slice of another #GBytes, then the resulting #GBytes will reference the same
// #GBytes instead of bytes. This allows consumers to simplify the usage of
// #GBytes when asynchronously writing to streams.
//
// The function takes the following parameters:
//
//   - offset which subsection starts at.
//   - length of subsection.
//
// The function returns the following values:
//
//   - ret: new #GBytes.
func (bytes *Bytes) NewFromBytes(offset uint, length uint) *Bytes {
	var _arg0 *C.GBytes // out
	var _arg1 C.gsize   // out
	var _arg2 C.gsize   // out
	var _cret *C.GBytes // in

	_arg0 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	_arg1 = C.gsize(offset)
	_arg2 = C.gsize(length)

	_cret = C.g_bytes_new_from_bytes(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(length)

	var _ret *Bytes // out

	_ret = (*Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _ret
}

// Checksum: GLib provides a generic API for computing checksums (or ‘digests’)
// for a sequence of arbitrary bytes, using various hashing algorithms like MD5,
// SHA-1 and SHA-256. Checksums are commonly used in various environments and
// specifications.
//
// To create a new GChecksum, use glib.Checksum.New. To free a GChecksum,
// use glib.Checksum.Free().
//
// GLib supports incremental checksums using the GChecksum data structure,
// by calling glib.Checksum.Update() as long as there’s data available and
// then using glib.Checksum.GetString() or glib.Checksum.GetDigest() to
// compute the checksum and return it either as a string in hexadecimal form,
// or as a raw sequence of bytes. To compute the checksum for binary blobs
// and nul-terminated strings in one go, use the convenience functions
// glib.ComputeChecksumForData() and glib.ComputeChecksumForString(),
// respectively.
//
// An instance of this type is always passed by reference.
type Checksum struct {
	*checksum
}

// checksum is the struct that's finalized.
type checksum struct {
	native *C.GChecksum
}

func marshalChecksum(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Checksum{&checksum{(*C.GChecksum)(b)}}, nil
}

// NewChecksum constructs a struct Checksum.
func NewChecksum(checksumType ChecksumType) *Checksum {
	var _arg1 C.GChecksumType // out
	var _cret *C.GChecksum    // in

	_arg1 = C.GChecksumType(checksumType)

	_cret = C.g_checksum_new(_arg1)
	runtime.KeepAlive(checksumType)

	var _checksum *Checksum // out

	if _cret != nil {
		_checksum = (*Checksum)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_checksum)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_checksum_free((*C.GChecksum)(intern.C))
			},
		)
	}

	return _checksum
}

// Copy copies a #GChecksum. If checksum has been closed, by calling
// g_checksum_get_string() or g_checksum_get_digest(), the copied checksum will
// be closed as well.
//
// The function returns the following values:
//
//   - ret: copy of the passed #GChecksum. Use g_checksum_free() when finished
//     using it.
func (checksum *Checksum) Copy() *Checksum {
	var _arg0 *C.GChecksum // out
	var _cret *C.GChecksum // in

	_arg0 = (*C.GChecksum)(gextras.StructNative(unsafe.Pointer(checksum)))

	_cret = C.g_checksum_copy(_arg0)
	runtime.KeepAlive(checksum)

	var _ret *Checksum // out

	_ret = (*Checksum)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_checksum_free((*C.GChecksum)(intern.C))
		},
	)

	return _ret
}

// String gets the digest as a hexadecimal string.
//
// Once this function has been called the #GChecksum can no longer be updated
// with g_checksum_update().
//
// The hexadecimal characters will be lower case.
//
// The function returns the following values:
//
//   - utf8: hexadecimal representation of the checksum. The returned string is
//     owned by the checksum and should not be modified or freed.
func (checksum *Checksum) String() string {
	var _arg0 *C.GChecksum // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GChecksum)(gextras.StructNative(unsafe.Pointer(checksum)))

	_cret = C.g_checksum_get_string(_arg0)
	runtime.KeepAlive(checksum)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Reset resets the state of the checksum back to its initial state.
func (checksum *Checksum) Reset() {
	var _arg0 *C.GChecksum // out

	_arg0 = (*C.GChecksum)(gextras.StructNative(unsafe.Pointer(checksum)))

	C.g_checksum_reset(_arg0)
	runtime.KeepAlive(checksum)
}

// Update feeds data into an existing #GChecksum. The checksum must still be
// open, that is g_checksum_get_string() or g_checksum_get_digest() must not
// have been called on checksum.
//
// The function takes the following parameters:
//
//   - data: buffer used to compute the checksum.
func (checksum *Checksum) Update(data []byte) {
	var _arg0 *C.GChecksum // out
	var _arg1 *C.guchar    // out
	var _arg2 C.gssize

	_arg0 = (*C.GChecksum)(gextras.StructNative(unsafe.Pointer(checksum)))
	_arg2 = (C.gssize)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))
	}

	C.g_checksum_update(_arg0, _arg1, _arg2)
	runtime.KeepAlive(checksum)
	runtime.KeepAlive(data)
}

// ChecksumTypeGetLength gets the length in bytes of digests of type
// checksum_type.
//
// The function takes the following parameters:
//
//   - checksumType: Type.
//
// The function returns the following values:
//
//   - gssize: checksum length, or -1 if checksum_type is not supported.
func ChecksumTypeGetLength(checksumType ChecksumType) int {
	var _arg1 C.GChecksumType // out
	var _cret C.gssize        // in

	_arg1 = C.GChecksumType(checksumType)

	_cret = C.g_checksum_type_get_length(_arg1)
	runtime.KeepAlive(checksumType)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// Completion: GCompletion provides support for automatic completion of a
// string using any group of target strings. It is typically used for file name
// completion as is common in many UNIX shells.
//
// A GCompletion is created using glib.Completion().New. Target items are added
// and removed with glib.Completion.AddItems(), glib.Completion.RemoveItems()
// and glib.Completion.ClearItems(). A completion attempt is requested with
// glib.Completion.Complete() or glib.Completion.CompleteUTF8(). When no longer
// needed, the GCompletion is freed with glib.Completion.Free().
//
// Items in the completion can be simple strings (e.g. filenames),
// or pointers to arbitrary data structures. If data structures are used you
// must provide a glib.CompletionFunc in glib.Completion().New, which retrieves
// the item’s string from the data structure. You can change the way in which
// strings are compared by setting a different glib.CompletionStrncmpFunc in
// glib.Completion.SetCompare().
//
// GCompletion has been marked as deprecated, since this API is rarely used and
// not very actively maintained.
//
// Deprecated: Rarely used API.
//
// An instance of this type is always passed by reference.
type Completion struct {
	*completion
}

// completion is the struct that's finalized.
type completion struct {
	native *C.GCompletion
}

// ClearItems removes all items from the #GCompletion. The items are not freed,
// so if the memory was dynamically allocated, it should be freed after calling
// this function.
//
// Deprecated: Rarely used API.
func (cmp *Completion) ClearItems() {
	var _arg0 *C.GCompletion // out

	_arg0 = (*C.GCompletion)(gextras.StructNative(unsafe.Pointer(cmp)))

	C.g_completion_clear_items(_arg0)
	runtime.KeepAlive(cmp)
}

// DateTime: GDateTime is a structure that combines a Gregorian date and time
// into a single structure.
//
// GDateTime provides many conversion and methods to manipulate dates and times.
// Time precision is provided down to microseconds and the time can range
// (proleptically) from 0001-01-01 00:00:00 to 9999-12-31 23:59:59.999999.
// GDateTime follows POSIX time in the sense that it is oblivious to leap
// seconds.
//
// GDateTime is an immutable object; once it has been created it cannot be
// modified further. All modifiers will create a new GDateTime. Nearly all such
// functions can fail due to the date or time going out of range, in which case
// NULL will be returned.
//
// GDateTime is reference counted: the reference count is increased by calling
// glib.DateTime.Ref() and decreased by calling glib.DateTime.Unref().
// When the reference count drops to 0, the resources allocated by the GDateTime
// structure are released.
//
// Many parts of the API may produce non-obvious results. As an example,
// adding two months to January 31st will yield March 31st whereas adding one
// month and then one month again will yield either March 28th or March 29th.
// Also note that adding 24 hours is not always the same as adding one day
// (since days containing daylight savings time transitions are either 23 or 25
// hours in length).
//
// An instance of this type is always passed by reference.
type DateTime struct {
	*dateTime
}

// dateTime is the struct that's finalized.
type dateTime struct {
	native *C.GDateTime
}

func marshalDateTime(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DateTime{&dateTime{(*C.GDateTime)(b)}}, nil
}

// NewDateTime constructs a struct DateTime.
func NewDateTime(tz *TimeZone, year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var _arg1 *C.GTimeZone // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out
	var _arg5 C.gint       // out
	var _arg6 C.gint       // out
	var _arg7 C.gdouble    // out
	var _cret *C.GDateTime // in

	_arg1 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))
	_arg2 = C.gint(year)
	_arg3 = C.gint(month)
	_arg4 = C.gint(day)
	_arg5 = C.gint(hour)
	_arg6 = C.gint(minute)
	_arg7 = C.gdouble(seconds)

	_cret = C.g_date_time_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromISO8601 constructs a struct DateTime.
func NewDateTimeFromISO8601(text string, defaultTz *TimeZone) *DateTime {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GTimeZone // out
	var _cret *C.GDateTime // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	if defaultTz != nil {
		_arg2 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(defaultTz)))
	}

	_cret = C.g_date_time_new_from_iso8601(_arg1, _arg2)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultTz)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromTimevalLocal constructs a struct DateTime.
func NewDateTimeFromTimevalLocal(tv *TimeVal) *DateTime {
	var _arg1 *C.GTimeVal  // out
	var _cret *C.GDateTime // in

	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(tv)))

	_cret = C.g_date_time_new_from_timeval_local(_arg1)
	runtime.KeepAlive(tv)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromTimevalUTC constructs a struct DateTime.
func NewDateTimeFromTimevalUTC(tv *TimeVal) *DateTime {
	var _arg1 *C.GTimeVal  // out
	var _cret *C.GDateTime // in

	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(tv)))

	_cret = C.g_date_time_new_from_timeval_utc(_arg1)
	runtime.KeepAlive(tv)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixLocal constructs a struct DateTime.
func NewDateTimeFromUnixLocal(t int64) *DateTime {
	var _arg1 C.gint64     // out
	var _cret *C.GDateTime // in

	_arg1 = C.gint64(t)

	_cret = C.g_date_time_new_from_unix_local(_arg1)
	runtime.KeepAlive(t)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixLocalUsec constructs a struct DateTime.
func NewDateTimeFromUnixLocalUsec(usecs int64) *DateTime {
	var _arg1 C.gint64     // out
	var _cret *C.GDateTime // in

	_arg1 = C.gint64(usecs)

	_cret = C.g_date_time_new_from_unix_local_usec(_arg1)
	runtime.KeepAlive(usecs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixUTC constructs a struct DateTime.
func NewDateTimeFromUnixUTC(t int64) *DateTime {
	var _arg1 C.gint64     // out
	var _cret *C.GDateTime // in

	_arg1 = C.gint64(t)

	_cret = C.g_date_time_new_from_unix_utc(_arg1)
	runtime.KeepAlive(t)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixUTCUsec constructs a struct DateTime.
func NewDateTimeFromUnixUTCUsec(usecs int64) *DateTime {
	var _arg1 C.gint64     // out
	var _cret *C.GDateTime // in

	_arg1 = C.gint64(usecs)

	_cret = C.g_date_time_new_from_unix_utc_usec(_arg1)
	runtime.KeepAlive(usecs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeLocal constructs a struct DateTime.
func NewDateTimeLocal(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out
	var _arg5 C.gint       // out
	var _arg6 C.gdouble    // out
	var _cret *C.GDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)
	_arg3 = C.gint(day)
	_arg4 = C.gint(hour)
	_arg5 = C.gint(minute)
	_arg6 = C.gdouble(seconds)

	_cret = C.g_date_time_new_local(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeNow constructs a struct DateTime.
func NewDateTimeNow(tz *TimeZone) *DateTime {
	var _arg1 *C.GTimeZone // out
	var _cret *C.GDateTime // in

	_arg1 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))

	_cret = C.g_date_time_new_now(_arg1)
	runtime.KeepAlive(tz)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeNowLocal constructs a struct DateTime.
func NewDateTimeNowLocal() *DateTime {
	var _cret *C.GDateTime // in

	_cret = C.g_date_time_new_now_local()

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeNowUTC constructs a struct DateTime.
func NewDateTimeNowUTC() *DateTime {
	var _cret *C.GDateTime // in

	_cret = C.g_date_time_new_now_utc()

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeUTC constructs a struct DateTime.
func NewDateTimeUTC(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out
	var _arg5 C.gint       // out
	var _arg6 C.gdouble    // out
	var _cret *C.GDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)
	_arg3 = C.gint(day)
	_arg4 = C.gint(hour)
	_arg5 = C.gint(minute)
	_arg6 = C.gdouble(seconds)

	_cret = C.g_date_time_new_utc(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// Add creates a copy of datetime and adds the specified timespan to the copy.
//
// The function takes the following parameters:
//
//   - timespan: Span.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) Add(timespan TimeSpan) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.GTimeSpan  // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.GTimeSpan(timespan)

	_cret = C.g_date_time_add(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(timespan)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddDays creates a copy of datetime and adds the specified number of days to
// the copy. Add negative values to subtract days.
//
// The function takes the following parameters:
//
//   - days: number of days.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddDays(days int) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gint(days)

	_cret = C.g_date_time_add_days(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(days)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddFull creates a new Time adding the specified values to the current date
// and time in datetime. Add negative values to subtract.
//
// The function takes the following parameters:
//
//   - years: number of years to add.
//   - months: number of months to add.
//   - days: number of days to add.
//   - hours: number of hours to add.
//   - minutes: number of minutes to add.
//   - seconds: number of seconds to add.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddFull(years int, months int, days int, hours int, minutes int, seconds float64) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out
	var _arg5 C.gint       // out
	var _arg6 C.gdouble    // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gint(years)
	_arg2 = C.gint(months)
	_arg3 = C.gint(days)
	_arg4 = C.gint(hours)
	_arg5 = C.gint(minutes)
	_arg6 = C.gdouble(seconds)

	_cret = C.g_date_time_add_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(years)
	runtime.KeepAlive(months)
	runtime.KeepAlive(days)
	runtime.KeepAlive(hours)
	runtime.KeepAlive(minutes)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddHours creates a copy of datetime and adds the specified number of hours.
// Add negative values to subtract hours.
//
// The function takes the following parameters:
//
//   - hours: number of hours to add.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddHours(hours int) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gint(hours)

	_cret = C.g_date_time_add_hours(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(hours)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddMinutes creates a copy of datetime adding the specified number of minutes.
// Add negative values to subtract minutes.
//
// The function takes the following parameters:
//
//   - minutes: number of minutes to add.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddMinutes(minutes int) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gint(minutes)

	_cret = C.g_date_time_add_minutes(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(minutes)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddMonths creates a copy of datetime and adds the specified number of months
// to the copy. Add negative values to subtract months.
//
// The day of the month of the resulting Time is clamped to the number of
// days in the updated calendar month. For example, if adding 1 month to 31st
// January 2018, the result would be 28th February 2018. In 2020 (a leap year),
// the result would be 29th February.
//
// The function takes the following parameters:
//
//   - months: number of months.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddMonths(months int) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gint(months)

	_cret = C.g_date_time_add_months(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(months)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddSeconds creates a copy of datetime and adds the specified number of
// seconds. Add negative values to subtract seconds.
//
// The function takes the following parameters:
//
//   - seconds: number of seconds to add.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddSeconds(seconds float64) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gdouble    // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gdouble(seconds)

	_cret = C.g_date_time_add_seconds(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddWeeks creates a copy of datetime and adds the specified number of weeks to
// the copy. Add negative values to subtract weeks.
//
// The function takes the following parameters:
//
//   - weeks: number of weeks.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddWeeks(weeks int) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gint(weeks)

	_cret = C.g_date_time_add_weeks(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(weeks)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// AddYears creates a copy of datetime and adds the specified number of years to
// the copy. Add negative values to subtract years.
//
// As with g_date_time_add_months(), if the resulting date would be 29th
// February on a non-leap year, the day will be clamped to 28th February.
//
// The function takes the following parameters:
//
//   - years: number of years.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) AddYears(years int) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = C.gint(years)

	_cret = C.g_date_time_add_years(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(years)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// Compare: comparison function for Times that is suitable as a Func. Both Times
// must be non-NULL.
//
// The function takes the following parameters:
//
//   - dt2: second Time to compare.
//
// The function returns the following values:
//
//   - gint: -1, 0 or 1 if dt1 is less than, equal to or greater than dt2.
func (dt1 *DateTime) Compare(dt2 *DateTime) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(dt1)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(dt2)))

	_cret = C.g_date_time_compare(_arg0, _arg1)
	runtime.KeepAlive(dt1)
	runtime.KeepAlive(dt2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Difference calculates the difference in time between end and begin. The
// Span that is returned is effectively end - begin (ie: positive if the first
// parameter is larger).
//
// The function takes the following parameters:
//
//   - begin: Time.
//
// The function returns the following values:
//
//   - timeSpan: difference between the two Time, as a time span expressed in
//     microseconds.
func (end *DateTime) Difference(begin *DateTime) TimeSpan {
	var _arg0 *C.GDateTime // out
	var _arg1 *C.GDateTime // out
	var _cret C.GTimeSpan  // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(end)))
	_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(begin)))

	_cret = C.g_date_time_difference(_arg0, _arg1)
	runtime.KeepAlive(end)
	runtime.KeepAlive(begin)

	var _timeSpan TimeSpan // out

	_timeSpan = TimeSpan(_cret)

	return _timeSpan
}

// Equal checks to see if dt1 and dt2 are equal.
//
// Equal here means that they represent the same moment after converting them to
// the same time zone.
//
// The function takes the following parameters:
//
//   - dt2: Time.
//
// The function returns the following values:
//
//   - ok: TRUE if dt1 and dt2 are equal.
func (dt1 *DateTime) Equal(dt2 *DateTime) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(dt1)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(dt2)))

	_cret = C.g_date_time_equal(_arg0, _arg1)
	runtime.KeepAlive(dt1)
	runtime.KeepAlive(dt2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Format creates a newly allocated string representing the requested format.
//
// The format strings understood by this function are a subset of the strftime()
// format language as specified by C99. The D, U and W conversions are not
// supported, nor is the E modifier. The GNU extensions k, l, s and P are
// supported, however, as are the 0, _ and - modifiers. The Python extension f
// is also supported.
//
// In contrast to strftime(), this function always produces a UTF-8 string,
// regardless of the current locale. Note that the rendering of many formats is
// locale-dependent and may not match the strftime() output exactly.
//
// The following format specifiers are supported:
//
// - a: the abbreviated weekday name according to the current locale
//
// - A: the full weekday name according to the current locale
//
// - b: the abbreviated month name according to the current locale
//
// - B: the full month name according to the current locale
//
// - c: the preferred date and time representation for the current locale
//
// - C: the century number (year/100) as a 2-digit integer (00-99)
//
// - d: the day of the month as a decimal number (range 01 to 31)
//
// - e: the day of the month as a decimal number (range 1 to 31); single digits
// are preceded by a figure space (U+2007)
//
// - F: equivalent to Y-m-d (the ISO 8601 date format)
//
// - g: the last two digits of the ISO 8601 week-based year as a decimal number
// (00-99). This works well with V and u.
//
// - G: the ISO 8601 week-based year as a decimal number. This works well with V
// and u.
//
// - h: equivalent to b
//
// - H: the hour as a decimal number using a 24-hour clock (range 00 to 23)
//
// - I: the hour as a decimal number using a 12-hour clock (range 01 to 12)
//
// - j: the day of the year as a decimal number (range 001 to 366)
//
// - k: the hour (24-hour clock) as a decimal number (range 0 to 23); single
// digits are preceded by a figure space (U+2007)
//
// - l: the hour (12-hour clock) as a decimal number (range 1 to 12); single
// digits are preceded by a figure space (U+2007)
//
// - m: the month as a decimal number (range 01 to 12)
//
// - M: the minute as a decimal number (range 00 to 59)
//
// - f: the microsecond as a decimal number (range 000000 to 999999)
//
// - p: either ‘AM’ or ‘PM’ according to the given time value, or the
// corresponding strings for the current locale. Noon is treated as ‘PM’ and
// midnight as ‘AM’. Use of this format specifier is discouraged, as many
// locales have no concept of AM/PM formatting. Use c or X instead.
//
// - P: like p but lowercase: ‘am’ or ‘pm’ or a corresponding string for the
// current locale. Use of this format specifier is discouraged, as many locales
// have no concept of AM/PM formatting. Use c or X instead.
//
// - r: the time in a.m. or p.m. notation. Use of this format specifier is
// discouraged, as many locales have no concept of AM/PM formatting. Use c or X
// instead.
//
// - R: the time in 24-hour notation (H:M)
//
// - s: the number of seconds since the Epoch, that is, since 1970-01-01
// 00:00:00 UTC
//
// - S: the second as a decimal number (range 00 to 60)
//
// - t: a tab character
//
// - T: the time in 24-hour notation with seconds (H:M:S)
//
// - u: the ISO 8601 standard day of the week as a decimal, range 1 to 7,
// Monday being 1. This works well with G and V.
//
// - V: the ISO 8601 standard week number of the current year as a decimal
// number, range 01 to 53, where week 1 is the first week that has at least 4
// days in the new year. See g_date_time_get_week_of_year(). This works well
// with G and u.
//
// - w: the day of the week as a decimal, range 0 to 6, Sunday being 0. This is
// not the ISO 8601 standard format — use u instead.
//
// - x: the preferred date representation for the current locale without the
// time
//
// - X: the preferred time representation for the current locale without the
// date
//
// - y: the year as a decimal number without the century
//
// - Y: the year as a decimal number including the century
//
// - z: the time zone as an offset from UTC (+hhmm)
//
// - %:z: the time zone as an offset from UTC (+hh:mm). This is a gnulib
// strftime() extension. Since: 2.38
//
// - %::z: the time zone as an offset from UTC (+hh:mm:ss). This is a gnulib
// strftime() extension. Since: 2.38
//
// - %:::z: the time zone as an offset from UTC, with : to necessary precision
// (e.g., -04, +05:30). This is a gnulib strftime() extension. Since: 2.38
//
// - Z: the time zone or name or abbreviation
//
// - %%: a literal % character
//
// Some conversion specifications can be modified by preceding the conversion
// specifier by one or more modifier characters.
//
// The following modifiers are supported for many of the numeric conversions:
//
// - O: Use alternative numeric symbols, if the current locale supports those.
//
// - _: Pad a numeric result with spaces. This overrides the default padding for
// the specifier.
//
// - -: Do not pad a numeric result. This overrides the default padding for the
// specifier.
//
// - 0: Pad a numeric result with zeros. This overrides the default padding for
// the specifier.
//
// The following modifiers are supported for many of the alphabetic conversions:
//
// - ^: Use upper case if possible. This is a gnulib strftime() extension.
// Since: 2.80
//
// - #: Use opposite case if possible. This is a gnulib strftime() extension.
// Since: 2.80
//
// Additionally, when O is used with B, b, or h, it produces the alternative
// form of a month name. The alternative form should be used when the month
// name is used without a day number (e.g., standalone). It is required in some
// languages (Baltic, Slavic, Greek, and more) due to their grammatical rules.
// For other languages there is no difference. OB is a GNU and BSD strftime()
// extension expected to be added to the future POSIX specification, Ob and Oh
// are GNU strftime() extensions. Since: 2.56
//
// Since GLib 2.80, when E is used with c, C, x, X, y or Y, the date is
// formatted using an alternate era representation specific to the locale.
// This is typically used for the Thai solar calendar or Japanese era names,
// for example.
//
// - Ec: the preferred date and time representation for the current locale,
// using the alternate era representation
//
// - EC: the name of the era
//
// - Ex: the preferred date representation for the current locale without the
// time, using the alternate era representation
//
// - EX: the preferred time representation for the current locale without the
// date, using the alternate era representation
//
// - Ey: the year since the beginning of the era denoted by the EC specifier
//
// - EY: the full alternative year representation.
//
// The function takes the following parameters:
//
//   - format: valid UTF-8 string, containing the format for the Time.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string formatted to the requested format
//     or NULL in the case that there was an error (such as a format specifier
//     not being supported in the current locale). The string should be freed
//     with g_free().
func (datetime *DateTime) Format(format string) string {
	var _arg0 *C.GDateTime // out
	var _arg1 *C.gchar     // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(format)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_date_time_format(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(format)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FormatISO8601: format datetime in ISO 8601 format
// (https://en.wikipedia.org/wiki/ISO_8601), including the date, time and time
// zone, and return that as a UTF-8 encoded string.
//
// Since GLib 2.66, this will output to sub-second precision if needed.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string formatted in ISO 8601 format or
//     NULL in the case that there was an error. The string should be freed with
//     g_free().
func (datetime *DateTime) FormatISO8601() string {
	var _arg0 *C.GDateTime // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_format_iso8601(_arg0)
	runtime.KeepAlive(datetime)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// DayOfMonth retrieves the day of the month represented by datetime in the
// gregorian calendar.
//
// The function returns the following values:
//
//   - gint: day of the month.
func (datetime *DateTime) DayOfMonth() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_day_of_month(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DayOfWeek retrieves the ISO 8601 day of the week on which datetime falls (1
// is Monday, 2 is Tuesday... 7 is Sunday).
//
// The function returns the following values:
//
//   - gint: day of the week.
func (datetime *DateTime) DayOfWeek() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_day_of_week(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DayOfYear retrieves the day of the year represented by datetime in the
// Gregorian calendar.
//
// The function returns the following values:
//
//   - gint: day of the year.
func (datetime *DateTime) DayOfYear() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_day_of_year(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Hour retrieves the hour of the day represented by datetime.
//
// The function returns the following values:
//
//   - gint: hour of the day.
func (datetime *DateTime) Hour() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_hour(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Microsecond retrieves the microsecond of the date represented by datetime.
//
// The function returns the following values:
//
//   - gint: microsecond of the second.
func (datetime *DateTime) Microsecond() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_microsecond(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Minute retrieves the minute of the hour represented by datetime.
//
// The function returns the following values:
//
//   - gint: minute of the hour.
func (datetime *DateTime) Minute() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_minute(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Month retrieves the month of the year represented by datetime in the
// Gregorian calendar.
//
// The function returns the following values:
//
//   - gint: month represented by datetime.
func (datetime *DateTime) Month() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_month(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Second retrieves the second of the minute represented by datetime.
//
// The function returns the following values:
//
//   - gint: second represented by datetime.
func (datetime *DateTime) Second() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_second(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Seconds retrieves the number of seconds since the start of the last minute,
// including the fractional part.
//
// The function returns the following values:
//
//   - gdouble: number of seconds.
func (datetime *DateTime) Seconds() float64 {
	var _arg0 *C.GDateTime // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_seconds(_arg0)
	runtime.KeepAlive(datetime)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Timezone: get the time zone for this datetime.
//
// The function returns the following values:
//
//   - timeZone: time zone.
func (datetime *DateTime) Timezone() *TimeZone {
	var _arg0 *C.GDateTime // out
	var _cret *C.GTimeZone // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_timezone(_arg0)
	runtime.KeepAlive(datetime)

	var _timeZone *TimeZone // out

	_timeZone = (*TimeZone)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_time_zone_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_timeZone)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_time_zone_unref((*C.GTimeZone)(intern.C))
		},
	)

	return _timeZone
}

// TimezoneAbbreviation determines the time zone abbreviation to be used at the
// time and in the time zone of datetime.
//
// For example, in Toronto this is currently "EST" during the winter months and
// "EDT" during the summer months when daylight savings time is in effect.
//
// The function returns the following values:
//
//   - utf8: time zone abbreviation. The returned string is owned by the Time
//     and it should not be modified or freed.
func (datetime *DateTime) TimezoneAbbreviation() string {
	var _arg0 *C.GDateTime // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_timezone_abbreviation(_arg0)
	runtime.KeepAlive(datetime)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UTCOffset determines the offset to UTC in effect at the time and in the time
// zone of datetime.
//
// The offset is the number of microseconds that you add to UTC time to arrive
// at local time for the time zone (ie: negative numbers for time zones west of
// GMT, positive numbers for east).
//
// If datetime represents UTC time, then the offset is always zero.
//
// The function returns the following values:
//
//   - timeSpan: number of microseconds that should be added to UTC to get the
//     local time.
func (datetime *DateTime) UTCOffset() TimeSpan {
	var _arg0 *C.GDateTime // out
	var _cret C.GTimeSpan  // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_utc_offset(_arg0)
	runtime.KeepAlive(datetime)

	var _timeSpan TimeSpan // out

	_timeSpan = TimeSpan(_cret)

	return _timeSpan
}

// WeekNumberingYear returns the ISO 8601 week-numbering year in which the week
// containing datetime falls.
//
// This function, taken together with g_date_time_get_week_of_year() and
// g_date_time_get_day_of_week() can be used to determine the full ISO week date
// on which datetime falls.
//
// This is usually equal to the normal Gregorian year (as returned by
// g_date_time_get_year()), except as detailed below:
//
// For Thursday, the week-numbering year is always equal to the usual calendar
// year. For other days, the number is such that every day within a complete
// week (Monday to Sunday) is contained within the same week-numbering year.
//
// For Monday, Tuesday and Wednesday occurring near the end of the year,
// this may mean that the week-numbering year is one greater than the calendar
// year (so that these days have the same week-numbering year as the Thursday
// occurring early in the next year).
//
// For Friday, Saturday and Sunday occurring near the start of the year, this
// may mean that the week-numbering year is one less than the calendar year (so
// that these days have the same week-numbering year as the Thursday occurring
// late in the previous year).
//
// An equivalent description is that the week-numbering year is equal to the
// calendar year containing the majority of the days in the current week (Monday
// to Sunday).
//
// Note that January 1 0001 in the proleptic Gregorian calendar is a Monday,
// so this function never returns 0.
//
// The function returns the following values:
//
//   - gint: ISO 8601 week-numbering year for datetime.
func (datetime *DateTime) WeekNumberingYear() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_week_numbering_year(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// WeekOfYear returns the ISO 8601 week number for the week containing datetime.
// The ISO 8601 week number is the same for every day of the week (from Moday
// through Sunday). That can produce some unusual results (described below).
//
// The first week of the year is week 1. This is the week that contains the
// first Thursday of the year. Equivalently, this is the first week that has
// more than 4 of its days falling within the calendar year.
//
// The value 0 is never returned by this function. Days contained within a year
// but occurring before the first ISO 8601 week of that year are considered as
// being contained in the last week of the previous year. Similarly, the final
// days of a calendar year may be considered as being part of the first ISO 8601
// week of the next year if 4 or more days of that week are contained within the
// new year.
//
// The function returns the following values:
//
//   - gint: ISO 8601 week number for datetime.
func (datetime *DateTime) WeekOfYear() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_week_of_year(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Year retrieves the year represented by datetime in the Gregorian calendar.
//
// The function returns the following values:
//
//   - gint: year represented by datetime.
func (datetime *DateTime) Year() int {
	var _arg0 *C.GDateTime // out
	var _cret C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_get_year(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Ymd retrieves the Gregorian day, month, and year of a given Time.
//
// The function returns the following values:
//
//   - year (optional): return location for the gregorian year, or NULL.
//   - month (optional): return location for the month of the year, or NULL.
//   - day (optional): return location for the day of the month, or NULL.
func (datetime *DateTime) Ymd() (year int, month int, day int) {
	var _arg0 *C.GDateTime // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	C.g_date_time_get_ymd(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(datetime)

	var _year int  // out
	var _month int // out
	var _day int   // out

	_year = int(_arg1)
	_month = int(_arg2)
	_day = int(_arg3)

	return _year, _month, _day
}

// Hash hashes datetime into a #guint, suitable for use within Table.
//
// The function returns the following values:
//
//   - guint containing the hash.
func (datetime *DateTime) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_hash(_arg0)
	runtime.KeepAlive(datetime)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsDaylightSavings determines if daylight savings time is in effect at the
// time and in the time zone of datetime.
//
// The function returns the following values:
//
//   - ok: TRUE if daylight savings time is in effect.
func (datetime *DateTime) IsDaylightSavings() bool {
	var _arg0 *C.GDateTime // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_is_daylight_savings(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToLocal creates a new Time corresponding to the same instant in time as
// datetime, but in the local time zone.
//
// This call is equivalent to calling g_date_time_to_timezone() with the time
// zone returned by g_time_zone_new_local().
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) ToLocal() *DateTime {
	var _arg0 *C.GDateTime // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_to_local(_arg0)
	runtime.KeepAlive(datetime)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// ToTimeval stores the instant in time that datetime represents into tv.
//
// The time contained in a Val is always stored in the form of seconds elapsed
// since 1970-01-01 00:00:00 UTC, regardless of the time zone associated with
// datetime.
//
// On systems where 'long' is 32bit (ie: all 32bit systems and all Windows
// systems), a Val is incapable of storing the entire range of values that Time
// is capable of expressing. On those systems, this function returns FALSE to
// indicate that the time is out of range.
//
// On systems where 'long' is 64bit, this function never fails.
//
// Deprecated: Val is not year-2038-safe. Use g_date_time_to_unix() instead.
//
// The function takes the following parameters:
//
//   - tv to modify.
//
// The function returns the following values:
//
//   - ok: TRUE if successful, else FALSE.
func (datetime *DateTime) ToTimeval(tv *TimeVal) bool {
	var _arg0 *C.GDateTime // out
	var _arg1 *C.GTimeVal  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(tv)))

	_cret = C.g_date_time_to_timeval(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(tv)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToTimezone: create a new Time corresponding to the same instant in time as
// datetime, but in the time zone tz.
//
// This call can fail in the case that the time goes out of bounds. For example,
// converting 0001-01-01 00:00:00 UTC to a time zone west of Greenwich will fail
// (due to the year 0 being out of range).
//
// The function takes the following parameters:
//
//   - tz: new Zone.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) ToTimezone(tz *TimeZone) *DateTime {
	var _arg0 *C.GDateTime // out
	var _arg1 *C.GTimeZone // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))
	_arg1 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))

	_cret = C.g_date_time_to_timezone(_arg0, _arg1)
	runtime.KeepAlive(datetime)
	runtime.KeepAlive(tz)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// ToUnix gives the Unix time corresponding to datetime, rounding down to the
// nearest second.
//
// Unix time is the number of seconds that have elapsed since 1970-01-01
// 00:00:00 UTC, regardless of the time zone associated with datetime.
//
// The function returns the following values:
//
//   - gint64: unix time corresponding to datetime.
func (datetime *DateTime) ToUnix() int64 {
	var _arg0 *C.GDateTime // out
	var _cret C.gint64     // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_to_unix(_arg0)
	runtime.KeepAlive(datetime)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ToUnixUsec gives the Unix time corresponding to datetime, in microseconds.
//
// Unix time is the number of microseconds that have elapsed since 1970-01-01
// 00:00:00 UTC, regardless of the time zone associated with datetime.
//
// The function returns the following values:
//
//   - gint64: unix time corresponding to datetime.
func (datetime *DateTime) ToUnixUsec() int64 {
	var _arg0 *C.GDateTime // out
	var _cret C.gint64     // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_to_unix_usec(_arg0)
	runtime.KeepAlive(datetime)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ToUTC creates a new Time corresponding to the same instant in time as
// datetime, but in UTC.
//
// This call is equivalent to calling g_date_time_to_timezone() with the time
// zone returned by g_time_zone_new_utc().
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time which should be freed with
//     g_date_time_unref(), or NULL.
func (datetime *DateTime) ToUTC() *DateTime {
	var _arg0 *C.GDateTime // out
	var _cret *C.GDateTime // in

	_arg0 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.g_date_time_to_utc(_arg0)
	runtime.KeepAlive(datetime)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// DebugKey associates a string with a bit flag. Used in g_parse_debug_string().
//
// An instance of this type is always passed by reference.
type DebugKey struct {
	*debugKey
}

// debugKey is the struct that's finalized.
type debugKey struct {
	native *C.GDebugKey
}

// Key: string.
func (d *DebugKey) Key() string {
	valptr := &d.native.key
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Value: flag.
func (d *DebugKey) Value() uint {
	valptr := &d.native.value
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Value: flag.
func (d *DebugKey) SetValue(value uint) {
	valptr := &d.native.value
	*valptr = C.guint(value)
}

// Dir: opaque structure representing an opened directory.
//
// An instance of this type is always passed by reference.
type Dir struct {
	*dir
}

// dir is the struct that's finalized.
type dir struct {
	native *C.GDir
}

func marshalDir(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Dir{&dir{(*C.GDir)(b)}}, nil
}

// NewDirOpen constructs a struct Dir.
func NewDirOpen(path string, flags uint) (*Dir, error) {
	var _arg1 *C.gchar  // out
	var _arg2 C.guint   // out
	var _cret *C.GDir   // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(flags)

	_cret = C.g_dir_open(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(flags)

	var _dir *Dir    // out
	var _goerr error // out

	_dir = (*Dir)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dir)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_dir_unref((*C.GDir)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dir, _goerr
}

// Close closes the directory immediately and decrements the reference count.
//
// Once the reference count reaches zero, the GDir structure itself will be
// freed. Prior to GLib 2.80, GDir was not reference counted.
//
// It is an error to call any of the GDir methods other than glib.Dir.Ref() and
// glib.Dir.Unref() on a GDir after calling glib.Dir.Close() on it.
func (dir *Dir) Close() {
	var _arg0 *C.GDir // out

	_arg0 = (*C.GDir)(gextras.StructNative(unsafe.Pointer(dir)))

	C.g_dir_close(_arg0)
	runtime.KeepAlive(dir)
}

// ReadName retrieves the name of another entry in the directory, or NULL.
// The order of entries returned from this function is not defined, and may vary
// by file system or other operating-system dependent factors.
//
// NULL may also be returned in case of errors. On Unix, you can check errno to
// find out if NULL was returned because of an error.
//
// On Unix, the '.' and '..' entries are omitted, and the returned name is in
// the on-disk encoding.
//
// On Windows, as is true of all GLib functions which operate on filenames,
// the returned name is in UTF-8.
//
// The function returns the following values:
//
//   - filename entry's name or NULL if there are no more entries. The return
//     value is owned by GLib and must not be modified or freed.
func (dir *Dir) ReadName() string {
	var _arg0 *C.GDir  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GDir)(gextras.StructNative(unsafe.Pointer(dir)))

	_cret = C.g_dir_read_name(_arg0)
	runtime.KeepAlive(dir)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Rewind resets the given directory. The next call to g_dir_read_name() will
// return the first entry again.
func (dir *Dir) Rewind() {
	var _arg0 *C.GDir // out

	_arg0 = (*C.GDir)(gextras.StructNative(unsafe.Pointer(dir)))

	C.g_dir_rewind(_arg0)
	runtime.KeepAlive(dir)
}

// DirMakeTmp creates a subdirectory in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is NULL, a default template is used.
//
// Note that in contrast to g_mkdtemp() (and mkdtemp()) tmpl is not modified,
// and might thus be a read-only literal string.
//
// The function takes the following parameters:
//
//   - tmpl (optional): template for directory name, as in g_mkdtemp(), basename
//     only, or NULL for a default template.
//
// The function returns the following values:
//
//   - filename: actual name used. This string should be freed with g_free()
//     when not needed any longer and is is in the GLib file name encoding.
//     In case of errors, NULL is returned and error will be set.
func DirMakeTmp(tmpl string) (string, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	if tmpl != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_dir_make_tmp(_arg1, &_cerr)
	runtime.KeepAlive(tmpl)

	var _filename string // out
	var _goerr error     // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _filename, _goerr
}

// HashTable struct is an opaque data structure to represent a [Hash
// Table][glib-Hash-Tables]. It should only be accessed via the following
// functions.
//
// An instance of this type is always passed by reference.
type HashTable struct {
	*hashTable
}

// hashTable is the struct that's finalized.
type hashTable struct {
	native *C.GHashTable
}

func marshalHashTable(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &HashTable{&hashTable{(*C.GHashTable)(b)}}, nil
}

// HashTableAdd: this is a convenience function for using a Table as a set.
// It is equivalent to calling g_hash_table_replace() with key as both the key
// and the value.
//
// In particular, this means that if key already exists in the hash table,
// then the old copy of key in the hash table is freed and key replaces it in
// the table.
//
// When a hash table only ever contains keys that have themselves as the
// corresponding value it is able to be stored more efficiently. See the
// discussion in the section description.
//
// Starting from GLib 2.40, this function returns a boolean value to indicate
// whether the newly added value was already in the hash table or not.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to insert.
//
// The function returns the following values:
//
//   - ok: TRUE if the key did not exist yet.
func HashTableAdd(hashTable map[unsafe.Pointer]unsafe.Pointer, key unsafe.Pointer) bool {
	var _arg1 *C.GHashTable // out
	var _arg2 C.gpointer    // out
	var _cret C.gboolean    // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gpointer)(unsafe.Pointer(key))

	_cret = C.g_hash_table_add(_arg1, _arg2)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HashTableContains checks if key is in hash_table.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to check.
//
// The function returns the following values:
//
//   - ok: TRUE if key is in hash_table, FALSE otherwise.
func HashTableContains(hashTable map[unsafe.Pointer]unsafe.Pointer, key unsafe.Pointer) bool {
	var _arg1 *C.GHashTable   // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_hash_table_contains(_arg1, _arg2)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HashTableDestroy destroys all keys and values in the Table and decrements
// its reference count by 1. If keys and/or values are dynamically allocated,
// you should either free them first or create the Table with destroy notifiers
// using g_hash_table_new_full(). In the latter case the destroy functions you
// supplied will be called on all keys and values during the destruction phase.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
func HashTableDestroy(hashTable map[unsafe.Pointer]unsafe.Pointer) {
	var _arg1 *C.GHashTable // out

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)

	C.g_hash_table_destroy(_arg1)
	runtime.KeepAlive(hashTable)
}

// HashTableFind calls the given function for key/value pairs in the Table until
// predicate returns TRUE. The function is passed the key and value of each
// pair, and the given user_data parameter. The hash table may not be modified
// while iterating over it (you can't add/remove items).
//
// Note, that hash tables are really only optimized for forward lookups, i.e.
// g_hash_table_lookup(). So code that frequently issues g_hash_table_find()
// or g_hash_table_foreach() (e.g. in the order of once per every entry in
// a hash table) should probably be reworked to use additional or different
// data structures for reverse lookups (keep in mind that an O(n) find/foreach
// operation issued for all n values in a hash table ends up needing O(n*n)
// operations).
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - predicate: function to test the key/value pairs for a certain property.
//
// The function returns the following values:
//
//   - gpointer (optional): value of the first key/value pair is returned,
//     for which predicate evaluates to TRUE. If no pair with the requested
//     property is found, NULL is returned.
func HashTableFind(hashTable map[unsafe.Pointer]unsafe.Pointer, predicate HRFunc) unsafe.Pointer {
	var _arg1 *C.GHashTable // out
	var _arg2 C.GHRFunc     // out
	var _arg3 C.gpointer
	var _cret C.gpointer // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (*[0]byte)(C._gotk4_glib2_HRFunc)
	_arg3 = C.gpointer(gbox.Assign(predicate))
	defer gbox.Delete(uintptr(_arg3))

	_cret = C.g_hash_table_find(_arg1, _arg2, _arg3)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(predicate)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// HashTableForEach calls the given function for each of the key/value pairs
// in the Table. The function is passed the key and value of each pair,
// and the given user_data parameter. The hash table may not be modified while
// iterating over it (you can't add/remove items). To remove all items matching
// a predicate, use g_hash_table_foreach_remove().
//
// The order in which g_hash_table_foreach() iterates over the keys/values in
// the hash table is not defined.
//
// See g_hash_table_find() for performance caveats for linear order searches in
// contrast to g_hash_table_lookup().
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - fn: function to call for each key/value pair.
func HashTableForEach(hashTable map[unsafe.Pointer]unsafe.Pointer, fn HFunc) {
	var _arg1 *C.GHashTable // out
	var _arg2 C.GHFunc      // out
	var _arg3 C.gpointer

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (*[0]byte)(C._gotk4_glib2_HFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg3))

	C.g_hash_table_foreach(_arg1, _arg2, _arg3)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(fn)
}

// HashTableForEachRemove calls the given function for each key/value pair in
// the Table. If the function returns TRUE, then the key/value pair is removed
// from the Table. If you supplied key or value destroy functions when creating
// the Table, they are used to free the memory allocated for the removed keys
// and values.
//
// See TableIter for an alternative way to loop over the key/value pairs in the
// hash table.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - fn: function to call for each key/value pair.
//
// The function returns the following values:
//
//   - guint: number of key/value pairs removed.
func HashTableForEachRemove(hashTable map[unsafe.Pointer]unsafe.Pointer, fn HRFunc) uint {
	var _arg1 *C.GHashTable // out
	var _arg2 C.GHRFunc     // out
	var _arg3 C.gpointer
	var _cret C.guint // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (*[0]byte)(C._gotk4_glib2_HRFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg3))

	_cret = C.g_hash_table_foreach_remove(_arg1, _arg2, _arg3)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(fn)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// HashTableForEachSteal calls the given function for each key/value pair in the
// Table. If the function returns TRUE, then the key/value pair is removed from
// the Table, but no key or value destroy functions are called.
//
// See TableIter for an alternative way to loop over the key/value pairs in the
// hash table.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - fn: function to call for each key/value pair.
//
// The function returns the following values:
//
//   - guint: number of key/value pairs removed.
func HashTableForEachSteal(hashTable map[unsafe.Pointer]unsafe.Pointer, fn HRFunc) uint {
	var _arg1 *C.GHashTable // out
	var _arg2 C.GHRFunc     // out
	var _arg3 C.gpointer
	var _cret C.guint // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (*[0]byte)(C._gotk4_glib2_HRFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg3))

	_cret = C.g_hash_table_foreach_steal(_arg1, _arg2, _arg3)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(fn)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// HashTableInsert inserts a new key and value into a Table.
//
// If the key already exists in the Table its current value is replaced with the
// new value. If you supplied a value_destroy_func when creating the Table, the
// old value is freed using that function. If you supplied a key_destroy_func
// when creating the Table, the passed key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to indicate
// whether the newly added value was already in the hash table or not.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to insert.
//   - value (optional) to associate with the key.
//
// The function returns the following values:
//
//   - ok: TRUE if the key did not exist yet.
func HashTableInsert(hashTable map[unsafe.Pointer]unsafe.Pointer, key, value unsafe.Pointer) bool {
	var _arg1 *C.GHashTable // out
	var _arg2 C.gpointer    // out
	var _arg3 C.gpointer    // out
	var _cret C.gboolean    // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gpointer)(unsafe.Pointer(key))
	_arg3 = (C.gpointer)(unsafe.Pointer(value))

	_cret = C.g_hash_table_insert(_arg1, _arg2, _arg3)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HashTableLookup looks up a key in a Table. Note that this function
// cannot distinguish between a key that is not present and one which
// is present and has the value NULL. If you need this distinction, use
// g_hash_table_lookup_extended().
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to look up.
//
// The function returns the following values:
//
//   - gpointer (optional): associated value, or NULL if the key is not found.
func HashTableLookup(hashTable map[unsafe.Pointer]unsafe.Pointer, key unsafe.Pointer) unsafe.Pointer {
	var _arg1 *C.GHashTable   // out
	var _arg2 C.gconstpointer // out
	var _cret C.gpointer      // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_hash_table_lookup(_arg1, _arg2)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// HashTableLookupExtended looks up a key in the Table, returning the original
// key and the associated value and a #gboolean which is TRUE if the key was
// found. This is useful if you need to free the memory allocated for the
// original key, for example before calling g_hash_table_remove().
//
// You can actually pass NULL for lookup_key to test whether the NULL key
// exists, provided the hash and equal functions of hash_table are NULL-safe.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - lookupKey (optional): key to look up.
//
// The function returns the following values:
//
//   - origKey (optional): return location for the original key.
//   - value (optional): return location for the value associated with the key.
//   - ok: TRUE if the key was found in the Table.
func HashTableLookupExtended(hashTable map[unsafe.Pointer]unsafe.Pointer, lookupKey unsafe.Pointer) (origKey, value unsafe.Pointer, ok bool) {
	var _arg1 *C.GHashTable   // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gpointer      // in
	var _arg4 C.gpointer      // in
	var _cret C.gboolean      // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gconstpointer)(unsafe.Pointer(lookupKey))

	_cret = C.g_hash_table_lookup_extended(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(lookupKey)

	var _origKey unsafe.Pointer // out
	var _value unsafe.Pointer   // out
	var _ok bool                // out

	_origKey = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	_value = (unsafe.Pointer)(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _origKey, _value, _ok
}

// NewHashTableSimilar creates a new Table like g_hash_table_new_full() with a
// reference count of 1.
//
// It inherits the hash function, the key equal function, the key destroy
// function, as well as the value destroy function, from other_hash_table.
//
// The returned hash table will be empty; it will not contain the keys or values
// from other_hash_table.
//
// The function takes the following parameters:
//
//   - otherHashTable: another Table.
//
// The function returns the following values:
//
//   - hashTable: new Table.
func NewHashTableSimilar(otherHashTable map[unsafe.Pointer]unsafe.Pointer) map[unsafe.Pointer]unsafe.Pointer {
	var _arg1 *C.GHashTable // out
	var _cret *C.GHashTable // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range otherHashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)

	_cret = C.g_hash_table_new_similar(_arg1)
	runtime.KeepAlive(otherHashTable)

	var _hashTable map[unsafe.Pointer]unsafe.Pointer // out

	_hashTable = make(map[unsafe.Pointer]unsafe.Pointer, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(*C.gpointer)(k)
		vsrc := *(*C.gpointer)(v)
		var kdst unsafe.Pointer // out
		var vdst unsafe.Pointer // out
		kdst = (unsafe.Pointer)(unsafe.Pointer(ksrc))
		vdst = (unsafe.Pointer)(unsafe.Pointer(vsrc))
		_hashTable[kdst] = vdst
	})

	return _hashTable
}

// HashTableRemoveAll removes all keys and their associated values from a Table.
//
// If the Table was created using g_hash_table_new_full(), the keys and values
// are freed using the supplied destroy functions, otherwise you have to make
// sure that any dynamically allocated values are freed yourself.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
func HashTableRemoveAll(hashTable map[unsafe.Pointer]unsafe.Pointer) {
	var _arg1 *C.GHashTable // out

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)

	C.g_hash_table_remove_all(_arg1)
	runtime.KeepAlive(hashTable)
}

// HashTableReplace inserts a new key and value into a Table similar
// to g_hash_table_insert(). The difference is that if the key already
// exists in the Table, it gets replaced by the new key. If you supplied a
// value_destroy_func when creating the Table, the old value is freed using
// that function. If you supplied a key_destroy_func when creating the Table,
// the old key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to indicate
// whether the newly added value was already in the hash table or not.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to insert.
//   - value (optional) to associate with the key.
//
// The function returns the following values:
//
//   - ok: TRUE if the key did not exist yet.
func HashTableReplace(hashTable map[unsafe.Pointer]unsafe.Pointer, key, value unsafe.Pointer) bool {
	var _arg1 *C.GHashTable // out
	var _arg2 C.gpointer    // out
	var _arg3 C.gpointer    // out
	var _cret C.gboolean    // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gpointer)(unsafe.Pointer(key))
	_arg3 = (C.gpointer)(unsafe.Pointer(value))

	_cret = C.g_hash_table_replace(_arg1, _arg2, _arg3)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HashTableSize returns the number of elements contained in the Table.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//
// The function returns the following values:
//
//   - guint: number of key/value pairs in the Table.
func HashTableSize(hashTable map[unsafe.Pointer]unsafe.Pointer) uint {
	var _arg1 *C.GHashTable // out
	var _cret C.guint       // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)

	_cret = C.g_hash_table_size(_arg1)
	runtime.KeepAlive(hashTable)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// HashTableSteal removes a key and its associated value from a Table without
// calling the key and value destroy functions.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the key was found and removed from the Table.
func HashTableSteal(hashTable map[unsafe.Pointer]unsafe.Pointer, key unsafe.Pointer) bool {
	var _arg1 *C.GHashTable   // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_hash_table_steal(_arg1, _arg2)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HashTableStealAll removes all keys and their associated values from a Table
// without calling the key and value destroy functions.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
func HashTableStealAll(hashTable map[unsafe.Pointer]unsafe.Pointer) {
	var _arg1 *C.GHashTable // out

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)

	C.g_hash_table_steal_all(_arg1)
	runtime.KeepAlive(hashTable)
}

// HashTableStealExtended looks up a key in the Table, stealing the original key
// and the associated value and returning TRUE if the key was found. If the key
// was not found, FALSE is returned.
//
// If found, the stolen key and value are removed from the hash table without
// calling the key and value destroy functions, and ownership is transferred
// to the caller of this method, as with g_hash_table_steal(). That is the
// case regardless whether stolen_key or stolen_value output parameters are
// requested.
//
// You can pass NULL for lookup_key, provided the hash and equal functions of
// hash_table are NULL-safe.
//
// The dictionary implementation optimizes for having all values identical to
// their keys, for example by using g_hash_table_add(). When stealing both the
// key and the value from such a dictionary, the value will be NULL.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - lookupKey (optional): key to look up.
//
// The function returns the following values:
//
//   - stolenKey (optional): return location for the original key.
//   - stolenValue (optional): return location for the value associated with the
//     key.
//   - ok: TRUE if the key was found in the Table.
func HashTableStealExtended(hashTable map[unsafe.Pointer]unsafe.Pointer, lookupKey unsafe.Pointer) (stolenKey, stolenValue unsafe.Pointer, ok bool) {
	var _arg1 *C.GHashTable   // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gpointer      // in
	var _arg4 C.gpointer      // in
	var _cret C.gboolean      // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gconstpointer)(unsafe.Pointer(lookupKey))

	_cret = C.g_hash_table_steal_extended(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(lookupKey)

	var _stolenKey unsafe.Pointer   // out
	var _stolenValue unsafe.Pointer // out
	var _ok bool                    // out

	_stolenKey = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	_stolenValue = (unsafe.Pointer)(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _stolenKey, _stolenValue, _ok
}

// HashTableIter structure represents an iterator that can be used to iterate
// over the elements of a Table. GHashTableIter structures are typically
// allocated on the stack and then initialized with g_hash_table_iter_init().
//
// The iteration order of a TableIter over the keys/values in a hash table is
// not defined.
//
// An instance of this type is always passed by reference.
type HashTableIter struct {
	*hashTableIter
}

// hashTableIter is the struct that's finalized.
type hashTableIter struct {
	native *C.GHashTableIter
}

// HashTable returns the Table associated with iter.
//
// The function returns the following values:
//
//   - hashTable associated with iter.
func (iter *HashTableIter) HashTable() map[unsafe.Pointer]unsafe.Pointer {
	var _arg0 *C.GHashTableIter // out
	var _cret *C.GHashTable     // in

	_arg0 = (*C.GHashTableIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.g_hash_table_iter_get_hash_table(_arg0)
	runtime.KeepAlive(iter)

	var _hashTable map[unsafe.Pointer]unsafe.Pointer // out

	_hashTable = make(map[unsafe.Pointer]unsafe.Pointer, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), false, func(k, v unsafe.Pointer) {
		ksrc := *(*C.gpointer)(k)
		vsrc := *(*C.gpointer)(v)
		var kdst unsafe.Pointer // out
		var vdst unsafe.Pointer // out
		kdst = (unsafe.Pointer)(unsafe.Pointer(ksrc))
		vdst = (unsafe.Pointer)(unsafe.Pointer(vsrc))
		_hashTable[kdst] = vdst
	})

	return _hashTable
}

// Init initializes a key/value pair iterator and associates it with hash_table.
// Modifying the hash table after calling this function invalidates the returned
// iterator.
//
// The iteration order of a TableIter over the keys/values in a hash table is
// not defined.
//
//	GHashTableIter iter;
//	gpointer key, value;
//
//	g_hash_table_iter_init (&iter, hash_table);
//	while (g_hash_table_iter_next (&iter, &key, &value))
//	  {
//	    // do something with key and value
//	  }.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
func (iter *HashTableIter) Init(hashTable map[unsafe.Pointer]unsafe.Pointer) {
	var _arg0 *C.GHashTableIter // out
	var _arg1 *C.GHashTable     // out

	_arg0 = (*C.GHashTableIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst C.gpointer // out
		var vdst C.gpointer // out
		kdst = (C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)

	C.g_hash_table_iter_init(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(hashTable)
}

// Next advances iter and retrieves the key and/or value that are now pointed to
// as a result of this advancement. If FALSE is returned, key and value are not
// set, and the iterator becomes invalid.
//
// The function returns the following values:
//
//   - key (optional): location to store the key.
//   - value (optional): location to store the value.
//   - ok: FALSE if the end of the Table has been reached.
func (iter *HashTableIter) Next() (key unsafe.Pointer, value unsafe.Pointer, ok bool) {
	var _arg0 *C.GHashTableIter // out
	var _arg1 C.gpointer        // in
	var _arg2 C.gpointer        // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GHashTableIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.g_hash_table_iter_next(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _key unsafe.Pointer   // out
	var _value unsafe.Pointer // out
	var _ok bool              // out

	_key = (unsafe.Pointer)(unsafe.Pointer(_arg1))
	_value = (unsafe.Pointer)(unsafe.Pointer(_arg2))
	if _cret != 0 {
		_ok = true
	}

	return _key, _value, _ok
}

// Remove removes the key/value pair currently pointed to by the iterator from
// its associated Table. Can only be called after g_hash_table_iter_next()
// returned TRUE, and cannot be called more than once for the same key/value
// pair.
//
// If the Table was created using g_hash_table_new_full(), the key and value are
// freed using the supplied destroy functions, otherwise you have to make sure
// that any dynamically allocated values are freed yourself.
//
// It is safe to continue iterating the Table afterward:
//
//	while (g_hash_table_iter_next (&iter, &key, &value))
//	  {
//	    if (condition)
//	      g_hash_table_iter_remove (&iter);
//	  }.
func (iter *HashTableIter) Remove() {
	var _arg0 *C.GHashTableIter // out

	_arg0 = (*C.GHashTableIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.g_hash_table_iter_remove(_arg0)
	runtime.KeepAlive(iter)
}

// Replace replaces the value currently pointed to by the iterator from its
// associated Table. Can only be called after g_hash_table_iter_next() returned
// TRUE.
//
// If you supplied a value_destroy_func when creating the Table, the old value
// is freed using that function.
//
// The function takes the following parameters:
//
//   - value (optional) to replace with.
func (iter *HashTableIter) Replace(value unsafe.Pointer) {
	var _arg0 *C.GHashTableIter // out
	var _arg1 C.gpointer        // out

	_arg0 = (*C.GHashTableIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (C.gpointer)(unsafe.Pointer(value))

	C.g_hash_table_iter_replace(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(value)
}

// Steal removes the key/value pair currently pointed to by the iterator from
// its associated Table, without calling the key and value destroy functions.
// Can only be called after g_hash_table_iter_next() returned TRUE, and cannot
// be called more than once for the same key/value pair.
func (iter *HashTableIter) Steal() {
	var _arg0 *C.GHashTableIter // out

	_arg0 = (*C.GHashTableIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.g_hash_table_iter_steal(_arg0)
	runtime.KeepAlive(iter)
}

// HMAC HMACs should be used when producing a cookie or hash based on data
// and a key. Simple mechanisms for using SHA1 and other algorithms to digest
// a key and data together are vulnerable to various security issues. HMAC
// (http://en.wikipedia.org/wiki/HMAC) uses algorithms like SHA1 in a secure way
// to produce a digest of a key and data.
//
// Both the key and data are arbitrary byte arrays of bytes or characters.
//
// Support for HMAC Digests has been added in GLib 2.30, and support for SHA-512
// in GLib 2.42. Support for SHA-384 was added in GLib 2.52.
//
// To create a new GHmac, use glib.HMAC.New. To free a GHmac, use
// glib.HMAC.Unref().
//
// An instance of this type is always passed by reference.
type HMAC struct {
	*hmaC
}

// hmaC is the struct that's finalized.
type hmaC struct {
	native *C.GHmac
}

func marshalHMAC(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &HMAC{&hmaC{(*C.GHmac)(b)}}, nil
}

// NewHMAC constructs a struct HMAC.
func NewHMAC(digestType ChecksumType, key []byte) *HMAC {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.guchar       // out
	var _arg3 C.gsize
	var _cret *C.GHmac // in

	_arg1 = C.GChecksumType(digestType)
	_arg3 = (C.gsize)(len(key))
	if len(key) > 0 {
		_arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	}

	_cret = C.g_hmac_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)

	var _hmac *HMAC // out

	if _cret != nil {
		_hmac = (*HMAC)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_hmac)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_hmac_unref((*C.GHmac)(intern.C))
			},
		)
	}

	return _hmac
}

// Copy copies a #GHmac. If hmac has been closed, by calling g_hmac_get_string()
// or g_hmac_get_digest(), the copied HMAC will be closed as well.
//
// The function returns the following values:
//
//   - ret: copy of the passed #GHmac. Use g_hmac_unref() when finished using
//     it.
func (hmac *HMAC) Copy() *HMAC {
	var _arg0 *C.GHmac // out
	var _cret *C.GHmac // in

	_arg0 = (*C.GHmac)(gextras.StructNative(unsafe.Pointer(hmac)))

	_cret = C.g_hmac_copy(_arg0)
	runtime.KeepAlive(hmac)

	var _ret *HMAC // out

	_ret = (*HMAC)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_hmac_unref((*C.GHmac)(intern.C))
		},
	)

	return _ret
}

// String gets the HMAC as a hexadecimal string.
//
// Once this function has been called the #GHmac can no longer be updated with
// g_hmac_update().
//
// The hexadecimal characters will be lower case.
//
// The function returns the following values:
//
//   - utf8: hexadecimal representation of the HMAC. The returned string is
//     owned by the HMAC and should not be modified or freed.
func (hmac *HMAC) String() string {
	var _arg0 *C.GHmac // out
	var _cret *C.gchar // in

	_arg0 = (*C.GHmac)(gextras.StructNative(unsafe.Pointer(hmac)))

	_cret = C.g_hmac_get_string(_arg0)
	runtime.KeepAlive(hmac)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Update feeds data into an existing #GHmac.
//
// The HMAC must still be open, that is g_hmac_get_string() or
// g_hmac_get_digest() must not have been called on hmac.
//
// The function takes the following parameters:
//
//   - data: buffer used to compute the checksum.
func (hmac *HMAC) Update(data []byte) {
	var _arg0 *C.GHmac  // out
	var _arg1 *C.guchar // out
	var _arg2 C.gssize

	_arg0 = (*C.GHmac)(gextras.StructNative(unsafe.Pointer(hmac)))
	_arg2 = (C.gssize)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))
	}

	C.g_hmac_update(_arg0, _arg1, _arg2)
	runtime.KeepAlive(hmac)
	runtime.KeepAlive(data)
}

// IOChannel: GIOChannel data type aims to provide a portable method for using
// file descriptors, pipes, and sockets, and integrating them into the main
// event loop (see glib.MainContext). Currently, full support is available on
// UNIX platforms; support for Windows is only partially complete.
//
// To create a new GIOChannel on UNIX systems use glib.IOChannel.NewUnix.
// This works for plain file descriptors, pipes and sockets. Alternatively,
// a channel can be created for a file in a system independent manner using
// glib.IOChannel.NewFile.
//
// Once a GIOChannel has been created, it can be used in a generic manner with
// the functions glib.IOChannel.ReadChars(), glib.IOChannel.WriteChars(),
// glib.IOChannel.SeekPosition(), and glib.IOChannel.Shutdown().
//
// To add a GIOChannel to the main event loop, use glib.IOAddWatch() or
// glib.IOAddWatchFull(). Here you specify which events you are interested in
// on the GIOChannel, and provide a function to be called whenever these events
// occur.
//
// GIOChannel instances are created with an initial reference count of 1.
// glib.IOChannel.Ref() and glib.IOChannel.Unref() can be used to increment
// or decrement the reference count respectively. When the reference count
// falls to 0, the GIOChannel is freed. (Though it isn’t closed automatically,
// unless it was created using glib.IOChannel.NewFile.) Using glib.IOAddWatch()
// or glib.IOAddWatchFull() increments a channel’s reference count.
//
// The new functions glib.IOChannel.ReadChars(), glib.IOChannel.ReadLine(),
// glib.IOChannel.ReadLineString(), glib.IOChannel.ReadToEnd(),
// glib.IOChannel.WriteChars(), glib.IOChannel.SeekPosition(), and
// glib.IOChannel.Flush() should not be mixed with the deprecated functions
// glib.IOChannel.Read(), glib.IOChannel.Write(), and glib.IOChannel.Seek() on
// the same channel.
//
// An instance of this type is always passed by reference.
type IOChannel struct {
	*ioChannel
}

// ioChannel is the struct that's finalized.
type ioChannel struct {
	native *C.GIOChannel
}

func marshalIOChannel(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &IOChannel{&ioChannel{(*C.GIOChannel)(b)}}, nil
}

// NewIOChannelFile constructs a struct IOChannel.
func NewIOChannelFile(filename string, mode string) (*IOChannel, error) {
	var _arg1 *C.gchar      // out
	var _arg2 *C.gchar      // out
	var _cret *C.GIOChannel // in
	var _cerr *C.GError     // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(mode)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_io_channel_new_file(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(mode)

	var _ioChannel *IOChannel // out
	var _goerr error          // out

	_ioChannel = (*IOChannel)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ioChannel)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_io_channel_unref((*C.GIOChannel)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioChannel, _goerr
}

// NewIOChannelUnix constructs a struct IOChannel.
func NewIOChannelUnix(fd int) *IOChannel {
	var _arg1 C.int         // out
	var _cret *C.GIOChannel // in

	_arg1 = C.int(fd)

	_cret = C.g_io_channel_unix_new(_arg1)
	runtime.KeepAlive(fd)

	var _ioChannel *IOChannel // out

	_ioChannel = (*IOChannel)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ioChannel)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_io_channel_unref((*C.GIOChannel)(intern.C))
		},
	)

	return _ioChannel
}

// Close an IO channel. Any pending data to be written will be flushed, ignoring
// errors. The channel will not be freed until the last reference is dropped
// using g_io_channel_unref().
//
// Deprecated: Use g_io_channel_shutdown() instead.
func (channel *IOChannel) Close() {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	C.g_io_channel_close(_arg0)
	runtime.KeepAlive(channel)
}

// Flush flushes the write buffer for the GIOChannel.
//
// The function returns the following values:
//
//   - ioStatus status of the operation: One of G_IO_STATUS_NORMAL,
//     G_IO_STATUS_AGAIN, or G_IO_STATUS_ERROR.
func (channel *IOChannel) Flush() (IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_flush(_arg0, &_cerr)
	runtime.KeepAlive(channel)

	var _ioStatus IOStatus // out
	var _goerr error       // out

	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStatus, _goerr
}

// BufferCondition: this function returns a OCondition depending on whether
// there is data to be read/space to write data in the internal buffers in the
// OChannel. Only the flags G_IO_IN and G_IO_OUT may be set.
//
// The function returns the following values:
//
//   - ioCondition: OCondition.
func (channel *IOChannel) BufferCondition() IOCondition {
	var _arg0 *C.GIOChannel  // out
	var _cret C.GIOCondition // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_get_buffer_condition(_arg0)
	runtime.KeepAlive(channel)

	var _ioCondition IOCondition // out

	_ioCondition = IOCondition(_cret)

	return _ioCondition
}

// BufferSize gets the buffer size.
//
// The function returns the following values:
//
//   - gsize: size of the buffer.
func (channel *IOChannel) BufferSize() uint {
	var _arg0 *C.GIOChannel // out
	var _cret C.gsize       // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_get_buffer_size(_arg0)
	runtime.KeepAlive(channel)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Buffered returns whether channel is buffered.
//
// The function returns the following values:
//
//   - ok: TRUE if the channel is buffered.
func (channel *IOChannel) Buffered() bool {
	var _arg0 *C.GIOChannel // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_get_buffered(_arg0)
	runtime.KeepAlive(channel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Encoding gets the encoding for the input/output of the channel. The internal
// encoding is always UTF-8. The encoding NULL makes the channel safe for binary
// data.
//
// The function returns the following values:
//
//   - utf8: string containing the encoding, this string is owned by GLib and
//     must not be freed.
func (channel *IOChannel) Encoding() string {
	var _arg0 *C.GIOChannel // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_get_encoding(_arg0)
	runtime.KeepAlive(channel)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Flags gets the current flags for a OChannel, including read-only flags such
// as G_IO_FLAG_IS_READABLE.
//
// The values of the flags G_IO_FLAG_IS_READABLE and G_IO_FLAG_IS_WRITABLE
// are cached for internal use by the channel when it is created. If they
// should change at some later point (e.g. partial shutdown of a socket
// with the UNIX shutdown() function), the user should immediately call
// g_io_channel_get_flags() to update the internal values of these flags.
//
// The function returns the following values:
//
//   - ioFlags flags which are set on the channel.
func (channel *IOChannel) Flags() IOFlags {
	var _arg0 *C.GIOChannel // out
	var _cret C.GIOFlags    // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_get_flags(_arg0)
	runtime.KeepAlive(channel)

	var _ioFlags IOFlags // out

	_ioFlags = IOFlags(_cret)

	return _ioFlags
}

// LineTerm: this returns the string that OChannel uses to determine where in
// the file a line break occurs. A value of NULL indicates autodetection.
//
// The function returns the following values:
//
//   - length (optional): location to return the length of the line terminator.
//   - utf8: line termination string. This value is owned by GLib and must not
//     be freed.
func (channel *IOChannel) LineTerm() (int, string) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gint        // in
	var _cret *C.gchar      // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_get_line_term(_arg0, &_arg1)
	runtime.KeepAlive(channel)

	var _length int  // out
	var _utf8 string // out

	_length = int(_arg1)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _length, _utf8
}

// Init initializes a OChannel struct.
//
// This is called by each of the above functions when creating a OChannel,
// and so is not often needed by the application programmer (unless you are
// creating a new type of OChannel).
func (channel *IOChannel) Init() {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	C.g_io_channel_init(_arg0)
	runtime.KeepAlive(channel)
}

// ReadChars: replacement for g_io_channel_read() with the new API.
//
// The function takes the following parameters:
//
//   - buf: a buffer to read data into.
//
// The function returns the following values:
//
//   - bytesRead (optional): number of bytes read. This may be zero even
//     on success if count < 6 and the channel's encoding is non-NULL. This
//     indicates that the next UTF-8 character is too wide for the buffer.
//   - ioStatus status of the operation.
func (channel *IOChannel) ReadChars(buf []byte) (uint, IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gsize
	var _arg3 C.gsize     // in
	var _cret C.GIOStatus // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg2 = (C.gsize)(len(buf))
	_arg1 = (*C.gchar)(C.CBytes(buf))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_io_channel_read_chars(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(buf)

	var _bytesRead uint    // out
	var _ioStatus IOStatus // out
	var _goerr error       // out

	_bytesRead = uint(_arg3)
	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _ioStatus, _goerr
}

// ReadLine reads a line, including the terminating character(s), from a
// OChannel into a newly-allocated string. str_return will contain allocated
// memory if the return is G_IO_STATUS_NORMAL.
//
// The function returns the following values:
//
//   - strReturn: line read from the OChannel, including the line terminator.
//     This data should be freed with g_free() when no longer needed. This is a
//     nul-terminated string. If a length of zero is returned, this will be NULL
//     instead.
//   - length (optional): location to store length of the read data, or NULL.
//   - terminatorPos (optional): location to store position of line terminator,
//     or NULL.
//   - ioStatus status of the operation.
func (channel *IOChannel) ReadLine() (strReturn string, length uint, terminatorPos uint, ioStatus IOStatus, goerr error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // in
	var _arg2 C.gsize       // in
	var _arg3 C.gsize       // in
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_read_line(_arg0, &_arg1, &_arg2, &_arg3, &_cerr)
	runtime.KeepAlive(channel)

	var _strReturn string   // out
	var _length uint        // out
	var _terminatorPos uint // out
	var _ioStatus IOStatus  // out
	var _goerr error        // out

	_strReturn = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	defer C.free(unsafe.Pointer(_arg1))
	_length = uint(_arg2)
	_terminatorPos = uint(_arg3)
	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _strReturn, _length, _terminatorPos, _ioStatus, _goerr
}

// ReadToEnd reads all the remaining data from the file.
//
// The function returns the following values:
//
//   - strReturn: location to store a pointer to a string holding the remaining
//     data in the OChannel. This data should be freed with g_free() when
//     no longer needed. This data is terminated by an extra nul character,
//     but there may be other nuls in the intervening data.
//   - ioStatus: G_IO_STATUS_NORMAL on success. This function never returns
//     G_IO_STATUS_EOF.
func (channel *IOChannel) ReadToEnd() ([]byte, IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // in
	var _arg2 C.gsize       // in
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_read_to_end(_arg0, &_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(channel)

	var _strReturn []byte  // out
	var _ioStatus IOStatus // out
	var _goerr error       // out

	defer C.free(unsafe.Pointer(_arg1))
	_strReturn = make([]byte, _arg2)
	copy(_strReturn, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))
	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _strReturn, _ioStatus, _goerr
}

// ReadUnichar reads a Unicode character from channel. This function cannot be
// called on a channel with NULL encoding.
//
// The function returns the following values:
//
//   - thechar: location to return a character.
//   - ioStatus: OStatus.
func (channel *IOChannel) ReadUnichar() (uint32, IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gunichar    // in
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_read_unichar(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(channel)

	var _thechar uint32    // out
	var _ioStatus IOStatus // out
	var _goerr error       // out

	_thechar = uint32(_arg1)
	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _thechar, _ioStatus, _goerr
}

// Seek sets the current position in the OChannel, similar to the standard
// library function fseek().
//
// Deprecated: Use g_io_channel_seek_position() instead.
//
// The function takes the following parameters:
//
//   - offset: offset, in bytes, which is added to the position specified by
//     type.
//   - typ: position in the file, which can be G_SEEK_CUR (the current
//     position), G_SEEK_SET (the start of the file), or G_SEEK_END (the end of
//     the file).
//
// The function returns the following values:
//
//   - ioError: G_IO_ERROR_NONE if the operation was successful.
func (channel *IOChannel) Seek(offset int64, typ SeekType) IOError {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gint64      // out
	var _arg2 C.GSeekType   // out
	var _cret C.GIOError    // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg1 = C.gint64(offset)
	_arg2 = C.GSeekType(typ)

	_cret = C.g_io_channel_seek(_arg0, _arg1, _arg2)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var _ioError IOError // out

	_ioError = IOError(_cret)

	return _ioError
}

// SeekPosition: replacement for g_io_channel_seek() with the new API.
//
// The function takes the following parameters:
//
//   - offset in bytes from the position specified by type.
//   - typ The type G_SEEK_CUR is only allowed in those cases where a call
//     to g_io_channel_set_encoding () is allowed. See the documentation for
//     g_io_channel_set_encoding () for details.
//
// The function returns the following values:
//
//   - ioStatus status of the operation.
func (channel *IOChannel) SeekPosition(offset int64, typ SeekType) (IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gint64      // out
	var _arg2 C.GSeekType   // out
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg1 = C.gint64(offset)
	_arg2 = C.GSeekType(typ)

	_cret = C.g_io_channel_seek_position(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var _ioStatus IOStatus // out
	var _goerr error       // out

	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStatus, _goerr
}

// SetBufferSize sets the buffer size.
//
// The function takes the following parameters:
//
//   - size of the buffer, or 0 to let GLib pick a good size.
func (channel *IOChannel) SetBufferSize(size uint) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gsize       // out

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg1 = C.gsize(size)

	C.g_io_channel_set_buffer_size(_arg0, _arg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(size)
}

// SetBuffered: buffering state can only be set if the channel's encoding is
// NULL. For any other encoding, the channel must be buffered.
//
// A buffered channel can only be set unbuffered if the channel's internal
// buffers have been flushed. Newly created channels or channels which have
// returned G_IO_STATUS_EOF not require such a flush. For write-only channels,
// a call to g_io_channel_flush () is sufficient. For all other channels,
// the buffers may be flushed by a call to g_io_channel_seek_position ().
// This includes the possibility of seeking with seek type G_SEEK_CUR and an
// offset of zero. Note that this means that socket-based channels cannot be set
// unbuffered once they have had data read from them.
//
// On unbuffered channels, it is safe to mix read and write calls from the new
// and old APIs, if this is necessary for maintaining old code.
//
// The default state of the channel is buffered.
//
// The function takes the following parameters:
//
//   - buffered: whether to set the channel buffered or unbuffered.
func (channel *IOChannel) SetBuffered(buffered bool) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	if buffered {
		_arg1 = C.TRUE
	}

	C.g_io_channel_set_buffered(_arg0, _arg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(buffered)
}

// SetEncoding sets the encoding for the input/output of the channel. The
// internal encoding is always UTF-8. The default encoding for the external file
// is UTF-8.
//
// The encoding NULL is safe to use with binary data.
//
// The encoding can only be set if one of the following conditions is true:
//
// - The channel was just created, and has not been written to or read from yet.
//
// - The channel is write-only.
//
// - The channel is a file, and the file pointer was just repositioned by a call
// to g_io_channel_seek_position(). (This flushes all the internal buffers.)
//
// - The current encoding is NULL or UTF-8.
//
// - One of the (new API) read functions has just returned G_IO_STATUS_EOF (or,
// in the case of g_io_channel_read_to_end(), G_IO_STATUS_NORMAL).
//
// - One of the functions g_io_channel_read_chars() or
// g_io_channel_read_unichar() has returned G_IO_STATUS_AGAIN
// or G_IO_STATUS_ERROR. This may be useful in the case of
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Returning one of these statuses
// from g_io_channel_read_line(), g_io_channel_read_line_string(),
// or g_io_channel_read_to_end() does not guarantee that the encoding can be
// changed.
//
// Channels which do not meet one of the above conditions cannot call
// g_io_channel_seek_position() with an offset of G_SEEK_CUR, and, if they are
// "seekable", cannot call g_io_channel_write_chars() after calling one of the
// API "read" functions.
//
// The function takes the following parameters:
//
//   - encoding (optional) type.
//
// The function returns the following values:
//
//   - ioStatus: G_IO_STATUS_NORMAL if the encoding was successfully set.
func (channel *IOChannel) SetEncoding(encoding string) (IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // out
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	if encoding != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(encoding)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_io_channel_set_encoding(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(encoding)

	var _ioStatus IOStatus // out
	var _goerr error       // out

	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStatus, _goerr
}

// SetFlags sets the (writeable) flags in channel to (flags &
// G_IO_FLAG_SET_MASK).
//
// The function takes the following parameters:
//
//   - flags to set on the IO channel.
//
// The function returns the following values:
//
//   - ioStatus status of the operation.
func (channel *IOChannel) SetFlags(flags IOFlags) (IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.GIOFlags    // out
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg1 = C.GIOFlags(flags)

	_cret = C.g_io_channel_set_flags(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(flags)

	var _ioStatus IOStatus // out
	var _goerr error       // out

	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStatus, _goerr
}

// SetLineTerm: this sets the string that OChannel uses to determine where in
// the file a line break occurs.
//
// The function takes the following parameters:
//
//   - lineTerm (optional): line termination string. Use NULL for autodetect.
//     Autodetection breaks on "\n", "\r\n", "\r", "\0", and the Unicode
//     paragraph separator. Autodetection should not be used for anything other
//     than file-based channels.
func (channel *IOChannel) SetLineTerm(lineTerm string) {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg2 = (C.gint)(len(lineTerm))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(lineTerm) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(lineTerm)), lineTerm)
	defer C.free(unsafe.Pointer(_arg1))

	C.g_io_channel_set_line_term(_arg0, _arg1, _arg2)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(lineTerm)
}

// Shutdown: close an IO channel. Any pending data to be written will be flushed
// if flush is TRUE. The channel will not be freed until the last reference is
// dropped using g_io_channel_unref().
//
// The function takes the following parameters:
//
//   - flush: if TRUE, flush pending.
//
// The function returns the following values:
//
//   - ioStatus status of the operation.
func (channel *IOChannel) Shutdown(flush bool) (IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gboolean    // out
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	if flush {
		_arg1 = C.TRUE
	}

	_cret = C.g_io_channel_shutdown(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(flush)

	var _ioStatus IOStatus // out
	var _goerr error       // out

	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStatus, _goerr
}

// UnixGetFd returns the file descriptor of the OChannel.
//
// On Windows this function returns the file descriptor or socket of the
// OChannel.
//
// The function returns the following values:
//
//   - gint: file descriptor of the OChannel.
func (channel *IOChannel) UnixGetFd() int {
	var _arg0 *C.GIOChannel // out
	var _cret C.gint        // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))

	_cret = C.g_io_channel_unix_get_fd(_arg0)
	runtime.KeepAlive(channel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Write writes data to a OChannel.
//
// Deprecated: Use g_io_channel_write_chars() instead.
//
// The function takes the following parameters:
//
//   - buf: buffer containing the data to write.
//   - count: number of bytes to write.
//   - bytesWritten: number of bytes actually written.
//
// The function returns the following values:
//
//   - ioError: G_IO_ERROR_NONE if the operation was successful.
func (channel *IOChannel) Write(buf string, count uint, bytesWritten *uint) IOError {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gsize       // out
	var _arg3 *C.gsize      // out
	var _cret C.GIOError    // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(buf)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gsize(count)
	_arg3 = (*C.gsize)(unsafe.Pointer(bytesWritten))

	_cret = C.g_io_channel_write(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(count)
	runtime.KeepAlive(bytesWritten)

	var _ioError IOError // out

	_ioError = IOError(_cret)

	return _ioError
}

// WriteChars: replacement for g_io_channel_write() with the new API.
//
// On seekable channels with encodings other than NULL or UTF-8, generic mixing
// of reading and writing is not allowed. A call to g_io_channel_write_chars
// () may only be made on a channel from which data has been read in the cases
// described in the documentation for g_io_channel_set_encoding ().
//
// The function takes the following parameters:
//
//   - buf: buffer to write data from.
//   - count: size of the buffer. If -1, the buffer is taken to be a
//     nul-terminated string.
//
// The function returns the following values:
//
//   - bytesWritten: number of bytes written. This can be nonzero even if
//     the return value is not G_IO_STATUS_NORMAL. If the return value is
//     G_IO_STATUS_NORMAL and the channel is blocking, this will always be equal
//     to count if count >= 0.
//   - ioStatus status of the operation.
func (channel *IOChannel) WriteChars(buf string, count int) (uint, IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gssize      // out
	var _arg3 C.gsize       // in
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(buf) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(buf)), buf)
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(count)

	_cret = C.g_io_channel_write_chars(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(count)

	var _bytesWritten uint // out
	var _ioStatus IOStatus // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _ioStatus, _goerr
}

// WriteUnichar writes a Unicode character to channel. This function cannot be
// called on a channel with NULL encoding.
//
// The function takes the following parameters:
//
//   - thechar: character.
//
// The function returns the following values:
//
//   - ioStatus: OStatus.
func (channel *IOChannel) WriteUnichar(thechar uint32) (IOStatus, error) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gunichar    // out
	var _cret C.GIOStatus   // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GIOChannel)(gextras.StructNative(unsafe.Pointer(channel)))
	_arg1 = C.gunichar(thechar)

	_cret = C.g_io_channel_write_unichar(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(thechar)

	var _ioStatus IOStatus // out
	var _goerr error       // out

	_ioStatus = IOStatus(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ioStatus, _goerr
}

// IOChannelErrorFromErrno converts an errno error number to a OChannelError.
//
// The function takes the following parameters:
//
//   - en: errno error number, e.g. EINVAL.
//
// The function returns the following values:
//
//   - ioChannelError error number, e.g. G_IO_CHANNEL_ERROR_INVAL.
func IOChannelErrorFromErrno(en int) IOChannelError {
	var _arg1 C.gint            // out
	var _cret C.GIOChannelError // in

	_arg1 = C.gint(en)

	_cret = C.g_io_channel_error_from_errno(_arg1)
	runtime.KeepAlive(en)

	var _ioChannelError IOChannelError // out

	_ioChannelError = IOChannelError(_cret)

	return _ioChannelError
}

func IOChannelErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_io_channel_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// IOFuncs: table of functions used to handle different types of OChannel in a
// generic way.
//
// An instance of this type is always passed by reference.
type IOFuncs struct {
	*ioFuncs
}

// ioFuncs is the struct that's finalized.
type ioFuncs struct {
	native *C.GIOFuncs
}

// KeyFile: GKeyFile parses .ini-like config files.
//
// GKeyFile lets you parse, edit or create files containing groups of key-value
// pairs, which we call "key files" for lack of a better name. Several
// freedesktop.org specifications use key files now, e.g the Desktop Entry
// Specification (http://freedesktop.org/Standards/desktop-entry-spec) and the
// Icon Theme Specification (http://freedesktop.org/Standards/icon-theme-spec).
//
// The syntax of key files is described in detail in the Desktop Entry
// Specification (http://freedesktop.org/Standards/desktop-entry-spec),
// here is a quick summary: Key files consists of groups of key-value pairs,
// interspersed with comments.
//
// this is just an example
//
// there can be comments before the first group
//
//	[First Group]
//
//	Name=Key File Example\tthis value shows\nescaping
//
// localized strings are stored in multiple key-value pairs
//
//	Welcome=Hello
//	Welcome[de]=Hallo
//	Welcome[fr_FR]=Bonjour
//	Welcome[it]=Ciao
//
//	[Another Group]
//
//	Numbers=2;20;-200;0
//
//	Booleans=true;false;true;true
//
// Lines beginning with a '#' and blank lines are considered comments.
//
// Groups are started by a header line containing the group name enclosed in '['
// and ']', and ended implicitly by the start of the next group or the end of
// the file. Each key-value pair must be contained in a group.
//
// Key-value pairs generally have the form key=value, with the exception of
// localized strings, which have the form key[locale]=value, with a locale
// identifier of the form lang_COUNTRYMODIFIER where COUNTRY and MODIFIER are
// optional. Space before and after the '=' character are ignored. Newline, tab,
// carriage return and backslash characters in value are escaped as \n, \t, \r,
// and \\\\, respectively. To preserve leading spaces in values, these can also
// be escaped as \s.
//
// Key files can store strings (possibly with localized variants), integers,
// booleans and lists of these. Lists are separated by a separator character,
// typically ';' or ','. To use the list separator character in a value in a
// list, it has to be escaped by prefixing it with a backslash.
//
// This syntax is obviously inspired by the .ini files commonly met on Windows,
// but there are some important differences:
//
// - .ini files use the ';' character to begin comments, key files use the '#'
// character.
//
// - Key files do not allow for ungrouped keys meaning only comments can precede
// the first group.
//
// - Key files are always encoded in UTF-8.
//
// - Key and Group names are case-sensitive. For example, a group called [GROUP]
// is a different from [group].
//
// - .ini files don't have a strongly typed boolean entry type, they only
// have GetProfileInt(). In key files, only true and false (in lower case) are
// allowed.
//
// Note that in contrast to the Desktop Entry Specification
// (http://freedesktop.org/Standards/desktop-entry-spec), groups in key files
// may contain the same key multiple times; the last entry wins. Key files may
// also contain multiple groups with the same name; they are merged together.
// Another difference is that keys and group names in key files are not
// restricted to ASCII characters.
//
// Here is an example of loading a key file and reading a value:
//
//	g_autoptr(GError) error = NULL;
//	g_autoptr(GKeyFile) key_file = g_key_file_new ();
//
//	if (!g_key_file_load_from_file (key_file, "key-file.ini", flags, &error))
//	  {
//	    if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
//	      g_warning ("Error loading key file: s", error->message);
//	    return;
//	  }
//
//	g_autofree gchar *val = g_key_file_get_string (key_file, "Group Name", "SomeKey", &error);
//	if (val == NULL &&
//	    !g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))
//	  {
//	    g_warning ("Error finding key in key file: s", error->message);
//	    return;
//	  }
//	else if (val == NULL)
//	  {
//	    // Fall back to a default value.
//	    val = g_strdup ("default-value");
//	  }
//
// Here is an example of creating and saving a key file:
//
//	g_autoptr(GKeyFile) key_file = g_key_file_new ();
//	const gchar *val = …;
//	g_autoptr(GError) error = NULL;
//
//	g_key_file_set_string (key_file, "Group Name", "SomeKey", val);
//
//	// Save as a file.
//	if (!g_key_file_save_to_file (key_file, "key-file.ini", &error))
//	  {
//	    g_warning ("Error saving key file: s", error->message);
//	    return;
//	  }
//
//	// Or store to a GBytes for use elsewhere.
//	gsize data_len;
//	g_autofree guint8 *data = (guint8 *) g_key_file_to_data (key_file, &data_len, &error);
//	if (data == NULL)
//	  {
//	    g_warning ("Error saving key file: s", error->message);
//	    return;
//	  }
//	g_autoptr(GBytes) bytes = g_bytes_new_take (g_steal_pointer (&data), data_len);
//
// An instance of this type is always passed by reference.
type KeyFile struct {
	*keyFile
}

// keyFile is the struct that's finalized.
type keyFile struct {
	native *C.GKeyFile
}

func marshalKeyFile(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &KeyFile{&keyFile{(*C.GKeyFile)(b)}}, nil
}

// NewKeyFile constructs a struct KeyFile.
func NewKeyFile() *KeyFile {
	var _cret *C.GKeyFile // in

	_cret = C.g_key_file_new()

	var _keyFile *KeyFile // out

	_keyFile = (*KeyFile)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_keyFile)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_key_file_unref((*C.GKeyFile)(intern.C))
		},
	)

	return _keyFile
}

// Boolean returns the value associated with key under group_name as a boolean.
//
// If key cannot be found then FALSE is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with key
// cannot be interpreted as a boolean then FALSE is returned and error is set to
// G_KEY_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
func (keyFile *KeyFile) Boolean(groupName string, key string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_key_file_get_boolean(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// BooleanList returns the values associated with key under group_name as
// booleans.
//
// If key cannot be found then NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated with key
// cannot be interpreted as booleans then NULL is returned and error is set to
// G_KEY_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - oks: the values associated with the key as a list of booleans, or NULL
//     if the key was not found or could not be parsed. The returned list of
//     booleans should be freed with g_free() when no longer needed.
func (keyFile *KeyFile) BooleanList(groupName string, key string) ([]bool, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gboolean // in
	var _arg3 C.gsize     // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_boolean_list(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _oks []bool  // out
	var _goerr error // out

	defer C.free(unsafe.Pointer(_cret))
	_oks = make([]bool, _arg3)
	copy(_oks, unsafe.Slice((*bool)(unsafe.Pointer(_cret)), _arg3))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _oks, _goerr
}

// Comment retrieves a comment above key from group_name. If key is NULL then
// comment will be read from above group_name. If both key and group_name are
// NULL, then comment will be read from above the first group in the file.
//
// Note that the returned string does not include the '#' comment markers,
// but does include any whitespace after them (on each line). It includes the
// line breaks between lines, but does not include the final line break.
//
// The function takes the following parameters:
//
//   - groupName (optional): group name, or NULL.
//   - key (optional): key.
//
// The function returns the following values:
//
//   - utf8: comment that should be freed with g_free().
func (keyFile *KeyFile) Comment(groupName string, key string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if key != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_key_file_get_comment(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// Double returns the value associated with key under group_name as a double.
// If group_name is NULL, the start_group is used.
//
// If key cannot be found then 0.0 is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with key
// cannot be interpreted as a double then 0.0 is returned and error is set to
// G_KEY_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - gdouble: value associated with the key as a double, or 0.0 if the key was
//     not found or could not be parsed.
func (keyFile *KeyFile) Double(groupName string, key string) (float64, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.gdouble   // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_double(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _gdouble float64 // out
	var _goerr error     // out

	_gdouble = float64(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gdouble, _goerr
}

// DoubleList returns the values associated with key under group_name as
// doubles.
//
// If key cannot be found then NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated with key
// cannot be interpreted as doubles then NULL is returned and error is set to
// G_KEY_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - gdoubles: the values associated with the key as a list of doubles,
//     or NULL if the key was not found or could not be parsed. The returned
//     list of doubles should be freed with g_free() when no longer needed.
func (keyFile *KeyFile) DoubleList(groupName string, key string) ([]float64, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gdouble  // in
	var _arg3 C.gsize     // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_double_list(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _gdoubles []float64 // out
	var _goerr error        // out

	defer C.free(unsafe.Pointer(_cret))
	_gdoubles = make([]float64, _arg3)
	copy(_gdoubles, unsafe.Slice((*float64)(unsafe.Pointer(_cret)), _arg3))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gdoubles, _goerr
}

// Groups returns all groups in the key file loaded with key_file. The array of
// returned groups will be NULL-terminated, so length may optionally be NULL.
//
// The function returns the following values:
//
//   - length (optional): return location for the number of returned groups,
//     or NULL.
//   - utf8s: newly-allocated NULL-terminated array of strings. Use g_strfreev()
//     to free it.
func (keyFile *KeyFile) Groups() (uint, []string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 C.gsize     // in
	var _cret **C.gchar   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))

	_cret = C.g_key_file_get_groups(_arg0, &_arg1)
	runtime.KeepAlive(keyFile)

	var _length uint    // out
	var _utf8s []string // out

	_length = uint(_arg1)
	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _length, _utf8s
}

// Int64 returns the value associated with key under group_name as a signed
// 64-bit integer. This is similar to g_key_file_get_integer() but can return
// 64-bit results without truncation.
//
// The function takes the following parameters:
//
//   - groupName: non-NULL group name.
//   - key: non-NULL key.
//
// The function returns the following values:
//
//   - gint64: value associated with the key as a signed 64-bit integer, or 0 if
//     the key was not found or could not be parsed.
func (keyFile *KeyFile) Int64(groupName string, key string) (int64, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.gint64    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_int64(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _gint64 int64 // out
	var _goerr error  // out

	_gint64 = int64(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint64, _goerr
}

// Integer returns the value associated with key under group_name as an integer.
//
// If key cannot be found then 0 is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with
// key cannot be interpreted as an integer, or is out of range for a #gint,
// then 0 is returned and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - gint: value associated with the key as an integer, or 0 if the key was
//     not found or could not be parsed.
func (keyFile *KeyFile) Integer(groupName string, key string) (int, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.gint      // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_integer(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// IntegerList returns the values associated with key under group_name as
// integers.
//
// If key cannot be found then NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated with key
// cannot be interpreted as integers, or are out of range for #gint, then NULL
// is returned and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - gints: the values associated with the key as a list of integers, or NULL
//     if the key was not found or could not be parsed. The returned list of
//     integers should be freed with g_free() when no longer needed.
func (keyFile *KeyFile) IntegerList(groupName string, key string) ([]int, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gint     // in
	var _arg3 C.gsize     // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_integer_list(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _gints []int // out
	var _goerr error // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((*C.gint)(_cret), _arg3)
		_gints = make([]int, _arg3)
		for i := 0; i < int(_arg3); i++ {
			_gints[i] = int(src[i])
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gints, _goerr
}

// Keys returns all keys for the group name group_name. The array of returned
// keys will be NULL-terminated, so length may optionally be NULL. In the event
// that the group_name cannot be found, NULL is returned and error is set to
// G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//
// The function returns the following values:
//
//   - length (optional): return location for the number of keys returned,
//     or NULL.
//   - utf8s: newly-allocated NULL-terminated array of strings. Use g_strfreev()
//     to free it.
func (keyFile *KeyFile) Keys(groupName string) (uint, []string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gsize     // in
	var _cret **C.gchar   // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_key_file_get_keys(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _length uint    // out
	var _utf8s []string // out
	var _goerr error    // out

	_length = uint(_arg2)
	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8s, _goerr
}

// LocaleForKey returns the actual locale which the result of
// g_key_file_get_locale_string() or g_key_file_get_locale_string_list() came
// from.
//
// If calling g_key_file_get_locale_string() or
// g_key_file_get_locale_string_list() with exactly the same key_file,
// group_name, key and locale, the result of those functions will have
// originally been tagged with the locale that is the result of this function.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - locale (optional) identifier or NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): locale from the file, or NULL if the key was not found
//     or the entry in the file was was untranslated.
func (keyFile *KeyFile) LocaleForKey(groupName string, key string, locale string) string {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	if locale != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_key_file_get_locale_for_key(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// LocaleString returns the value associated with key under group_name
// translated in the given locale if available. If locale is NULL then the
// current locale is assumed.
//
// If locale is to be non-NULL, or if the current locale will change over the
// lifetime of the File, it must be loaded with G_KEY_FILE_KEEP_TRANSLATIONS in
// order to load strings for all locales.
//
// If key cannot be found then NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated with key cannot be
// interpreted or no suitable translation can be found then the untranslated
// value is returned.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - locale (optional) identifier or NULL.
//
// The function returns the following values:
//
//   - utf8: newly allocated string or NULL if the specified key cannot be
//     found.
func (keyFile *KeyFile) LocaleString(groupName string, key string, locale string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	if locale != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_key_file_get_locale_string(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LocaleStringList returns the values associated with key under group_name
// translated in the given locale if available. If locale is NULL then the
// current locale is assumed.
//
// If locale is to be non-NULL, or if the current locale will change over the
// lifetime of the File, it must be loaded with G_KEY_FILE_KEEP_TRANSLATIONS in
// order to load strings for all locales.
//
// If key cannot be found then NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated with key cannot be
// interpreted or no suitable translations can be found then the untranslated
// values are returned. The returned array is NULL-terminated, so length may
// optionally be NULL.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - locale (optional) identifier or NULL.
//
// The function returns the following values:
//
//   - utf8s: newly allocated NULL-terminated string array or NULL if the key
//     isn't found. The string array should be freed with g_strfreev().
func (keyFile *KeyFile) LocaleStringList(groupName string, key string, locale string) ([]string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _cret **C.gchar   // in
	var _arg4 C.gsize     // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	if locale != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_key_file_get_locale_string_list(_arg0, _arg1, _arg2, _arg3, &_arg4, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg4)
		_utf8s = make([]string, _arg4)
		for i := 0; i < int(_arg4); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// StartGroup returns the name of the start group of the file.
//
// The function returns the following values:
//
//   - utf8 (optional): start group of the key file.
func (keyFile *KeyFile) StartGroup() string {
	var _arg0 *C.GKeyFile // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))

	_cret = C.g_key_file_get_start_group(_arg0)
	runtime.KeepAlive(keyFile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// String returns the string value associated with key under group_name. Unlike
// g_key_file_get_value(), this function handles escape sequences like \s.
//
// In the event the key cannot be found, NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the group_name cannot be
// found, NULL is returned and error is set to G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - utf8: newly allocated string or NULL if the specified key cannot be
//     found.
func (keyFile *KeyFile) String(groupName string, key string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_string(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// StringList returns the values associated with key under group_name.
//
// In the event the key cannot be found, NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the group_name cannot be
// found, NULL is returned and error is set to G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated string array or NULL if the specified key cannot
//     be found. The array should be freed with g_strfreev().
func (keyFile *KeyFile) StringList(groupName string, key string) ([]string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret **C.gchar   // in
	var _arg3 C.gsize     // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_string_list(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg3)
		_utf8s = make([]string, _arg3)
		for i := 0; i < int(_arg3); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// Uint64 returns the value associated with key under group_name as an unsigned
// 64-bit integer. This is similar to g_key_file_get_integer() but can return
// large positive results without truncation.
//
// The function takes the following parameters:
//
//   - groupName: non-NULL group name.
//   - key: non-NULL key.
//
// The function returns the following values:
//
//   - guint64: value associated with the key as an unsigned 64-bit integer,
//     or 0 if the key was not found or could not be parsed.
func (keyFile *KeyFile) Uint64(groupName string, key string) (uint64, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.guint64   // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_uint64(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _guint64 uint64 // out
	var _goerr error    // out

	_guint64 = uint64(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint64, _goerr
}

// Value returns the raw value associated with key under group_name. Use
// g_key_file_get_string() to retrieve an unescaped UTF-8 string.
//
// In the event the key cannot be found, NULL is returned and error is set to
// G_KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the group_name cannot be
// found, NULL is returned and error is set to G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//
// The function returns the following values:
//
//   - utf8: newly allocated string or NULL if the specified key cannot be
//     found.
func (keyFile *KeyFile) Value(groupName string, key string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_value(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// HasGroup looks whether the key file has the group group_name.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//
// The function returns the following values:
//
//   - ok: TRUE if group_name is a part of key_file, FALSE otherwise.
func (keyFile *KeyFile) HasGroup(groupName string) bool {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_key_file_has_group(_arg0, _arg1)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadFromBytes loads a key file from the data in bytes into an empty File
// structure. If the object cannot be created then error is set to a FileError.
//
// The function takes the following parameters:
//
//   - bytes: #GBytes.
//   - flags from FileFlags.
func (keyFile *KeyFile) LoadFromBytes(bytes *Bytes, flags KeyFileFlags) error {
	var _arg0 *C.GKeyFile     // out
	var _arg1 *C.GBytes       // out
	var _arg2 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	_arg2 = C.GKeyFileFlags(flags)

	C.g_key_file_load_from_bytes(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadFromData loads a key file from memory into an empty File structure.
// If the object cannot be created then error is set to a FileError.
//
// The function takes the following parameters:
//
//   - data: key file loaded in memory.
//   - flags from FileFlags.
func (keyFile *KeyFile) LoadFromData(data string, flags KeyFileFlags) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gsize
	var _arg3 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg2 = (C.gsize)(len(data))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(data) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(data)), data)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.GKeyFileFlags(flags)

	C.g_key_file_load_from_data(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(data)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadFromDataDirs: this function looks for a key file named file in the paths
// returned from g_get_user_data_dir() and g_get_system_data_dirs(), loads the
// file into key_file and returns the file's full path in full_path. If the file
// could not be loaded then an error is set to either a Error or FileError.
//
// The function takes the following parameters:
//
//   - file: relative path to a filename to open and parse.
//   - flags from FileFlags.
//
// The function returns the following values:
//
//   - fullPath (optional): return location for a string containing the full
//     path of the file, or NULL.
func (keyFile *KeyFile) LoadFromDataDirs(file string, flags KeyFileFlags) (string, error) {
	var _arg0 *C.GKeyFile     // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // in
	var _arg3 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.GKeyFileFlags(flags)

	C.g_key_file_load_from_data_dirs(_arg0, _arg1, &_arg2, _arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)

	var _fullPath string // out
	var _goerr error     // out

	if _arg2 != nil {
		_fullPath = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fullPath, _goerr
}

// LoadFromDirs: this function looks for a key file named file in the paths
// specified in search_dirs, loads the file into key_file and returns the file's
// full path in full_path.
//
// If the file could not be found in any of the search_dirs,
// G_KEY_FILE_ERROR_NOT_FOUND is returned. If the file is found but the
// OS returns an error when opening or reading the file, a G_FILE_ERROR is
// returned. If there is a problem parsing the file, a G_KEY_FILE_ERROR is
// returned.
//
// The function takes the following parameters:
//
//   - file: relative path to a filename to open and parse.
//   - searchDirs: NULL-terminated array of directories to search.
//   - flags from FileFlags.
//
// The function returns the following values:
//
//   - fullPath (optional): return location for a string containing the full
//     path of the file, or NULL.
func (keyFile *KeyFile) LoadFromDirs(file string, searchDirs []string, flags KeyFileFlags) (string, error) {
	var _arg0 *C.GKeyFile     // out
	var _arg1 *C.gchar        // out
	var _arg2 **C.gchar       // out
	var _arg3 *C.gchar        // in
	var _arg4 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(searchDirs) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(searchDirs)+1)
			var zero *C.gchar
			out[len(searchDirs)] = zero
			for i := range searchDirs {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(searchDirs[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = C.GKeyFileFlags(flags)

	C.g_key_file_load_from_dirs(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(searchDirs)
	runtime.KeepAlive(flags)

	var _fullPath string // out
	var _goerr error     // out

	if _arg3 != nil {
		_fullPath = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fullPath, _goerr
}

// LoadFromFile loads a key file into an empty File structure.
//
// If the OS returns an error when opening or reading the file, a G_FILE_ERROR
// is returned. If there is a problem parsing the file, a G_KEY_FILE_ERROR is
// returned.
//
// This function will never return a G_KEY_FILE_ERROR_NOT_FOUND error. If the
// file is not found, G_FILE_ERROR_NOENT is returned.
//
// The function takes the following parameters:
//
//   - file: path of a filename to load, in the GLib filename encoding.
//   - flags from FileFlags.
func (keyFile *KeyFile) LoadFromFile(file string, flags KeyFileFlags) error {
	var _arg0 *C.GKeyFile     // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GKeyFileFlags(flags)

	C.g_key_file_load_from_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveComment removes a comment above key from group_name. If key is NULL
// then comment will be removed above group_name. If both key and group_name are
// NULL, then comment will be removed above the first group in the file.
//
// The function takes the following parameters:
//
//   - groupName (optional): group name, or NULL.
//   - key (optional): key.
func (keyFile *KeyFile) RemoveComment(groupName string, key string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if key != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.g_key_file_remove_comment(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveGroup removes the specified group, group_name, from the key file.
//
// The function takes the following parameters:
//
//   - groupName: group name.
func (keyFile *KeyFile) RemoveGroup(groupName string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_key_file_remove_group(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveKey removes key in group_name from the key file.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key name to remove.
func (keyFile *KeyFile) RemoveKey(groupName string, key string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_key_file_remove_key(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SaveToFile writes the contents of key_file to filename using
// g_file_set_contents(). If you need stricter guarantees about durability
// of the written file than are provided by g_file_set_contents(), use
// g_file_set_contents_full() with the return value of g_key_file_to_data().
//
// This function can fail for any of the reasons that g_file_set_contents() may
// fail.
//
// The function takes the following parameters:
//
//   - filename: name of the file to write to.
func (keyFile *KeyFile) SaveToFile(filename string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_key_file_save_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetBoolean associates a new boolean value with key under group_name. If key
// cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - value: TRUE or FALSE.
func (keyFile *KeyFile) SetBoolean(groupName string, key string, value bool) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gboolean  // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	if value {
		_arg3 = C.TRUE
	}

	C.g_key_file_set_boolean(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetBooleanList associates a list of boolean values with key under group_name.
// If key cannot be found then it is created. If group_name is NULL, the
// start_group is used.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - list: array of boolean values.
func (keyFile *KeyFile) SetBooleanList(groupName string, key string, list []bool) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gboolean // out
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = (C.gsize)(len(list))
	if len(list) > 0 {
		_arg3 = (*C.gboolean)(unsafe.Pointer(&list[0]))
	}

	C.g_key_file_set_boolean_list(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetComment places a comment above key from group_name.
//
// If key is NULL then comment will be written above group_name. If both key and
// group_name are NULL, then comment will be written above the first group in
// the file.
//
// Note that this function prepends a '#' comment marker to each line of
// comment.
//
// The function takes the following parameters:
//
//   - groupName (optional): group name, or NULL.
//   - key (optional): key.
//   - comment: comment.
func (keyFile *KeyFile) SetComment(groupName string, key string, comment string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if key != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(comment)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_key_file_set_comment(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(comment)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetDouble associates a new double value with key under group_name. If key
// cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - value: double value.
func (keyFile *KeyFile) SetDouble(groupName string, key string, value float64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gdouble   // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gdouble(value)

	C.g_key_file_set_double(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetDoubleList associates a list of double values with key under group_name.
// If key cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - list: array of double values.
func (keyFile *KeyFile) SetDoubleList(groupName string, key string, list []float64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gdouble  // out
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = (C.gsize)(len(list))
	if len(list) > 0 {
		_arg3 = (*C.gdouble)(unsafe.Pointer(&list[0]))
	}

	C.g_key_file_set_double_list(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetInt64 associates a new integer value with key under group_name. If key
// cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - value: integer value.
func (keyFile *KeyFile) SetInt64(groupName string, key string, value int64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gint64    // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint64(value)

	C.g_key_file_set_int64(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetInteger associates a new integer value with key under group_name. If key
// cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - value: integer value.
func (keyFile *KeyFile) SetInteger(groupName string, key string, value int) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gint      // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(value)

	C.g_key_file_set_integer(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetIntegerList associates a list of integer values with key under group_name.
// If key cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - list: array of integer values.
func (keyFile *KeyFile) SetIntegerList(groupName string, key string, list []int) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gint     // out
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = (C.gsize)(len(list))
	_arg3 = (*C.gint)(C.calloc(C.size_t(len(list)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.gint)(_arg3), len(list))
		for i := range list {
			out[i] = C.gint(list[i])
		}
	}

	C.g_key_file_set_integer_list(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetListSeparator sets the character which is used to separate values
// in lists. Typically ';' or ',' are used as separators. The default list
// separator is ';'.
//
// The function takes the following parameters:
//
//   - separator: separator.
func (keyFile *KeyFile) SetListSeparator(separator byte) {
	var _arg0 *C.GKeyFile // out
	var _arg1 C.gchar     // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = C.gchar(separator)

	C.g_key_file_set_list_separator(_arg0, _arg1)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(separator)
}

// SetLocaleString associates a string value for key and locale under
// group_name. If the translation for key cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - locale identifier.
//   - str: string.
func (keyFile *KeyFile) SetLocaleString(groupName string, key string, locale string, str string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg4))

	C.g_key_file_set_locale_string(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(str)
}

// SetLocaleStringList associates a list of string values for key and locale
// under group_name. If the translation for key cannot be found then it is
// created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - locale identifier.
//   - list: NULL-terminated array of locale string values.
func (keyFile *KeyFile) SetLocaleStringList(groupName string, key string, locale string, list []string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 **C.gchar   // out
	var _arg5 C.gsize

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg5 = (C.gsize)(len(list))
	_arg4 = (**C.gchar)(C.calloc(C.size_t(len(list)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((**C.gchar)(_arg4), len(list))
		for i := range list {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(list[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_key_file_set_locale_string_list(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(list)
}

// SetString associates a new string value with key under group_name. If key
// cannot be found then it is created. If group_name cannot be found then it is
// created. Unlike g_key_file_set_value(), this function handles characters that
// need escaping, such as newlines.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - str: string.
func (keyFile *KeyFile) SetString(groupName string, key string, str string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_key_file_set_string(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(str)
}

// SetStringList associates a list of string values for key under group_name.
// If key cannot be found then it is created. If group_name cannot be found then
// it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - list: array of string values.
func (keyFile *KeyFile) SetStringList(groupName string, key string, list []string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 **C.gchar   // out
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = (C.gsize)(len(list))
	_arg3 = (**C.gchar)(C.calloc(C.size_t(len(list)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((**C.gchar)(_arg3), len(list))
		for i := range list {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(list[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_key_file_set_string_list(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetUint64 associates a new integer value with key under group_name. If key
// cannot be found then it is created.
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - value: integer value.
func (keyFile *KeyFile) SetUint64(groupName string, key string, value uint64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.guint64   // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint64(value)

	C.g_key_file_set_uint64(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetValue associates a new value with key under group_name.
//
// If key cannot be found then it is created. If group_name cannot be found then
// it is created. To set an UTF-8 string which may contain characters that need
// escaping (such as newlines or spaces), use g_key_file_set_string().
//
// The function takes the following parameters:
//
//   - groupName: group name.
//   - key: key.
//   - value: string.
func (keyFile *KeyFile) SetValue(groupName string, key string, value string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_key_file_set_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// ToData: this function outputs key_file as a string.
//
// Note that this function never reports an error, so it is safe to pass NULL as
// error.
//
// The function returns the following values:
//
//   - length (optional): return location for the length of the returned string,
//     or NULL.
//   - utf8: newly allocated string holding the contents of the File.
func (keyFile *KeyFile) ToData() (uint, string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))

	_cret = C.g_key_file_to_data(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(keyFile)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = uint(_arg1)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _length, _utf8, _goerr
}

func KeyFileErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_key_file_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// LogField: structure representing a single field in a structured log entry.
// See g_log_structured() for details.
//
// Log fields may contain arbitrary values, including binary with embedded nul
// bytes. If the field contains a string, the string must be UTF-8 encoded and
// have a trailing nul byte. Otherwise, length must be set to a non-negative
// value.
//
// An instance of this type is always passed by reference.
type LogField struct {
	*logField
}

// logField is the struct that's finalized.
type logField struct {
	native *C.GLogField
}

// Key: field name (UTF-8 string).
func (l *LogField) Key() string {
	valptr := &l.native.key
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// MainContext: GMainContext struct is an opaque data type representing a set of
// sources to be handled in a main loop.
//
// An instance of this type is always passed by reference.
type MainContext struct {
	*mainContext
}

// mainContext is the struct that's finalized.
type mainContext struct {
	native *C.GMainContext
}

func marshalMainContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MainContext{&mainContext{(*C.GMainContext)(b)}}, nil
}

// NewMainContext constructs a struct MainContext.
func NewMainContext() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_new()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_main_context_unref((*C.GMainContext)(intern.C))
		},
	)

	return _mainContext
}

// NewMainContextWithFlags constructs a struct MainContext.
func NewMainContextWithFlags(flags MainContextFlags) *MainContext {
	var _arg1 C.GMainContextFlags // out
	var _cret *C.GMainContext     // in

	_arg1 = C.GMainContextFlags(flags)

	_cret = C.g_main_context_new_with_flags(_arg1)
	runtime.KeepAlive(flags)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_main_context_unref((*C.GMainContext)(intern.C))
		},
	)

	return _mainContext
}

// Acquire tries to become the owner of the specified context. If some other
// thread is the owner of the context, returns FALSE immediately. Ownership
// is properly recursive: the owner can require ownership again and will
// release ownership when g_main_context_release() is called as many times as
// g_main_context_acquire().
//
// You must be the owner of a context before you can call
// g_main_context_prepare(), g_main_context_query(), g_main_context_check(),
// g_main_context_dispatch(), g_main_context_release().
//
// Since 2.76 context can be NULL to use the global-default main context.
//
// The function returns the following values:
//
//   - ok: TRUE if the operation succeeded, and this thread is now the owner of
//     context.
func (context *MainContext) Acquire() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	_cret = C.g_main_context_acquire(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dispatch dispatches all pending sources.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
//
// Since 2.76 context can be NULL to use the global-default main context.
func (context *MainContext) Dispatch() {
	var _arg0 *C.GMainContext // out

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.g_main_context_dispatch(_arg0)
	runtime.KeepAlive(context)
}

// FindSourceByFuncsUserData finds a source with the given source functions and
// user data. If multiple sources exist with the same source function and user
// data, the first one found will be returned.
//
// The function takes the following parameters:
//
//   - funcs passed to g_source_new().
//   - userData (optional): user data from the callback.
//
// The function returns the following values:
//
//   - source: source, if one was found, otherwise NULL.
func (context *MainContext) FindSourceByFuncsUserData(funcs *SourceFuncs, userData unsafe.Pointer) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.gpointer      // out
	var _cret *C.GSource      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(funcs)))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_main_context_find_source_by_funcs_user_data(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(funcs)
	runtime.KeepAlive(userData)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// FindSourceByID finds a #GSource given a pair of context and ID.
//
// It is a programmer error to attempt to look up a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
//
// The function takes the following parameters:
//
//   - sourceId: source ID, as returned by g_source_get_id().
//
// The function returns the following values:
//
//   - source: #GSource.
func (context *MainContext) FindSourceByID(sourceId uint) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 C.guint         // out
	var _cret *C.GSource      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg1 = C.guint(sourceId)

	_cret = C.g_main_context_find_source_by_id(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(sourceId)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// FindSourceByUserData finds a source with the given user data for the
// callback. If multiple sources exist with the same user data, the first one
// found will be returned.
//
// The function takes the following parameters:
//
//   - userData (optional): user_data for the callback.
//
// The function returns the following values:
//
//   - source: source, if one was found, otherwise NULL.
func (context *MainContext) FindSourceByUserData(userData unsafe.Pointer) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gpointer      // out
	var _cret *C.GSource      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg1 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_main_context_find_source_by_user_data(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(userData)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// InvokeFull invokes a function in such a way that context is owned during the
// invocation of function.
//
// This function is the same as g_main_context_invoke() except that it lets you
// specify the priority in case function ends up being scheduled as an idle and
// also lets you give a Notify for data.
//
// notify should not assume that it is called from any particular thread or with
// any particular context acquired.
//
// The function takes the following parameters:
//
//   - priority at which to run function.
//   - function to call.
func (context *MainContext) InvokeFull(priority int, function SourceFunc) {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // out
	var _arg2 C.GSourceFunc   // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg1 = C.gint(priority)
	_arg2 = (*[0]byte)(C._gotk4_glib2_SourceFunc)
	_arg3 = C.gpointer(gbox.Assign(function))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.g_main_context_invoke_full(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(function)
}

// IsOwner determines whether this thread holds the (recursive) ownership of
// this Context. This is useful to know before waiting on another thread that
// may be blocking to get ownership of context.
//
// The function returns the following values:
//
//   - ok: TRUE if current thread is owner of context.
func (context *MainContext) IsOwner() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	_cret = C.g_main_context_is_owner(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iteration runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed, then if
// no events sources are ready and may_block is TRUE, waiting for a source to
// become ready, then dispatching the highest priority events sources that are
// ready. Otherwise, if may_block is FALSE sources are not waited to become
// ready, only those highest priority events sources will be dispatched (if
// any), that are ready at this given moment without further waiting.
//
// Note that even when may_block is TRUE, it is still possible for
// g_main_context_iteration() to return FALSE, since the wait may be interrupted
// for other reasons than an event source becoming ready.
//
// The function takes the following parameters:
//
//   - mayBlock: whether the call may block.
//
// The function returns the following values:
//
//   - ok: TRUE if events were dispatched.
func (context *MainContext) Iteration(mayBlock bool) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	if mayBlock {
		_arg1 = C.TRUE
	}

	_cret = C.g_main_context_iteration(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(mayBlock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pending checks if any sources have pending events for the given context.
//
// The function returns the following values:
//
//   - ok: TRUE if events are pending.
func (context *MainContext) Pending() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	_cret = C.g_main_context_pending(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopThreadDefault pops context off the thread-default context stack (verifying
// that it was on the top of the stack).
func (context *MainContext) PopThreadDefault() {
	var _arg0 *C.GMainContext // out

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.g_main_context_pop_thread_default(_arg0)
	runtime.KeepAlive(context)
}

// Prepare prepares to poll sources within a main loop. The resulting
// information for polling is determined by calling g_main_context_query ().
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
//
// The function returns the following values:
//
//   - priority (optional): location to store priority of highest priority
//     source already ready.
//   - ok: TRUE if some source is ready to be dispatched prior to polling.
func (context *MainContext) Prepare() (int, bool) {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // in
	var _cret C.gboolean      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	_cret = C.g_main_context_prepare(_arg0, &_arg1)
	runtime.KeepAlive(context)

	var _priority int // out
	var _ok bool      // out

	_priority = int(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _priority, _ok
}

// PushThreadDefault acquires context and sets it as the thread-default context
// for the current thread. This will cause certain asynchronous operations (such
// as most [gio][gio]-based I/O) which are started in this thread to run under
// context and deliver their results to its main loop, rather than running under
// the global default main context in the main thread. Note that calling this
// function changes the context returned by g_main_context_get_thread_default(),
// not the one returned by g_main_context_default(), so it does not affect the
// context used by functions like g_idle_add().
//
// Normally you would call this function shortly after creating a new thread,
// passing it a Context which will be run by a Loop in that thread, to set a new
// default context for all async operations in that thread. In this case you may
// not need to ever call g_main_context_pop_thread_default(), assuming you want
// the new Context to be the default for the whole lifecycle of the thread.
//
// If you don't have control over how the new thread was created (e.g.
// in the new thread isn't newly created, or if the thread life cycle is
// managed by a Pool), it is always suggested to wrap the logic that needs
// to use the new Context inside a g_main_context_push_thread_default() /
// g_main_context_pop_thread_default() pair, otherwise threads that are re-used
// will end up never explicitly releasing the Context reference they hold.
//
// In some cases you may want to schedule a single operation in a non-default
// context, or temporarily use a non-default context in the main thread.
// In that case, you can wrap the call to the asynchronous operation inside a
// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
// pair, but it is up to you to ensure that no other asynchronous operations
// accidentally get started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly
// handle being used from a thread with a thread-default context. Eg, see
// g_file_supports_thread_contexts().
func (context *MainContext) PushThreadDefault() {
	var _arg0 *C.GMainContext // out

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.g_main_context_push_thread_default(_arg0)
	runtime.KeepAlive(context)
}

// Release releases ownership of a context previously acquired by this thread
// with g_main_context_acquire(). If the context was acquired multiple times,
// the ownership will be released only when g_main_context_release() is called
// as many times as it was acquired.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Release() {
	var _arg0 *C.GMainContext // out

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.g_main_context_release(_arg0)
	runtime.KeepAlive(context)
}

// Wakeup: if context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//	perform_work();
//
//	if (g_atomic_int_dec_and_test (&tasks_remaining))
//	  g_main_context_wakeup (NULL);.
func (context *MainContext) Wakeup() {
	var _arg0 *C.GMainContext // out

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.g_main_context_wakeup(_arg0)
	runtime.KeepAlive(context)
}

// MainContextDefault returns the global-default main context. This is
// the main context used for main loop functions when a main loop is not
// explicitly specified, and corresponds to the "main" main loop. See also
// g_main_context_get_thread_default().
//
// The function returns the following values:
//
//   - mainContext: global-default main context.
func MainContextDefault() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_default()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_main_context_unref((*C.GMainContext)(intern.C))
		},
	)

	return _mainContext
}

// MainContextGetThreadDefault gets the thread-default Context for
// this thread. Asynchronous operations that want to be able to be run
// in contexts other than the default one should call this method or
// g_main_context_ref_thread_default() to get a Context to add their #GSources
// to. (Note that even in single-threaded programs applications may sometimes
// want to temporarily push a non-default context, so it is not safe to assume
// that this will always return NULL if you are running in the default thread.)
//
// If you need to hold a reference on the context, use
// g_main_context_ref_thread_default() instead.
//
// The function returns the following values:
//
//   - mainContext (optional): thread-default Context, or NULL if the
//     thread-default context is the global-default main context.
func MainContextGetThreadDefault() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_get_thread_default()

	var _mainContext *MainContext // out

	if _cret != nil {
		_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_main_context_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_mainContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_main_context_unref((*C.GMainContext)(intern.C))
			},
		)
	}

	return _mainContext
}

// MainContextRefThreadDefault gets the thread-default Context for this
// thread, as with g_main_context_get_thread_default(), but also adds
// a reference to it with g_main_context_ref(). In addition, unlike
// g_main_context_get_thread_default(), if the thread-default context is the
// global-default context, this will return that Context (with a ref added to
// it) rather than returning NULL.
//
// The function returns the following values:
//
//   - mainContext: thread-default Context. Unref with g_main_context_unref()
//     when you are done with it.
func MainContextRefThreadDefault() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_ref_thread_default()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_main_context_unref((*C.GMainContext)(intern.C))
		},
	)

	return _mainContext
}

// MainLoop: GMainLoop struct is an opaque data type representing the main event
// loop of a GLib or GTK application.
//
// An instance of this type is always passed by reference.
type MainLoop struct {
	*mainLoop
}

// mainLoop is the struct that's finalized.
type mainLoop struct {
	native *C.GMainLoop
}

func marshalMainLoop(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MainLoop{&mainLoop{(*C.GMainLoop)(b)}}, nil
}

// NewMainLoop constructs a struct MainLoop.
func NewMainLoop(context *MainContext, isRunning bool) *MainLoop {
	var _arg1 *C.GMainContext // out
	var _arg2 C.gboolean      // out
	var _cret *C.GMainLoop    // in

	if context != nil {
		_arg1 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	if isRunning {
		_arg2 = C.TRUE
	}

	_cret = C.g_main_loop_new(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(isRunning)

	var _mainLoop *MainLoop // out

	_mainLoop = (*MainLoop)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainLoop)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_main_loop_unref((*C.GMainLoop)(intern.C))
		},
	)

	return _mainLoop
}

// Context returns the Context of loop.
//
// The function returns the following values:
//
//   - mainContext of loop.
func (loop *MainLoop) Context() *MainContext {
	var _arg0 *C.GMainLoop    // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	_cret = C.g_main_loop_get_context(_arg0)
	runtime.KeepAlive(loop)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_main_context_unref((*C.GMainContext)(intern.C))
		},
	)

	return _mainContext
}

// IsRunning checks to see if the main loop is currently being run via
// g_main_loop_run().
//
// The function returns the following values:
//
//   - ok: TRUE if the mainloop is currently being run.
func (loop *MainLoop) IsRunning() bool {
	var _arg0 *C.GMainLoop // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	_cret = C.g_main_loop_is_running(_arg0)
	runtime.KeepAlive(loop)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Quit stops a Loop from running. Any calls to g_main_loop_run() for the loop
// will return.
//
// Note that sources that have already been dispatched when g_main_loop_quit()
// is called will still be executed.
func (loop *MainLoop) Quit() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	C.g_main_loop_quit(_arg0)
	runtime.KeepAlive(loop)
}

// Run runs a main loop until g_main_loop_quit() is called on the loop. If this
// is called for the thread of the loop's Context, it will process events from
// the loop, otherwise it will simply wait.
func (loop *MainLoop) Run() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	C.g_main_loop_run(_arg0)
	runtime.KeepAlive(loop)
}

// MappedFile represents a file mapping created with g_mapped_file_new().
// It has only private members and should not be accessed directly.
//
// An instance of this type is always passed by reference.
type MappedFile struct {
	*mappedFile
}

// mappedFile is the struct that's finalized.
type mappedFile struct {
	native *C.GMappedFile
}

func marshalMappedFile(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MappedFile{&mappedFile{(*C.GMappedFile)(b)}}, nil
}

// NewMappedFile constructs a struct MappedFile.
func NewMappedFile(filename string, writable bool) (*MappedFile, error) {
	var _arg1 *C.gchar       // out
	var _arg2 C.gboolean     // out
	var _cret *C.GMappedFile // in
	var _cerr *C.GError      // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	if writable {
		_arg2 = C.TRUE
	}

	_cret = C.g_mapped_file_new(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(writable)

	var _mappedFile *MappedFile // out
	var _goerr error            // out

	_mappedFile = (*MappedFile)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mappedFile)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_mapped_file_unref((*C.GMappedFile)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _mappedFile, _goerr
}

// NewMappedFileFromFd constructs a struct MappedFile.
func NewMappedFileFromFd(fd int, writable bool) (*MappedFile, error) {
	var _arg1 C.gint         // out
	var _arg2 C.gboolean     // out
	var _cret *C.GMappedFile // in
	var _cerr *C.GError      // in

	_arg1 = C.gint(fd)
	if writable {
		_arg2 = C.TRUE
	}

	_cret = C.g_mapped_file_new_from_fd(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(writable)

	var _mappedFile *MappedFile // out
	var _goerr error            // out

	_mappedFile = (*MappedFile)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mappedFile)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_mapped_file_unref((*C.GMappedFile)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _mappedFile, _goerr
}

// Bytes creates a new #GBytes which references the data mapped from file.
// The mapped contents of the file must not be modified after creating this
// bytes object, because a #GBytes should be immutable.
//
// The function returns the following values:
//
//   - bytes: newly allocated #GBytes referencing data from file.
func (file *MappedFile) Bytes() *Bytes {
	var _arg0 *C.GMappedFile // out
	var _cret *C.GBytes      // in

	_arg0 = (*C.GMappedFile)(gextras.StructNative(unsafe.Pointer(file)))

	_cret = C.g_mapped_file_get_bytes(_arg0)
	runtime.KeepAlive(file)

	var _bytes *Bytes // out

	_bytes = (*Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Contents returns the contents of a File.
//
// Note that the contents may not be zero-terminated, even if the File is backed
// by a text file.
//
// If the file is empty then NULL is returned.
//
// The function returns the following values:
//
//   - utf8 contents of file, or NULL.
func (file *MappedFile) Contents() string {
	var _arg0 *C.GMappedFile // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GMappedFile)(gextras.StructNative(unsafe.Pointer(file)))

	_cret = C.g_mapped_file_get_contents(_arg0)
	runtime.KeepAlive(file)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Length returns the length of the contents of a File.
//
// The function returns the following values:
//
//   - gsize: length of the contents of file.
func (file *MappedFile) Length() uint {
	var _arg0 *C.GMappedFile // out
	var _cret C.gsize        // in

	_arg0 = (*C.GMappedFile)(gextras.StructNative(unsafe.Pointer(file)))

	_cret = C.g_mapped_file_get_length(_arg0)
	runtime.KeepAlive(file)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// MarkupParseContext: parse context is used to parse a stream of bytes that you
// expect to contain marked-up text.
//
// See g_markup_parse_context_new(), Parser, and so on for more details.
//
// An instance of this type is always passed by reference.
type MarkupParseContext struct {
	*markupParseContext
}

// markupParseContext is the struct that's finalized.
type markupParseContext struct {
	native *C.GMarkupParseContext
}

func marshalMarkupParseContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MarkupParseContext{&markupParseContext{(*C.GMarkupParseContext)(b)}}, nil
}

// EndParse signals to the ParseContext that all data has been fed into the
// parse context with g_markup_parse_context_parse().
//
// This function reports an error if the document isn't complete, for example if
// elements are still open.
func (context *MarkupParseContext) EndParse() error {
	var _arg0 *C.GMarkupParseContext // out
	var _cerr *C.GError              // in

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.g_markup_parse_context_end_parse(_arg0, &_cerr)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Element retrieves the name of the currently open element.
//
// If called from the start_element or end_element handlers this will give
// the element_name as passed to those functions. For the parent elements,
// see g_markup_parse_context_get_element_stack().
//
// The function returns the following values:
//
//   - utf8: name of the currently open element, or NULL.
func (context *MarkupParseContext) Element() string {
	var _arg0 *C.GMarkupParseContext // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.g_markup_parse_context_get_element(_arg0)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ElementStack retrieves the element stack from the internal state of the
// parser.
//
// The returned List is a list of strings where the first item is the currently
// open tag (as would be returned by g_markup_parse_context_get_element()) and
// the next item is its immediate parent.
//
// This function is intended to be used in the start_element and end_element
// handlers where g_markup_parse_context_get_element() would merely return the
// name of the element that is being processed.
//
// The function returns the following values:
//
//   - sList: element stack, which must not be modified.
func (context *MarkupParseContext) ElementStack() []string {
	var _arg0 *C.GMarkupParseContext // out
	var _cret *C.GSList              // in

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.g_markup_parse_context_get_element_stack(_arg0)
	runtime.KeepAlive(context)

	var _sList []string // out

	_sList = make([]string, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// Position retrieves the current line number and the number of the character on
// that line. Intended for use in error messages; there are no strict semantics
// for what constitutes the "current" line number other than "the best number we
// could come up with for error messages.".
//
// The function returns the following values:
//
//   - lineNumber (optional): return location for a line number, or NULL.
//   - charNumber (optional): return location for a char-on-line number,
//     or NULL.
func (context *MarkupParseContext) Position() (lineNumber int, charNumber int) {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 C.gint                 // in
	var _arg2 C.gint                 // in

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.g_markup_parse_context_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _lineNumber int // out
	var _charNumber int // out

	_lineNumber = int(_arg1)
	_charNumber = int(_arg2)

	return _lineNumber, _charNumber
}

// UserData returns the user_data associated with context.
//
// This will either be the user_data that was provided to
// g_markup_parse_context_new() or to the most recent call of
// g_markup_parse_context_push().
//
// The function returns the following values:
//
//   - gpointer (optional): provided user_data. The returned data belongs to the
//     markup context and will be freed when g_markup_parse_context_free() is
//     called.
func (context *MarkupParseContext) UserData() unsafe.Pointer {
	var _arg0 *C.GMarkupParseContext // out
	var _cret C.gpointer             // in

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.g_markup_parse_context_get_user_data(_arg0)
	runtime.KeepAlive(context)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Parse: feed some data to the ParseContext.
//
// The data need not be valid UTF-8; an error will be signaled if it's invalid.
// The data need not be an entire document; you can feed a document into the
// parser incrementally, via multiple calls to this function. Typically,
// as you receive data from a network connection or file, you feed each received
// chunk of data into this function, aborting the process if an error occurs.
// Once an error is reported, no further data may be fed to the ParseContext;
// all errors are fatal.
//
// The function takes the following parameters:
//
//   - text: chunk of text to parse.
func (context *MarkupParseContext) Parse(text string) error {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 *C.gchar               // out
	var _arg2 C.gssize
	var _cerr *C.GError // in

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	_arg2 = (C.gssize)(len(text))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.g_markup_parse_context_parse(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(text)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Pop completes the process of a temporary sub-parser redirection.
//
// This function exists to collect the user_data allocated by a matching call
// to g_markup_parse_context_push(). It must be called in the end_element
// handler corresponding to the start_element handler during which
// g_markup_parse_context_push() was called. You must not call this function
// from the error callback -- the user_data is provided directly to the callback
// in that case.
//
// This function is not intended to be directly called by users interested in
// invoking subparsers. Instead, it is intended to be used by the subparsers
// themselves to implement a higher-level interface.
//
// The function returns the following values:
//
//   - gpointer (optional): user data passed to g_markup_parse_context_push().
func (context *MarkupParseContext) Pop() unsafe.Pointer {
	var _arg0 *C.GMarkupParseContext // out
	var _cret C.gpointer             // in

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.g_markup_parse_context_pop(_arg0)
	runtime.KeepAlive(context)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Push: temporarily redirects markup data to a sub-parser.
//
// This function may only be called from the start_element handler of a Parser.
// It must be matched with a corresponding call to g_markup_parse_context_pop()
// in the matching end_element handler (except in the case that the parser
// aborts due to an error).
//
// All tags, text and other data between the matching tags is redirected to
// the subparser given by parser. user_data is used as the user_data for that
// parser. user_data is also passed to the error callback in the event that an
// error occurs. This includes errors that occur in subparsers of the subparser.
//
// The end tag matching the start tag for which this call was made is handled
// by the previous parser (which is given its own user_data) which is why
// g_markup_parse_context_pop() is provided to allow "one last access" to the
// user_data provided to this function. In the case of error, the user_data
// provided here is passed directly to the error callback of the subparser
// and g_markup_parse_context_pop() should not be called. In either case,
// if user_data was allocated then it ought to be freed from both of these
// locations.
//
// This function is not intended to be directly called by users interested in
// invoking subparsers. Instead, it is intended to be used by the subparsers
// themselves to implement a higher-level interface.
//
// As an example, see the following implementation of a simple parser that
// counts the number of tags encountered.
//
//	static void start_element (context, element_name, ...)
//	{
//	  if (strcmp (element_name, "count-these") == 0)
//	    start_counting (context);
//
//	  // else, handle other tags...
//	}
//
//	static void end_element (context, element_name, ...)
//	{
//	  if (strcmp (element_name, "count-these") == 0)
//	    g_print ("Counted d tags\n", end_counting (context));
//
//	  // else, handle other tags...
//	}.
//
// The function takes the following parameters:
//
//   - parser: Parser.
//   - userData (optional): user data to pass to Parser functions.
func (context *MarkupParseContext) Push(parser *MarkupParser, userData unsafe.Pointer) {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 *C.GMarkupParser       // out
	var _arg2 C.gpointer             // out

	_arg0 = (*C.GMarkupParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	_arg1 = (*C.GMarkupParser)(gextras.StructNative(unsafe.Pointer(parser)))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	C.g_markup_parse_context_push(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(parser)
	runtime.KeepAlive(userData)
}

// MarkupParser: any of the fields in Parser can be NULL, in which case they
// will be ignored. Except for the error function, any of these callbacks
// can set an error; in particular the G_MARKUP_ERROR_UNKNOWN_ELEMENT,
// G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and G_MARKUP_ERROR_INVALID_CONTENT errors
// are intended to be set from these callbacks. If you set an error from a
// callback, g_markup_parse_context_parse() will report that error back to its
// caller.
//
// An instance of this type is always passed by reference.
type MarkupParser struct {
	*markupParser
}

// markupParser is the struct that's finalized.
type markupParser struct {
	native *C.GMarkupParser
}

// MatchInfo is an opaque struct used to return information about matches.
//
// An instance of this type is always passed by reference.
type MatchInfo struct {
	*matchInfo
}

// matchInfo is the struct that's finalized.
type matchInfo struct {
	native *C.GMatchInfo
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MatchInfo{&matchInfo{(*C.GMatchInfo)(b)}}, nil
}

// ExpandReferences returns a new string containing the text in string_to_expand
// with references and escape sequences expanded. References refer to the
// last match done with string against regex and have the same syntax used by
// g_regex_replace().
//
// The string_to_expand must be UTF-8 encoded even if G_REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// match_info may be NULL in which case string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether string_to_expand contains references.
//
// The function takes the following parameters:
//
//   - stringToExpand: string to expand.
//
// The function returns the following values:
//
//   - utf8 (optional): expanded string, or NULL if an error occurred.
func (matchInfo *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in
	var _cerr *C.GError     // in

	if matchInfo != nil {
		_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(stringToExpand)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(stringToExpand)

	var _utf8 string // out
	var _goerr error // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// Fetch retrieves the text matching the match_num'th capturing parentheses.
// 0 is the full text of the match, 1 is the first paren set, 2 the second,
// and so on.
//
// If match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
//
// The function takes the following parameters:
//
//   - matchNum: number of the sub expression.
//
// The function returns the following values:
//
//   - utf8 (optional): matched substring, or NULL if an error occurred.
//     You have to free the string yourself.
func (matchInfo *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch(_arg0, _arg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of gchar * pointers. It must be freed using
//     g_strfreev(). If the previous match failed NULL is returned.
func (matchInfo *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out
	var _cret **C.gchar     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_fetch_all(_arg0)
	runtime.KeepAlive(matchInfo)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// FetchNamed retrieves the text matching the capturing parentheses named name.
//
// If name is a valid sub pattern name but it didn't match anything (e.g.
// sub pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
//
// The function takes the following parameters:
//
//   - name of the subexpression.
//
// The function returns the following values:
//
//   - utf8 (optional): matched substring, or NULL if an error occurred.
//     You have to free the string yourself.
func (matchInfo *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named name.
//
// If name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then start_pos and end_pos
// are set to -1 and TRUE is returned.
//
// The function takes the following parameters:
//
//   - name of the subexpression.
//
// The function returns the following values:
//
//   - startPos (optional): pointer to location where to store the start
//     position, or NULL.
//   - endPos (optional): pointer to location where to store the end position,
//     or NULL.
//   - ok: TRUE if the position was fetched, FALSE otherwise. If the position
//     cannot be fetched, start_pos and end_pos are left unchanged.
func (matchInfo *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos retrieves the position in bytes of the match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set,
// 2 the second, and so on.
//
// If match_num is a valid sub pattern but it didn't match anything (e.g.
// sub pattern 1, matching "b" against "(a)?b") then start_pos and end_pos are
// set to -1 and TRUE is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
//
// The function takes the following parameters:
//
//   - matchNum: number of the sub expression.
//
// The function returns the following values:
//
//   - startPos (optional): pointer to location where to store the start
//     position, or NULL.
//   - endPos (optional): pointer to location where to store the end position,
//     or NULL.
//   - ok: TRUE if the position was fetched, FALSE otherwise. If the position
//     cannot be fetched, start_pos and end_pos are left unchanged.
func (matchInfo *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
//
// The function returns the following values:
//
//   - gint: number of matched substrings, or -1 if an error occurred.
func (matchInfo *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gint        // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_match_count(_arg0)
	runtime.KeepAlive(matchInfo)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Regex returns #GRegex object used in match_info. It belongs to Glib and
// must not be freed. Use g_regex_ref() if you need to keep it after you free
// match_info object.
//
// The function returns the following values:
//
//   - regex object used in match_info.
func (matchInfo *MatchInfo) Regex() *Regex {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GRegex     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_regex(_arg0)
	runtime.KeepAlive(matchInfo)

	var _regex *Regex // out

	_regex = (*Regex)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_regex_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_regex)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_regex_unref((*C.GRegex)(intern.C))
		},
	)

	return _regex
}

// String returns the string searched with match_info. This is the string passed
// to g_regex_match() or g_regex_replace() so you may not free it before calling
// this function.
//
// The function returns the following values:
//
//   - utf8: string searched with match_info.
func (matchInfo *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_string(_arg0)
	runtime.KeepAlive(matchInfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches
// as far as it goes, but is too short to match the entire pattern, FALSE is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to
// type in data for a field with specific formatting requirements.
// An example might be a date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// G_REGEX_MATCH_PARTIAL_SOFT and G_REGEX_MATCH_PARTIAL_HARD flags. When they
// are used, the return code for g_regex_match() or g_regex_match_full() is,
// as usual, TRUE for a complete match, FALSE otherwise. But, when these
// functions return FALSE, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between G_REGEX_MATCH_PARTIAL_SOFT and
// G_REGEX_MATCH_PARTIAL_HARD is that when a partial match is encountered
// with G_REGEX_MATCH_PARTIAL_SOFT, matching continues to search for a
// possible complete match, while with G_REGEX_MATCH_PARTIAL_HARD matching
// stops at the partial match. When both G_REGEX_MATCH_PARTIAL_SOFT and
// G_REGEX_MATCH_PARTIAL_HARD are set, the latter takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
//
// The function returns the following values:
//
//   - ok: TRUE if the match was partial, FALSE otherwise.
func (matchInfo *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_is_partial_match(_arg0)
	runtime.KeepAlive(matchInfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches returns whether the previous match operation succeeded.
//
// The function returns the following values:
//
//   - ok: TRUE if the previous match operation succeeded, FALSE otherwise.
func (matchInfo *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_matches(_arg0)
	runtime.KeepAlive(matchInfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (matchInfo *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	C.g_match_info_next(_arg0, &_cerr)
	runtime.KeepAlive(matchInfo)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Node struct represents one node in a [n-ary tree][glib-N-ary-Trees].
//
// An instance of this type is always passed by reference.
type Node struct {
	*node
}

// node is the struct that's finalized.
type node struct {
	native *C.GNode
}

// Data contains the actual data of the node.
func (n *Node) Data() unsafe.Pointer {
	valptr := &n.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Next points to the node's next sibling (a sibling is another #GNode with the
// same parent).
func (n *Node) Next() *Node {
	valptr := &n.native.next
	var _v *Node // out
	_v = (*Node)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Prev points to the node's previous sibling.
func (n *Node) Prev() *Node {
	valptr := &n.native.prev
	var _v *Node // out
	_v = (*Node)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Parent points to the parent of the #GNode, or is NULL if the #GNode is the
// root of the tree.
func (n *Node) Parent() *Node {
	valptr := &n.native.parent
	var _v *Node // out
	_v = (*Node)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Children points to the first child of the #GNode. The other children are
// accessed by using the next pointer of each child.
func (n *Node) Children() *Node {
	valptr := &n.native.children
	var _v *Node // out
	_v = (*Node)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// ChildIndex gets the position of the first child of a #GNode which contains
// the given data.
//
// The function takes the following parameters:
//
//   - data (optional) to find.
//
// The function returns the following values:
//
//   - gint: index of the child of node which contains data, or -1 if the data
//     is not found.
func (node *Node) ChildIndex(data unsafe.Pointer) int {
	var _arg0 *C.GNode   // out
	var _arg1 C.gpointer // out
	var _cret C.gint     // in

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(node)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.g_node_child_index(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(data)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ChildPosition gets the position of a #GNode with respect to its siblings.
// child must be a child of node. The first child is numbered 0, the second 1,
// and so on.
//
// The function takes the following parameters:
//
//   - child of node.
//
// The function returns the following values:
//
//   - gint: position of child with respect to its siblings.
func (node *Node) ChildPosition(child *Node) int {
	var _arg0 *C.GNode // out
	var _arg1 *C.GNode // out
	var _cret C.gint   // in

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(node)))
	_arg1 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(child)))

	_cret = C.g_node_child_position(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Depth gets the depth of a #GNode.
//
// If node is NULL the depth is 0. The root node has a depth of 1. For the
// children of the root node the depth is 2. And so on.
//
// The function returns the following values:
//
//   - guint: depth of the #GNode.
func (node *Node) Depth() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(node)))

	_cret = C.g_node_depth(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Destroy removes root and its children from the tree, freeing any memory
// allocated.
func (root *Node) Destroy() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(root)))

	C.g_node_destroy(_arg0)
	runtime.KeepAlive(root)
}

// IsAncestor returns TRUE if node is an ancestor of descendant. This is true if
// node is the parent of descendant, or if node is the grandparent of descendant
// etc.
//
// The function takes the following parameters:
//
//   - descendant: #GNode.
//
// The function returns the following values:
//
//   - ok: TRUE if node is an ancestor of descendant.
func (node *Node) IsAncestor(descendant *Node) bool {
	var _arg0 *C.GNode   // out
	var _arg1 *C.GNode   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(node)))
	_arg1 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(descendant)))

	_cret = C.g_node_is_ancestor(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(descendant)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxHeight gets the maximum height of all branches beneath a #GNode. This is
// the maximum distance from the #GNode to all leaf nodes.
//
// If root is NULL, 0 is returned. If root has no children, 1 is returned.
// If root has children, 2 is returned. And so on.
//
// The function returns the following values:
//
//   - guint: maximum height of the tree beneath root.
func (root *Node) MaxHeight() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(root)))

	_cret = C.g_node_max_height(_arg0)
	runtime.KeepAlive(root)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NChildren gets the number of children of a #GNode.
//
// The function returns the following values:
//
//   - guint: number of children of node.
func (node *Node) NChildren() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(node)))

	_cret = C.g_node_n_children(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NNodes gets the number of nodes in a tree.
//
// The function takes the following parameters:
//
//   - flags: which types of children are to be counted, one of G_TRAVERSE_ALL,
//     G_TRAVERSE_LEAVES and G_TRAVERSE_NON_LEAVES.
//
// The function returns the following values:
//
//   - guint: number of nodes in the tree.
func (root *Node) NNodes(flags TraverseFlags) uint {
	var _arg0 *C.GNode         // out
	var _arg1 C.GTraverseFlags // out
	var _cret C.guint          // in

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(root)))
	_arg1 = C.GTraverseFlags(flags)

	_cret = C.g_node_n_nodes(_arg0, _arg1)
	runtime.KeepAlive(root)
	runtime.KeepAlive(flags)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ReverseChildren reverses the order of the children of a #GNode. (It doesn't
// change the order of the grandchildren.).
func (node *Node) ReverseChildren() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(node)))

	C.g_node_reverse_children(_arg0)
	runtime.KeepAlive(node)
}

// Unlink unlinks a #GNode from a tree, resulting in two separate trees.
func (node *Node) Unlink() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(gextras.StructNative(unsafe.Pointer(node)))

	C.g_node_unlink(_arg0)
	runtime.KeepAlive(node)
}

func NodePopAllocator() {
	C.g_node_pop_allocator()
}

// OptionEntry struct defines a single option. To have an effect,
// they must be added to a Group with g_option_context_add_main_entries() or
// g_option_group_add_entries().
//
// An instance of this type is always passed by reference.
type OptionEntry struct {
	*optionEntry
}

// optionEntry is the struct that's finalized.
type optionEntry struct {
	native *C.GOptionEntry
}

// LongName: long name of an option can be used to specify it in a commandline
// as --long_name. Every option must have a long name. To resolve conflicts if
// multiple option groups contain the same long name, it is also possible to
// specify the option as --groupname-long_name.
func (o *OptionEntry) LongName() string {
	valptr := &o.native.long_name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ShortName: if an option has a short name, it can be specified -short_name in
// a commandline. short_name must be a printable ASCII character different from
// '-', or zero if the option has no short name.
func (o *OptionEntry) ShortName() byte {
	valptr := &o.native.short_name
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// Flags from Flags.
func (o *OptionEntry) Flags() int {
	valptr := &o.native.flags
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Arg: type of the option, as a Arg.
func (o *OptionEntry) Arg() OptionArg {
	valptr := &o.native.arg
	var _v OptionArg // out
	_v = OptionArg(*valptr)
	return _v
}

// ArgData: if the arg type is G_OPTION_ARG_CALLBACK, then arg_data must
// point to a ArgFunc callback function, which will be called to handle the
// extra argument. Otherwise, arg_data is a pointer to a location to store
// the value, the required type of the location depends on the arg type: -
// G_OPTION_ARG_NONE: gboolean - G_OPTION_ARG_STRING: gchar* - G_OPTION_ARG_INT:
// gint - G_OPTION_ARG_FILENAME: gchar* - G_OPTION_ARG_STRING_ARRAY:
// gchar** - G_OPTION_ARG_FILENAME_ARRAY: gchar** - G_OPTION_ARG_DOUBLE:
// gdouble If arg type is G_OPTION_ARG_STRING or G_OPTION_ARG_FILENAME,
// the location will contain a newly allocated string if the option was given.
// That string needs to be freed by the callee using g_free(). Likewise if arg
// type is G_OPTION_ARG_STRING_ARRAY or G_OPTION_ARG_FILENAME_ARRAY, the data
// should be freed using g_strfreev().
func (o *OptionEntry) ArgData() unsafe.Pointer {
	valptr := &o.native.arg_data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Description: description for the option in --help output. The
// description is translated using the translate_func of the group, see
// g_option_group_set_translation_domain().
func (o *OptionEntry) Description() string {
	valptr := &o.native.description
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ArgDescription: placeholder to use for the extra argument parsed by the
// option in --help output. The arg_description is translated using the
// translate_func of the group, see g_option_group_set_translation_domain().
func (o *OptionEntry) ArgDescription() string {
	valptr := &o.native.arg_description
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ShortName: if an option has a short name, it can be specified -short_name in
// a commandline. short_name must be a printable ASCII character different from
// '-', or zero if the option has no short name.
func (o *OptionEntry) SetShortName(shortName byte) {
	valptr := &o.native.short_name
	*valptr = C.gchar(shortName)
}

// Flags from Flags.
func (o *OptionEntry) SetFlags(flags int) {
	valptr := &o.native.flags
	*valptr = C.gint(flags)
}

// OptionGroup: GOptionGroup struct defines the options in a single group.
// The struct has only private fields and should not be directly accessed.
//
// All options in a group share the same translation function. Libraries which
// need to parse commandline options are expected to provide a function for
// getting a GOptionGroup holding their options, which the application can then
// add to its Context.
//
// An instance of this type is always passed by reference.
type OptionGroup struct {
	*optionGroup
}

// optionGroup is the struct that's finalized.
type optionGroup struct {
	native *C.GOptionGroup
}

func marshalOptionGroup(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &OptionGroup{&optionGroup{(*C.GOptionGroup)(b)}}, nil
}

// AddEntries adds the options specified in entries to group.
//
// The function takes the following parameters:
//
//   - entries: NULL-terminated array of Entrys.
func (group *OptionGroup) AddEntries(entries []OptionEntry) {
	var _arg0 *C.GOptionGroup // out
	var _arg1 *C.GOptionEntry // out

	_arg0 = (*C.GOptionGroup)(gextras.StructNative(unsafe.Pointer(group)))
	{
		_arg1 = (*C.GOptionEntry)(C.calloc(C.size_t((len(entries) + 1)), C.size_t(C.sizeof_GOptionEntry)))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(entries)+1)
			var zero C.GOptionEntry
			out[len(entries)] = zero
			for i := range entries {
				out[i] = *(*C.GOptionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
			}
		}
	}

	C.g_option_group_add_entries(_arg0, _arg1)
	runtime.KeepAlive(group)
	runtime.KeepAlive(entries)
}

// SetTranslationDomain: convenience function to use gettext() for translating
// user-visible strings.
//
// The function takes the following parameters:
//
//   - domain to use.
func (group *OptionGroup) SetTranslationDomain(domain string) {
	var _arg0 *C.GOptionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GOptionGroup)(gextras.StructNative(unsafe.Pointer(group)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_option_group_set_translation_domain(_arg0, _arg1)
	runtime.KeepAlive(group)
	runtime.KeepAlive(domain)
}

// PathBuf: GPathBuf is a helper type that allows you to easily build paths
// from individual elements, using the platform specific conventions for path
// separators.
//
//	g_auto (GPathBuf) path;
//
//	g_path_buf_init (&path);
//
//	g_path_buf_push (&path, "usr");
//	g_path_buf_push (&path, "bin");
//	g_path_buf_push (&path, "echo");
//
//	g_autofree char *echo = g_path_buf_to_path (&path);
//	g_assert_cmpstr (echo, ==, "/usr/bin/echo");
//
// You can also load a full path and then operate on its components:
//
//	g_auto (GPathBuf) path;
//
//	g_path_buf_init_from_path (&path, "/usr/bin/echo");
//
//	g_path_buf_pop (&path);
//	g_path_buf_push (&path, "sh");
//
//	g_autofree char *sh = g_path_buf_to_path (&path);
//	g_assert_cmpstr (sh, ==, "/usr/bin/sh");
//
// An instance of this type is always passed by reference.
type PathBuf struct {
	*pathBuf
}

// pathBuf is the struct that's finalized.
type pathBuf struct {
	native *C.GPathBuf
}

// Clear clears the contents of the path buffer.
//
// This function should be use to free the resources in a stack-allocated
// GPathBuf initialized using g_path_buf_init() or g_path_buf_init_from_path().
func (buf *PathBuf) Clear() {
	var _arg0 *C.GPathBuf // out

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))

	C.g_path_buf_clear(_arg0)
	runtime.KeepAlive(buf)
}

// ClearToPath clears the contents of the path buffer and returns the built
// path.
//
// This function returns NULL if the GPathBuf is empty.
//
// See also: g_path_buf_to_path().
//
// The function returns the following values:
//
//   - filename (optional): built path.
func (buf *PathBuf) ClearToPath() string {
	var _arg0 *C.GPathBuf // out
	var _cret *C.char     // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C.g_path_buf_clear_to_path(_arg0)
	runtime.KeepAlive(buf)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// FreeToPath frees a GPathBuf allocated by g_path_buf_new(), and returns the
// path inside the buffer.
//
// This function returns NULL if the GPathBuf is empty.
//
// See also: g_path_buf_to_path().
//
// The function returns the following values:
//
//   - filename (optional): path.
func (buf *PathBuf) FreeToPath() string {
	var _arg0 *C.GPathBuf // out
	var _cret *C.char     // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf)), nil)

	_cret = C.g_path_buf_free_to_path(_arg0)
	runtime.KeepAlive(buf)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// Init initializes a GPathBuf instance.
//
// The function returns the following values:
//
//   - pathBuf: initialized path builder.
func (buf *PathBuf) Init() *PathBuf {
	var _arg0 *C.GPathBuf // out
	var _cret *C.GPathBuf // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C.g_path_buf_init(_arg0)
	runtime.KeepAlive(buf)

	var _pathBuf *PathBuf // out

	_pathBuf = (*PathBuf)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _pathBuf
}

// InitFromPath initializes a GPathBuf instance with the given path.
//
// The function takes the following parameters:
//
//   - path (optional): file system path.
//
// The function returns the following values:
//
//   - pathBuf: initialized path builder.
func (buf *PathBuf) InitFromPath(path string) *PathBuf {
	var _arg0 *C.GPathBuf // out
	var _arg1 *C.char     // out
	var _cret *C.GPathBuf // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_path_buf_init_from_path(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(path)

	var _pathBuf *PathBuf // out

	_pathBuf = (*PathBuf)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _pathBuf
}

// Pop removes the last element of the path buffer.
//
// If there is only one element in the path buffer (for example, / on Unix-like
// operating systems or the drive on Windows systems), it will not be removed
// and FALSE will be returned instead.
//
//	GPathBuf buf, cmp;
//
//	g_path_buf_init_from_path (&buf, "/bin/sh");
//
//	g_path_buf_pop (&buf);
//	g_path_buf_init_from_path (&cmp, "/bin");
//	g_assert_true (g_path_buf_equal (&buf, &cmp));
//	g_path_buf_clear (&cmp);
//
//	g_path_buf_pop (&buf);
//	g_path_buf_init_from_path (&cmp, "/");
//	g_assert_true (g_path_buf_equal (&buf, &cmp));
//	g_path_buf_clear (&cmp);
//
//	g_path_buf_clear (&buf);.
//
// The function returns the following values:
//
//   - ok: TRUE if the buffer was modified and FALSE otherwise.
func (buf *PathBuf) Pop() bool {
	var _arg0 *C.GPathBuf // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C.g_path_buf_pop(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Push extends the given path buffer with path.
//
// If path is absolute, it replaces the current path.
//
// If path contains a directory separator, the buffer is extended by as many
// elements the path provides.
//
// On Windows, both forward slashes and backslashes are treated as directory
// separators. On other platforms, G_DIR_SEPARATOR_S is the only directory
// separator.
//
//	GPathBuf buf, cmp;
//
//	g_path_buf_init_from_path (&buf, "/tmp");
//	g_path_buf_push (&buf, ".X11-unix/X0");
//	g_path_buf_init_from_path (&cmp, "/tmp/.X11-unix/X0");
//	g_assert_true (g_path_buf_equal (&buf, &cmp));
//	g_path_buf_clear (&cmp);
//
//	g_path_buf_push (&buf, "/etc/locale.conf");
//	g_path_buf_init_from_path (&cmp, "/etc/locale.conf");
//	g_assert_true (g_path_buf_equal (&buf, &cmp));
//	g_path_buf_clear (&cmp);
//
//	g_path_buf_clear (&buf);.
//
// The function takes the following parameters:
//
//   - path: path.
//
// The function returns the following values:
//
//   - pathBuf: same pointer to buf, for convenience.
func (buf *PathBuf) Push(path string) *PathBuf {
	var _arg0 *C.GPathBuf // out
	var _arg1 *C.char     // out
	var _cret *C.GPathBuf // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_buf_push(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(path)

	var _pathBuf *PathBuf // out

	_pathBuf = (*PathBuf)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _pathBuf
}

// SetExtension adds an extension to the file name in the path buffer.
//
// If extension is NULL, the extension will be unset.
//
// If the path buffer does not have a file name set, this function returns FALSE
// and leaves the path buffer unmodified.
//
// The function takes the following parameters:
//
//   - extension (optional): file extension.
//
// The function returns the following values:
//
//   - ok: TRUE if the extension was replaced, and FALSE otherwise.
func (buf *PathBuf) SetExtension(extension string) bool {
	var _arg0 *C.GPathBuf // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))
	if extension != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_path_buf_set_extension(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(extension)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFilename sets the file name of the path.
//
// If the path buffer is empty, the filename is left unset and this function
// returns FALSE.
//
// If the path buffer only contains the root element (on Unix-like operating
// systems) or the drive (on Windows), this is the equivalent of pushing the new
// file_name.
//
// If the path buffer contains a path, this is the equivalent of popping the
// path buffer and pushing file_name, creating a sibling of the original path.
//
//	GPathBuf buf, cmp;
//
//	g_path_buf_init_from_path (&buf, "/");
//
//	g_path_buf_set_filename (&buf, "bar");
//	g_path_buf_init_from_path (&cmp, "/bar");
//	g_assert_true (g_path_buf_equal (&buf, &cmp));
//	g_path_buf_clear (&cmp);
//
//	g_path_buf_set_filename (&buf, "baz.txt");
//	g_path_buf_init_from_path (&cmp, "/baz.txt");
//	g_assert_true (g_path_buf_equal (&buf, &cmp);
//	g_path_buf_clear (&cmp);
//
//	g_path_buf_clear (&buf);.
//
// The function takes the following parameters:
//
//   - fileName: file name in the path.
//
// The function returns the following values:
//
//   - ok: TRUE if the file name was replaced, and FALSE otherwise.
func (buf *PathBuf) SetFilename(fileName string) bool {
	var _arg0 *C.GPathBuf // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_buf_set_filename(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(fileName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToPath retrieves the built path from the path buffer.
//
// On Windows, the result contains backslashes as directory separators, even if
// forward slashes were used in input.
//
// If the path buffer is empty, this function returns NULL.
//
// The function returns the following values:
//
//   - filename (optional): path.
func (buf *PathBuf) ToPath() string {
	var _arg0 *C.GPathBuf // out
	var _cret *C.char     // in

	_arg0 = (*C.GPathBuf)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C.g_path_buf_to_path(_arg0)
	runtime.KeepAlive(buf)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// PathBufEqual compares two path buffers for equality and returns TRUE if they
// are equal.
//
// The path inside the paths buffers are not going to be normalized,
// so X/Y/Z/A/.., X/./Y/Z and X/Y/Z are not going to be considered equal.
//
// This function can be passed to g_hash_table_new() as the key_equal_func
// parameter.
//
// The function takes the following parameters:
//
//   - v1: path buffer to compare.
//   - v2: path buffer to compare.
//
// The function returns the following values:
//
//   - ok: TRUE if the two path buffers are equal, and FALSE otherwise.
func PathBufEqual(v1, v2 unsafe.Pointer) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_path_buf_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PatternSpec: GPatternSpec struct is the 'compiled' form of a glob-style
// pattern.
//
// The glib.PatternMatchSimple() and glib.PatternSpec.Match() functions match
// a string against a pattern containing '*' and '?' wildcards with similar
// semantics as the standard glob() function: '*' matches an arbitrary, possibly
// empty, string, '?' matches an arbitrary character.
//
// Note that in contrast to glob(), the '/' character can be matched by the
// wildcards, there are no '[...]' character ranges and '*' and '?' can not be
// escaped to include them literally in a pattern.
//
// When multiple strings must be matched against the same pattern, it is better
// to compile the pattern to a glib.PatternSpec using glib.PatternSpec.New and
// use glib.PatternSpec.MatchString() instead of glib.PatternMatchSimple().
// This avoids the overhead of repeated pattern compilation.
//
// An instance of this type is always passed by reference.
type PatternSpec struct {
	*patternSpec
}

// patternSpec is the struct that's finalized.
type patternSpec struct {
	native *C.GPatternSpec
}

func marshalPatternSpec(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &PatternSpec{&patternSpec{(*C.GPatternSpec)(b)}}, nil
}

// NewPatternSpec constructs a struct PatternSpec.
func NewPatternSpec(pattern string) *PatternSpec {
	var _arg1 *C.gchar        // out
	var _cret *C.GPatternSpec // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_pattern_spec_new(_arg1)
	runtime.KeepAlive(pattern)

	var _patternSpec *PatternSpec // out

	_patternSpec = (*PatternSpec)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_patternSpec)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_pattern_spec_free((*C.GPatternSpec)(intern.C))
		},
	)

	return _patternSpec
}

// Copy copies pspec in a new Spec.
//
// The function returns the following values:
//
//   - patternSpec: copy of pspec.
func (pspec *PatternSpec) Copy() *PatternSpec {
	var _arg0 *C.GPatternSpec // out
	var _cret *C.GPatternSpec // in

	_arg0 = (*C.GPatternSpec)(gextras.StructNative(unsafe.Pointer(pspec)))

	_cret = C.g_pattern_spec_copy(_arg0)
	runtime.KeepAlive(pspec)

	var _patternSpec *PatternSpec // out

	_patternSpec = (*PatternSpec)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_patternSpec)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_pattern_spec_free((*C.GPatternSpec)(intern.C))
		},
	)

	return _patternSpec
}

// Equal compares two compiled pattern specs and returns whether they will match
// the same set of strings.
//
// The function takes the following parameters:
//
//   - pspec2: another Spec.
//
// The function returns the following values:
//
//   - ok: whether the compiled patterns are equal.
func (pspec1 *PatternSpec) Equal(pspec2 *PatternSpec) bool {
	var _arg0 *C.GPatternSpec // out
	var _arg1 *C.GPatternSpec // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GPatternSpec)(gextras.StructNative(unsafe.Pointer(pspec1)))
	_arg1 = (*C.GPatternSpec)(gextras.StructNative(unsafe.Pointer(pspec2)))

	_cret = C.g_pattern_spec_equal(_arg0, _arg1)
	runtime.KeepAlive(pspec1)
	runtime.KeepAlive(pspec2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Match matches a string against a compiled pattern. Passing the correct length
// of the string given is mandatory. The reversed string can be omitted by
// passing NULL, this is more efficient if the reversed version of the string to
// be matched is not at hand, as g_pattern_match() will only construct it if the
// compiled pattern requires reverse matches.
//
// Note that, if the user code will (possibly) match a string against a
// multitude of patterns containing wildcards, chances are high that some
// patterns will require a reversed string. In this case, it's more efficient
// to provide the reversed string to avoid multiple constructions thereof in the
// various calls to g_pattern_match().
//
// Note also that the reverse of a UTF-8 encoded string can in general not be
// obtained by g_strreverse(). This works only if the string does not contain
// any multibyte characters. GLib offers the g_utf8_strreverse() function to
// reverse UTF-8 encoded strings.
//
// The function takes the following parameters:
//
//   - stringLength: length of string (in bytes, i.e. strlen(), not
//     g_utf8_strlen()).
//   - str: UTF-8 encoded string to match.
//   - stringReversed (optional): reverse of string or NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if string matches pspec.
func (pspec *PatternSpec) Match(stringLength uint, str string, stringReversed string) bool {
	var _arg0 *C.GPatternSpec // out
	var _arg1 C.gsize         // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GPatternSpec)(gextras.StructNative(unsafe.Pointer(pspec)))
	_arg1 = C.gsize(stringLength)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))
	if stringReversed != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(stringReversed)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_pattern_spec_match(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(stringLength)
	runtime.KeepAlive(str)
	runtime.KeepAlive(stringReversed)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchString matches a string against a compiled pattern. If the string is to
// be matched against more than one pattern, consider using g_pattern_match()
// instead while supplying the reversed string.
//
// The function takes the following parameters:
//
//   - str: UTF-8 encoded string to match.
//
// The function returns the following values:
//
//   - ok: TRUE if string matches pspec.
func (pspec *PatternSpec) MatchString(str string) bool {
	var _arg0 *C.GPatternSpec // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GPatternSpec)(gextras.StructNative(unsafe.Pointer(pspec)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_pattern_spec_match_string(_arg0, _arg1)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtrArray contains the public fields of a pointer array.
//
// An instance of this type is always passed by reference.
type PtrArray struct {
	*ptrArray
}

// ptrArray is the struct that's finalized.
type ptrArray struct {
	native *C.GPtrArray
}

// Pdata points to the array of pointers, which may be moved when the array
// grows.
func (p *PtrArray) Pdata() *unsafe.Pointer {
	valptr := &p.native.pdata
	var _v *unsafe.Pointer // out
	_v = (*unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Len: number of pointers in the array.
func (p *PtrArray) Len() uint {
	valptr := &p.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of pointers in the array.
func (p *PtrArray) SetLen(len uint) {
	valptr := &p.native.len
	*valptr = C.guint(len)
}

// Queue contains the public fields of a [Queue][glib-Double-ended-Queues].
//
// An instance of this type is always passed by reference.
type Queue struct {
	*queue
}

// queue is the struct that's finalized.
type queue struct {
	native *C.GQueue
}

// Clear removes all the elements in queue. If queue elements contain
// dynamically-allocated memory, they should be freed first.
func (queue *Queue) Clear() {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	C.g_queue_clear(_arg0)
	runtime.KeepAlive(queue)
}

// ForEach calls func for each element in the queue passing user_data to the
// function.
//
// It is safe for func to remove the element from queue, but it must not modify
// any part of the queue after that element.
//
// The function takes the following parameters:
//
//   - fn: function to call for each element's data.
func (queue *Queue) ForEach(fn Func) {
	var _arg0 *C.GQueue // out
	var _arg1 C.GFunc   // out
	var _arg2 C.gpointer

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (*[0]byte)(C._gotk4_glib2_Func)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.g_queue_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(fn)
}

// Length returns the number of items in queue.
//
// The function returns the following values:
//
//   - guint: number of items in queue.
func (queue *Queue) Length() uint {
	var _arg0 *C.GQueue // out
	var _cret C.guint   // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.g_queue_get_length(_arg0)
	runtime.KeepAlive(queue)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Index returns the position of the first element in queue which contains data.
//
// The function takes the following parameters:
//
//   - data (optional) to find.
//
// The function returns the following values:
//
//   - gint: position of the first element in queue which contains data,
//     or -1 if no element in queue contains data.
func (queue *Queue) Index(data unsafe.Pointer) int {
	var _arg0 *C.GQueue       // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(data))

	_cret = C.g_queue_index(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Init: statically-allocated #GQueue must be initialized with this function
// before it can be used. Alternatively you can initialize it with G_QUEUE_INIT.
// It is not necessary to initialize queues created with g_queue_new().
func (queue *Queue) Init() {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	C.g_queue_init(_arg0)
	runtime.KeepAlive(queue)
}

// InsertSorted inserts data into queue using func to determine the new
// position.
//
// The function takes the following parameters:
//
//   - data (optional) to insert.
//   - fn used to compare elements in the queue. It is called with two elements
//     of the queue and user_data. It should return 0 if the elements are equal,
//     a negative value if the first element comes before the second, and a
//     positive value if the second element comes before the first.
func (queue *Queue) InsertSorted(data unsafe.Pointer, fn CompareDataFunc) {
	var _arg0 *C.GQueue          // out
	var _arg1 C.gpointer         // out
	var _arg2 C.GCompareDataFunc // out
	var _arg3 C.gpointer

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))
	_arg2 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg3))

	C.g_queue_insert_sorted(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)
	runtime.KeepAlive(fn)
}

// IsEmpty returns TRUE if the queue is empty.
//
// The function returns the following values:
//
//   - ok: TRUE if the queue is empty.
func (queue *Queue) IsEmpty() bool {
	var _arg0 *C.GQueue  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.g_queue_is_empty(_arg0)
	runtime.KeepAlive(queue)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeekHead returns the first element of the queue.
//
// The function returns the following values:
//
//   - gpointer (optional): data of the first element in the queue, or NULL if
//     the queue is empty.
func (queue *Queue) PeekHead() unsafe.Pointer {
	var _arg0 *C.GQueue  // out
	var _cret C.gpointer // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.g_queue_peek_head(_arg0)
	runtime.KeepAlive(queue)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// PeekNth returns the n'th element of queue.
//
// The function takes the following parameters:
//
//   - n of the element.
//
// The function returns the following values:
//
//   - gpointer (optional): data for the n'th element of queue, or NULL if n is
//     off the end of queue.
func (queue *Queue) PeekNth(n uint) unsafe.Pointer {
	var _arg0 *C.GQueue  // out
	var _arg1 C.guint    // out
	var _cret C.gpointer // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = C.guint(n)

	_cret = C.g_queue_peek_nth(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(n)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// PeekTail returns the last element of the queue.
//
// The function returns the following values:
//
//   - gpointer (optional): data of the last element in the queue, or NULL if
//     the queue is empty.
func (queue *Queue) PeekTail() unsafe.Pointer {
	var _arg0 *C.GQueue  // out
	var _cret C.gpointer // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.g_queue_peek_tail(_arg0)
	runtime.KeepAlive(queue)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// PopHead removes the first element of the queue and returns its data.
//
// The function returns the following values:
//
//   - gpointer (optional): data of the first element in the queue, or NULL if
//     the queue is empty.
func (queue *Queue) PopHead() unsafe.Pointer {
	var _arg0 *C.GQueue  // out
	var _cret C.gpointer // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.g_queue_pop_head(_arg0)
	runtime.KeepAlive(queue)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// PopNth removes the n'th element of queue and returns its data.
//
// The function takes the following parameters:
//
//   - n of the element.
//
// The function returns the following values:
//
//   - gpointer (optional) element's data, or NULL if n is off the end of queue.
func (queue *Queue) PopNth(n uint) unsafe.Pointer {
	var _arg0 *C.GQueue  // out
	var _arg1 C.guint    // out
	var _cret C.gpointer // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = C.guint(n)

	_cret = C.g_queue_pop_nth(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(n)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// PopTail removes the last element of the queue and returns its data.
//
// The function returns the following values:
//
//   - gpointer (optional): data of the last element in the queue, or NULL if
//     the queue is empty.
func (queue *Queue) PopTail() unsafe.Pointer {
	var _arg0 *C.GQueue  // out
	var _cret C.gpointer // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.g_queue_pop_tail(_arg0)
	runtime.KeepAlive(queue)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// PushHead adds a new element at the head of the queue.
//
// The function takes the following parameters:
//
//   - data (optional) for the new element.
func (queue *Queue) PushHead(data unsafe.Pointer) {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C.g_queue_push_head(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)
}

// PushNth inserts a new element into queue at the given position.
//
// The function takes the following parameters:
//
//   - data (optional) for the new element.
//   - n to insert the new element. If n is negative or larger than the number
//     of elements in the queue, the element is added to the end of the queue.
func (queue *Queue) PushNth(data unsafe.Pointer, n int) {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out
	var _arg2 C.gint     // out

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))
	_arg2 = C.gint(n)

	C.g_queue_push_nth(_arg0, _arg1, _arg2)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)
	runtime.KeepAlive(n)
}

// PushTail adds a new element at the tail of the queue.
//
// The function takes the following parameters:
//
//   - data (optional) for the new element.
func (queue *Queue) PushTail(data unsafe.Pointer) {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C.g_queue_push_tail(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)
}

// Remove removes the first element in queue that contains data.
//
// The function takes the following parameters:
//
//   - data (optional) to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if data was found and removed from queue.
func (queue *Queue) Remove(data unsafe.Pointer) bool {
	var _arg0 *C.GQueue       // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(data))

	_cret = C.g_queue_remove(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAll: remove all elements whose data equals data from queue.
//
// The function takes the following parameters:
//
//   - data (optional) to remove.
//
// The function returns the following values:
//
//   - guint: number of elements removed from queue.
func (queue *Queue) RemoveAll(data unsafe.Pointer) uint {
	var _arg0 *C.GQueue       // out
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(data))

	_cret = C.g_queue_remove_all(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Reverse reverses the order of the items in queue.
func (queue *Queue) Reverse() {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	C.g_queue_reverse(_arg0)
	runtime.KeepAlive(queue)
}

// Sort sorts queue using compare_func.
//
// The function takes the following parameters:
//
//   - compareFunc used to sort queue. This function is passed two elements of
//     the queue and should return 0 if they are equal, a negative value if the
//     first comes before the second, and a positive value if the second comes
//     before the first.
func (queue *Queue) Sort(compareFunc CompareDataFunc) {
	var _arg0 *C.GQueue          // out
	var _arg1 C.GCompareDataFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
	_arg2 = C.gpointer(gbox.Assign(compareFunc))
	defer gbox.Delete(uintptr(_arg2))

	C.g_queue_sort(_arg0, _arg1, _arg2)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(compareFunc)
}

// Rand struct is an opaque data structure. It should only be accessed through
// the g_rand_* functions.
//
// An instance of this type is always passed by reference.
type Rand struct {
	*rand
}

// rand is the struct that's finalized.
type rand struct {
	native *C.GRand
}

func marshalRand(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Rand{&rand{(*C.GRand)(b)}}, nil
}

// NewRand constructs a struct Rand.
func NewRand() *Rand {
	var _cret *C.GRand // in

	_cret = C.g_rand_new()

	var _rand *Rand // out

	_rand = (*Rand)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_rand)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_rand_free((*C.GRand)(intern.C))
		},
	)

	return _rand
}

// NewRandWithSeed constructs a struct Rand.
func NewRandWithSeed(seed uint32) *Rand {
	var _arg1 C.guint32 // out
	var _cret *C.GRand  // in

	_arg1 = C.guint32(seed)

	_cret = C.g_rand_new_with_seed(_arg1)
	runtime.KeepAlive(seed)

	var _rand *Rand // out

	_rand = (*Rand)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_rand)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_rand_free((*C.GRand)(intern.C))
		},
	)

	return _rand
}

// NewRandWithSeedArray constructs a struct Rand.
func NewRandWithSeedArray(seed *uint32, seedLength uint) *Rand {
	var _arg1 *C.guint32 // out
	var _arg2 C.guint    // out
	var _cret *C.GRand   // in

	_arg1 = (*C.guint32)(unsafe.Pointer(seed))
	_arg2 = C.guint(seedLength)

	_cret = C.g_rand_new_with_seed_array(_arg1, _arg2)
	runtime.KeepAlive(seed)
	runtime.KeepAlive(seedLength)

	var _rand *Rand // out

	_rand = (*Rand)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_rand)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_rand_free((*C.GRand)(intern.C))
		},
	)

	return _rand
}

// Copy copies a #GRand into a new one with the same exact state as before.
// This way you can take a snapshot of the random number generator for replaying
// later.
//
// The function returns the following values:
//
//   - rand: new #GRand.
func (rand_ *Rand) Copy() *Rand {
	var _arg0 *C.GRand // out
	var _cret *C.GRand // in

	_arg0 = (*C.GRand)(gextras.StructNative(unsafe.Pointer(rand_)))

	_cret = C.g_rand_copy(_arg0)
	runtime.KeepAlive(rand_)

	var _rand *Rand // out

	_rand = (*Rand)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_rand)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_rand_free((*C.GRand)(intern.C))
		},
	)

	return _rand
}

// Double returns the next random #gdouble from rand_ equally distributed over
// the range [0..1).
//
// The function returns the following values:
//
//   - gdouble: random number.
func (rand_ *Rand) Double() float64 {
	var _arg0 *C.GRand  // out
	var _cret C.gdouble // in

	_arg0 = (*C.GRand)(gextras.StructNative(unsafe.Pointer(rand_)))

	_cret = C.g_rand_double(_arg0)
	runtime.KeepAlive(rand_)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// DoubleRange returns the next random #gdouble from rand_ equally distributed
// over the range [begin..end).
//
// The function takes the following parameters:
//
//   - begin: lower closed bound of the interval.
//   - end: upper open bound of the interval.
//
// The function returns the following values:
//
//   - gdouble: random number.
func (rand_ *Rand) DoubleRange(begin float64, end float64) float64 {
	var _arg0 *C.GRand  // out
	var _arg1 C.gdouble // out
	var _arg2 C.gdouble // out
	var _cret C.gdouble // in

	_arg0 = (*C.GRand)(gextras.StructNative(unsafe.Pointer(rand_)))
	_arg1 = C.gdouble(begin)
	_arg2 = C.gdouble(end)

	_cret = C.g_rand_double_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rand_)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Int returns the next random #guint32 from rand_ equally distributed over the
// range [0..2^32-1].
//
// The function returns the following values:
//
//   - guint32: random number.
func (rand_ *Rand) Int() uint32 {
	var _arg0 *C.GRand  // out
	var _cret C.guint32 // in

	_arg0 = (*C.GRand)(gextras.StructNative(unsafe.Pointer(rand_)))

	_cret = C.g_rand_int(_arg0)
	runtime.KeepAlive(rand_)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// IntRange returns the next random #gint32 from rand_ equally distributed over
// the range [begin..end-1].
//
// The function takes the following parameters:
//
//   - begin: lower closed bound of the interval.
//   - end: upper open bound of the interval.
//
// The function returns the following values:
//
//   - gint32: random number.
func (rand_ *Rand) IntRange(begin int32, end int32) int32 {
	var _arg0 *C.GRand // out
	var _arg1 C.gint32 // out
	var _arg2 C.gint32 // out
	var _cret C.gint32 // in

	_arg0 = (*C.GRand)(gextras.StructNative(unsafe.Pointer(rand_)))
	_arg1 = C.gint32(begin)
	_arg2 = C.gint32(end)

	_cret = C.g_rand_int_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rand_)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// SetSeed sets the seed for the random number generator #GRand to seed.
//
// The function takes the following parameters:
//
//   - seed: value to reinitialize the random number generator.
func (rand_ *Rand) SetSeed(seed uint32) {
	var _arg0 *C.GRand  // out
	var _arg1 C.guint32 // out

	_arg0 = (*C.GRand)(gextras.StructNative(unsafe.Pointer(rand_)))
	_arg1 = C.guint32(seed)

	C.g_rand_set_seed(_arg0, _arg1)
	runtime.KeepAlive(rand_)
	runtime.KeepAlive(seed)
}

// SetSeedArray initializes the random number generator by an array of longs.
// Array can be of arbitrary size, though only the first 624 values are taken.
// This function is useful if you have many low entropy seeds, or if you require
// more then 32 bits of actual entropy for your application.
//
// The function takes the following parameters:
//
//   - seed: array to initialize with.
//   - seedLength: length of array.
func (rand_ *Rand) SetSeedArray(seed *uint32, seedLength uint) {
	var _arg0 *C.GRand   // out
	var _arg1 *C.guint32 // out
	var _arg2 C.guint    // out

	_arg0 = (*C.GRand)(gextras.StructNative(unsafe.Pointer(rand_)))
	_arg1 = (*C.guint32)(unsafe.Pointer(seed))
	_arg2 = C.guint(seedLength)

	C.g_rand_set_seed_array(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rand_)
	runtime.KeepAlive(seed)
	runtime.KeepAlive(seedLength)
}

// Regex: GRegex is the "compiled" form of a regular expression pattern.
//
// GRegex implements regular expression pattern matching using syntax and
// semantics similar to Perl regular expression. See the PCRE documentation
// (man:pcrepattern(3)) for the syntax definition.
//
// Some functions accept a start_position argument, setting it differs from just
// passing over a shortened string and setting G_REGEX_MATCH_NOTBOL in the case
// of a pattern that begins with any kind of lookbehind assertion. For example,
// consider the pattern "\Biss\B" which finds occurrences of "iss" in the middle
// of words. ("\B" matches only if the current position in the subject is not a
// word boundary.) When applied to the string "Mississipi" from the fourth byte,
// namely "issipi", it does not match, because "\B" is always false at the start
// of the subject, which is deemed to be a word boundary. However, if the entire
// string is passed , but with start_position set to 4, it finds the second
// occurrence of "iss" because it is able to look behind the starting point to
// discover that it is preceded by a letter.
//
// Note that, unless you set the G_REGEX_RAW flag, all the strings passed to
// these functions must be encoded in UTF-8. The lengths and the positions
// inside the strings are in bytes and not in characters, so, for instance,
// "\xc3\xa0" (i.e. "à") is two bytes long but it is treated as a single
// character. If you set G_REGEX_RAW the strings can be non-valid UTF-8 strings
// and a byte is treated as a character, so "\xc3\xa0" is two bytes and two
// characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are
// affected by newline characters, the default is to recognize any newline
// character (the same characters recognized by "\R"). This can be changed
// with G_REGEX_NEWLINE_CR, G_REGEX_NEWLINE_LF and G_REGEX_NEWLINE_CRLF compile
// options, and with G_REGEX_MATCH_NEWLINE_ANY, G_REGEX_MATCH_NEWLINE_CR,
// G_REGEX_MATCH_NEWLINE_LF and G_REGEX_MATCH_NEWLINE_CRLF match options.
// These settings are also relevant when compiling a pattern if G_REGEX_EXTENDED
// is set, and an unescaped "#" outside a character class is encountered.
// This indicates a comment that lasts until after the next newline.
//
// Creating and manipulating the same GRegex structure from different threads is
// not a problem as GRegex does not modify its internal state between creation
// and destruction, on the other hand GMatchInfo is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
//
// An instance of this type is always passed by reference.
type Regex struct {
	*regex
}

// regex is the struct that's finalized.
type regex struct {
	native *C.GRegex
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Regex{&regex{(*C.GRegex)(b)}}, nil
}

// NewRegex constructs a struct Regex.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (*Regex, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GRegexCompileFlags // out
	var _arg3 C.GRegexMatchFlags   // out
	var _cret *C.GRegex            // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexCompileFlags(compileOptions)
	_arg3 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_new(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var _regex *Regex // out
	var _goerr error  // out

	if _cret != nil {
		_regex = (*Regex)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_regex)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_regex_unref((*C.GRegex)(intern.C))
			},
		)
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _regex, _goerr
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
//
// The function returns the following values:
//
//   - gint: number of capturing subpatterns.
func (regex *Regex) CaptureCount() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_capture_count(_arg0)
	runtime.KeepAlive(regex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CompileFlags returns the compile options that regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not include
// flags set by option expressions such as (?i) found at the top-level within
// the compiled pattern.
//
// The function returns the following values:
//
//   - regexCompileFlags flags from CompileFlags.
func (regex *Regex) CompileFlags() RegexCompileFlags {
	var _arg0 *C.GRegex            // out
	var _cret C.GRegexCompileFlags // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_compile_flags(_arg0)
	runtime.KeepAlive(regex)

	var _regexCompileFlags RegexCompileFlags // out

	_regexCompileFlags = RegexCompileFlags(_cret)

	return _regexCompileFlags
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
//
// The function returns the following values:
//
//   - ok: TRUE if the pattern contains explicit CR or LF references.
func (regex *Regex) HasCrOrLf() bool {
	var _arg0 *C.GRegex  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_has_cr_or_lf(_arg0)
	runtime.KeepAlive(regex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchFlags returns the match options that regex was created with.
//
// The function returns the following values:
//
//   - regexMatchFlags flags from MatchFlags.
func (regex *Regex) MatchFlags() RegexMatchFlags {
	var _arg0 *C.GRegex          // out
	var _cret C.GRegexMatchFlags // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_match_flags(_arg0)
	runtime.KeepAlive(regex)

	var _regexMatchFlags RegexMatchFlags // out

	_regexMatchFlags = RegexMatchFlags(_cret)

	return _regexMatchFlags
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
//
// The function returns the following values:
//
//   - gint: number of the highest back reference.
func (regex *Regex) MaxBackref() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_max_backref(_arg0)
	runtime.KeepAlive(regex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
//
// The function returns the following values:
//
//   - gint: number of characters in the longest lookbehind assertion.
func (regex *Regex) MaxLookbehind() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_max_lookbehind(_arg0)
	runtime.KeepAlive(regex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pattern gets the pattern string associated with regex, i.e. a copy of the
// string passed to g_regex_new().
//
// The function returns the following values:
//
//   - utf8: pattern of regex.
func (regex *Regex) Pattern() string {
	var _arg0 *C.GRegex // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_pattern(_arg0)
	runtime.KeepAlive(regex)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// StringNumber retrieves the number of the subexpression named name.
//
// The function takes the following parameters:
//
//   - name of the subexpression.
//
// The function returns the following values:
//
//   - gint: number of the subexpression or -1 if name does not exists.
func (regex *Regex) StringNumber(name string) int {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar  // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_get_string_number(_arg0, _arg1)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(name)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Match scans for a match in string for the pattern in regex. The match_options
// are combined with the match options specified when the regex structure was
// created, letting you have more flexibility in reusing #GRegex structures.
//
// Unless G_REGEX_RAW is specified in the options, string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// match_info if not NULL. Note that if match_info is not NULL then it is
// created even if the function returns FALSE, i.e. you must free it regardless
// if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//	static void
//	print_uppercase_words (const gchar *string)
//	{
//	  // Print all uppercase-only words.
//	  GRegex *regex;
//	  GMatchInfo *match_info;
//
//	  regex = g_regex_new ("[A-Z]+", G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
//	  g_regex_match (regex, string, 0, &match_info);
//	  while (g_match_info_matches (match_info))
//	    {
//	      gchar *word = g_match_info_fetch (match_info, 0);
//	      g_print ("Found: s\n", word);
//	      g_free (word);
//	      g_match_info_next (match_info, NULL);
//	    }
//	  g_match_info_free (match_info);
//	  g_regex_unref (regex);
//	}
//
// string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying string then
// the behaviour is undefined.
//
// The function takes the following parameters:
//
//   - str: string to scan for matches.
//   - matchOptions: match options.
//
// The function returns the following values:
//
//   - matchInfo (optional): pointer to location where to store the Info,
//     or NULL if you do not need it.
//   - ok: TRUE is the string matched, FALSE otherwise.
func (regex *Regex) Match(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	if _arg3 != nil {
		_matchInfo = (*MatchInfo)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_matchInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_match_info_unref((*C.GMatchInfo)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAll: using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses a different
// algorithm so it can retrieve all the possible matches. For more documentation
// see g_regex_match_all_full().
//
// A Info structure, used to get information on the match, is stored in
// match_info if not NULL. Note that if match_info is not NULL then it is
// created even if the function returns FALSE, i.e. you must free it regardless
// if regular expression actually matched.
//
// string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying string then
// the behaviour is undefined.
//
// The function takes the following parameters:
//
//   - str: string to scan for matches.
//   - matchOptions: match options.
//
// The function returns the following values:
//
//   - matchInfo (optional): pointer to location where to store the Info,
//     or NULL if you do not need it.
//   - ok: TRUE is the string matched, FALSE otherwise.
func (regex *Regex) MatchAll(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match_all(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	if _arg3 != nil {
		_matchInfo = (*MatchInfo)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_matchInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_match_info_unref((*C.GMatchInfo)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// Split breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each of the
// substrings will also be returned. If the pattern does not match anywhere in
// the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent
// empty elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits string into separate characters
// wherever it matches the empty string between characters. For example
// splitting "ab c" using as a separator "\s*", you will get "a", "b" and "c".
//
// The function takes the following parameters:
//
//   - str: string to split with the pattern.
//   - matchOptions: match time option flags.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated gchar ** array. Free it using g_strfreev().
func (regex *Regex) Split(str string, matchOptions RegexMatchFlags) []string {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _cret **C.gchar          // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_split(_arg0, _arg1, _arg2)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// RegexCheckReplacement checks whether replacement is a valid replacement
// string (see g_regex_replace()), i.e. that all escape sequences in it are
// valid.
//
// If has_references is not NULL then replacement is checked for pattern
// references. For instance, replacement text 'foo\n' does not contain
// references and may be evaluated without information about actual match, but
// '\0\1' (whole match followed by first subpattern) requires valid Info object.
//
// The function takes the following parameters:
//
//   - replacement string.
//
// The function returns the following values:
//
//   - hasReferences (optional): location to store information about references
//     in replacement or NULL.
func RegexCheckReplacement(replacement string) (bool, error) {
	var _arg1 *C.gchar   // out
	var _arg2 C.gboolean // in
	var _cerr *C.GError  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_regex_check_replacement(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(replacement)

	var _hasReferences bool // out
	var _goerr error        // out

	if _arg2 != 0 {
		_hasReferences = true
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _hasReferences, _goerr
}

func RegexErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_regex_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// RegexEscapeNUL escapes the nul characters in string to "\x00". It can be used
// to compile a regex with embedded nul characters.
//
// For completeness, length can be -1 for a nul-terminated string. In this case
// the output string will be of course equal to string.
//
// The function takes the following parameters:
//
//   - str: string to escape.
//
// The function returns the following values:
//
//   - utf8: newly-allocated escaped string.
func RegexEscapeNUL(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gint
	var _cret *C.gchar // in

	_arg2 = (C.gint)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_escape_nul(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RegexEscapeString escapes the special characters used for regular expressions
// in string, for instance "a.b*c" becomes "a\.b\*c". This function is useful to
// dynamically generate regular expressions.
//
// string can contain nul characters that are replaced with "\0", in this case
// remember to specify the correct length of string in length.
//
// The function takes the following parameters:
//
//   - str: string to escape.
//
// The function returns the following values:
//
//   - utf8: newly-allocated escaped string.
func RegexEscapeString(str string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gint
	var _cret *C.gchar // in

	_arg2 = (C.gint)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_escape_string(_arg1, _arg2)
	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RegexMatchSimple scans for a match in string for pattern.
//
// This function is equivalent to g_regex_match() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when
// you need just to do a match without extracting substrings, capture counts,
// and so on.
//
// If this function is to be called on the same pattern more than once,
// it's more efficient to compile the pattern once with g_regex_new() and then
// use g_regex_match().
//
// The function takes the following parameters:
//
//   - pattern: regular expression.
//   - str: string to scan for matches.
//   - compileOptions: compile options for the regular expression, or 0.
//   - matchOptions: match options, or 0.
//
// The function returns the following values:
//
//   - ok: TRUE if the string matched, FALSE otherwise.
func RegexMatchSimple(pattern, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) bool {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _arg3 C.GRegexCompileFlags // out
	var _arg4 C.GRegexMatchFlags   // out
	var _cret C.gboolean           // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GRegexCompileFlags(compileOptions)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match_simple(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegexSplitSimple breaks the string on the pattern, and returns an array of
// the tokens. If the pattern contains capturing parentheses, then the text for
// each of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// This function is equivalent to g_regex_split() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when
// you need just to do a split without extracting substrings, capture counts,
// and so on.
//
// If this function is to be called on the same pattern more than once,
// it's more efficient to compile the pattern once with g_regex_new() and then
// use g_regex_split().
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent
// empty elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits string into separate characters
// wherever it matches the empty string between characters. For example
// splitting "ab c" using as a separator "\s*", you will get "a", "b" and "c".
//
// The function takes the following parameters:
//
//   - pattern: regular expression.
//   - str: string to scan for matches.
//   - compileOptions: compile options for the regular expression, or 0.
//   - matchOptions: match options, or 0.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings. Free it using g_strfreev().
func RegexSplitSimple(pattern, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) []string {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _arg3 C.GRegexCompileFlags // out
	var _arg4 C.GRegexMatchFlags   // out
	var _cret **C.gchar            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GRegexCompileFlags(compileOptions)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_split_simple(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Scanner: GScanner provides a general-purpose lexical scanner.
//
// You should set input_name after creating the scanner, since it is used by
// the default message handler when displaying warnings and errors. If you are
// scanning a file, the filename would be a good choice.
//
// The user_data and max_parse_errors fields are not used. If you need to
// associate extra data with the scanner you can place them here.
//
// If you want to use your own message handler you can set the msg_handler
// field. The type of the message handler function is declared by MsgFunc.
//
// An instance of this type is always passed by reference.
type Scanner struct {
	*scanner
}

// scanner is the struct that's finalized.
type scanner struct {
	native *C.GScanner
}

// CurLine returns the current line in the input stream (counting from 1).
// This is the line of the last token parsed via g_scanner_get_next_token().
//
// The function returns the following values:
//
//   - guint: current line.
func (scanner *Scanner) CurLine() uint {
	var _arg0 *C.GScanner // out
	var _cret C.guint     // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_cur_line(_arg0)
	runtime.KeepAlive(scanner)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CurPosition returns the current position in the current line
// (counting from 0). This is the position of the last token parsed via
// g_scanner_get_next_token().
//
// The function returns the following values:
//
//   - guint: current position on the line.
func (scanner *Scanner) CurPosition() uint {
	var _arg0 *C.GScanner // out
	var _cret C.guint     // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_cur_position(_arg0)
	runtime.KeepAlive(scanner)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CurToken gets the current token type. This is simply the token field in the
// #GScanner structure.
//
// The function returns the following values:
//
//   - tokenType: current token type.
func (scanner *Scanner) CurToken() TokenType {
	var _arg0 *C.GScanner  // out
	var _cret C.GTokenType // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_cur_token(_arg0)
	runtime.KeepAlive(scanner)

	var _tokenType TokenType // out

	_tokenType = TokenType(_cret)

	return _tokenType
}

// Destroy frees all memory used by the #GScanner.
func (scanner *Scanner) Destroy() {
	var _arg0 *C.GScanner // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	C.g_scanner_destroy(_arg0)
	runtime.KeepAlive(scanner)
}

// EOF returns TRUE if the scanner has reached the end of the file or text
// buffer.
//
// The function returns the following values:
//
//   - ok: TRUE if the scanner has reached the end of the file or text buffer.
func (scanner *Scanner) EOF() bool {
	var _arg0 *C.GScanner // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_eof(_arg0)
	runtime.KeepAlive(scanner)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextToken parses the next token just like g_scanner_peek_next_token() and
// also removes it from the input stream. The token data is placed in the token,
// value, line, and position fields of the #GScanner structure.
//
// The function returns the following values:
//
//   - tokenType: type of the token.
func (scanner *Scanner) NextToken() TokenType {
	var _arg0 *C.GScanner  // out
	var _cret C.GTokenType // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_get_next_token(_arg0)
	runtime.KeepAlive(scanner)

	var _tokenType TokenType // out

	_tokenType = TokenType(_cret)

	return _tokenType
}

// InputFile prepares to scan a file.
//
// The function takes the following parameters:
//
//   - inputFd: file descriptor.
func (scanner *Scanner) InputFile(inputFd int) {
	var _arg0 *C.GScanner // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.gint(inputFd)

	C.g_scanner_input_file(_arg0, _arg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(inputFd)
}

// InputText prepares to scan a text buffer.
//
// The function takes the following parameters:
//
//   - text buffer to scan.
func (scanner *Scanner) InputText(text string) {
	var _arg0 *C.GScanner // out
	var _arg1 *C.gchar    // out
	var _arg2 C.guint

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg2 = (C.guint)(len(text))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.g_scanner_input_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(text)
}

// LookupSymbol looks up a symbol in the current scope and return its value.
// If the symbol is not bound in the current scope, NULL is returned.
//
// The function takes the following parameters:
//
//   - symbol to look up.
//
// The function returns the following values:
//
//   - gpointer (optional): value of symbol in the current scope, or NULL if
//     symbol is not bound in the current scope.
func (scanner *Scanner) LookupSymbol(symbol string) unsafe.Pointer {
	var _arg0 *C.GScanner // out
	var _arg1 *C.gchar    // out
	var _cret C.gpointer  // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_scanner_lookup_symbol(_arg0, _arg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(symbol)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// PeekNextToken parses the next token, without removing it from the input
// stream. The token data is placed in the next_token, next_value, next_line,
// and next_position fields of the #GScanner structure.
//
// Note that, while the token is not removed from the input stream (i.e.
// the next call to g_scanner_get_next_token() will return the same token),
// it will not be reevaluated. This can lead to surprising results when changing
// scope or the scanner configuration after peeking the next token. Getting the
// next token after switching the scope or configuration will return whatever
// was peeked before, regardless of any symbols that may have been added or
// removed in the new scope.
//
// The function returns the following values:
//
//   - tokenType: type of the token.
func (scanner *Scanner) PeekNextToken() TokenType {
	var _arg0 *C.GScanner  // out
	var _cret C.GTokenType // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_peek_next_token(_arg0)
	runtime.KeepAlive(scanner)

	var _tokenType TokenType // out

	_tokenType = TokenType(_cret)

	return _tokenType
}

// ScopeAddSymbol adds a symbol to the given scope.
//
// The function takes the following parameters:
//
//   - scopeId: scope id.
//   - symbol to add.
//   - value (optional) of the symbol.
func (scanner *Scanner) ScopeAddSymbol(scopeId uint, symbol string, value unsafe.Pointer) {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gpointer  // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gpointer)(unsafe.Pointer(value))

	C.g_scanner_scope_add_symbol(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)
	runtime.KeepAlive(value)
}

// ScopeForEachSymbol calls the given function for each of the symbol/value
// pairs in the given scope of the #GScanner. The function is passed the symbol
// and value of each pair, and the given user_data parameter.
//
// The function takes the following parameters:
//
//   - scopeId: scope id.
//   - fn: function to call for each symbol/value pair.
func (scanner *Scanner) ScopeForEachSymbol(scopeId uint, fn HFunc) {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _arg2 C.GHFunc    // out
	var _arg3 C.gpointer

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)
	_arg2 = (*[0]byte)(C._gotk4_glib2_HFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg3))

	C.g_scanner_scope_foreach_symbol(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(fn)
}

// ScopeLookupSymbol looks up a symbol in a scope and return its value. If the
// symbol is not bound in the scope, NULL is returned.
//
// The function takes the following parameters:
//
//   - scopeId: scope id.
//   - symbol to look up.
//
// The function returns the following values:
//
//   - gpointer (optional): value of symbol in the given scope, or NULL if
//     symbol is not bound in the given scope.
func (scanner *Scanner) ScopeLookupSymbol(scopeId uint, symbol string) unsafe.Pointer {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _arg2 *C.gchar    // out
	var _cret C.gpointer  // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_scanner_scope_lookup_symbol(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// ScopeRemoveSymbol removes a symbol from a scope.
//
// The function takes the following parameters:
//
//   - scopeId: scope id.
//   - symbol to remove.
func (scanner *Scanner) ScopeRemoveSymbol(scopeId uint, symbol string) {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _arg2 *C.gchar    // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_scanner_scope_remove_symbol(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)
}

// SetScope sets the current scope.
//
// The function takes the following parameters:
//
//   - scopeId: new scope id.
//
// The function returns the following values:
//
//   - guint: old scope id.
func (scanner *Scanner) SetScope(scopeId uint) uint {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _cret C.guint     // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)

	_cret = C.g_scanner_set_scope(_arg0, _arg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SyncFileOffset rewinds the filedescriptor to the current buffer position and
// blows the file read ahead buffer. This is useful for third party uses of the
// scanners filedescriptor, which hooks onto the current scanning position.
func (scanner *Scanner) SyncFileOffset() {
	var _arg0 *C.GScanner // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	C.g_scanner_sync_file_offset(_arg0)
	runtime.KeepAlive(scanner)
}

// UnexpToken outputs a message through the scanner's msg_handler, resulting
// from an unexpected token in the input stream. Note that you should not call
// g_scanner_peek_next_token() followed by g_scanner_unexp_token() without an
// intermediate call to g_scanner_get_next_token(), as g_scanner_unexp_token()
// evaluates the scanner's current token (not the peeked token) to construct
// part of the message.
//
// The function takes the following parameters:
//
//   - expectedToken: expected token.
//   - identifierSpec: string describing how the scanner's user refers
//     to identifiers (NULL defaults to "identifier"). This is used if
//     expected_token is G_TOKEN_IDENTIFIER or G_TOKEN_IDENTIFIER_NULL.
//   - symbolSpec: string describing how the scanner's user refers to
//     symbols (NULL defaults to "symbol"). This is used if expected_token is
//     G_TOKEN_SYMBOL or any token value greater than G_TOKEN_LAST.
//   - symbolName: name of the symbol, if the scanner's current token is a
//     symbol.
//   - message string to output at the end of the warning/error, or NULL.
//   - isError: if TRUE it is output as an error. If FALSE it is output as a
//     warning.
func (scanner *Scanner) UnexpToken(expectedToken TokenType, identifierSpec string, symbolSpec string, symbolName string, message string, isError int) {
	var _arg0 *C.GScanner  // out
	var _arg1 C.GTokenType // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out
	var _arg4 *C.gchar     // out
	var _arg5 *C.gchar     // out
	var _arg6 C.gint       // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.GTokenType(expectedToken)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(identifierSpec)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(symbolSpec)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(symbolName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = C.gint(isError)

	C.g_scanner_unexp_token(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(expectedToken)
	runtime.KeepAlive(identifierSpec)
	runtime.KeepAlive(symbolSpec)
	runtime.KeepAlive(symbolName)
	runtime.KeepAlive(message)
	runtime.KeepAlive(isError)
}

// ScannerConfig specifies the #GScanner parser configuration. Most settings can
// be changed during the parsing phase and will affect the lexical parsing of
// the next unpeeked token.
//
// An instance of this type is always passed by reference.
type ScannerConfig struct {
	*scannerConfig
}

// scannerConfig is the struct that's finalized.
type scannerConfig struct {
	native *C.GScannerConfig
}

// CsetSkipCharacters specifies which characters should be skipped by
// the scanner (the default is the whitespace characters: space, tab,
// carriage-return and line-feed).
func (s *ScannerConfig) CsetSkipCharacters() string {
	valptr := &s.native.cset_skip_characters
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// CsetIdentifierFirst specifies the characters which can start identifiers (the
// default is G_CSET_a_2_z, "_", and G_CSET_A_2_Z).
func (s *ScannerConfig) CsetIdentifierFirst() string {
	valptr := &s.native.cset_identifier_first
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// CsetIdentifierNth specifies the characters which can be used in identifiers,
// after the first character (the default is G_CSET_a_2_z, "_0123456789",
// G_CSET_A_2_Z, G_CSET_LATINS, G_CSET_LATINC).
func (s *ScannerConfig) CsetIdentifierNth() string {
	valptr := &s.native.cset_identifier_nth
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// CpairCommentSingle specifies the characters at the start and end of
// single-line comments. The default is "#\n" which means that single-line
// comments start with a '#' and continue until a '\n' (end of line).
func (s *ScannerConfig) CpairCommentSingle() string {
	valptr := &s.native.cpair_comment_single
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Source: GSource struct is an opaque data type representing an event source.
//
// An instance of this type is always passed by reference.
type Source struct {
	*source
}

// source is the struct that's finalized.
type source struct {
	native *C.GSource
}

func marshalSource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Source{&source{(*C.GSource)(b)}}, nil
}

// NewSource constructs a struct Source.
func NewSource(sourceFuncs *SourceFuncs, structSize uint) *Source {
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.guint         // out
	var _cret *C.GSource      // in

	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(sourceFuncs)))
	_arg2 = C.guint(structSize)

	_cret = C.g_source_new(_arg1, _arg2)
	runtime.KeepAlive(sourceFuncs)
	runtime.KeepAlive(structSize)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_unref((*C.GSource)(intern.C))
		},
	)

	return _source
}

// AddChildSource adds child_source to source as a "polled" source; when source
// is added to a Context, child_source will be automatically added with the same
// priority, when child_source is triggered, it will cause source to dispatch
// (in addition to calling its own callback), and when source is destroyed,
// it will destroy child_source as well. (source will also still be dispatched
// if its own prepare/check functions indicate that it is ready.)
//
// If you don't need child_source to do anything on its own when it triggers,
// you can call g_source_set_dummy_callback() on it to set a callback that does
// nothing (except return TRUE if appropriate).
//
// source will hold a reference on child_source while child_source is attached
// to it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// The function takes the following parameters:
//
//   - childSource: second #GSource that source should "poll".
func (source *Source) AddChildSource(childSource *Source) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GSource // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(childSource)))

	C.g_source_add_child_source(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(childSource)
}

// Attach adds a #GSource to a context so that it will be executed within that
// context. Remove it by calling g_source_destroy().
//
// This function is safe to call from any thread, regardless of which thread the
// context is running in.
//
// The function takes the following parameters:
//
//   - context (optional) (if NULL, the global-default main context will be
//     used).
//
// The function returns the following values:
//
//   - guint: ID (greater than 0) for the source within the Context.
func (source *Source) Attach(context *MainContext) uint {
	var _arg0 *C.GSource      // out
	var _arg1 *C.GMainContext // out
	var _cret C.guint         // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	if context != nil {
		_arg1 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	_cret = C.g_source_attach(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(context)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Destroy removes a source from its Context, if any, and mark it as destroyed.
// The source cannot be subsequently added to another context. It is safe to
// call this on sources which have already been removed from their context.
//
// This does not unref the #GSource: if you still hold a reference, use
// g_source_unref() to drop it.
//
// This function is safe to call from any thread, regardless of which thread the
// Context is running in.
//
// If the source is currently attached to a Context, destroying it will
// effectively unset the callback similar to calling g_source_set_callback().
// This can mean, that the data's Notify gets called right away.
func (source *Source) Destroy() {
	var _arg0 *C.GSource // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	C.g_source_destroy(_arg0)
	runtime.KeepAlive(source)
}

// CanRecurse checks whether a source is allowed to be called recursively.
// see g_source_set_can_recurse().
//
// The function returns the following values:
//
//   - ok: whether recursion is allowed.
func (source *Source) CanRecurse() bool {
	var _arg0 *C.GSource // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_can_recurse(_arg0)
	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Context gets the Context with which the source is associated.
//
// You can call this on a source that has been destroyed, provided that the
// Context it was attached to still exists (in which case it will return that
// Context). In particular, you can always call this function on the source
// returned from g_main_current_source(). But calling this function on a source
// whose Context has been destroyed is an error.
//
// The function returns the following values:
//
//   - mainContext (optional) with which the source is associated, or NULL if
//     the context has not yet been added to a source.
func (source *Source) Context() *MainContext {
	var _arg0 *C.GSource      // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_context(_arg0)
	runtime.KeepAlive(source)

	var _mainContext *MainContext // out

	if _cret != nil {
		_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_main_context_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_mainContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_main_context_unref((*C.GMainContext)(intern.C))
			},
		)
	}

	return _mainContext
}

// CurrentTime: this function ignores source and is otherwise the same as
// g_get_current_time().
//
// Deprecated: use g_source_get_time() instead.
//
// The function takes the following parameters:
//
//   - timeval structure in which to store current time.
func (source *Source) CurrentTime(timeval *TimeVal) {
	var _arg0 *C.GSource  // out
	var _arg1 *C.GTimeVal // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(timeval)))

	C.g_source_get_current_time(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(timeval)
}

// ID returns the numeric ID for a particular source. The ID of a
// source is a positive integer which is unique within a particular
// main loop context. The reverse mapping from ID to source is done by
// g_main_context_find_source_by_id().
//
// You can only call this function while the source is associated to a
// Context instance; calling this function before g_source_attach() or after
// g_source_destroy() yields undefined behavior. The ID returned is unique
// within the Context instance passed to g_source_attach().
//
// The function returns the following values:
//
//   - guint: ID (greater than 0) for the source.
func (source *Source) ID() uint {
	var _arg0 *C.GSource // out
	var _cret C.guint    // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_id(_arg0)
	runtime.KeepAlive(source)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Name gets a name for the source, used in debugging and profiling. The name
// may be LL if it has never been set with g_source_set_name().
//
// The function returns the following values:
//
//   - utf8 (optional): name of the source.
func (source *Source) Name() string {
	var _arg0 *C.GSource // out
	var _cret *C.char    // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_name(_arg0)
	runtime.KeepAlive(source)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Priority gets the priority of a source.
//
// The function returns the following values:
//
//   - gint: priority of the source.
func (source *Source) Priority() int {
	var _arg0 *C.GSource // out
	var _cret C.gint     // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_priority(_arg0)
	runtime.KeepAlive(source)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ReadyTime gets the "ready time" of source, as set by
// g_source_set_ready_time().
//
// Any time before or equal to the current monotonic time (including 0) is an
// indication that the source will fire immediately.
//
// The function returns the following values:
//
//   - gint64: monotonic ready time, -1 for "never".
func (source *Source) ReadyTime() int64 {
	var _arg0 *C.GSource // out
	var _cret C.gint64   // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_ready_time(_arg0)
	runtime.KeepAlive(source)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Time gets the time to be used when checking this source. The advantage of
// calling this function over calling g_get_monotonic_time() directly is that
// when checking multiple sources, GLib can cache a single value instead of
// having to repeatedly get the system monotonic time.
//
// The time here is the system monotonic time, if available, or some other
// reasonable alternative otherwise. See g_get_monotonic_time().
//
// The function returns the following values:
//
//   - gint64: monotonic time in microseconds.
func (source *Source) Time() int64 {
	var _arg0 *C.GSource // out
	var _cret C.gint64   // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_time(_arg0)
	runtime.KeepAlive(source)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// IsDestroyed returns whether source has been destroyed.
//
// This is important when you operate upon your objects from within idle
// handlers, but may have freed the object before the dispatch of your idle
// handler.
//
//	static gboolean
//	idle_callback (gpointer data)
//	{
//	  SomeWidget *self = data;
//
//	  g_mutex_lock (&self->idle_id_mutex);
//	  if (!g_source_is_destroyed (g_main_current_source ()))
//	    {
//	      // do stuff with self
//	    }
//	  g_mutex_unlock (&self->idle_id_mutex);
//
//	  return FALSE;
//	}
//
// Calls to this function from a thread other than the one acquired by the
// Context the #GSource is attached to are typically redundant, as the source
// could be destroyed immediately after this function returns. However, once a
// source is destroyed it cannot be un-destroyed, so this function can be used
// for opportunistic checks from any thread.
//
// The function returns the following values:
//
//   - ok: TRUE if the source has been destroyed.
func (source *Source) IsDestroyed() bool {
	var _arg0 *C.GSource // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_is_destroyed(_arg0)
	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveChildSource detaches child_source from source and destroys it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// The function takes the following parameters:
//
//   - childSource previously passed to g_source_add_child_source().
func (source *Source) RemoveChildSource(childSource *Source) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GSource // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(childSource)))

	C.g_source_remove_child_source(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(childSource)
}

// SetCallback sets the callback function for a source. The callback for a
// source is called from the source's dispatch function.
//
// The exact type of func depends on the type of source; ie. you should not
// count on func being called with data as its first parameter. Cast func with
// G_SOURCE_FUNC() to avoid warnings about incompatible function types.
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle memory management of data.
//
// Typically, you won't use this function. Instead use functions specific to the
// type of source you are using, such as g_idle_add() or g_timeout_add().
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
//
// Note that g_source_destroy() for a currently attached source has the effect
// of also unsetting the callback.
//
// The function takes the following parameters:
//
//   - fn: callback function.
func (source *Source) SetCallback(fn SourceFunc) {
	var _arg0 *C.GSource    // out
	var _arg1 C.GSourceFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*[0]byte)(C._gotk4_glib2_SourceFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.g_source_set_callback(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(source)
	runtime.KeepAlive(fn)
}

// SetCallbackIndirect sets the callback function storing the data as a
// refcounted callback "object". This is used internally. Note that calling
// g_source_set_callback_indirect() assumes an initial reference count on
// callback_data, and thus callback_funcs->unref will eventually be called once
// more than callback_funcs->ref.
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
//
// The function takes the following parameters:
//
//   - callbackData (optional): pointer to callback data "object".
//   - callbackFuncs functions for reference counting callback_data and getting
//     the callback and data.
func (source *Source) SetCallbackIndirect(callbackData unsafe.Pointer, callbackFuncs *SourceCallbackFuncs) {
	var _arg0 *C.GSource              // out
	var _arg1 C.gpointer              // out
	var _arg2 *C.GSourceCallbackFuncs // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (C.gpointer)(unsafe.Pointer(callbackData))
	_arg2 = (*C.GSourceCallbackFuncs)(gextras.StructNative(unsafe.Pointer(callbackFuncs)))

	C.g_source_set_callback_indirect(_arg0, _arg1, _arg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(callbackData)
	runtime.KeepAlive(callbackFuncs)
}

// SetCanRecurse sets whether a source can be called recursively. If can_recurse
// is TRUE, then while the source is being dispatched then this source will be
// processed normally. Otherwise, all processing of this source is blocked until
// the dispatch function returns.
//
// The function takes the following parameters:
//
//   - canRecurse: whether recursion is allowed for this source.
func (source *Source) SetCanRecurse(canRecurse bool) {
	var _arg0 *C.GSource // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	if canRecurse {
		_arg1 = C.TRUE
	}

	C.g_source_set_can_recurse(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(canRecurse)
}

// SetFuncs sets the source functions (can be used to override default
// implementations) of an unattached source.
//
// The function takes the following parameters:
//
//   - funcs: new Funcs.
func (source *Source) SetFuncs(funcs *SourceFuncs) {
	var _arg0 *C.GSource      // out
	var _arg1 *C.GSourceFuncs // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(funcs)))

	C.g_source_set_funcs(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(funcs)
}

// SetName sets a name for the source, used in debugging and profiling. The name
// defaults to LL.
//
// The source name should describe in a human-readable way what the source does.
// For example, "X11 event queue" or "GTK repaint idle handler" or whatever it
// is.
//
// It is permitted to call this function multiple times, but is not recommended
// due to the potential performance impact. For example, one could change the
// name in the "check" function of a Funcs to include details like the event
// type in the source name.
//
// Use caution if changing the name while another thread may be accessing it
// with g_source_get_name(); that function does not copy the value, and changing
// the value will free it while the other thread may be attempting to use it.
//
// Also see g_source_set_static_name().
//
// The function takes the following parameters:
//
//   - name: debug name for the source.
func (source *Source) SetName(name string) {
	var _arg0 *C.GSource // out
	var _arg1 *C.char    // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_source_set_name(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(name)
}

// SetPriority sets the priority of a source. While the main loop is being run,
// a source will be dispatched if it is ready to be dispatched and no sources at
// a higher (numerically smaller) priority are ready to be dispatched.
//
// A child source always has the same priority as its parent. It is not
// permitted to change the priority of a source once it has been added as a
// child of another source.
//
// The function takes the following parameters:
//
//   - priority: new priority.
func (source *Source) SetPriority(priority int) {
	var _arg0 *C.GSource // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = C.gint(priority)

	C.g_source_set_priority(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(priority)
}

// SetReadyTime sets a #GSource to be dispatched when the given monotonic time
// is reached (or passed). If the monotonic time is in the past (as it always
// will be if ready_time is 0) then the source will be dispatched immediately.
//
// If ready_time is -1 then the source is never woken up on the basis of the
// passage of time.
//
// Dispatching the source does not reset the ready time. You should do so
// yourself, from the source dispatch function.
//
// Note that if you have a pair of sources where the ready time of one suggests
// that it will be delivered first but the priority for the other suggests
// that it would be delivered first, and the ready time for both sources is
// reached during the same main context iteration, then the order of dispatch is
// undefined.
//
// It is a no-op to call this function on a #GSource which has already been
// destroyed with g_source_destroy().
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// The function takes the following parameters:
//
//   - readyTime: monotonic time at which the source will be ready, 0 for
//     "immediately", -1 for "never".
func (source *Source) SetReadyTime(readyTime int64) {
	var _arg0 *C.GSource // out
	var _arg1 C.gint64   // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = C.gint64(readyTime)

	C.g_source_set_ready_time(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(readyTime)
}

// SetStaticName: variant of g_source_set_name() that does not duplicate the
// name, and can only be used with string literals.
//
// The function takes the following parameters:
//
//   - name: debug name for the source.
func (source *Source) SetStaticName(name string) {
	var _arg0 *C.GSource // out
	var _arg1 *C.char    // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_source_set_static_name(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(name)
}

// SourceRemoveByFuncsUserData removes a source from the default main loop
// context given the source functions and user data. If multiple sources exist
// with the same source functions and user data, only one will be destroyed.
//
// The function takes the following parameters:
//
//   - funcs passed to g_source_new().
//   - userData (optional): user data for the callback.
//
// The function returns the following values:
//
//   - ok: TRUE if a source was found and removed.
func SourceRemoveByFuncsUserData(funcs *SourceFuncs, userData unsafe.Pointer) bool {
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.gpointer      // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(funcs)))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_source_remove_by_funcs_user_data(_arg1, _arg2)
	runtime.KeepAlive(funcs)
	runtime.KeepAlive(userData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SourceRemoveByUserData removes a source from the default main loop context
// given the user data for the callback. If multiple sources exist with the same
// user data, only one will be destroyed.
//
// The function takes the following parameters:
//
//   - userData (optional): user_data for the callback.
//
// The function returns the following values:
//
//   - ok: TRUE if a source was found and removed.
func SourceRemoveByUserData(userData unsafe.Pointer) bool {
	var _arg1 C.gpointer // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_source_remove_by_user_data(_arg1)
	runtime.KeepAlive(userData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SourceSetNameByID sets the name of a source using its ID.
//
// This is a convenience utility to set source names from the return value of
// g_idle_add(), g_timeout_add(), etc.
//
// It is a programmer error to attempt to set the name of a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
//
// The function takes the following parameters:
//
//   - tag: #GSource ID.
//   - name: debug name for the source.
func SourceSetNameByID(tag uint, name string) {
	var _arg1 C.guint // out
	var _arg2 *C.char // out

	_arg1 = C.guint(tag)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_source_set_name_by_id(_arg1, _arg2)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(name)
}

// SourceCallbackFuncs: GSourceCallbackFuncs struct contains functions for
// managing callback objects.
//
// An instance of this type is always passed by reference.
type SourceCallbackFuncs struct {
	*sourceCallbackFuncs
}

// sourceCallbackFuncs is the struct that's finalized.
type sourceCallbackFuncs struct {
	native *C.GSourceCallbackFuncs
}

// SourceFuncs: GSourceFuncs struct contains a table of functions used to handle
// event sources in a generic manner.
//
// For idle sources, the prepare and check functions always return TRUE to
// indicate that the source is always ready to be processed. The prepare
// function also returns a timeout value of 0 to ensure that the poll() call
// doesn't block (since that would be time wasted which could have been spent
// running the idle function).
//
// For timeout sources, the prepare and check functions both return TRUE if the
// timeout interval has expired. The prepare function also returns a timeout
// value to ensure that the poll() call doesn't block too long and miss the next
// timeout.
//
// For file descriptor sources, the prepare function typically returns FALSE,
// since it must wait until poll() has been called before it knows whether any
// events need to be processed. It sets the returned timeout to -1 to indicate
// that it doesn't mind how long the poll() call blocks. In the check function,
// it tests the results of the poll() call to see if the required condition has
// been met, and returns TRUE if so.
//
// An instance of this type is always passed by reference.
type SourceFuncs struct {
	*sourceFuncs
}

// sourceFuncs is the struct that's finalized.
type sourceFuncs struct {
	native *C.GSourceFuncs
}

// TimeVal represents a precise time, with seconds and microseconds.
//
// Similar to the struct timeval returned by the gettimeofday() UNIX system
// call.
//
// GLib is attempting to unify around the use of 64-bit integers to represent
// microsecond-precision time. As such, this type will be removed from a future
// version of GLib. A consequence of using glong for tv_sec is that on 32-bit
// systems GTimeVal is subject to the year 2038 problem.
//
// Deprecated: Use Time or #guint64 instead.
//
// An instance of this type is always passed by reference.
type TimeVal struct {
	*timeVal
}

// timeVal is the struct that's finalized.
type timeVal struct {
	native *C.GTimeVal
}

// NewTimeVal creates a new TimeVal instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewTimeVal(tvSec, tvUsec int32) TimeVal {
	var f0 C.glong // out
	f0 = C.glong(tvSec)
	var f1 C.glong // out
	f1 = C.glong(tvUsec)

	v := C.GTimeVal{
		tv_sec:  f0,
		tv_usec: f1,
	}

	return *(*TimeVal)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// TvSec: seconds.
func (t *TimeVal) TvSec() int32 {
	valptr := &t.native.tv_sec
	var _v int32 // out
	_v = int32(*valptr)
	return _v
}

// TvUsec: microseconds.
func (t *TimeVal) TvUsec() int32 {
	valptr := &t.native.tv_usec
	var _v int32 // out
	_v = int32(*valptr)
	return _v
}

// TvSec: seconds.
func (t *TimeVal) SetTvSec(tvSec int32) {
	valptr := &t.native.tv_sec
	*valptr = C.glong(tvSec)
}

// TvUsec: microseconds.
func (t *TimeVal) SetTvUsec(tvUsec int32) {
	valptr := &t.native.tv_usec
	*valptr = C.glong(tvUsec)
}

// Add adds the given number of microseconds to time_. microseconds can also be
// negative to decrease the value of time_.
//
// Deprecated: Val is not year-2038-safe. Use guint64 for representing
// microseconds since the epoch, or use Time.
//
// The function takes the following parameters:
//
//   - microseconds: number of microseconds to add to time.
func (time_ *TimeVal) Add(microseconds int32) {
	var _arg0 *C.GTimeVal // out
	var _arg1 C.glong     // out

	_arg0 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(time_)))
	_arg1 = C.glong(microseconds)

	C.g_time_val_add(_arg0, _arg1)
	runtime.KeepAlive(time_)
	runtime.KeepAlive(microseconds)
}

// ToISO8601 converts time_ into an RFC 3339 encoded string, relative to the
// Coordinated Universal Time (UTC). This is one of the many formats allowed by
// ISO 8601.
//
// ISO 8601 allows a large number of date/time formats, with or without
// punctuation and optional elements. The format returned by this function is
// a complete date and time, with optional punctuation included, the UTC time
// zone represented as "Z", and the tv_usec part included if and only if it is
// nonzero, i.e. either "YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".
//
// This corresponds to the Internet date/time format defined by RFC 3339
// (https://www.ietf.org/rfc/rfc3339.txt), and to either of the two
// most-precise formats defined by the W3C Note Date and Time Formats
// (http://www.w3.org/TR/NOTE-datetime-19980827). Both of these documents are
// profiles of ISO 8601.
//
// Use g_date_time_format() or g_strdup_printf() if a different variation of ISO
// 8601 format is required.
//
// If time_ represents a date which is too large to fit into a struct tm, NULL
// will be returned. This is platform dependent. Note also that since GTimeVal
// stores the number of seconds as a glong, on 32-bit systems it is subject to
// the year 2038 problem. Accordingly, since GLib 2.62, this function has been
// deprecated. Equivalent functionality is available using:
//
//	GDateTime *dt = g_date_time_new_from_unix_utc (time_val);
//	iso8601_string = g_date_time_format_iso8601 (dt);
//	g_date_time_unref (dt);
//
// The return value of g_time_val_to_iso8601() has been nullable since GLib
// 2.54; before then, GLib would crash under the same conditions.
//
// Deprecated: Val is not year-2038-safe. Use g_date_time_format_iso8601(dt)
// instead.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing an ISO 8601 date,
//     or NULL if time_ was too large.
func (time_ *TimeVal) ToISO8601() string {
	var _arg0 *C.GTimeVal // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(time_)))

	_cret = C.g_time_val_to_iso8601(_arg0)
	runtime.KeepAlive(time_)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TimeValFromISO8601 converts a string containing an ISO 8601 encoded date and
// time to a Val and puts it into time_.
//
// iso_date must include year, month, day, hours, minutes, and seconds.
// It can optionally include fractions of a second and a time zone indicator.
// (In the absence of any time zone indication, the timestamp is assumed to be
// in local time.)
//
// Any leading or trailing space in iso_date is ignored.
//
// This function was deprecated, along with Val itself, in GLib 2.62. Equivalent
// functionality is available using code like:
//
//	GDateTime *dt = g_date_time_new_from_iso8601 (iso8601_string, NULL);
//	gint64 time_val = g_date_time_to_unix (dt);
//	g_date_time_unref (dt);
//
// Deprecated: Val is not year-2038-safe. Use g_date_time_new_from_iso8601()
// instead.
//
// The function takes the following parameters:
//
//   - isoDate: ISO 8601 encoded date string.
//
// The function returns the following values:
//
//   - time_: Val.
//   - ok: TRUE if the conversion was successful.
func TimeValFromISO8601(isoDate string) (*TimeVal, bool) {
	var _arg1 *C.gchar   // out
	var _arg2 C.GTimeVal // in
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(isoDate)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_time_val_from_iso8601(_arg1, &_arg2)
	runtime.KeepAlive(isoDate)

	var _time_ *TimeVal // out
	var _ok bool        // out

	_time_ = (*TimeVal)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _time_, _ok
}

// TimeZone: GTimeZone represents a time zone, at no particular point in time.
//
// The GTimeZone struct is refcounted and immutable.
//
// Each time zone has an identifier (for example, ‘Europe/London’) which
// is platform dependent. See glib.TimeZone.New for information on the
// identifier formats. The identifier of a time zone can be retrieved using
// glib.TimeZone.GetIdentifier().
//
// A time zone contains a number of intervals. Each interval has an abbreviation
// to describe it (for example, ‘PDT’), an offset to UTC and a flag indicating
// if the daylight savings time is in effect during that interval. A time
// zone always has at least one interval — interval 0. Note that interval
// abbreviations are not the same as time zone identifiers (apart from ‘UTC’),
// and cannot be passed to glib.TimeZone.New.
//
// Every UTC time is contained within exactly one interval, but a given
// local time may be contained within zero, one or two intervals (due to
// incontinuities associated with daylight savings time).
//
// An interval may refer to a specific period of time (eg: the duration of
// daylight savings time during 2010) or it may refer to many periods of time
// that share the same properties (eg: all periods of daylight savings time). It
// is also possible (usually for political reasons) that some properties (like
// the abbreviation) change between intervals without other properties changing.
//
// An instance of this type is always passed by reference.
type TimeZone struct {
	*timeZone
}

// timeZone is the struct that's finalized.
type timeZone struct {
	native *C.GTimeZone
}

func marshalTimeZone(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TimeZone{&timeZone{(*C.GTimeZone)(b)}}, nil
}

// NewTimeZone constructs a struct TimeZone.
func NewTimeZone(identifier string) *TimeZone {
	var _arg1 *C.gchar     // out
	var _cret *C.GTimeZone // in

	if identifier != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(identifier)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_time_zone_new(_arg1)
	runtime.KeepAlive(identifier)

	var _timeZone *TimeZone // out

	_timeZone = (*TimeZone)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_timeZone)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_time_zone_unref((*C.GTimeZone)(intern.C))
		},
	)

	return _timeZone
}

// NewTimeZoneIdentifier constructs a struct TimeZone.
func NewTimeZoneIdentifier(identifier string) *TimeZone {
	var _arg1 *C.gchar     // out
	var _cret *C.GTimeZone // in

	if identifier != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(identifier)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.g_time_zone_new_identifier(_arg1)
	runtime.KeepAlive(identifier)

	var _timeZone *TimeZone // out

	if _cret != nil {
		_timeZone = (*TimeZone)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_timeZone)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_time_zone_unref((*C.GTimeZone)(intern.C))
			},
		)
	}

	return _timeZone
}

// NewTimeZoneLocal constructs a struct TimeZone.
func NewTimeZoneLocal() *TimeZone {
	var _cret *C.GTimeZone // in

	_cret = C.g_time_zone_new_local()

	var _timeZone *TimeZone // out

	_timeZone = (*TimeZone)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_timeZone)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_time_zone_unref((*C.GTimeZone)(intern.C))
		},
	)

	return _timeZone
}

// NewTimeZoneOffset constructs a struct TimeZone.
func NewTimeZoneOffset(seconds int32) *TimeZone {
	var _arg1 C.gint32     // out
	var _cret *C.GTimeZone // in

	_arg1 = C.gint32(seconds)

	_cret = C.g_time_zone_new_offset(_arg1)
	runtime.KeepAlive(seconds)

	var _timeZone *TimeZone // out

	_timeZone = (*TimeZone)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_timeZone)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_time_zone_unref((*C.GTimeZone)(intern.C))
		},
	)

	return _timeZone
}

// NewTimeZoneUTC constructs a struct TimeZone.
func NewTimeZoneUTC() *TimeZone {
	var _cret *C.GTimeZone // in

	_cret = C.g_time_zone_new_utc()

	var _timeZone *TimeZone // out

	_timeZone = (*TimeZone)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_timeZone)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_time_zone_unref((*C.GTimeZone)(intern.C))
		},
	)

	return _timeZone
}

// FindInterval finds an interval within tz that corresponds to the given time_.
// The meaning of time_ depends on type.
//
// If type is G_TIME_TYPE_UNIVERSAL then this function will always succeed
// (since universal time is monotonic and continuous).
//
// Otherwise time_ is treated as local time. The distinction between
// G_TIME_TYPE_STANDARD and G_TIME_TYPE_DAYLIGHT is ignored except in the case
// that the given time_ is ambiguous. In Toronto, for example, 01:30 on November
// 7th 2010 occurred twice (once inside of daylight savings time and the next,
// an hour later, outside of daylight savings time). In this case, the different
// value of type would result in a different interval being returned.
//
// It is still possible for this function to fail. In Toronto, for example,
// 02:00 on March 14th 2010 does not exist (due to the leap forward to begin
// daylight savings time). -1 is returned in that case.
//
// The function takes the following parameters:
//
//   - typ of time_.
//   - time_: number of seconds since January 1, 1970.
//
// The function returns the following values:
//
//   - gint: interval containing time_, or -1 in case of failure.
func (tz *TimeZone) FindInterval(typ TimeType, time_ int64) int {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.GTimeType  // out
	var _arg2 C.gint64     // out
	var _cret C.gint       // in

	_arg0 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))
	_arg1 = C.GTimeType(typ)
	_arg2 = C.gint64(time_)

	_cret = C.g_time_zone_find_interval(_arg0, _arg1, _arg2)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(time_)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Abbreviation determines the time zone abbreviation to be used during a
// particular interval of time in the time zone tz.
//
// For example, in Toronto this is currently "EST" during the winter months and
// "EDT" during the summer months when daylight savings time is in effect.
//
// The function takes the following parameters:
//
//   - interval within the timezone.
//
// The function returns the following values:
//
//   - utf8: time zone abbreviation, which belongs to tz.
func (tz *TimeZone) Abbreviation(interval int) string {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.gint       // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))
	_arg1 = C.gint(interval)

	_cret = C.g_time_zone_get_abbreviation(_arg0, _arg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Identifier: get the identifier of this Zone, as passed to g_time_zone_new().
// If the identifier passed at construction time was not recognised,
// UTC will be returned. If it was NULL, the identifier of the local timezone at
// construction time will be returned.
//
// The identifier will be returned in the same format as provided at
// construction time: if provided as a time offset, that will be returned by
// this function.
//
// The function returns the following values:
//
//   - utf8: identifier for this timezone.
func (tz *TimeZone) Identifier() string {
	var _arg0 *C.GTimeZone // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))

	_cret = C.g_time_zone_get_identifier(_arg0)
	runtime.KeepAlive(tz)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Offset determines the offset to UTC in effect during a particular interval of
// time in the time zone tz.
//
// The offset is the number of seconds that you add to UTC time to arrive at
// local time for tz (ie: negative numbers for time zones west of GMT, positive
// numbers for east).
//
// The function takes the following parameters:
//
//   - interval within the timezone.
//
// The function returns the following values:
//
//   - gint32: number of seconds that should be added to UTC to get the local
//     time in tz.
func (tz *TimeZone) Offset(interval int) int32 {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.gint       // out
	var _cret C.gint32     // in

	_arg0 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))
	_arg1 = C.gint(interval)

	_cret = C.g_time_zone_get_offset(_arg0, _arg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// IsDst determines if daylight savings time is in effect during a particular
// interval of time in the time zone tz.
//
// The function takes the following parameters:
//
//   - interval within the timezone.
//
// The function returns the following values:
//
//   - ok: TRUE if daylight savings time is in effect.
func (tz *TimeZone) IsDst(interval int) bool {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GTimeZone)(gextras.StructNative(unsafe.Pointer(tz)))
	_arg1 = C.gint(interval)

	_cret = C.g_time_zone_is_dst(_arg0, _arg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Tree struct is an opaque data structure representing a [balanced binary
// tree][glib-Balanced-Binary-Trees]. It should be accessed only by using the
// following functions.
//
// An instance of this type is always passed by reference.
type Tree struct {
	*tree
}

// tree is the struct that's finalized.
type tree struct {
	native *C.GTree
}

func marshalTree(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Tree{&tree{(*C.GTree)(b)}}, nil
}

// Destroy removes all keys and values from the #GTree and decreases its
// reference count by one. If keys and/or values are dynamically allocated, you
// should either free them first or create the #GTree using g_tree_new_full().
// In the latter case the destroy functions you supplied will be called on all
// keys and values before destroying the #GTree.
func (tree *Tree) Destroy() {
	var _arg0 *C.GTree // out

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))

	C.g_tree_destroy(_arg0)
	runtime.KeepAlive(tree)
}

// Height gets the height of a #GTree.
//
// If the #GTree contains no nodes, the height is 0. If the #GTree contains only
// one root node the height is 1. If the root node has children the height is 2,
// etc.
//
// The function returns the following values:
//
//   - gint: height of tree.
func (tree *Tree) Height() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))

	_cret = C.g_tree_height(_arg0)
	runtime.KeepAlive(tree)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Insert inserts a key/value pair into a #GTree.
//
// Inserts a new key and value into a #GTree as g_tree_insert_node() does,
// only this function does not return the inserted or set node.
//
// The function takes the following parameters:
//
//   - key (optional) to insert.
//   - value (optional) corresponding to the key.
func (tree *Tree) Insert(key unsafe.Pointer, value unsafe.Pointer) {
	var _arg0 *C.GTree   // out
	var _arg1 C.gpointer // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gpointer)(unsafe.Pointer(key))
	_arg2 = (C.gpointer)(unsafe.Pointer(value))

	C.g_tree_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// Lookup gets the value corresponding to the given key. Since a #GTree is
// automatically balanced as key/value pairs are added, key lookup is O(log n)
// (where n is the number of key/value pairs in the tree).
//
// The function takes the following parameters:
//
//   - key (optional) to look up.
//
// The function returns the following values:
//
//   - gpointer (optional): value corresponding to the key, or NULL if the key
//     was not found.
func (tree *Tree) Lookup(key unsafe.Pointer) unsafe.Pointer {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gpointer      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_tree_lookup(_arg0, _arg1)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// LookupExtended looks up a key in the #GTree, returning the original key and
// the associated value. This is useful if you need to free the memory allocated
// for the original key, for example before calling g_tree_remove().
//
// The function takes the following parameters:
//
//   - lookupKey (optional): key to look up.
//
// The function returns the following values:
//
//   - origKey (optional) returns the original key.
//   - value (optional) returns the value associated with the key.
//   - ok: TRUE if the key was found in the #GTree.
func (tree *Tree) LookupExtended(lookupKey unsafe.Pointer) (origKey unsafe.Pointer, value unsafe.Pointer, ok bool) {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _arg2 C.gpointer      // in
	var _arg3 C.gpointer      // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(lookupKey))

	_cret = C.g_tree_lookup_extended(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(lookupKey)

	var _origKey unsafe.Pointer // out
	var _value unsafe.Pointer   // out
	var _ok bool                // out

	_origKey = (unsafe.Pointer)(unsafe.Pointer(_arg2))
	_value = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	if _cret != 0 {
		_ok = true
	}

	return _origKey, _value, _ok
}

// Nnodes gets the number of nodes in a #GTree.
//
// The function returns the following values:
//
//   - gint: number of nodes in tree
//
//     The node counter value type is really a #guint, but it is returned as a
//     #gint due to backward compatibility issues (can be cast back to #guint to
//     support its full range of values).
func (tree *Tree) Nnodes() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))

	_cret = C.g_tree_nnodes(_arg0)
	runtime.KeepAlive(tree)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Remove removes a key/value pair from a #GTree.
//
// If the #GTree was created using g_tree_new_full(), the key and value are
// freed using the supplied destroy functions, otherwise you have to make sure
// that any dynamically allocated values are freed yourself. If the key does not
// exist in the #GTree, the function does nothing.
//
// The cost of maintaining a balanced tree while removing a key/value result in
// a O(n log(n)) operation where most of the other operations are O(log(n)).
//
// The function takes the following parameters:
//
//   - key (optional) to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the key was found (prior to 2.8, this function returned
//     nothing).
func (tree *Tree) Remove(key unsafe.Pointer) bool {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_tree_remove(_arg0, _arg1)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAll removes all nodes from a #GTree and destroys their keys and values,
// then resets the #GTree’s root to NULL.
func (tree *Tree) RemoveAll() {
	var _arg0 *C.GTree // out

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))

	C.g_tree_remove_all(_arg0)
	runtime.KeepAlive(tree)
}

// Replace inserts a new key and value into a #GTree as g_tree_replace_node()
// does, only this function does not return the inserted or set node.
//
// The function takes the following parameters:
//
//   - key (optional) to insert.
//   - value (optional) corresponding to the key.
func (tree *Tree) Replace(key unsafe.Pointer, value unsafe.Pointer) {
	var _arg0 *C.GTree   // out
	var _arg1 C.gpointer // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gpointer)(unsafe.Pointer(key))
	_arg2 = (C.gpointer)(unsafe.Pointer(value))

	C.g_tree_replace(_arg0, _arg1, _arg2)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// Steal removes a key and its associated value from a #GTree without calling
// the key and value destroy functions.
//
// If the key does not exist in the #GTree, the function does nothing.
//
// The function takes the following parameters:
//
//   - key (optional) to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the key was found (prior to 2.8, this function returned
//     nothing).
func (tree *Tree) Steal(key unsafe.Pointer) bool {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_tree_steal(_arg0, _arg1)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Tuples struct is used to return records (or tuples) from the #GRelation
// by g_relation_select(). It only contains one public member - the number
// of records that matched. To access the matched records, you must use
// g_tuples_index().
//
// Deprecated: Rarely used API.
//
// An instance of this type is always passed by reference.
type Tuples struct {
	*tuples
}

// tuples is the struct that's finalized.
type tuples struct {
	native *C.GTuples
}

// NewTuples creates a new Tuples instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewTuples(len uint) Tuples {
	var f0 C.guint // out
	f0 = C.guint(len)

	v := C.GTuples{
		len: f0,
	}

	return *(*Tuples)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Len: number of records that matched.
func (t *Tuples) Len() uint {
	valptr := &t.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of records that matched.
func (t *Tuples) SetLen(len uint) {
	valptr := &t.native.len
	*valptr = C.guint(len)
}

// Destroy frees the records which were returned by g_relation_select().
// This should always be called after g_relation_select() when you are finished
// with the records. The records are not removed from the #GRelation.
//
// Deprecated: Rarely used API.
func (tuples *Tuples) Destroy() {
	var _arg0 *C.GTuples // out

	_arg0 = (*C.GTuples)(gextras.StructNative(unsafe.Pointer(tuples)))

	C.g_tuples_destroy(_arg0)
	runtime.KeepAlive(tuples)
}

// Index gets a field from the records returned by g_relation_select().
// It returns the given field of the record at the given index. The returned
// value should not be changed.
//
// Deprecated: Rarely used API.
//
// The function takes the following parameters:
//
//   - index_: index of the record.
//   - field to return.
//
// The function returns the following values:
//
//   - gpointer (optional): field of the record.
func (tuples *Tuples) Index(index_ int, field int) unsafe.Pointer {
	var _arg0 *C.GTuples // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTuples)(gextras.StructNative(unsafe.Pointer(tuples)))
	_arg1 = C.gint(index_)
	_arg2 = C.gint(field)

	_cret = C.g_tuples_index(_arg0, _arg1, _arg2)
	runtime.KeepAlive(tuples)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(field)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// URI: GUri type and related functions can be used to parse URIs into their
// components, and build valid URIs from individual components.
//
// Since GUri only represents absolute URIs, all GUris will have a URI scheme,
// so glib.URI.GetScheme() will always return a non-NULL answer. Likewise,
// by definition, all URIs have a path component, so glib.URI.GetPath() will
// always return a non-NULL string (which may be empty).
//
// If the URI string has an ‘authority’ component
// (https://tools.ietf.org/html/rfc3986#section-3) (that is, if the scheme is
// followed by :// rather than just :), then the GUri will contain a hostname,
// and possibly a port and ‘userinfo’. Additionally, depending on how the GUri
// was constructed/parsed (for example, using the G_URI_FLAGS_HAS_PASSWORD and
// G_URI_FLAGS_HAS_AUTH_PARAMS flags), the userinfo may be split out into a
// username, password, and additional authorization-related parameters.
//
// Normally, the components of a GUri will have all %-encoded characters
// decoded. However, if you construct/parse a GUri with G_URI_FLAGS_ENCODED,
// then the %-encoding will be preserved instead in the userinfo,
// path, and query fields (and in the host field if also created with
// G_URI_FLAGS_NON_DNS). In particular, this is necessary if the URI may contain
// binary data or non-UTF-8 text, or if decoding the components might change the
// interpretation of the URI.
//
// For example, with the encoded flag:
//
//	g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http3A2F2Fhost2Fpath3Fparam3Dvalue", G_URI_FLAGS_ENCODED, &err);
//	g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http3A2F2Fhost2Fpath3Fparam3Dvalue");
//
// While the default %-decoding behaviour would give:
//
//	g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http3A2F2Fhost2Fpath3Fparam3Dvalue", G_URI_FLAGS_NONE, &err);
//	g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http://host/path?param=value");
//
// During decoding, if an invalid UTF-8 string is encountered, parsing will fail
// with an error indicating the bad string location:
//
//	g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http3A2F2Fhost2Fpath3Fbad3D00alue", G_URI_FLAGS_NONE, &err);
//	g_assert_error (err, G_URI_ERROR, G_URI_ERROR_BAD_QUERY);
//
// You should pass G_URI_FLAGS_ENCODED or G_URI_FLAGS_ENCODED_QUERY if you need
// to handle that case manually. In particular, if the query string contains =
// characters that are %-encoded, you should let glib.URI().ParseParams do the
// decoding once of the query.
//
// GUri is immutable once constructed, and can safely be accessed from multiple
// threads. Its reference counting is atomic.
//
// Note that the scope of GUri is to help manipulate URIs in various
// applications, following RFC 3986 (https://tools.ietf.org/html/rfc3986).
// In particular, it doesn't intend to cover web browser needs,
// and doesn’t implement the WHATWG URL (https://url.spec.whatwg.org/)
// standard. No APIs are provided to help prevent homograph attacks
// (https://en.wikipedia.org/wiki/IDN_homograph_attack), so GUri is not suitable
// for formatting URIs for display to the user for making security-sensitive
// decisions.
//
// # Relative and absolute URIs
//
// As defined in RFC 3986 (https://tools.ietf.org/html/rfc3986#section-4),
// the hierarchical nature of URIs means that they can either
// be ‘relative references’ (sometimes referred to as ‘relative
// URIs’) or ‘URIs’ (for clarity, ‘URIs’ are referred to in this
// documentation as ‘absolute URIs’ — although in constrast to RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-4.3), fragment identifiers are
// always allowed).
//
// Relative references have one or more components of the URI missing.
// In particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with ./ rather than /.
//
// For example, a valid relative reference is ./path?query, /?query#fragment or
// //example.com.
//
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using glib.URI.ParseRelative().
//
// For example, a valid absolute URI is file:///home/bob or
// https://search.com?query=string.
//
// A GUri instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
//
// # Parsing URIs
//
// The most minimalist APIs for parsing URIs are glib.URI().Split and
// glib.URI().SplitWithUser. These split a URI into its component parts,
// and return the parts; the difference between the two is that glib.URI().Split
// treats the ‘userinfo’ component of the URI as a single element, while
// glib.URI().SplitWithUser can (depending on the glib.URIFlags you pass)
// treat it as containing a username, password, and authentication parameters.
// Alternatively, glib.URI().SplitNetwork can be used when you are only
// interested in the components that are needed to initiate a network connection
// to the service (scheme, host, and port).
//
// glib.URI().Parse is similar to glib.URI().Split, but instead of returning
// individual strings, it returns a GUri structure (and it requires that the URI
// be an absolute URI).
//
// glib.URI().ResolveRelative and glib.URI.ParseRelative() allow you to resolve
// a relative URI relative to a base URI. glib.URI().ResolveRelative takes two
// strings and returns a string, and glib.URI.ParseRelative() takes a GUri and a
// string and returns a GUri.
//
// All of the parsing functions take a glib.URIFlags argument describing exactly
// how to parse the URI; see the documentation for that type for more details on
// the specific flags that you can pass. If you need to choose different flags
// based on the type of URI, you can use glib.URI().PeekScheme on the URI string
// to check the scheme first, and use that to decide what flags to parse it
// with.
//
// For example, you might want to use G_URI_PARAMS_WWW_FORM when parsing the
// params for a web URI, so compare the result of glib.URI().PeekScheme against
// http and https.
//
// # Building URIs
//
// glib.URI().Join and glib.URI().JoinWithUser can be used to construct
// valid URI strings from a set of component strings. They are the inverse of
// glib.URI().Split and glib.URI().SplitWithUser.
//
// Similarly, glib.URI().Build and glib.URI().BuildWithUser can be used to
// construct a GUri from a set of component strings.
//
// As with the parsing functions, the building functions take a glib.URIFlags
// argument. In particular, it is important to keep in mind whether the URI
// components you are using are already %-encoded. If so, you must pass the
// G_URI_FLAGS_ENCODED flag.
//
// file:// URIs
//
// Note that Windows and Unix both define special rules for parsing file://
// URIs (involving non-UTF-8 character sets on Unix, and the interpretation
// of path separators on Windows). GUri does not implement these rules.
// Use glib.FilenameFromURI() and glib.FilenameToURI() if you want to properly
// convert between file:// URIs and local filenames.
//
// # URI Equality
//
// Note that there is no g_uri_equal () function, because comparing URIs
// usefully requires scheme-specific knowledge that GUri does not have. GUri can
// help with normalization if you use the various encoded glib.URIFlags as well
// as G_URI_FLAGS_SCHEME_NORMALIZE however it is not comprehensive. For example,
// data:,foo and data:;base64,Zm9v resolve to the same thing according to the
// data: URI specification which GLib does not handle.
//
// An instance of this type is always passed by reference.
type URI struct {
	*urI
}

// urI is the struct that's finalized.
type urI struct {
	native *C.GUri
}

func marshalURI(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &URI{&urI{(*C.GUri)(b)}}, nil
}

// AuthParams gets uri's authentication parameters, which may contain
// %-encoding, depending on the flags with which uri was created. (If uri was
// not created with G_URI_FLAGS_HAS_AUTH_PARAMS then this will be NULL.)
//
// Depending on the URI scheme, g_uri_parse_params() may be useful for further
// parsing this information.
//
// The function returns the following values:
//
//   - utf8 (optional) uri's authentication parameters.
func (uri *URI) AuthParams() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_auth_params(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Flags gets uri's flags set upon construction.
//
// The function returns the following values:
//
//   - uriFlags uri's flags.
func (uri *URI) Flags() URIFlags {
	var _arg0 *C.GUri     // out
	var _cret C.GUriFlags // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_flags(_arg0)
	runtime.KeepAlive(uri)

	var _uriFlags URIFlags // out

	_uriFlags = URIFlags(_cret)

	return _uriFlags
}

// Fragment gets uri's fragment, which may contain %-encoding, depending on the
// flags with which uri was created.
//
// The function returns the following values:
//
//   - utf8 (optional) uri's fragment.
func (uri *URI) Fragment() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_fragment(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Host gets uri's host. This will never have %-encoded characters,
// unless it is non-UTF-8 (which can only be the case if uri was created with
// G_URI_FLAGS_NON_DNS).
//
// If uri contained an IPv6 address literal, this value will be just that
// address, without the brackets around it that are necessary in the string form
// of the URI. Note that in this case there may also be a scope ID attached to
// the address. Eg, fe80::1234em1 (or fe80::123425em1 if the string is still
// encoded).
//
// The function returns the following values:
//
//   - utf8 (optional) uri's host.
func (uri *URI) Host() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_host(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Password gets uri's password, which may contain %-encoding, depending
// on the flags with which uri was created. (If uri was not created with
// G_URI_FLAGS_HAS_PASSWORD then this will be NULL.).
//
// The function returns the following values:
//
//   - utf8 (optional) uri's password.
func (uri *URI) Password() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_password(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Path gets uri's path, which may contain %-encoding, depending on the flags
// with which uri was created.
//
// The function returns the following values:
//
//   - utf8 uri's path.
func (uri *URI) Path() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_path(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Port gets uri's port.
//
// The function returns the following values:
//
//   - gint uri's port, or -1 if no port was specified.
func (uri *URI) Port() int {
	var _arg0 *C.GUri // out
	var _cret C.gint  // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_port(_arg0)
	runtime.KeepAlive(uri)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Query gets uri's query, which may contain %-encoding, depending on the flags
// with which uri was created.
//
// For queries consisting of a series of name=value parameters, ParamsIter or
// g_uri_parse_params() may be useful.
//
// The function returns the following values:
//
//   - utf8 (optional) uri's query.
func (uri *URI) Query() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_query(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Scheme gets uri's scheme. Note that this will always be all-lowercase,
// regardless of the string or strings that uri was created from.
//
// The function returns the following values:
//
//   - utf8 uri's scheme.
func (uri *URI) Scheme() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_scheme(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// User gets the ‘username’ component of uri's userinfo, which may contain
// %-encoding, depending on the flags with which uri was created. If uri was
// not created with G_URI_FLAGS_HAS_PASSWORD or G_URI_FLAGS_HAS_AUTH_PARAMS,
// this is the same as g_uri_get_userinfo().
//
// The function returns the following values:
//
//   - utf8 (optional) uri's user.
func (uri *URI) User() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_user(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Userinfo gets uri's userinfo, which may contain %-encoding, depending on the
// flags with which uri was created.
//
// The function returns the following values:
//
//   - utf8 (optional) uri's userinfo.
func (uri *URI) Userinfo() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_userinfo(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ParseRelative parses uri_ref according to flags and, if it is a relative
// URI (#relative-and-absolute-uris), resolves it relative to base_uri.
// If the result is not a valid absolute URI, it will be discarded, and an error
// returned.
//
// The function takes the following parameters:
//
//   - uriRef: string representing a relative or absolute URI.
//   - flags describing how to parse uri_ref.
//
// The function returns the following values:
//
//   - uri: new #GUri, or NULL on error.
func (baseUri *URI) ParseRelative(uriRef string, flags URIFlags) (*URI, error) {
	var _arg0 *C.GUri     // out
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _cret *C.GUri     // in
	var _cerr *C.GError   // in

	if baseUri != nil {
		_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(baseUri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	_cret = C.g_uri_parse_relative(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(baseUri)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _uri *URI    // out
	var _goerr error // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _uri, _goerr
}

// String returns a string representing uri.
//
// This is not guaranteed to return a string which is identical to the string
// that uri was parsed from. However, if the source URI was syntactically
// correct (according to RFC 3986), and it was parsed with G_URI_FLAGS_ENCODED,
// then g_uri_to_string() is guaranteed to return a string which is at least
// semantically equivalent to the source URI (according to RFC 3986).
//
// If uri might contain sensitive details, such as authentication parameters,
// or private data in its query string, and the returned string is going to be
// logged, then consider using g_uri_to_string_partial() to redact parts.
//
// The function returns the following values:
//
//   - utf8: string representing uri, which the caller must free.
func (uri *URI) String() string {
	var _arg0 *C.GUri // out
	var _cret *C.char // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_to_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToStringPartial returns a string representing uri, subject to the options in
// flags. See g_uri_to_string() and HideFlags for more details.
//
// The function takes the following parameters:
//
//   - flags describing what parts of uri to hide.
//
// The function returns the following values:
//
//   - utf8: string representing uri, which the caller must free.
func (uri *URI) ToStringPartial(flags URIHideFlags) string {
	var _arg0 *C.GUri         // out
	var _arg1 C.GUriHideFlags // out
	var _cret *C.char         // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg1 = C.GUriHideFlags(flags)

	_cret = C.g_uri_to_string_partial(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIBuild creates a new #GUri from the given components according to flags.
//
// See also g_uri_build_with_user(), which allows specifying the components of
// the "userinfo" separately.
//
// The function takes the following parameters:
//
//   - flags describing how to build the #GUri.
//   - scheme: URI scheme.
//   - userinfo (optional) component, or NULL.
//   - host (optional) component, or NULL.
//   - port: port, or -1.
//   - path component.
//   - query (optional) component, or NULL.
//   - fragment (optional): fragment, or NULL.
//
// The function returns the following values:
//
//   - uri: new #GUri.
func URIBuild(flags URIFlags, scheme, userinfo, host string, port int, path, query, fragment string) *URI {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 C.gint      // out
	var _arg6 *C.gchar    // out
	var _arg7 *C.gchar    // out
	var _arg8 *C.gchar    // out
	var _cret *C.GUri     // in

	_arg1 = C.GUriFlags(flags)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg2))
	if userinfo != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if host != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = C.gint(port)
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg6))
	if query != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	if fragment != "" {
		_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg8))
	}

	_cret = C.g_uri_build(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

// URIBuildWithUser creates a new #GUri from the given components according to
// flags (G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The flags must
// be coherent with the passed values, in particular use %-encoded values with
// G_URI_FLAGS_ENCODED.
//
// In contrast to g_uri_build(), this allows specifying the components of the
// ‘userinfo’ field separately. Note that user must be non-NULL if either
// password or auth_params is non-NULL.
//
// The function takes the following parameters:
//
//   - flags describing how to build the #GUri.
//   - scheme: URI scheme.
//   - user (optional) component of the userinfo, or NULL.
//   - password (optional) component of the userinfo, or NULL.
//   - authParams (optional): auth params of the userinfo, or NULL.
//   - host (optional) component, or NULL.
//   - port: port, or -1.
//   - path component.
//   - query (optional) component, or NULL.
//   - fragment (optional): fragment, or NULL.
//
// The function returns the following values:
//
//   - uri: new #GUri.
func URIBuildWithUser(flags URIFlags, scheme, user, password, authParams, host string, port int, path, query, fragment string) *URI {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 *C.gchar    // out
	var _arg6 *C.gchar    // out
	var _arg7 C.gint      // out
	var _arg8 *C.gchar    // out
	var _arg9 *C.gchar    // out
	var _arg10 *C.gchar   // out
	var _cret *C.GUri     // in

	_arg1 = C.GUriFlags(flags)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg2))
	if user != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if password != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if authParams != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if host != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	_arg7 = C.gint(port)
	_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg8))
	if query != "" {
		_arg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if fragment != "" {
		_arg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg10))
	}

	_cret = C.g_uri_build_with_user(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

func URIErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_uri_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// URIEscapeBytes escapes arbitrary data for use in a URI.
//
// Normally all characters that are not ‘unreserved’ (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in reserved_chars_allowed they are not escaped. This is
// useful for the ‘reserved’ characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
//
// Though technically incorrect, this will also allow escaping nul bytes as 00.
//
// The function takes the following parameters:
//
//   - unescaped input data.
//   - reservedCharsAllowed (optional): string of reserved characters that are
//     allowed to be used, or NULL.
//
// The function returns the following values:
//
//   - utf8: escaped version of unescaped. The returned string should be freed
//     when no longer needed.
func URIEscapeBytes(unescaped []byte, reservedCharsAllowed string) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.gsize
	var _arg3 *C.char // out
	var _cret *C.char // in

	_arg2 = (C.gsize)(len(unescaped))
	if len(unescaped) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&unescaped[0]))
	}
	if reservedCharsAllowed != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_uri_escape_bytes(_arg1, _arg2, _arg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIEscapeString escapes a string for use in a URI.
//
// Normally all characters that are not "unreserved" (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in reserved_chars_allowed they are not escaped. This is
// useful for the "reserved" characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
//
// The function takes the following parameters:
//
//   - unescaped input string.
//   - reservedCharsAllowed (optional): string of reserved characters that are
//     allowed to be used, or NULL.
//   - allowUtf8: TRUE if the result can include UTF-8 characters.
//
// The function returns the following values:
//
//   - utf8: escaped version of unescaped. The returned string should be freed
//     when no longer needed.
func URIEscapeString(unescaped, reservedCharsAllowed string, allowUtf8 bool) string {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // out
	var _arg3 C.gboolean // out
	var _cret *C.char    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(unescaped)))
	defer C.free(unsafe.Pointer(_arg1))
	if reservedCharsAllowed != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if allowUtf8 {
		_arg3 = C.TRUE
	}

	_cret = C.g_uri_escape_string(_arg1, _arg2, _arg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)
	runtime.KeepAlive(allowUtf8)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIIsValid parses uri_string according to flags, to determine whether it is a
// valid absolute URI (#relative-and-absolute-uris), i.e. it does not need to be
// resolved relative to another URI using g_uri_parse_relative().
//
// If it’s not a valid URI, an error is returned explaining how it’s invalid.
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of flags.
//
// The function takes the following parameters:
//
//   - uriString: string containing an absolute URI.
//   - flags for parsing uri_string.
func URIIsValid(uriString string, flags URIFlags) error {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_is_valid(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// URIJoin joins the given components together according to flags to create
// an absolute URI string. path may not be NULL (though it may be the empty
// string).
//
// When host is present, path must either be empty or begin with
// a slash (/) character. When host is not present, path cannot
// begin with two slash characters (//). See RFC 3986, section 3
// (https://tools.ietf.org/html/rfc3986#section-3).
//
// See also g_uri_join_with_user(), which allows specifying the components of
// the ‘userinfo’ separately.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in flags.
//
// The function takes the following parameters:
//
//   - flags describing how to build the URI string.
//   - scheme (optional): URI scheme, or NULL.
//   - userinfo (optional) component, or NULL.
//   - host (optional) component, or NULL.
//   - port: port, or -1.
//   - path component.
//   - query (optional) component, or NULL.
//   - fragment (optional): fragment, or NULL.
//
// The function returns the following values:
//
//   - utf8: absolute URI string.
func URIJoin(flags URIFlags, scheme, userinfo, host string, port int, path, query, fragment string) string {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 C.gint      // out
	var _arg6 *C.gchar    // out
	var _arg7 *C.gchar    // out
	var _arg8 *C.gchar    // out
	var _cret *C.gchar    // in

	_arg1 = C.GUriFlags(flags)
	if scheme != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if userinfo != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if host != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = C.gint(port)
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg6))
	if query != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	if fragment != "" {
		_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg8))
	}

	_cret = C.g_uri_join(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIJoinWithUser joins the given components together according to flags to
// create an absolute URI string. path may not be NULL (though it may be the
// empty string).
//
// In contrast to g_uri_join(), this allows specifying the components of the
// ‘userinfo’ separately. It otherwise behaves the same.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in flags.
//
// The function takes the following parameters:
//
//   - flags describing how to build the URI string.
//   - scheme (optional): URI scheme, or NULL.
//   - user (optional) component of the userinfo, or NULL.
//   - password (optional) component of the userinfo, or NULL.
//   - authParams (optional): auth params of the userinfo, or NULL.
//   - host (optional) component, or NULL.
//   - port: port, or -1.
//   - path component.
//   - query (optional) component, or NULL.
//   - fragment (optional): fragment, or NULL.
//
// The function returns the following values:
//
//   - utf8: absolute URI string.
func URIJoinWithUser(flags URIFlags, scheme, user, password, authParams, host string, port int, path, query, fragment string) string {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 *C.gchar    // out
	var _arg6 *C.gchar    // out
	var _arg7 C.gint      // out
	var _arg8 *C.gchar    // out
	var _arg9 *C.gchar    // out
	var _arg10 *C.gchar   // out
	var _cret *C.gchar    // in

	_arg1 = C.GUriFlags(flags)
	if scheme != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if user != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if password != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if authParams != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if host != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	_arg7 = C.gint(port)
	_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg8))
	if query != "" {
		_arg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if fragment != "" {
		_arg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg10))
	}

	_cret = C.g_uri_join_with_user(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIListExtractURIs splits an URI list conforming to the text/uri-list mime
// type defined in RFC 2483 into individual URIs, discarding any comments.
// The URIs are not validated.
//
// The function takes the following parameters:
//
//   - uriList: URI list.
//
// The function returns the following values:
//
//   - utf8s: newly allocated NULL-terminated list of strings holding the
//     individual URIs. The array should be freed with g_strfreev().
func URIListExtractURIs(uriList string) []string {
	var _arg1 *C.gchar  // out
	var _cret **C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriList)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uri_list_extract_uris(_arg1)
	runtime.KeepAlive(uriList)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// URIParse parses uri_string according to flags. If the result is not a valid
// absolute URI (#relative-and-absolute-uris), it will be discarded, and an
// error returned.
//
// The function takes the following parameters:
//
//   - uriString: string representing an absolute URI.
//   - flags describing how to parse uri_string.
//
// The function returns the following values:
//
//   - uri: new #GUri, or NULL on error.
func URIParse(uriString string, flags URIFlags) (*URI, error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _cret *C.GUri     // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	_cret = C.g_uri_parse(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var _uri *URI    // out
	var _goerr error // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _uri, _goerr
}

// URIParseParams: many URI schemes include one or more attribute/value pairs
// as part of the URI value. This method can be used to parse them into a hash
// table. When an attribute has multiple occurrences, the last value is the
// final returned value. If you need to handle repeated attributes differently,
// use ParamsIter.
//
// The params string is assumed to still be %-encoded, but the returned values
// will be fully decoded. (Thus it is possible that the returned values may
// contain = or separators, if the value was encoded in the input.) Invalid
// %-encoding is treated as with the G_URI_FLAGS_PARSE_RELAXED rules for
// g_uri_parse(). (However, if params is the path or query string from a #GUri
// that was parsed without G_URI_FLAGS_PARSE_RELAXED and G_URI_FLAGS_ENCODED,
// then you already know that it does not contain any invalid encoding.)
//
// G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().
//
// If G_URI_PARAMS_CASE_INSENSITIVE is passed to flags, attributes will be
// compared case-insensitively, so a params string attr=123&Attr=456 will only
// return a single attribute–value pair, Attr=456. Case will be preserved in the
// returned attributes.
//
// If params cannot be parsed (for example, it contains two separators
// characters in a row), then error is set and NULL is returned.
//
// The function takes the following parameters:
//
//   - params: %-encoded string containing attribute=value parameters.
//   - separators: separator byte character set between parameters. (usually &,
//     but sometimes ; or both &;). Note that this function works on bytes not
//     characters, so it can't be used to delimit UTF-8 strings for anything but
//     ASCII characters. You may pass an empty set, in which case no splitting
//     will occur.
//   - flags to modify the way the parameters are handled.
//
// The function returns the following values:
//
//   - hashTable: A hash table of attribute/value pairs, with both names and
//     values fully-decoded; or NULL on error.
func URIParseParams(params, separators string, flags URIParamsFlags) (map[string]string, error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 *C.gchar          // out
	var _arg4 C.GUriParamsFlags // out
	var _cret *C.GHashTable     // in
	var _cerr *C.GError         // in

	_arg2 = (C.gssize)(len(params))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(params) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(params)), params)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(separators)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.GUriParamsFlags(flags)

	_cret = C.g_uri_parse_params(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(params)
	runtime.KeepAlive(separators)
	runtime.KeepAlive(flags)

	var _hashTable map[string]string // out
	var _goerr error                 // out

	_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.gchar)(v)
		var kdst string // out
		var vdst string // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		defer C.free(unsafe.Pointer(ksrc))
		vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
		defer C.free(unsafe.Pointer(vsrc))
		_hashTable[kdst] = vdst
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _hashTable, _goerr
}

// URIParseScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//	URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include file, https, svn+ssh, etc.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - utf8 (optional): ‘scheme’ component of the URI, or NULL on error.
//     The returned string should be freed when no longer needed.
func URIParseScheme(uri string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uri_parse_scheme(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIPeekScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//	URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include file, https, svn+ssh, etc.
//
// Unlike g_uri_parse_scheme(), the returned scheme is normalized to
// all-lowercase and does not need to be freed.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - utf8 (optional): ‘scheme’ component of the URI, or NULL on error.
//     The returned string is normalized to all-lowercase, and interned via
//     g_intern_string(), so it does not need to be freed.
func URIPeekScheme(uri string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uri_peek_scheme(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// URIResolveRelative parses uri_ref according to flags and, if it is a relative
// URI (#relative-and-absolute-uris), resolves it relative to base_uri_string.
// If the result is not a valid absolute URI, it will be discarded, and an error
// returned.
//
// (If base_uri_string is NULL, this just returns uri_ref, or NULL if uri_ref is
// invalid or not absolute.).
//
// The function takes the following parameters:
//
//   - baseUriString (optional): string representing a base URI.
//   - uriRef: string representing a relative or absolute URI.
//   - flags describing how to parse uri_ref.
//
// The function returns the following values:
//
//   - utf8: resolved URI string, or NULL on error.
func URIResolveRelative(baseUriString, uriRef string, flags URIFlags) (string, error) {
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.GUriFlags // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	if baseUriString != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(baseUriString)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GUriFlags(flags)

	_cret = C.g_uri_resolve_relative(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(baseUriString)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// URISplit parses uri_ref (which can be an absolute or relative URI
// (#relative-and-absolute-uris)) according to flags, and returns the pieces.
// Any component that doesn't appear in uri_ref will be returned as NULL (but
// note that all URIs always have a path component, though it may be the empty
// string).
//
// If flags contains G_URI_FLAGS_ENCODED, then %-encoded characters in uri_ref
// will remain encoded in the output strings. (If not, then all such characters
// will be decoded.) Note that decoding will only work if the URI components are
// ASCII or UTF-8, so you will need to use G_URI_FLAGS_ENCODED if they are not.
//
// Note that the G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS flags
// are ignored by g_uri_split(), since it always returns only the full userinfo;
// use g_uri_split_with_user() if you want it split up.
//
// The function takes the following parameters:
//
//   - uriRef: string containing a relative or absolute URI.
//   - flags for parsing uri_ref.
//
// The function returns the following values:
//
//   - scheme (optional): on return, contains the scheme (converted to
//     lowercase), or NULL.
//   - userinfo (optional): on return, contains the userinfo, or NULL.
//   - host (optional): on return, contains the host, or NULL.
//   - port (optional): on return, contains the port, or -1.
//   - path (optional): on return, contains the path.
//   - query (optional): on return, contains the query, or NULL.
//   - fragment (optional): on return, contains the fragment, or NULL.
func URISplit(uriRef string, flags URIFlags) (scheme, userinfo, host string, port int, path, query, fragment string, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _arg3 *C.gchar    // in
	var _arg4 *C.gchar    // in
	var _arg5 *C.gchar    // in
	var _arg6 C.gint      // in
	var _arg7 *C.gchar    // in
	var _arg8 *C.gchar    // in
	var _arg9 *C.gchar    // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_split(_arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7, &_arg8, &_arg9, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _scheme string   // out
	var _userinfo string // out
	var _host string     // out
	var _port int        // out
	var _path string     // out
	var _query string    // out
	var _fragment string // out
	var _goerr error     // out

	if _arg3 != nil {
		_scheme = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_userinfo = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _arg5 != nil {
		_host = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	_port = int(_arg6)
	if _arg7 != nil {
		_path = C.GoString((*C.gchar)(unsafe.Pointer(_arg7)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	if _arg8 != nil {
		_query = C.GoString((*C.gchar)(unsafe.Pointer(_arg8)))
		defer C.free(unsafe.Pointer(_arg8))
	}
	if _arg9 != nil {
		_fragment = C.GoString((*C.gchar)(unsafe.Pointer(_arg9)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _scheme, _userinfo, _host, _port, _path, _query, _fragment, _goerr
}

// URISplitNetwork parses uri_string (which must be an absolute URI
// (#relative-and-absolute-uris)) according to flags, and returns the pieces
// relevant to connecting to a host. See the documentation for g_uri_split()
// for more details; this is mostly a wrapper around that function with simpler
// arguments. However, it will return an error if uri_string is a relative URI,
// or does not contain a hostname component.
//
// The function takes the following parameters:
//
//   - uriString: string containing an absolute URI.
//   - flags for parsing uri_string.
//
// The function returns the following values:
//
//   - scheme (optional): on return, contains the scheme (converted to
//     lowercase), or NULL.
//   - host (optional): on return, contains the host, or NULL.
//   - port (optional): on return, contains the port, or -1.
func URISplitNetwork(uriString string, flags URIFlags) (scheme, host string, port int, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _arg3 *C.gchar    // in
	var _arg4 *C.gchar    // in
	var _arg5 C.gint      // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_split_network(_arg1, _arg2, &_arg3, &_arg4, &_arg5, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var _scheme string // out
	var _host string   // out
	var _port int      // out
	var _goerr error   // out

	if _arg3 != nil {
		_scheme = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_host = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_port = int(_arg5)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _scheme, _host, _port, _goerr
}

// URISplitWithUser parses uri_ref (which can be an absolute or relative URI
// (#relative-and-absolute-uris)) according to flags, and returns the pieces.
// Any component that doesn't appear in uri_ref will be returned as NULL (but
// note that all URIs always have a path component, though it may be the empty
// string).
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of flags. Note that password will only be parsed out if flags contains
// G_URI_FLAGS_HAS_PASSWORD, and auth_params will only be parsed out if flags
// contains G_URI_FLAGS_HAS_AUTH_PARAMS.
//
// The function takes the following parameters:
//
//   - uriRef: string containing a relative or absolute URI.
//   - flags for parsing uri_ref.
//
// The function returns the following values:
//
//   - scheme (optional): on return, contains the scheme (converted to
//     lowercase), or NULL.
//   - user (optional): on return, contains the user, or NULL.
//   - password (optional): on return, contains the password, or NULL.
//   - authParams (optional): on return, contains the auth_params, or NULL.
//   - host (optional): on return, contains the host, or NULL.
//   - port (optional): on return, contains the port, or -1.
//   - path (optional): on return, contains the path.
//   - query (optional): on return, contains the query, or NULL.
//   - fragment (optional): on return, contains the fragment, or NULL.
func URISplitWithUser(uriRef string, flags URIFlags) (scheme, user, password, authParams, host string, port int, path, query, fragment string, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _arg3 *C.gchar    // in
	var _arg4 *C.gchar    // in
	var _arg5 *C.gchar    // in
	var _arg6 *C.gchar    // in
	var _arg7 *C.gchar    // in
	var _arg8 C.gint      // in
	var _arg9 *C.gchar    // in
	var _arg10 *C.gchar   // in
	var _arg11 *C.gchar   // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_split_with_user(_arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7, &_arg8, &_arg9, &_arg10, &_arg11, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _scheme string     // out
	var _user string       // out
	var _password string   // out
	var _authParams string // out
	var _host string       // out
	var _port int          // out
	var _path string       // out
	var _query string      // out
	var _fragment string   // out
	var _goerr error       // out

	if _arg3 != nil {
		_scheme = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_user = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _arg5 != nil {
		_password = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _arg6 != nil {
		_authParams = C.GoString((*C.gchar)(unsafe.Pointer(_arg6)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if _arg7 != nil {
		_host = C.GoString((*C.gchar)(unsafe.Pointer(_arg7)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	_port = int(_arg8)
	if _arg9 != nil {
		_path = C.GoString((*C.gchar)(unsafe.Pointer(_arg9)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if _arg10 != nil {
		_query = C.GoString((*C.gchar)(unsafe.Pointer(_arg10)))
		defer C.free(unsafe.Pointer(_arg10))
	}
	if _arg11 != nil {
		_fragment = C.GoString((*C.gchar)(unsafe.Pointer(_arg11)))
		defer C.free(unsafe.Pointer(_arg11))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _scheme, _user, _password, _authParams, _host, _port, _path, _query, _fragment, _goerr
}

// URIUnescapeBytes unescapes a segment of an escaped string as binary data.
//
// Note that in contrast to g_uri_unescape_string(), this does allow nul bytes
// to appear in the output.
//
// If any of the characters in illegal_characters appears as an escaped
// character in escaped_string, then that is an error and NULL will be returned.
// This is useful if you want to avoid for instance having a slash being
// expanded in an escaped path element, which might confuse pathname handling.
//
// The function takes the following parameters:
//
//   - escapedString: URI-escaped string.
//   - illegalCharacters (optional): string of illegal characters not to be
//     allowed, or NULL.
//
// The function returns the following values:
//
//   - bytes: unescaped version of escaped_string or NULL on error (if decoding
//     failed, using G_URI_ERROR_FAILED error code). The returned #GBytes should
//     be unreffed when no longer needed.
func URIUnescapeBytes(escapedString, illegalCharacters string) (*Bytes, error) {
	var _arg1 *C.char // out
	var _arg2 C.gssize
	var _arg3 *C.char   // out
	var _cret *C.GBytes // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(escapedString))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(escapedString) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(escapedString)), escapedString)
	defer C.free(unsafe.Pointer(_arg1))
	if illegalCharacters != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_uri_unescape_bytes(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(illegalCharacters)

	var _bytes *Bytes // out
	var _goerr error  // out

	_bytes = (*Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// URIUnescapeSegment unescapes a segment of an escaped string.
//
// If any of the characters in illegal_characters or the NUL character appears
// as an escaped character in escaped_string, then that is an error and NULL
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// Note: NUL byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
//
// The function takes the following parameters:
//
//   - escapedString (optional): string, may be NULL.
//   - escapedStringEnd (optional): pointer to end of escaped_string, may be
//     NULL.
//   - illegalCharacters (optional): optional string of illegal characters not
//     to be allowed, may be NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): unescaped version of escaped_string, or NULL on error.
//     The returned string should be freed when no longer needed. As a special
//     case if NULL is given for escaped_string, this function will return NULL.
func URIUnescapeSegment(escapedString, escapedStringEnd, illegalCharacters string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _arg3 *C.char // out
	var _cret *C.char // in

	if escapedString != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if escapedStringEnd != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(escapedStringEnd)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if illegalCharacters != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_uri_unescape_segment(_arg1, _arg2, _arg3)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(escapedStringEnd)
	runtime.KeepAlive(illegalCharacters)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIUnescapeString unescapes a whole escaped string.
//
// If any of the characters in illegal_characters or the NUL character appears
// as an escaped character in escaped_string, then that is an error and NULL
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// The function takes the following parameters:
//
//   - escapedString: escaped string to be unescaped.
//   - illegalCharacters (optional): string of illegal characters not to be
//     allowed, or NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): unescaped version of escaped_string. The returned string
//     should be freed when no longer needed.
func URIUnescapeString(escapedString, illegalCharacters string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(_arg1))
	if illegalCharacters != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_uri_unescape_string(_arg1, _arg2)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(illegalCharacters)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIParamsIter: many URI schemes include one or more attribute/value pairs as
// part of the URI value. For example scheme://server/path?query=string&is=there
// has two attributes – query=string and is=there – in its query part.
//
// A ParamsIter structure represents an iterator that can be used to
// iterate over the attribute/value pairs of a URI query string. ParamsIter
// structures are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
//
// An instance of this type is always passed by reference.
type URIParamsIter struct {
	*uriParamsIter
}

// uriParamsIter is the struct that's finalized.
type uriParamsIter struct {
	native *C.GUriParamsIter
}

// Init initializes an attribute/value pair iterator.
//
// The iterator keeps pointers to the params and separators arguments,
// those variables must thus outlive the iterator and not be modified during the
// iteration.
//
// If G_URI_PARAMS_WWW_FORM is passed in flags, + characters in the param string
// will be replaced with spaces in the output. For example, foo=bar+baz will
// give attribute foo with value bar baz. This is commonly used on the web (the
// https and http schemes only), but is deprecated in favour of the equivalent
// of encoding spaces as 20.
//
// Unlike with g_uri_parse_params(), G_URI_PARAMS_CASE_INSENSITIVE has no effect
// if passed to flags for g_uri_params_iter_init(). The caller is responsible
// for doing their own case-insensitive comparisons.
//
//	GUriParamsIter iter;
//	GError *error = NULL;
//	gchar *unowned_attr, *unowned_value;
//
//	g_uri_params_iter_init (&iter, "foo=bar&baz=bar&Foo=frob&baz=bar2", -1, "&", G_URI_PARAMS_NONE);
//	while (g_uri_params_iter_next (&iter, &unowned_attr, &unowned_value, &error))
//	  {
//	    g_autofree gchar *attr = g_steal_pointer (&unowned_attr);
//	    g_autofree gchar *value = g_steal_pointer (&unowned_value);
//	    // do something with attr and value; this code will be called 4 times
//	    // for the params string in this example: once with attr=foo and value=bar,
//	    // then with baz/bar, then Foo/frob, then baz/bar2.
//	  }
//	if (error)
//	  // handle parsing error.
//
// The function takes the following parameters:
//
//   - params: %-encoded string containing attribute=value parameters.
//   - separators: separator byte character set between parameters. (usually &,
//     but sometimes ; or both &;). Note that this function works on bytes not
//     characters, so it can't be used to delimit UTF-8 strings for anything but
//     ASCII characters. You may pass an empty set, in which case no splitting
//     will occur.
//   - flags to modify the way the parameters are handled.
func (iter *URIParamsIter) Init(params string, separators string, flags URIParamsFlags) {
	var _arg0 *C.GUriParamsIter // out
	var _arg1 *C.gchar          // out
	var _arg2 C.gssize
	var _arg3 *C.gchar          // out
	var _arg4 C.GUriParamsFlags // out

	_arg0 = (*C.GUriParamsIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (C.gssize)(len(params))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(params) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(params)), params)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(separators)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.GUriParamsFlags(flags)

	C.g_uri_params_iter_init(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(params)
	runtime.KeepAlive(separators)
	runtime.KeepAlive(flags)
}

// Next advances iter and retrieves the next attribute/value. FALSE is returned
// if an error has occurred (in which case error is set), or if the end of the
// iteration is reached (in which case attribute and value are set to NULL and
// the iterator becomes invalid). If TRUE is returned, g_uri_params_iter_next()
// may be called again to receive another attribute/value pair.
//
// Note that the same attribute may be returned multiple times, since URIs allow
// repeated attributes.
//
// The function returns the following values:
//
//   - attribute (optional): on return, contains the attribute, or NULL.
//   - value (optional): on return, contains the value, or NULL.
func (iter *URIParamsIter) Next() (attribute string, value string, goerr error) {
	var _arg0 *C.GUriParamsIter // out
	var _arg1 *C.gchar          // in
	var _arg2 *C.gchar          // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GUriParamsIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.g_uri_params_iter_next(_arg0, &_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(iter)

	var _attribute string // out
	var _value string     // out
	var _goerr error      // out

	if _arg1 != nil {
		_attribute = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _attribute, _value, _goerr
}

// Variant: GVariant is a variant datatype; it can contain one or more values
// along with information about the type of the values.
//
// A GVariant may contain simple types, like an integer, or a boolean value;
// or complex types, like an array of two strings, or a dictionary of key value
// pairs. A GVariant is also immutable: once it’s been created neither its type
// nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in D-Bus, or when saving settings using GSettings
// (../gio/class.Settings.html).
//
// When creating a new GVariant, you pass the data you want to store in it along
// with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a GVariant holding an integer value you
// can use:
//
//	GVariant *v = g_variant_new ("u", 40);
//
// The string u in the first argument tells GVariant that the data passed to the
// constructor (40) is going to be an unsigned integer.
//
// More advanced examples of GVariant in use can be found in documentation for
// GVariant format strings (gvariant-format-strings.html#pointers).
//
// The range of possible values is determined by the type.
//
// The type system used by GVariant is glib.VariantType.
//
// GVariant instances always have a type and a value (which are given at
// construction time). The type and value of a GVariant instance can never
// change other than by the GVariant itself being destroyed. A GVariant cannot
// contain a pointer.
//
// GVariant is reference counted using glib.Variant.Ref() and
// glib.Variant.Unref(). GVariant also has floating reference counts — see
// glib.Variant.RefSink().
//
// GVariant is completely threadsafe. A GVariant instance can be concurrently
// accessed in any way from any number of threads without problems.
//
// GVariant is heavily optimised for dealing with data in serialized form.
// It works particularly well with data located in memory-mapped files. It can
// perform nearly all deserialization operations in a small constant time,
// usually touching only a single memory page. Serialized GVariant data can also
// be sent over the network.
//
// GVariant is largely compatible with D-Bus. Almost all types of GVariant
// instances can be sent over D-Bus. See glib.VariantType for exceptions.
// (However, GVariant’s serialization format is not the same as the
// serialization format of a D-Bus message body: use GDBusMessage
// (../gio/class.DBusMessage.html), in the GIO library, for those.)
//
// For space-efficiency, the GVariant serialization format does not
// automatically include the variant’s length, type or endianness, which
// must either be implied from context (such as knowledge that a particular
// file format always contains a little-endian G_VARIANT_TYPE_VARIANT which
// occupies the whole length of the file) or supplied out-of-band (for instance,
// a length, type and/or endianness indicator could be placed at the beginning
// of a file, network message or network stream).
//
// A GVariant’s size is limited mainly by any lower level operating system
// constraints, such as the number of bits in gsize. For example, it is
// reasonable to have a 2GB file mapped into memory with glib.MappedFile,
// and call glib.Variant.NewFromData on it.
//
// For convenience to C programmers, GVariant features powerful varargs-based
// value construction and destruction. This feature is designed to be embedded
// in other libraries.
//
// There is a Python-inspired text language for describing GVariant values.
// GVariant includes a printer for this language and a parser with type
// inferencing.
//
// # Memory Use
//
// GVariant tries to be quite efficient with respect to memory use. This section
// gives a rough idea of how much memory is used by the current implementation.
// The information here is subject to change in the future.
//
// The memory allocated by GVariant can be grouped into 4 broad purposes: memory
// for serialized data, memory for the type information cache, buffer management
// memory and memory for the GVariant structure itself.
//
// # Serialized Data Memory
//
// This is the memory that is used for storing GVariant data in serialized form.
// This is what would be sent over the network or what would end up on disk,
// not counting any indicator of the endianness, or of the length or type of the
// top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16, 32 and 64
// bit integers and double precision floating point numbers use their ‘natural’
// size. Strings (including object path and signature strings) are stored with a
// nul terminator, and as such use the length of the string plus 1 byte.
//
// ‘Maybe’ types use no space at all to represent the null value and use
// the same amount of space (sometimes plus one byte) as the equivalent
// non-maybe-typed value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their members,
// concatenated. Additionally, if the items stored in an array are not of a
// fixed-size (ie: strings, other arrays, etc) then an additional framing
// offset is stored for each item. The size of this offset is either 1,
// 2 or 4 bytes depending on the overall size of the container. Additionally,
// extra padding bytes are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space required to
// store each of their members, concatenated, plus one framing offset (as per
// arrays) for each non-fixed-sized item in the tuple, except for the last one.
// Additionally, extra padding bytes are added as required for alignment of
// child values.
//
// Variants use the same amount of space as the item inside of the variant, plus
// 1 byte, plus the length of the type string for the item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants. In the case
// that the dictionary is empty, 0 bytes are required for the serialization.
//
// If we add an item ‘width’ that maps to the int32 value of 500 then we will
// use 4 bytes to store the int32 (so 6 for the variant containing it) and 6
// bytes for the string. The variant must be aligned to 8 after the 6 bytes of
// the string, so that’s 2 extra bytes. 6 (string) + 2 (padding) + 6 (variant)
// is 14 bytes used for the dictionary entry. An additional 1 byte is added to
// the array as a framing offset making a total of 15 bytes.
//
// If we add another entry, ‘title’ that maps to a nullable string that happens
// to have a value of null, then we use 0 bytes for the null value (and 3 bytes
// for the variant to contain it along with its type string) plus 6 bytes for
// the string. Again, we need 2 padding bytes. That makes a total of 6 + 2 + 3 =
// 11 bytes.
//
// We now require extra padding between the two items in the array. After the 14
// bytes of the first item, that’s 2 bytes required. We now require 2 framing
// offsets for an extra two bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the
// entire two-item dictionary.
//
// # Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache. The type
// information structure is required for rapid deserialization.
//
// Continuing with the above example, if a GVariant exists with the type a{sv}
// then a type information struct will exist for a{sv}, {sv}, s, and v. Multiple
// uses of the same type will share the same type information. Additionally,
// all single-digit types are stored in read-only static memory and do not
// contribute to the writable memory footprint of a program using GVariant.
//
// Aside from the type information structures stored in read-only memory,
// there are two forms of type information. One is used for container types
// where there is a single element type: arrays and maybe types. The other is
// used for container types where there are multiple element types: tuples and
// dictionary entries.
//
// Array type info structures are 6 * sizeof (void *), plus the memory required
// to store the type string itself. This means that on 32-bit systems, the cache
// entry for a{sv} would require 30 bytes of memory (plus allocation overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 * sizeof (void *)
// for each item in the tuple, plus the memory required to store the type string
// itself. A 2-item tuple, for example, would have a type information structure
// that consumed writable memory in the size of 14 * sizeof (void *) (plus type
// string) This means that on 32-bit systems, the cache entry for {sv} would
// require 61 bytes of memory (plus allocation overhead).
//
// This means that in total, for our a{sv} example, 91 bytes of type information
// would be allocated.
//
// The type information cache, additionally, uses a glib.HashTable to store and
// look up the cached items and stores a pointer to this hash table in static
// storage. The hash table is freed when there are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember that a
// program will probably only have a very small number of different types of
// values in it and that only one type information structure is required for
// many different values of the same type.
//
// # Buffer Management Memory
//
// GVariant uses an internal buffer management structure to deal with the
// various different possible sources of serialized data that it uses.
// The buffer is responsible for ensuring that the correct call is made when the
// data is no longer in use by GVariant. This may involve a glib.Free() or even
// glib.MappedFile.Unref().
//
// One buffer management structure is used for each chunk of serialized data.
// The size of the buffer management structure is 4 * (void *). On 32-bit
// systems, that’s 16 bytes.
//
// # GVariant structure
//
// The size of a GVariant structure is 6 * (void *). On 32-bit systems, that’s
// 24 bytes.
//
// GVariant structures only exist if they are explicitly created with API calls.
// For example, if a GVariant is constructed out of serialized data for
// the example given above (with the dictionary) then although there are 9
// individual values that comprise the entire dictionary (two keys, two values,
// two variants containing the values, two dictionary entries, plus the
// dictionary itself), only 1 GVariant instance exists — the one referring to
// the dictionary.
//
// If calls are made to start accessing the other values then GVariant instances
// will exist for those values only for as long as they are in use (ie:
// until you call glib.Variant.Unref()). The type information is shared.
// The serialized data and the buffer management structure for that serialized
// data is shared by the child.
//
// # Summary
//
// To put the entire example together, for our dictionary mapping strings
// to variants (with two entries, as given above), we are using 91 bytes of
// memory for type information, 29 bytes of memory for the serialized data,
// 16 bytes for buffer management and 24 bytes for the GVariant instance,
// or a total of 160 bytes, plus allocation overhead. If we were to use
// glib.Variant.GetChildValue() to access the two dictionary entries, we would
// use an additional 48 bytes. If we were to have other dictionaries of the same
// type, we would use more memory for the serialized data and buffer management
// for those dictionaries, but the type information would be shared.
//
// An instance of this type is always passed by reference.
type Variant struct {
	*variant
}

// variant is the struct that's finalized.
type variant struct {
	native *C.GVariant
}

// NewVariantArray constructs a struct Variant.
func NewVariantArray(childType *VariantType, children []*Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 **C.GVariant    // out
	var _arg3 C.gsize
	var _cret *C.GVariant // in

	if childType != nil {
		_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(childType)))
	}
	if children != nil {
		_arg3 = (C.gsize)(len(children))
		_arg2 = (**C.GVariant)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice((**C.GVariant)(_arg2), len(children))
			for i := range children {
				out[i] = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(children[i])))
			}
		}
	}

	_cret = C.g_variant_new_array(_arg1, _arg2, _arg3)
	runtime.KeepAlive(childType)
	runtime.KeepAlive(children)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantBoolean constructs a struct Variant.
func NewVariantBoolean(value bool) *Variant {
	var _arg1 C.gboolean  // out
	var _cret *C.GVariant // in

	if value {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_new_boolean(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantByte constructs a struct Variant.
func NewVariantByte(value byte) *Variant {
	var _arg1 C.guint8    // out
	var _cret *C.GVariant // in

	_arg1 = C.guint8(value)

	_cret = C.g_variant_new_byte(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantBytestring constructs a struct Variant.
func NewVariantBytestring(str []byte) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_bytestring(_arg1)
	runtime.KeepAlive(str)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantBytestringArray constructs a struct Variant.
func NewVariantBytestringArray(strv []string) *Variant {
	var _arg1 **C.gchar // out
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = (C.gssize)(len(strv))
	_arg1 = (**C.gchar)(C.calloc(C.size_t(len(strv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(strv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_bytestring_array(_arg1, _arg2)
	runtime.KeepAlive(strv)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantDictEntry constructs a struct Variant.
func NewVariantDictEntry(key *Variant, value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _arg2 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(key)))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_new_dict_entry(_arg1, _arg2)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantDouble constructs a struct Variant.
func NewVariantDouble(value float64) *Variant {
	var _arg1 C.gdouble   // out
	var _cret *C.GVariant // in

	_arg1 = C.gdouble(value)

	_cret = C.g_variant_new_double(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantFixedArray constructs a struct Variant.
func NewVariantFixedArray(elementType *VariantType, elements unsafe.Pointer, nElements uint, elementSize uint) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize         // out
	var _arg4 C.gsize         // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(elementType)))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(elements))
	_arg3 = C.gsize(nElements)
	_arg4 = C.gsize(elementSize)

	_cret = C.g_variant_new_fixed_array(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(elementType)
	runtime.KeepAlive(elements)
	runtime.KeepAlive(nElements)
	runtime.KeepAlive(elementSize)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantFromBytes constructs a struct Variant.
func NewVariantFromBytes(typ *VariantType, bytes *Bytes, trusted bool) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GBytes       // out
	var _arg3 C.gboolean      // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	if trusted {
		_arg3 = C.TRUE
	}

	_cret = C.g_variant_new_from_bytes(_arg1, _arg2, _arg3)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(trusted)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantHandle constructs a struct Variant.
func NewVariantHandle(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_handle(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantInt16 constructs a struct Variant.
func NewVariantInt16(value int16) *Variant {
	var _arg1 C.gint16    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint16(value)

	_cret = C.g_variant_new_int16(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantInt32 constructs a struct Variant.
func NewVariantInt32(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_int32(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantInt64 constructs a struct Variant.
func NewVariantInt64(value int64) *Variant {
	var _arg1 C.gint64    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint64(value)

	_cret = C.g_variant_new_int64(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantMaybe constructs a struct Variant.
func NewVariantMaybe(childType *VariantType, child *Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GVariant     // out
	var _cret *C.GVariant     // in

	if childType != nil {
		_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(childType)))
	}
	if child != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(child)))
	}

	_cret = C.g_variant_new_maybe(_arg1, _arg2)
	runtime.KeepAlive(childType)
	runtime.KeepAlive(child)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantObjectPath constructs a struct Variant.
func NewVariantObjectPath(objectPath string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_object_path(_arg1)
	runtime.KeepAlive(objectPath)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantObjv constructs a struct Variant.
func NewVariantObjv(strv []string) *Variant {
	var _arg1 **C.gchar // out
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = (C.gssize)(len(strv))
	_arg1 = (**C.gchar)(C.calloc(C.size_t(len(strv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(strv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_objv(_arg1, _arg2)
	runtime.KeepAlive(strv)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantSignature constructs a struct Variant.
func NewVariantSignature(signature string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(signature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_signature(_arg1)
	runtime.KeepAlive(signature)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantString constructs a struct Variant.
func NewVariantString(str string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_string(_arg1)
	runtime.KeepAlive(str)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantStrv constructs a struct Variant.
func NewVariantStrv(strv []string) *Variant {
	var _arg1 **C.gchar // out
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = (C.gssize)(len(strv))
	_arg1 = (**C.gchar)(C.calloc(C.size_t(len(strv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(strv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_strv(_arg1, _arg2)
	runtime.KeepAlive(strv)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantTuple constructs a struct Variant.
func NewVariantTuple(children []*Variant) *Variant {
	var _arg1 **C.GVariant // out
	var _arg2 C.gsize
	var _cret *C.GVariant // in

	_arg2 = (C.gsize)(len(children))
	_arg1 = (**C.GVariant)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GVariant)(_arg1), len(children))
		for i := range children {
			out[i] = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(children[i])))
		}
	}

	_cret = C.g_variant_new_tuple(_arg1, _arg2)
	runtime.KeepAlive(children)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantUint16 constructs a struct Variant.
func NewVariantUint16(value uint16) *Variant {
	var _arg1 C.guint16   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint16(value)

	_cret = C.g_variant_new_uint16(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantUint32 constructs a struct Variant.
func NewVariantUint32(value uint32) *Variant {
	var _arg1 C.guint32   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint32(value)

	_cret = C.g_variant_new_uint32(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantUint64 constructs a struct Variant.
func NewVariantUint64(value uint64) *Variant {
	var _arg1 C.guint64   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint64(value)

	_cret = C.g_variant_new_uint64(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// NewVariantVariant constructs a struct Variant.
func NewVariantVariant(value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_new_variant(_arg1)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Byteswap performs a byteswapping operation on the contents of value. The
// result is that all multi-byte numeric data contained in value is byteswapped.
// That includes 16, 32, and 64bit signed and unsigned integers as well as file
// handles and double precision floating point values.
//
// This function is an identity mapping on any value that does not contain
// multi-byte numeric data. That include strings, booleans, bytes and containers
// containing only these things (recursively).
//
// While this function can safely handle untrusted, non-normal data,
// it is recommended to check whether the input is in normal form beforehand,
// using g_variant_is_normal_form(), and to reject non-normal inputs if your
// application can be strict about what inputs it rejects.
//
// The returned value is always in normal form and is marked as trusted. A full,
// not floating, reference is returned.
//
// The function returns the following values:
//
//   - variant (optional): byteswapped form of value.
func (value *Variant) Byteswap() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_byteswap(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// CheckFormatString checks if calling g_variant_get() with format_string on
// value would be valid from a type-compatibility standpoint. format_string is
// assumed to be a valid format string (from a syntactic standpoint).
//
// If copy_only is TRUE then this function additionally checks that it would
// be safe to call g_variant_unref() on value immediately after the call to
// g_variant_get() without invalidating the result. This is only possible if
// deep copies are made (ie: there are no pointers to the data inside of the
// soon-to-be-freed #GVariant instance). If this check fails then a g_critical()
// is printed and FALSE is returned.
//
// This function is meant to be used by functions that wish to provide varargs
// accessors to #GVariant values of uncertain values (eg: g_variant_lookup() or
// g_menu_model_get_item_attribute()).
//
// The function takes the following parameters:
//
//   - formatString: valid #GVariant format string.
//   - copyOnly: TRUE to ensure the format string makes deep copies.
//
// The function returns the following values:
//
//   - ok: TRUE if format_string is safe to use.
func (value *Variant) CheckFormatString(formatString string, copyOnly bool) bool {
	var _arg0 *C.GVariant // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gboolean  // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(formatString)))
	defer C.free(unsafe.Pointer(_arg1))
	if copyOnly {
		_arg2 = C.TRUE
	}

	_cret = C.g_variant_check_format_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(formatString)
	runtime.KeepAlive(copyOnly)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Classify classifies value according to its top-level type.
//
// The function returns the following values:
//
//   - variantClass of value.
func (value *Variant) Classify() VariantClass {
	var _arg0 *C.GVariant     // out
	var _cret C.GVariantClass // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_classify(_arg0)
	runtime.KeepAlive(value)

	var _variantClass VariantClass // out

	_variantClass = VariantClass(_cret)

	return _variantClass
}

// Compare compares one and two.
//
// The types of one and two are #gconstpointer only to allow use of this
// function with #GTree, Array, etc. They must each be a #GVariant.
//
// Comparison is only defined for basic types (ie: booleans, numbers, strings).
// For booleans, FALSE is less than TRUE. Numbers are ordered in the usual way.
// Strings are in ASCII lexographical order.
//
// It is a programmer error to attempt to compare container values or two values
// that have types that are not exactly equal. For example, you cannot compare
// a 32-bit signed integer with a 32-bit unsigned integer. Also note that this
// function is not particularly well-behaved when it comes to comparison of
// doubles; in particular, the handling of incomparable values (ie: NaN) is
// undefined.
//
// If you only require an equality comparison, g_variant_equal() is more
// general.
//
// The function takes the following parameters:
//
//   - two instance of the same type.
//
// The function returns the following values:
//
//   - gint: negative value if a < b; zero if a = b; positive value if a > b.
func (one *Variant) Compare(two *Variant) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(one)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(two)))

	_cret = C.g_variant_compare(_arg0, _arg1)
	runtime.KeepAlive(one)
	runtime.KeepAlive(two)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DupBytestring: similar to g_variant_get_bytestring() except that instead of
// returning a constant string, the string is duplicated.
//
// The return value must be freed using g_free().
//
// The function returns the following values:
//
//   - guint8s: a newly allocated string.
func (value *Variant) DupBytestring() []byte {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_bytestring(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _guint8s []byte // out

	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// DupBytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a deep copy; the return result should be released with
// g_strfreev().
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
//
// The function returns the following values:
//
//   - utf8s: array of strings.
func (value *Variant) DupBytestringArray() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_bytestring_array(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// DupObjv gets the contents of an array of object paths #GVariant. This call
// makes a deep copy; the return result should be released with g_strfreev().
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
//
// The function returns the following values:
//
//   - utf8s: array of strings.
func (value *Variant) DupObjv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_objv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// DupString: similar to g_variant_get_string() except that instead of returning
// a constant string, the string is duplicated.
//
// The string will always be UTF-8 encoded.
//
// The return value must be freed using g_free().
//
// The function returns the following values:
//
//   - length: pointer to a #gsize, to store the length.
//   - utf8: newly allocated string, UTF-8 encoded.
func (value *Variant) DupString() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_string(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _length uint // out
	var _utf8 string // out

	_length = uint(_arg1)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _length, _utf8
}

// DupStrv gets the contents of an array of strings #GVariant. This call makes a
// deep copy; the return result should be released with g_strfreev().
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
//
// The function returns the following values:
//
//   - utf8s: array of strings.
func (value *Variant) DupStrv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_dup_strv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Equal checks if one and two have the same type and value.
//
// The types of one and two are #gconstpointer only to allow use of this
// function with Table. They must each be a #GVariant.
//
// The function takes the following parameters:
//
//   - two: #GVariant instance.
//
// The function returns the following values:
//
//   - ok: TRUE if one and two are equal.
func (one *Variant) Equal(two *Variant) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(one)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(two)))

	_cret = C.g_variant_equal(_arg0, _arg1)
	runtime.KeepAlive(one)
	runtime.KeepAlive(two)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Boolean returns the boolean value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_BOOLEAN.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE.
func (value *Variant) Boolean() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_boolean(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Byte returns the byte value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_BYTE.
//
// The function returns the following values:
//
//   - guint8: #guint8.
func (value *Variant) Byte() byte {
	var _arg0 *C.GVariant // out
	var _cret C.guint8    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_byte(_arg0)
	runtime.KeepAlive(value)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Bytestring returns the string value of a #GVariant instance with an
// array-of-bytes type. The string has no particular encoding.
//
// If the array does not end with a nul terminator character, the empty
// string is returned. For this reason, you can always trust that a non-NULL
// nul-terminated string will be returned by this function.
//
// If the array contains a nul terminator character somewhere other than the
// last byte then the returned string is the string, up to the first such nul
// character.
//
// g_variant_get_fixed_array() should be used instead if the array contains
// arbitrary data that could not be nul-terminated or could contain nul bytes.
//
// It is an error to call this function with a value that is not an array of
// bytes.
//
// The return value remains valid as long as value exists.
//
// The function returns the following values:
//
//   - guint8s: the constant string.
func (value *Variant) Bytestring() []byte {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_bytestring(_arg0)
	runtime.KeepAlive(value)

	var _guint8s []byte // out

	{
		var i int
		var z C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

// BytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a shallow copy; the return result should be released with
// g_free(), but the individual strings must not be modified.
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
//
// The function returns the following values:
//
//   - utf8s: array of constant strings.
func (value *Variant) BytestringArray() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_bytestring_array(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// ChildValue reads a child item out of a container #GVariant instance.
// This includes variants, maybes, arrays, tuples and dictionary entries.
// It is an error to call this function on any other type of #GVariant.
//
// It is an error if index_ is greater than the number of child items in the
// container. See g_variant_n_children().
//
// The returned value is never floating. You should free it with
// g_variant_unref() when you're done with it.
//
// Note that values borrowed from the returned child are not guaranteed to
// still be valid after the child is freed even if you still hold a reference to
// value, if value has not been serialized at the time this function is called.
// To avoid this, you can serialize value by calling g_variant_get_data() and
// optionally ignoring the return value.
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in the unit tuple being returned as the child value,
// instead of further nested children. #GVariant is guaranteed to handle nesting
// up to at least 64 levels.
//
// This function is O(1).
//
// The function takes the following parameters:
//
//   - index_: index of the child to fetch.
//
// The function returns the following values:
//
//   - variant (optional): child at the specified index.
func (value *Variant) ChildValue(index_ uint) *Variant {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = C.gsize(index_)

	_cret = C.g_variant_get_child_value(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index_)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Data returns a pointer to the serialized form of a #GVariant instance. The
// returned data may not be in fully-normalised form if read from an untrusted
// source. The returned data must not be freed; it remains valid for as long as
// value exists.
//
// If value is a fixed-sized value that was deserialized from a corrupted
// serialized container then NULL may be returned. In this case, the proper
// thing to do is typically to use the appropriate number of nul bytes in place
// of value. If value is not fixed-sized then NULL is never returned.
//
// In the case that value is already in serialized form, this function is O(1).
// If the value is not already in serialized form, serialization occurs
// implicitly and is approximately O(n) in the size of the result.
//
// To deserialize the data returned by this function, in addition to the
// serialized data, you must know the type of the #GVariant, and (if the
// machine might be different) the endianness of the machine that stored it.
// As a result, file formats or network messages that incorporate serialized
// #GVariants must include this information either implicitly (for instance
// "the file always contains a G_VARIANT_TYPE_VARIANT and it is always in
// little-endian order") or explicitly (by storing the type and/or endianness in
// addition to the serialized data).
//
// The function returns the following values:
//
//   - gpointer (optional): serialized form of value, or NULL.
func (value *Variant) Data() unsafe.Pointer {
	var _arg0 *C.GVariant     // out
	var _cret C.gconstpointer // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_data(_arg0)
	runtime.KeepAlive(value)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// DataAsBytes returns a pointer to the serialized form of a #GVariant instance.
// The semantics of this function are exactly the same as g_variant_get_data(),
// except that the returned #GBytes holds a reference to the variant data.
//
// The function returns the following values:
//
//   - bytes: new #GBytes representing the variant data.
func (value *Variant) DataAsBytes() *Bytes {
	var _arg0 *C.GVariant // out
	var _cret *C.GBytes   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_data_as_bytes(_arg0)
	runtime.KeepAlive(value)

	var _bytes *Bytes // out

	_bytes = (*Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Double returns the double precision floating point value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_DOUBLE.
//
// The function returns the following values:
//
//   - gdouble: #gdouble.
func (value *Variant) Double() float64 {
	var _arg0 *C.GVariant // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_double(_arg0)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Handle returns the 32-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_HANDLE.
//
// By convention, handles are indexes into an array of file descriptors that
// are sent alongside a D-Bus message. If you're not interacting with D-Bus,
// you probably don't need them.
//
// The function returns the following values:
//
//   - gint32: #gint32.
func (value *Variant) Handle() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_handle(_arg0)
	runtime.KeepAlive(value)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int16 returns the 16-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_INT16.
//
// The function returns the following values:
//
//   - gint16: #gint16.
func (value *Variant) Int16() int16 {
	var _arg0 *C.GVariant // out
	var _cret C.gint16    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_int16(_arg0)
	runtime.KeepAlive(value)

	var _gint16 int16 // out

	_gint16 = int16(_cret)

	return _gint16
}

// Int32 returns the 32-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_INT32.
//
// The function returns the following values:
//
//   - gint32: #gint32.
func (value *Variant) Int32() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_int32(_arg0)
	runtime.KeepAlive(value)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int64 returns the 64-bit signed integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_INT64.
//
// The function returns the following values:
//
//   - gint64: #gint64.
func (value *Variant) Int64() int64 {
	var _arg0 *C.GVariant // out
	var _cret C.gint64    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_int64(_arg0)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Maybe: given a maybe-typed #GVariant instance, extract its value. If the
// value is Nothing, then this function returns NULL.
//
// The function returns the following values:
//
//   - variant (optional) contents of value, or NULL.
func (value *Variant) Maybe() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_maybe(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// NormalForm gets a #GVariant instance that has the same value as value and is
// trusted to be in normal form.
//
// If value is already trusted to be in normal form then a new reference to
// value is returned.
//
// If value is not already trusted, then it is scanned to check if it is in
// normal form. If it is found to be in normal form then it is marked as trusted
// and a new reference to it is returned.
//
// If value is found not to be in normal form then a new trusted #GVariant is
// created with the same value as value. The non-normal parts of value will be
// replaced with default values which are guaranteed to be in normal form.
//
// It makes sense to call this function if you've received #GVariant data from
// untrusted sources and you want to ensure your serialized output is definitely
// in normal form.
//
// If value is already in normal form, a new reference will be returned (which
// will be floating if value is floating). If it is not in normal form,
// the newly created #GVariant will be returned with a single non-floating
// reference. Typically, g_variant_take_ref() should be called on the return
// value from this function to guarantee ownership of a single non-floating
// reference to it.
//
// The function returns the following values:
//
//   - variant (optional): trusted #GVariant.
func (value *Variant) NormalForm() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_normal_form(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Objv gets the contents of an array of object paths #GVariant. This call
// makes a shallow copy; the return result should be released with g_free(),
// but the individual strings must not be modified.
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
//
// The function returns the following values:
//
//   - utf8s: array of constant strings.
func (value *Variant) Objv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_objv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Size determines the number of bytes that would be required to store value
// with g_variant_store().
//
// If value has a fixed-sized type then this function always returned that fixed
// size.
//
// In the case that value is already in serialized form or the size has already
// been calculated (ie: this function has been called before) then this
// function is O(1). Otherwise, the size is calculated, an operation which is
// approximately O(n) in the number of values involved.
//
// The function returns the following values:
//
//   - gsize: serialized size of value.
func (value *Variant) Size() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_size(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// String returns the string value of a #GVariant instance with a string type.
// This includes the types G_VARIANT_TYPE_STRING, G_VARIANT_TYPE_OBJECT_PATH and
// G_VARIANT_TYPE_SIGNATURE.
//
// The string will always be UTF-8 encoded, will never be NULL, and will never
// contain nul bytes.
//
// If length is non-NULL then the length of the string (in bytes) is returned
// there. For trusted values, this information is already known. Untrusted
// values will be validated and, if valid, a strlen() will be performed. If
// invalid, a default value will be returned — for G_VARIANT_TYPE_OBJECT_PATH,
// this is "/", and for other types it is the empty string.
//
// It is an error to call this function with a value of any type other than
// those three.
//
// The return value remains valid as long as value exists.
//
// The function returns the following values:
//
//   - utf8: constant string, UTF-8 encoded.
func (value *Variant) String() string {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_string(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8 string

	_utf8 = C.GoStringN(_cret, C.int(_arg1))

	return _utf8
}

// Strv gets the contents of an array of strings #GVariant. This call makes a
// shallow copy; the return result should be released with g_free(), but the
// individual strings must not be modified.
//
// If length is non-NULL then the number of elements in the result is stored
// there. In any case, the resulting array will be NULL-terminated.
//
// For an empty array, length will be set to 0 and a pointer to a NULL pointer
// will be returned.
//
// The function returns the following values:
//
//   - utf8s: array of constant strings.
func (value *Variant) Strv() []string {
	var _arg0 *C.GVariant // out
	var _cret **C.gchar   // in
	var _arg1 C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_strv(_arg0, &_arg1)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.gchar)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Type determines the type of value.
//
// The return value is valid for the lifetime of value and must not be freed.
//
// The function returns the following values:
//
//   - variantType: Type.
func (value *Variant) Type() *VariantType {
	var _arg0 *C.GVariant     // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_type(_arg0)
	runtime.KeepAlive(value)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

// TypeString returns the type string of value. Unlike the result of calling
// g_variant_type_peek_string(), this string is nul-terminated. This string
// belongs to #GVariant and must not be freed.
//
// The function returns the following values:
//
//   - utf8: type string for the type of value.
func (value *Variant) TypeString() string {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_type_string(_arg0)
	runtime.KeepAlive(value)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Uint16 returns the 16-bit unsigned integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_UINT16.
//
// The function returns the following values:
//
//   - guint16: #guint16.
func (value *Variant) Uint16() uint16 {
	var _arg0 *C.GVariant // out
	var _cret C.guint16   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_uint16(_arg0)
	runtime.KeepAlive(value)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Uint32 returns the 32-bit unsigned integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_UINT32.
//
// The function returns the following values:
//
//   - guint32: #guint32.
func (value *Variant) Uint32() uint32 {
	var _arg0 *C.GVariant // out
	var _cret C.guint32   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_uint32(_arg0)
	runtime.KeepAlive(value)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Uint64 returns the 64-bit unsigned integer value of value.
//
// It is an error to call this function with a value of any type other than
// G_VARIANT_TYPE_UINT64.
//
// The function returns the following values:
//
//   - guint64: #guint64.
func (value *Variant) Uint64() uint64 {
	var _arg0 *C.GVariant // out
	var _cret C.guint64   // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_uint64(_arg0)
	runtime.KeepAlive(value)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Variant unboxes value. The result is the #GVariant instance that was
// contained in value.
//
// The function returns the following values:
//
//   - variant (optional): item contained in the variant.
func (value *Variant) Variant() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_get_variant(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Hash generates a hash value for a #GVariant instance.
//
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures
// or even different versions of GLib. Do not use this function as a basis for
// building protocols or file formats.
//
// The type of value is #gconstpointer only to allow use of this function with
// Table. value must be a #GVariant.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to value.
func (value *Variant) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_hash(_arg0)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsContainer checks if value is a container.
//
// The function returns the following values:
//
//   - ok: TRUE if value is a container.
func (value *Variant) IsContainer() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_is_container(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFloating checks whether value has a floating reference count.
//
// This function should only ever be used to assert that a given variant
// is or is not floating, or for debug purposes. To acquire a reference
// to a variant that might be floating, always use g_variant_ref_sink() or
// g_variant_take_ref().
//
// See g_variant_ref_sink() for more information about floating reference
// counts.
//
// The function returns the following values:
//
//   - ok: whether value is floating.
func (value *Variant) IsFloating() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_is_floating(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNormalForm checks if value is in normal form.
//
// The main reason to do this is to detect if a given chunk of serialized
// data is in normal form: load the data into a #GVariant using
// g_variant_new_from_data() and then use this function to check.
//
// If value is found to be in normal form then it will be marked as being
// trusted. If the value was already marked as being trusted then this function
// will immediately return TRUE.
//
// There may be implementation specific restrictions on deeply nested values.
// GVariant is guaranteed to handle nesting up to at least 64 levels.
//
// The function returns the following values:
//
//   - ok: TRUE if value is in normal form.
func (value *Variant) IsNormalForm() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_is_normal_form(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsOfType checks if a value has a type matching the provided type.
//
// The function takes the following parameters:
//
//   - typ: Type.
//
// The function returns the following values:
//
//   - ok: TRUE if the type of value matches type.
func (value *Variant) IsOfType(typ *VariantType) bool {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_is_of_type(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupValue looks up a value in a dictionary #GVariant.
//
// This function works with dictionaries of the type a{s*} (and equally well
// with type a{o*}, but we only further discuss the string case for sake of
// clarity).
//
// In the event that dictionary has the type a{sv}, the expected_type string
// specifies what type of value is expected to be inside of the variant.
// If the value inside the variant has a different type then NULL is returned.
// In the event that dictionary has a value type other than v then expected_type
// must directly match the value type and it is used to unpack the value
// directly or an error occurs.
//
// In either case, if key is not found in dictionary, NULL is returned.
//
// If the key is found and the value has the correct type, it is returned.
// If expected_type was specified then any non-NULL return value will have this
// type.
//
// This function is currently implemented with a linear scan. If you plan to do
// many lookups then Dict may be more efficient.
//
// The function takes the following parameters:
//
//   - key to look up in the dictionary.
//   - expectedType (optional) or NULL.
//
// The function returns the following values:
//
//   - variant (optional): value of the dictionary key, or NULL.
func (dictionary *Variant) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(dictionary)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	if expectedType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_cret = C.g_variant_lookup_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dictionary)
	runtime.KeepAlive(key)
	runtime.KeepAlive(expectedType)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// NChildren determines the number of children in a container #GVariant
// instance. This includes variants, maybes, arrays, tuples and dictionary
// entries. It is an error to call this function on any other type of #GVariant.
//
// For variants, the return value is always 1. For values with maybe types,
// it is always zero or one. For arrays, it is the length of the array.
// For tuples it is the number of tuple items (which depends only on the type).
// For dictionary entries, it is always 2
//
// This function is O(1).
//
// The function returns the following values:
//
//   - gsize: number of children in the container.
func (value *Variant) NChildren() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_n_children(_arg0)
	runtime.KeepAlive(value)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Print pretty-prints value in the format understood by g_variant_parse().
//
// The format is described [here][gvariant-text].
//
// If type_annotate is TRUE, then type information is included in the output.
//
// The function takes the following parameters:
//
//   - typeAnnotate: TRUE if type information should be included in the output.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string holding the result.
func (value *Variant) Print(typeAnnotate bool) string {
	var _arg0 *C.GVariant // out
	var _arg1 C.gboolean  // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	if typeAnnotate {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_print(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(typeAnnotate)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RefSink uses a floating reference count system. All functions with names
// starting with g_variant_new_ return floating references.
//
// Calling g_variant_ref_sink() on a #GVariant with a floating reference
// will convert the floating reference into a full reference. Calling
// g_variant_ref_sink() on a non-floating #GVariant results in an additional
// normal reference being added.
//
// In other words, if the value is floating, then this call "assumes ownership"
// of the floating reference, converting it to a normal reference. If the value
// is not floating, then this call adds a new normal reference increasing the
// reference count by one.
//
// All calls that result in a #GVariant instance being inserted into a container
// will call g_variant_ref_sink() on the instance. This means that if the value
// was just created (and has only its floating reference) then the container
// will assume sole ownership of the value at that point and the caller will not
// need to unreference it. This makes certain common styles of programming much
// easier while still maintaining normal refcounting semantics in situations
// where values are not floating.
//
// The function returns the following values:
//
//   - variant (optional): same value.
func (value *Variant) RefSink() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_ref_sink(_arg0)
	runtime.KeepAlive(value)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Store stores the serialized form of value at data. data should be large
// enough. See g_variant_get_size().
//
// The stored data is in machine native byte order but may not be
// in fully-normalised form if read from an untrusted source. See
// g_variant_get_normal_form() for a solution.
//
// As with g_variant_get_data(), to be able to deserialize the serialized
// variant successfully, its type and (if the destination machine might be
// different) its endianness must also be available.
//
// This function is approximately O(n) in the size of data.
//
// The function takes the following parameters:
//
//   - data: location to store the serialized data at.
func (value *Variant) Store(data unsafe.Pointer) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gpointer  // out

	_arg0 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C.g_variant_store(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(data)
}

// VariantIsObjectPath determines if a given string is a valid D-Bus object
// path. You should ensure that a string is a valid D-Bus object path before
// passing it to g_variant_new_object_path().
//
// A valid object path starts with / followed by zero or more sequences of
// characters separated by / characters. Each sequence must contain only the
// characters [A-Z][a-z][0-9]_. No sequence (including the one following the
// final / character) may be empty.
//
// The function takes the following parameters:
//
//   - str: normal C nul-terminated string.
//
// The function returns the following values:
//
//   - ok: TRUE if string is a D-Bus object path.
func VariantIsObjectPath(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_is_object_path(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VariantIsSignature determines if a given string is a valid D-Bus type
// signature. You should ensure that a string is a valid D-Bus type signature
// before passing it to g_variant_new_signature().
//
// D-Bus type signatures consist of zero or more definite Type strings in
// sequence.
//
// The function takes the following parameters:
//
//   - str: normal C nul-terminated string.
//
// The function returns the following values:
//
//   - ok: TRUE if string is a D-Bus type signature.
func VariantIsSignature(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_is_signature(_arg1)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VariantParseErrorPrintContext pretty-prints a message showing the context of
// a #GVariant parse error within the string for which parsing was attempted.
//
// The resulting string is suitable for output to the console or other monospace
// media where newlines are treated in the usual way.
//
// The message will typically look something like one of the following:
//
//	unterminated string constant:
//	  (1, 2, 3, 'abc
//	            ^^^^
//
// or
//
//	unable to find a common type:
//	  [1, 2, 3, 'str']
//	   ^        ^^^^^
//
// The format of the message may change in a future version.
//
// error must have come from a failed attempt to g_variant_parse() and
// source_str must be exactly the same string that caused the error.
// If source_str was not nul-terminated when you passed it to g_variant_parse()
// then you must add nul termination before using this function.
//
// The function takes the following parameters:
//
//   - err from the ParseError domain.
//   - sourceStr: string that was given to the parser.
//
// The function returns the following values:
//
//   - utf8: printed message.
func VariantParseErrorPrintContext(err error, sourceStr string) string {
	var _arg1 *C.GError // out
	var _arg2 *C.gchar  // out
	var _cret *C.gchar  // in

	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(sourceStr)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_variant_parse_error_print_context(_arg1, _arg2)
	runtime.KeepAlive(err)
	runtime.KeepAlive(sourceStr)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func VariantParseErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_variant_parse_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// VariantParserGetErrorQuark: same as g_variant_error_quark().
//
// Deprecated: Use g_variant_parse_error_quark() instead.
func VariantParserGetErrorQuark() Quark {
	var _cret C.GQuark // in

	_cret = C.g_variant_parser_get_error_quark()

	var _quark Quark // out

	_quark = Quark(_cret)

	return _quark
}

// VariantBuilder: utility type for constructing container-type #GVariant
// instances.
//
// This is an opaque structure and may only be accessed using the following
// functions.
//
// Builder is not threadsafe in any way. Do not attempt to access it from more
// than one thread.
//
// An instance of this type is always passed by reference.
type VariantBuilder struct {
	*variantBuilder
}

// variantBuilder is the struct that's finalized.
type variantBuilder struct {
	native *C.GVariantBuilder
}

func marshalVariantBuilder(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VariantBuilder{&variantBuilder{(*C.GVariantBuilder)(b)}}, nil
}

// NewVariantBuilder constructs a struct VariantBuilder.
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var _arg1 *C.GVariantType    // out
	var _cret *C.GVariantBuilder // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_builder_new(_arg1)
	runtime.KeepAlive(typ)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = (*VariantBuilder)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantBuilder)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_builder_unref((*C.GVariantBuilder)(intern.C))
		},
	)

	return _variantBuilder
}

// AddValue adds value to builder.
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed. Some examples of this are putting
// different types of items into an array, putting the wrong types or number of
// items in a tuple, putting more than one value into a variant, etc.
//
// If value is a floating reference (see g_variant_ref_sink()), the builder
// instance takes ownership of value.
//
// The function takes the following parameters:
//
//   - value: #GVariant.
func (builder *VariantBuilder) AddValue(value *Variant) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariant        // out

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_variant_builder_add_value(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// Close closes the subcontainer inside the given builder that was opened by the
// most recent call to g_variant_builder_open().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: too few values added to the
// subcontainer).
func (builder *VariantBuilder) Close() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	C.g_variant_builder_close(_arg0)
	runtime.KeepAlive(builder)
}

// End ends the builder process and returns the constructed value.
//
// It is not permissible to use builder in any way after this call except
// for reference counting operations (in the case of a heap-allocated
// Builder) or by reinitialising it with g_variant_builder_init() (in the
// case of stack-allocated). This means that for the stack-allocated builders
// there is no need to call g_variant_builder_clear() after the call to
// g_variant_builder_end().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: insufficient number of items added
// to a container with a specific number of children required). It is also an
// error to call this function if the builder was created with an indefinite
// array or maybe type and no children have been added; in this case it is
// impossible to infer the type of the empty array.
//
// The function returns the following values:
//
//   - variant: new, floating, #GVariant.
func (builder *VariantBuilder) End() *Variant {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariant        // in

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	_cret = C.g_variant_builder_end(_arg0)
	runtime.KeepAlive(builder)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// Open opens a subcontainer inside the given builder. When done adding items to
// the subcontainer, g_variant_builder_close() must be called. type is the type
// of the container: so to build a tuple of several values, type must include
// the tuple itself.
//
// It is an error to call this function in any way that would cause an
// inconsistent value to be constructed (ie: adding too many values or a value
// of an incorrect type).
//
// Example of building a nested variant:
//
//	GVariantBuilder builder;
//	guint32 some_number = get_number ();
//	g_autoptr (GHashTable) some_dict = get_dict ();
//	GHashTableIter iter;
//	const gchar *key;
//	const GVariant *value;
//	g_autoptr (GVariant) output = NULL;
//
//	g_variant_builder_init (&builder, G_VARIANT_TYPE ("(ua{sv})"));
//	g_variant_builder_add (&builder, "u", some_number);
//	g_variant_builder_open (&builder, G_VARIANT_TYPE ("a{sv}"));
//
//	g_hash_table_iter_init (&iter, some_dict);
//	while (g_hash_table_iter_next (&iter, (gpointer *) &key, (gpointer *) &value))
//	  {
//	    g_variant_builder_open (&builder, G_VARIANT_TYPE ("{sv}"));
//	    g_variant_builder_add (&builder, "s", key);
//	    g_variant_builder_add (&builder, "v", value);
//	    g_variant_builder_close (&builder);
//	  }
//
//	g_variant_builder_close (&builder);
//
//	output = g_variant_builder_end (&builder);.
//
// The function takes the following parameters:
//
//   - typ of the container.
func (builder *VariantBuilder) Open(typ *VariantType) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariantType    // out

	_arg0 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))
	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	C.g_variant_builder_open(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typ)
}

// VariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an efficient
// way on an existing #GVariant dictionary or it can be used to construct new
// dictionaries with a hashtable-like interface. It can also be used for taking
// existing dictionaries and modifying them in order to create new ones.
//
// Dict can only be used with G_VARIANT_TYPE_VARDICT dictionaries.
//
// It is possible to use Dict allocated on the stack or on the heap. When using
// a stack-allocated Dict, you begin with a call to g_variant_dict_init() and
// free the resources with a call to g_variant_dict_clear().
//
// Heap-allocated Dict follows normal refcounting rules: you allocate it with
// g_variant_dict_new() and use g_variant_dict_ref() and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the Dict back into a dictionary-type
// #GVariant. When used with stack-allocated instances, this also implicitly
// frees all associated memory, but for heap-allocated instances, you must still
// call g_variant_dict_unref() afterwards.
//
// You will typically want to use a heap-allocated Dict when you expose it as
// part of an API. For most other uses, the stack-allocated form will be more
// convenient.
//
// Consider the following two examples that do the same thing in each style:
// take an existing dictionary and look up the "count" uint32 key, adding
// 1 to it if it is found, or returning an error if the key is not found.
// Each returns the new dictionary as a floating #GVariant.
//
// Using a stack-allocated GVariantDict
//
//	GVariant *
//	add_to_count (GVariant  *orig,
//	              GError   **error)
//	{
//	  GVariantDict *dict;
//	  GVariant *result;
//	  guint32 count;
//
//	  dict = g_variant_dict_new (orig);
//
//	  if (g_variant_dict_lookup (dict, "count", "u", &count))
//	    {
//	      g_variant_dict_insert (dict, "count", "u", count + 1);
//	      result = g_variant_dict_end (dict);
//	    }
//	  else
//	    {
//	      g_set_error (...);
//	      result = NULL;
//	    }
//
//	  g_variant_dict_unref (dict);
//
//	  return result;
//	}
//
// An instance of this type is always passed by reference.
type VariantDict struct {
	*variantDict
}

// variantDict is the struct that's finalized.
type variantDict struct {
	native *C.GVariantDict
}

func marshalVariantDict(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VariantDict{&variantDict{(*C.GVariantDict)(b)}}, nil
}

// NewVariantDict constructs a struct VariantDict.
func NewVariantDict(fromAsv *Variant) *VariantDict {
	var _arg1 *C.GVariant     // out
	var _cret *C.GVariantDict // in

	if fromAsv != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(fromAsv)))
	}

	_cret = C.g_variant_dict_new(_arg1)
	runtime.KeepAlive(fromAsv)

	var _variantDict *VariantDict // out

	_variantDict = (*VariantDict)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantDict)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_dict_unref((*C.GVariantDict)(intern.C))
		},
	)

	return _variantDict
}

// Clear releases all memory associated with a Dict without freeing the Dict
// structure itself.
//
// It typically only makes sense to do this on a stack-allocated Dict if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_dict_end() and it also doesn't need to be called
// on dicts allocated with g_variant_dict_new (see g_variant_dict_unref() for
// that).
//
// It is valid to call this function on either an initialised Dict or one that
// was previously cleared by an earlier call to g_variant_dict_clear() but it is
// not valid to call this function on uninitialised memory.
func (dict *VariantDict) Clear() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))

	C.g_variant_dict_clear(_arg0)
	runtime.KeepAlive(dict)
}

// Contains checks if key exists in dict.
//
// The function takes the following parameters:
//
//   - key to look up in the dictionary.
//
// The function returns the following values:
//
//   - ok: TRUE if key is in dict.
func (dict *VariantDict) Contains(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_contains(_arg0, _arg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// End returns the current value of dict as a #GVariant of type
// G_VARIANT_TYPE_VARDICT, clearing it in the process.
//
// It is not permissible to use dict in any way after this call except for
// reference counting operations (in the case of a heap-allocated Dict)
// or by reinitialising it with g_variant_dict_init() (in the case of
// stack-allocated).
//
// The function returns the following values:
//
//   - variant: new, floating, #GVariant.
func (dict *VariantDict) End() *Variant {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))

	_cret = C.g_variant_dict_end(_arg0)
	runtime.KeepAlive(dict)

	var _variant *Variant // out

	_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// InsertValue inserts (or replaces) a key in a Dict.
//
// value is consumed if it is floating.
//
// The function takes the following parameters:
//
//   - key to insert a value for.
//   - value to insert.
func (dict *VariantDict) InsertValue(key string, value *Variant) {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	C.g_variant_dict_insert_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// LookupValue looks up a value in a Dict.
//
// If key is not found in dictionary, NULL is returned.
//
// The expected_type string specifies what type of value is expected. If the
// value associated with key has a different type then NULL is returned.
//
// If the key is found and the value has the correct type, it is returned.
// If expected_type was specified then any non-NULL return value will have this
// type.
//
// The function takes the following parameters:
//
//   - key to look up in the dictionary.
//   - expectedType (optional) or NULL.
//
// The function returns the following values:
//
//   - variant (optional): value of the dictionary key, or NULL.
func (dict *VariantDict) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	if expectedType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_cret = C.g_variant_dict_lookup_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)
	runtime.KeepAlive(expectedType)

	var _variant *Variant // out

	if _cret != nil {
		_variant = (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Remove removes a key and its associated value from a Dict.
//
// The function takes the following parameters:
//
//   - key to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the key was found and removed.
func (dict *VariantDict) Remove(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(dict)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_remove(_arg0, _arg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VariantType: type in the glib.Variant type system.
//
// This section introduces the glib.Variant type system. It is based,
// in large part, on the D-Bus type system, with two major changes
// and some minor lifting of restrictions. The D-Bus specification
// (http://dbus.freedesktop.org/doc/dbus-specification.html), therefore,
// provides a significant amount of information that is useful when working with
// glib.Variant.
//
// The first major change with respect to the D-Bus type system is the
// introduction of maybe (or ‘nullable’) types. Any type in glib.Variant can be
// converted to a maybe type, in which case, nothing (or null) becomes a valid
// value. Maybe types have been added by introducing the character m to type
// strings.
//
// The second major change is that the glib.Variant type system supports the
// concept of ‘indefinite types’ — types that are less specific than the normal
// types found in D-Bus. For example, it is possible to speak of ‘an array of
// any type’ in glib.Variant, where the D-Bus type system would require you to
// speak of ‘an array of integers’ or ‘an array of strings’. Indefinite types
// have been added by introducing the characters *, ? and r to type strings.
//
// Finally, all arbitrary restrictions relating to the complexity of types are
// lifted along with the restriction that dictionary entries may only appear
// nested inside of arrays.
//
// Just as in D-Bus, glib.Variant types are described with strings (‘type
// strings’). Subject to the differences mentioned above, these strings are of
// the same form as those found in D-Bus. Note, however: D-Bus always works in
// terms of messages and therefore individual type strings appear nowhere in its
// interface. Instead, ‘signatures’ are a concatenation of the strings of the
// type of each argument in a message. glib.Variant deals with single values
// directly so glib.Variant type strings always describe the type of exactly
// one value. This means that a D-Bus signature string is generally not a valid
// glib.Variant type string — except in the case that it is the signature of a
// message containing exactly one argument.
//
// An indefinite type is similar in spirit to what may be called an abstract
// type in other type systems. No value can exist that has an indefinite type
// as its type, but values can exist that have types that are subtypes of
// indefinite types. That is to say, glib.Variant.GetType() will never return an
// indefinite type, but calling glib.Variant.IsOfType() with an indefinite type
// may return true. For example, you cannot have a value that represents ‘an
// array of no particular type’, but you can have an ‘array of integers’ which
// certainly matches the type of ‘an array of no particular type’, since ‘array
// of integers’ is a subtype of ‘array of no particular type’.
//
// This is similar to how instances of abstract classes may not directly
// exist in other type systems, but instances of their non-abstract
// subtypes may. For example, in GTK, no object that has the type
// of GtkWidget (https://docs.gtk.org/gtk4/class.Widget.html) can
// exist (since GtkWidget is an abstract class), but a GtkWindow
// (https://docs.gtk.org/gtk4/class.Window.html) can certainly be instantiated,
// and you would say that a GtkWindow is a GtkWidget (since GtkWindow is a
// subclass of GtkWidget).
//
// Two types may not be compared by value; use glib.VariantType.Equal() or
// glib.VariantType.IsSubtypeOf() May be copied using glib.VariantType.Copy()
// and freed using glib.VariantType.Free().
//
// # GVariant Type Strings
//
// A glib.Variant type string can be any of the following:
//
// - any basic type string (listed below)
//
// - v, r or *
//
// - one of the characters a or m, followed by another type string
//
// - the character (, followed by a concatenation of zero or more other type
// strings, followed by the character )
//
// - the character {, followed by a basic type string (see below), followed by
// another type string, followed by the character }
//
// A basic type string describes a basic type (as per
// glib.VariantType.IsBasic()) and is always a single character in length.
// The valid basic type strings are b, y, n, q, i, u, x, t, h, d, s, o, g and ?.
//
// The above definition is recursive to arbitrary depth. aaaaai and
// (ui(nq((y)))s) are both valid type strings, as is a(aa(ui)(qna{ya(yd)})).
// In order to not hit memory limits, glib.Variant imposes a limit on recursion
// depth of 65 nested containers. This is the limit in the D-Bus specification
// (64) plus one to allow a GDBusMessage (../gio/class.DBusMessage.html) to be
// nested in a top-level tuple.
//
// The meaning of each of the characters is as follows:
//
// - b: the type string of G_VARIANT_TYPE_BOOLEAN; a boolean value.
//
// - y: the type string of G_VARIANT_TYPE_BYTE; a byte.
//
// - n: the type string of G_VARIANT_TYPE_INT16; a signed 16 bit integer.
//
// - q: the type string of G_VARIANT_TYPE_UINT16; an unsigned 16 bit integer.
//
// - i: the type string of G_VARIANT_TYPE_INT32; a signed 32 bit integer.
//
// - u: the type string of G_VARIANT_TYPE_UINT32; an unsigned 32 bit integer.
//
// - x: the type string of G_VARIANT_TYPE_INT64; a signed 64 bit integer.
//
// - t: the type string of G_VARIANT_TYPE_UINT64; an unsigned 64 bit integer.
//
// - h: the type string of G_VARIANT_TYPE_HANDLE; a signed 32 bit value that,
// by convention, is used as an index into an array of file descriptors that are
// sent alongside a D-Bus message.
//
// - d: the type string of G_VARIANT_TYPE_DOUBLE; a double precision floating
// point value.
//
// - s: the type string of G_VARIANT_TYPE_STRING; a string.
//
// - o: the type string of G_VARIANT_TYPE_OBJECT_PATH; a string in the form of a
// D-Bus object path.
//
// - g: the type string of G_VARIANT_TYPE_SIGNATURE; a string in the form of a
// D-Bus type signature.
//
// - ?: the type string of G_VARIANT_TYPE_BASIC; an indefinite type that is a
// supertype of any of the basic types.
//
// - v: the type string of G_VARIANT_TYPE_VARIANT; a container type that contain
// any other type of value.
//
// - a: used as a prefix on another type string to mean an array of that type;
// the type string ai, for example, is the type of an array of signed 32-bit
// integers.
//
// - m: used as a prefix on another type string to mean a ‘maybe’,
// or ‘nullable’, version of that type; the type string ms, for example, is the
// type of a value that maybe contains a string, or maybe contains nothing.
//
// - (): used to enclose zero or more other concatenated type strings to create
// a tuple type; the type string (is), for example, is the type of a pair of an
// integer and a string.
//
// - r: the type string of G_VARIANT_TYPE_TUPLE; an indefinite type that is a
// supertype of any tuple type, regardless of the number of items.
//
// - {}: used to enclose a basic type string concatenated with another type
// string to create a dictionary entry type, which usually appears inside of an
// array to form a dictionary; the type string a{sd}, for example, is the type
// of a dictionary that maps strings to double precision floating point values.
//
//	The first type (the basic type) is the key type and the second type is
//	the value type. The reason that the first type is restricted to being a
//	basic type is so that it can easily be hashed.
//
// - *: the type string of G_VARIANT_TYPE_ANY; the indefinite type that is a
// supertype of all types. Note that, as with all type strings, this character
// represents exactly one type. It cannot be used inside of tuples to mean ‘any
// number of items’.
//
// Any type string of a container that contains an indefinite type is, itself,
// an indefinite type. For example, the type string a* (corresponding to
// G_VARIANT_TYPE_ARRAY) is an indefinite type that is a supertype of every
// array type. (*s) is a supertype of all tuples that contain exactly two items
// where the second item is a string.
//
// a{?*} is an indefinite type that is a supertype of all arrays containing
// dictionary entries where the key is any basic type and the value is any type
// at all. This is, by definition, a dictionary, so this type string corresponds
// to G_VARIANT_TYPE_DICTIONARY. Note that, due to the restriction that the key
// of a dictionary entry must be a basic type, {**} is not a valid type string.
//
// An instance of this type is always passed by reference.
type VariantType struct {
	*variantType
}

// variantType is the struct that's finalized.
type variantType struct {
	native *C.GVariantType
}

func marshalVariantType(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VariantType{&variantType{(*C.GVariantType)(b)}}, nil
}

// NewVariantType constructs a struct VariantType.
func NewVariantType(typeString string) *VariantType {
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_type_new(_arg1)
	runtime.KeepAlive(typeString)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantType)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_type_free((*C.GVariantType)(intern.C))
		},
	)

	return _variantType
}

// NewVariantTypeArray constructs a struct VariantType.
func NewVariantTypeArray(element *VariantType) *VariantType {
	var _arg1 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(element)))

	_cret = C.g_variant_type_new_array(_arg1)
	runtime.KeepAlive(element)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantType)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_type_free((*C.GVariantType)(intern.C))
		},
	)

	return _variantType
}

// NewVariantTypeDictEntry constructs a struct VariantType.
func NewVariantTypeDictEntry(key *VariantType, value *VariantType) *VariantType {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(key)))
	_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_variant_type_new_dict_entry(_arg1, _arg2)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantType)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_type_free((*C.GVariantType)(intern.C))
		},
	)

	return _variantType
}

// NewVariantTypeMaybe constructs a struct VariantType.
func NewVariantTypeMaybe(element *VariantType) *VariantType {
	var _arg1 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(element)))

	_cret = C.g_variant_type_new_maybe(_arg1)
	runtime.KeepAlive(element)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantType)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_type_free((*C.GVariantType)(intern.C))
		},
	)

	return _variantType
}

// NewVariantTypeTuple constructs a struct VariantType.
func NewVariantTypeTuple(items []*VariantType) *VariantType {
	var _arg1 **C.GVariantType // out
	var _arg2 C.gint
	var _cret *C.GVariantType // in

	_arg2 = (C.gint)(len(items))
	_arg1 = (**C.GVariantType)(C.calloc(C.size_t(len(items)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GVariantType)(_arg1), len(items))
		for i := range items {
			out[i] = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(items[i])))
		}
	}

	_cret = C.g_variant_type_new_tuple(_arg1, _arg2)
	runtime.KeepAlive(items)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantType)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_type_free((*C.GVariantType)(intern.C))
		},
	)

	return _variantType
}

// Copy makes a copy of a Type. It is appropriate to call g_variant_type_free()
// on the return value. type may not be NULL.
//
// The function returns the following values:
//
//   - variantType: new Type
//
//     Since 2.24.
func (typ *VariantType) Copy() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_copy(_arg0)
	runtime.KeepAlive(typ)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variantType)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_type_free((*C.GVariantType)(intern.C))
		},
	)

	return _variantType
}

// DupString returns a newly-allocated copy of the type string corresponding
// to type. The returned string is nul-terminated. It is appropriate to call
// g_free() on the return value.
//
// The function returns the following values:
//
//   - utf8: corresponding type string
//
//     Since 2.24.
func (typ *VariantType) DupString() string {
	var _arg0 *C.GVariantType // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_dup_string(_arg0)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Element determines the element type of an array or maybe type.
//
// This function may only be used with array or maybe types.
//
// The function returns the following values:
//
//   - variantType: element type of type
//
//     Since 2.24.
func (typ *VariantType) Element() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_element(_arg0)
	runtime.KeepAlive(typ)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

// Equal compares type1 and type2 for equality.
//
// Only returns TRUE if the types are exactly equal. Even if one type is an
// indefinite type and the other is a subtype of it, FALSE will be returned
// if they are not exactly equal. If you want to check for subtypes, use
// g_variant_type_is_subtype_of().
//
// The argument types of type1 and type2 are only #gconstpointer to allow use
// with Table without function pointer casting. For both arguments, a valid Type
// must be provided.
//
// The function takes the following parameters:
//
//   - type2: Type.
//
// The function returns the following values:
//
//   - ok: TRUE if type1 and type2 are exactly equal
//
//     Since 2.24.
func (type1 *VariantType) Equal(type2 *VariantType) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(type1)))
	_arg1 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(type2)))

	_cret = C.g_variant_type_equal(_arg0, _arg1)
	runtime.KeepAlive(type1)
	runtime.KeepAlive(type2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// First determines the first item type of a tuple or dictionary entry type.
//
// This function may only be used with tuple or dictionary entry types, but must
// not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.
//
// In the case of a dictionary entry type, this returns the type of the key.
//
// NULL is returned in case of type being G_VARIANT_TYPE_UNIT.
//
// This call, together with g_variant_type_next() provides an iterator interface
// over tuple and dictionary entry types.
//
// The function returns the following values:
//
//   - variantType: first item type of type, or NULL
//
//     Since 2.24.
func (typ *VariantType) First() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_first(_arg0)
	runtime.KeepAlive(typ)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

// StringLength returns the length of the type string corresponding to the given
// type. This function must be used to determine the valid extent of the memory
// region returned by g_variant_type_peek_string().
//
// The function returns the following values:
//
//   - gsize: length of the corresponding type string
//
//     Since 2.24.
func (typ *VariantType) StringLength() uint {
	var _arg0 *C.GVariantType // out
	var _cret C.gsize         // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_get_string_length(_arg0)
	runtime.KeepAlive(typ)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Hash hashes type.
//
// The argument type of type is only #gconstpointer to allow use with Table
// without function pointer casting. A valid Type must be provided.
//
// The function returns the following values:
//
//   - guint: hash value
//
//     Since 2.24.
func (typ *VariantType) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_hash(_arg0)
	runtime.KeepAlive(typ)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsArray determines if the given type is an array type. This is true if the
// type string for type starts with an 'a'.
//
// This function returns TRUE for any indefinite type for which every definite
// subtype is an array type -- G_VARIANT_TYPE_ARRAY, for example.
//
// The function returns the following values:
//
//   - ok: TRUE if type is an array type
//
//     Since 2.24.
func (typ *VariantType) IsArray() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_array(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBasic determines if the given type is a basic type.
//
// Basic types are booleans, bytes, integers, doubles, strings, object paths and
// signatures.
//
// Only a basic type may be used as the key of a dictionary entry.
//
// This function returns FALSE for all indefinite types except
// G_VARIANT_TYPE_BASIC.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a basic type
//
//     Since 2.24.
func (typ *VariantType) IsBasic() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_basic(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsContainer determines if the given type is a container type.
//
// Container types are any array, maybe, tuple, or dictionary entry types plus
// the variant type.
//
// This function returns TRUE for any indefinite type for which every definite
// subtype is a container -- G_VARIANT_TYPE_ARRAY, for example.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a container type
//
//     Since 2.24.
func (typ *VariantType) IsContainer() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_container(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDefinite determines if the given type is definite (ie: not indefinite).
//
// A type is definite if its type string does not contain any indefinite type
// characters ('*', '?', or 'r').
//
// A #GVariant instance may not have an indefinite type, so calling this
// function on the result of g_variant_get_type() will always result in
// TRUE being returned. Calling this function on an indefinite type like
// G_VARIANT_TYPE_ARRAY, however, will result in FALSE being returned.
//
// The function returns the following values:
//
//   - ok: TRUE if type is definite
//
//     Since 2.24.
func (typ *VariantType) IsDefinite() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_definite(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDictEntry determines if the given type is a dictionary entry type. This is
// true if the type string for type starts with a '{'.
//
// This function returns TRUE for any indefinite type for which every definite
// subtype is a dictionary entry type -- G_VARIANT_TYPE_DICT_ENTRY, for example.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a dictionary entry type
//
//     Since 2.24.
func (typ *VariantType) IsDictEntry() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_dict_entry(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMaybe determines if the given type is a maybe type. This is true if the
// type string for type starts with an 'm'.
//
// This function returns TRUE for any indefinite type for which every definite
// subtype is a maybe type -- G_VARIANT_TYPE_MAYBE, for example.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a maybe type
//
//     Since 2.24.
func (typ *VariantType) IsMaybe() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_maybe(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubtypeOf checks if type is a subtype of supertype.
//
// This function returns TRUE if type is a subtype of supertype. All types are
// considered to be subtypes of themselves. Aside from that, only indefinite
// types can have subtypes.
//
// The function takes the following parameters:
//
//   - supertype: Type.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a subtype of supertype
//
//     Since 2.24.
func (typ *VariantType) IsSubtypeOf(supertype *VariantType) bool {
	var _arg0 *C.GVariantType // out
	var _arg1 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))
	_arg1 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(supertype)))

	_cret = C.g_variant_type_is_subtype_of(_arg0, _arg1)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(supertype)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsTuple determines if the given type is a tuple type. This is true if the
// type string for type starts with a '(' or if type is G_VARIANT_TYPE_TUPLE.
//
// This function returns TRUE for any indefinite type for which every definite
// subtype is a tuple type -- G_VARIANT_TYPE_TUPLE, for example.
//
// The function returns the following values:
//
//   - ok: TRUE if type is a tuple type
//
//     Since 2.24.
func (typ *VariantType) IsTuple() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_tuple(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVariant determines if the given type is the variant type.
//
// The function returns the following values:
//
//   - ok: TRUE if type is the variant type
//
//     Since 2.24.
func (typ *VariantType) IsVariant() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_is_variant(_arg0)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Key determines the key type of a dictionary entry type.
//
// This function may only be used with a dictionary entry type. Other than the
// additional restriction, this call is equivalent to g_variant_type_first().
//
// The function returns the following values:
//
//   - variantType: key type of the dictionary entry
//
//     Since 2.24.
func (typ *VariantType) Key() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_key(_arg0)
	runtime.KeepAlive(typ)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

// NItems determines the number of items contained in a tuple or dictionary
// entry type.
//
// This function may only be used with tuple or dictionary entry types, but must
// not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.
//
// In the case of a dictionary entry type, this function will always return 2.
//
// The function returns the following values:
//
//   - gsize: number of items in type
//
//     Since 2.24.
func (typ *VariantType) NItems() uint {
	var _arg0 *C.GVariantType // out
	var _cret C.gsize         // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_n_items(_arg0)
	runtime.KeepAlive(typ)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Next determines the next item type of a tuple or dictionary entry type.
//
// type must be the result of a previous call to g_variant_type_first() or
// g_variant_type_next().
//
// If called on the key type of a dictionary entry then this call returns the
// value type. If called on the value type of a dictionary entry then this call
// returns NULL.
//
// For tuples, NULL is returned when type is the last item in a tuple.
//
// The function returns the following values:
//
//   - variantType: next Type after type, or NULL
//
//     Since 2.24.
func (typ *VariantType) Next() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_next(_arg0)
	runtime.KeepAlive(typ)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

// Value determines the value type of a dictionary entry type.
//
// This function may only be used with a dictionary entry type.
//
// The function returns the following values:
//
//   - variantType: value type of the dictionary entry
//
//     Since 2.24.
func (typ *VariantType) Value() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(typ)))

	_cret = C.g_variant_type_value(_arg0)
	runtime.KeepAlive(typ)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

func VariantTypeChecked_(typeString string) *VariantType {
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_type_checked_(_arg1)
	runtime.KeepAlive(typeString)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _variantType
}

func VariantTypeStringGetDepth_(typeString string) uint {
	var _arg1 *C.gchar // out
	var _cret C.gsize  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_type_string_get_depth_(_arg1)
	runtime.KeepAlive(typeString)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// VariantTypeStringIsValid checks if type_string is a valid GVariant type
// string. This call is equivalent to calling g_variant_type_string_scan() and
// confirming that the following character is a nul terminator.
//
// The function takes the following parameters:
//
//   - typeString: pointer to any string.
//
// The function returns the following values:
//
//   - ok: TRUE if type_string is exactly one valid type string
//
//     Since 2.24.
func VariantTypeStringIsValid(typeString string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_type_string_is_valid(_arg1)
	runtime.KeepAlive(typeString)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VariantTypeStringScan: scan for a single complete and valid GVariant type
// string in string. The memory pointed to by limit (or bytes beyond it) is
// never accessed.
//
// If a valid type string is found, endptr is updated to point to the first
// character past the end of the string that was found and TRUE is returned.
//
// If there is no valid type string starting at string, or if the type string
// does not end before limit then FALSE is returned.
//
// For the simple case of checking if a string is a valid type string,
// see g_variant_type_string_is_valid().
//
// The function takes the following parameters:
//
//   - str: pointer to any string.
//   - limit (optional): end of string, or NULL.
//
// The function returns the following values:
//
//   - endptr (optional): location to store the end pointer, or NULL.
//   - ok: TRUE if a valid type string was found.
func VariantTypeStringScan(str, limit string) (string, bool) {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	if limit != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(limit)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_variant_type_string_scan(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(limit)

	var _endptr string // out
	var _ok bool       // out

	if _arg3 != nil {
		_endptr = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _cret != 0 {
		_ok = true
	}

	return _endptr, _ok
}

// NewBytesWithGo is similar to NewBytes, except the given Go byte slice
// is not copied, but will be kept alive for the lifetime of the GBytes.
// Note that the user must NOT modify data.
//
// Refer to g_bytes_new_with_free_func() for more information.
func NewBytesWithGo(data []byte) *Bytes {
	byteID := gbox.Assign(data)

	v := C.g_bytes_new_with_free_func(
		C.gconstpointer(unsafe.Pointer(&data[0])),
		C.gsize(len(data)),
		C.GDestroyNotify((*[0]byte)(C.callbackDelete)),
		C.gpointer(byteID),
	)

	_bytes := (*Bytes)(gextras.NewStructNative(unsafe.Pointer(v)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Use calls f with Bytes' internal byte slice without making a copy. f
// must NOT move the byte slice to outside of the closure, since the
// slice's internal array buffer may be freed after.
func (b *Bytes) Use(f func([]byte)) {
	var ptr C.gconstpointer // in
	var len C.gsize         // in

	ptr = C.g_bytes_get_data(
		(*C.GBytes)(gextras.StructNative(unsafe.Pointer(b))),
		&len,
	)

	var buf []byte

	h := (*reflect.SliceHeader)(unsafe.Pointer(&buf))
	h.Data = uintptr(ptr)
	h.Len = int(len)
	h.Cap = int(len)

	f(buf)
	runtime.KeepAlive(b)
}

func marshalVariant(p uintptr) (interface{}, error) {
	_cret := C.g_value_dup_variant((*C.GValue)(unsafe.Pointer(p)))
	if _cret == nil {
		return (*Variant)(nil), nil
	}

	_variant := (*Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	return _variant, nil
}

// ForEach iterates over items in value. The iteration breaks out once f
// returns true. This method wraps around g_variant_iter_new.
func (value *Variant) ForEach(f func(*Variant) (stop bool)) {
	valueNative := (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	var iter C.GVariantIter
	C.g_variant_iter_init(&iter, valueNative)

	next := func() *Variant {
		item := C.g_variant_iter_next_value(&iter)
		if item == nil {
			return nil
		}

		variant := (*Variant)(gextras.NewStructNative(unsafe.Pointer(item)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)

		return variant
	}

	for item := next(); item != nil; item = next() {
		if f(item) {
			break
		}
	}

	runtime.KeepAlive(value)
}

// IdleAdd is an alias for pkg/core/glib.IdleAdd.
func IdleAdd(f interface{}) SourceHandle {
	return coreglib.IdleAdd(f)
}

// IdleAddPriority is an alias for pkg/core/glib.IdleAddPriority.
func IdleAddPriority(p Priority, f interface{}) SourceHandle {
	return coreglib.IdleAddPriority(p, f)
}

// TimeoutAdd is an alias for pkg/core/glib.TimeoutAdd.
func TimeoutAdd(ms uint, f interface{}) SourceHandle {
	return coreglib.TimeoutAdd(ms, f)
}

// TimeoutAddPriority is an alias for pkg/core/glib.TimeoutAddPriority.
func TimeoutAddPriority(ms uint, p Priority, f interface{}) SourceHandle {
	return coreglib.TimeoutAddPriority(ms, p, f)
}

// TimeoutSecondsAdd is an alias for pkg/core/glib.TimeoutSecondsAdd.
func TimeoutSecondsAdd(s uint, f interface{}) SourceHandle {
	return coreglib.TimeoutSecondsAdd(s, f)
}

// TimeoutSecondsAddPriority is an alias for pkg/core/glib.TimeoutSecondsAddPriority.
func TimeoutSecondsAddPriority(s uint, p Priority, f interface{}) SourceHandle {
	return coreglib.TimeoutSecondsAddPriority(s, p, f)
}

// TypeFromName is an alias for pkg/core/glib.TypeFromName.
func TypeFromName(typeName string) Type {
	return coreglib.TypeFromName(typeName)
}

// NewValue is an alias for pkg/core/glib.NewValue.
func NewValue(v interface{}) *Value {
	return coreglib.NewValue(v)
}

// SourceRemove is an alias for pkg/core/glib.SourceRemove.
func SourceRemove(src SourceHandle) bool {
	return coreglib.SourceRemove(src)
}

// ObjectEq is an alias for pkg/core/glib.ObjectEq.
func ObjectEq(obj1 Objector, obj2 Objector) bool {
	return coreglib.ObjectEq(obj1, obj2)
}

// BaseObject is an alias for pkg/core/glib.BaseObject.
func BaseObject(obj Objector) *Object {
	return coreglib.BaseObject(obj)
}

// Object is an alias for pkg/core/glib.Object.
type Object = coreglib.Object

// Objector is an alias for pkg/core/glib.Objector.
type Objector = coreglib.Objector

// Type is an alias for pkg/core/glib.Type.
type Type = coreglib.Type

// Value is an alias for pkg/core/glib.Value.
type Value = coreglib.Value

// Priority is an alias for pkg/core/glib.Priority.
type Priority = coreglib.Priority

// SourceHandle is an alias for pkg/core/glib.SourceHandle.
type SourceHandle = coreglib.SourceHandle

// SignalHandle is an alias for pkg/core/glib.SignalHandle.
type SignalHandle = coreglib.SignalHandle

// Constant aliases from pkg/core/glib.
const (
	TypeInvalid   = coreglib.TypeInvalid
	TypeNone      = coreglib.TypeNone
	TypeInterface = coreglib.TypeInterface
	TypeChar      = coreglib.TypeChar
	TypeUchar     = coreglib.TypeUchar
	TypeBoolean   = coreglib.TypeBoolean
	TypeInt       = coreglib.TypeInt
	TypeUint      = coreglib.TypeUint
	TypeLong      = coreglib.TypeLong
	TypeUlong     = coreglib.TypeUlong
	TypeInt64     = coreglib.TypeInt64
	TypeUint64    = coreglib.TypeUint64
	TypeEnum      = coreglib.TypeEnum
	TypeFlags     = coreglib.TypeFlags
	TypeFloat     = coreglib.TypeFloat
	TypeDouble    = coreglib.TypeDouble
	TypeString    = coreglib.TypeString
	TypePointer   = coreglib.TypePointer
	TypeBoxed     = coreglib.TypeBoxed
	TypeParam     = coreglib.TypeParam
	TypeObject    = coreglib.TypeObject
	TypeVariant   = coreglib.TypeVariant

	PriorityHigh        = coreglib.PriorityHigh
	PriorityDefault     = coreglib.PriorityDefault
	PriorityHighIdle    = coreglib.PriorityHighIdle
	PriorityDefaultIdle = coreglib.PriorityDefaultIdle
	PriorityLow         = coreglib.PriorityLow
)

// NewVariantValue creates a new GValue from a GVariant. This function
// only exists as a workaround for coreglib's cyclical imports. It
// be removed in the future once coreglib is merged in.
func NewVariantValue(variant *Variant) *coreglib.Value {
	value := coreglib.InitValue(coreglib.TypeVariant)
	C.g_value_set_variant(
		(*C.GValue)(unsafe.Pointer(value.Native())),
		(*C.GVariant)(gextras.StructNative(unsafe.Pointer(variant))),
	)
	return value
}

// Value returns the field's value.
func (l *LogField) Value() string {
	if l.native.length == -1 {
		return C.GoString((*C.gchar)(unsafe.Pointer(l.native.value)))
	}
	return C.GoStringN((*C.gchar)(unsafe.Pointer(l.native.value)), C.int(l.native.length))
}

// logSetWriter sets the log writer to the given callback, which should
// take in a list of pair of key-value strings and return true if the
// log has been successfully written. It is a wrapper around
// g_log_set_writer_func.
func logSetWriter(f LogWriterFunc) {
	data := gbox.Assign(f)
	C.g_log_set_writer_func(
		C.GLogWriterFunc((*[0]byte)(C._gotk4_glib2_LogWriterFunc)),
		C.gpointer(data),
		C.GDestroyNotify((*[0]byte)(C.callbackDelete)),
	)
}

func init() {
	logSetWriter(func(lvl LogLevelFlags, fields []LogField) LogWriterOutput {
		handle := newSlogWriterFunc(slog.Default())
		handle(lvl, fields)
		return LogWriterHandled
	})
}

// Support $G_MESSAGES_DEBUG.
var debugDomains = func() map[string]struct{} {
	debugDomains := make(map[string]struct{})
	for _, debugDomain := range strings.Fields(os.Getenv("G_MESSAGES_DEBUG")) {
		debugDomains[debugDomain] = struct{}{}
	}
	return debugDomains
}()

// Special case: G_MESSAGES_DEBUG=all.
var _, debugAllDomains = debugDomains["all"]

// newSlogWriterFunc returns a new LogWriterFunc that writes to the given
// slog.Logger.
func newSlogWriterFunc(l *slog.Logger) LogWriterFunc {
	return func(lvl LogLevelFlags, fields []LogField) LogWriterOutput {
		attrs := make([]slog.Attr, 0, len(fields))
		var message, domain string

		for _, field := range fields {
			k := field.Key()
			v := field.Value()
			if k == "MESSAGE" {
				message = v
			} else {
				if k == "GLIB_DOMAIN" {
					domain = v
				}
				k = strings.ToLower(k)
				attrs = append(attrs, slog.String(k, v))
			}
		}

		if !debugAllDomains && (lvl&LogLevelDebug != 0) && domain != "" {
			if _, ok := debugDomains[domain]; !ok {
				return LogWriterHandled
			}
		}

		slogLevel := slog.LevelInfo
		switch {
		case lvl.Has(LogLevelError), lvl.Has(LogLevelCritical):
			slogLevel = slog.LevelError
		case lvl.Has(LogLevelWarning):
			slogLevel = slog.LevelWarn
		case lvl.Has(LogLevelMessage), lvl.Has(LogLevelInfo):
			slogLevel = slog.LevelInfo
		case lvl.Has(LogLevelDebug):
			slogLevel = slog.LevelDebug
		}

		l.LogAttrs(context.Background(), slogLevel, message, attrs...)

		if lvl.Has(LogFlagFatal) {
			panic(message)
		}

		return LogWriterHandled
	}
}

// NewTimeZoneFromGo creates a new TimeZone instance from Go's Location.
// The location's accuracy is down to the second.
func NewTimeZoneFromGo(loc *time.Location) *TimeZone {
	switch loc {
	case time.UTC:
		return NewTimeZoneUTC()
	case time.Local:
		return NewTimeZoneLocal()
	}

	t1 := time.Date(2009, time.November, 10, 23, 0, 0, 0, loc)
	t2 := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
	return NewTimeZoneOffset(int32(t2.Sub(t1) / time.Second))
}

// NewDateTimeFromGo creates a new DateTime instance from Go's Time. The
// TimeZone of the DateTime will be implicitly converted from the Time.
func NewDateTimeFromGo(t time.Time) *DateTime {
	tz := NewTimeZoneFromGo(t.Location())

	Y, M, D := t.Date()
	h, m, s := t.Clock()

	// Second offset within a minute in nanoseconds.
	seconds := (time.Duration(s) * time.Second) + time.Duration(t.Nanosecond())

	return NewDateTime(tz, int(Y), int(M), int(D), int(h), int(m), seconds.Seconds())
}

// NewObjectComparer returns a CompareDataFunc that uses the given function to
// compare two objects of type T. If the underlying objects are not of type T,
// then the function panics. If the underlying pointers aren't objects, then the
// behavior is undefined.
func NewObjectComparer[T Objector](f func(a, b T) int) CompareDataFunc {
	return func(a, b unsafe.Pointer) int {
		var aobj, bobj T
		if a != nil {
			aobj = coreglib.Take(a).Cast().(T)
		}
		if b != nil {
			bobj = coreglib.Take(b).Cast().(T)
		}
		return f(aobj, bobj)
	}
}
